#include "stm32n6xx_hal.h"
/*
 * yolo_deer_detection.c
 * YOLOv8 nano Deer Detection Implementation for STM32N6570-DK
 * Optimized for INT8 quantized model
 * 
 * Copyright (C) 2025
 */

#include "yolo_deer_detection.h"
#include "ai_datatypes_defines.h"
#include "ai_platform_interface.h"
#include <string.h>
#include <math.h>
#include <stdio.h>

/* External AI network functions (generated by X-CUBE-AI) */
extern ai_handle ai_yolo_deer_create(void);
extern ai_bool ai_yolo_deer_init(ai_handle network, const ai_network_params* params);
extern ai_bool ai_yolo_deer_destroy(ai_handle network);
extern ai_i32 ai_yolo_deer_run(ai_handle network, const ai_buffer* input, ai_buffer* output);
extern ai_bool ai_yolo_deer_get_info(ai_handle network, ai_network_report* report);

/* Static memory allocation for AI model */
AI_ALIGNED(4)
static ai_u8 g_network_activations[AI_NETWORK_DATA_ACTIVATIONS_SIZE];

AI_ALIGNED(4)
static ai_u8 g_network_weights[AI_NETWORK_DATA_WEIGHTS_SIZE];

/* Quantization parameters for INT8 model */
static const float INPUT_SCALE = 0.00784313725f;  /* 2/255 */
static const int32_t INPUT_ZERO_POINT = -128;
static const float OUTPUT_SCALE = 0.00390625f;     /* 1/256 */
static const int32_t OUTPUT_ZERO_POINT = 0;

/**
 * Initialize YOLO model
 */
int32_t YOLO_Init(yolo_model_t* model)
{
    if (model == NULL) {
        return -1;
    }
    
    /* Clear model structure */
    memset(model, 0, sizeof(yolo_model_t));
    
    /* Create network instance */
    model->network = ai_yolo_deer_create();
    if (model->network == NULL) {
        return -2;
    }
    
    /* Set up network parameters */
    ai_network_params params;
    memset(&params, 0, sizeof(params));
    params.params.data = g_network_weights;
    params.activations.data = g_network_activations;
    
    /* Initialize network */
    if (!ai_yolo_deer_init(model->network, &params)) {
        return -3;
    }
    
    /* Get network info */
    if (!ai_yolo_deer_get_info(model->network, &model->network_info)) {
        return -4;
    }
    
    model->activations = g_network_activations;
    model->weights = g_network_weights;
    model->initialized = true;
    model->total_inferences = 0;
    model->total_detections = 0;
    
    return 0;
}

/**
 * Deinitialize YOLO model
 */
void YOLO_DeInit(yolo_model_t* model)
{
    if (model && model->initialized) {
        ai_yolo_deer_destroy(model->network);
        model->initialized = false;
    }
}

/**
 * Quantize float value to INT8
 */
int8_t YOLO_QuantizeFloat(float value, float scale, int32_t zero_point)
{
    int32_t quantized = (int32_t)roundf(value / scale) + zero_point;
    
    /* Clamp to INT8 range */
    if (quantized > 127) quantized = 127;
    if (quantized < -128) quantized = -128;
    
    return (int8_t)quantized;
}

/**
 * Dequantize INT8 to float
 */
float YOLO_DequantizeInt8(int8_t value, float scale, int32_t zero_point)
{
    return scale * ((float)value - (float)zero_point);
}

/**
 * Preprocess camera image for YOLO input
 * Convert RGB565 to INT8 and resize to 320x320
 */
int32_t YOLO_PreprocessImage(const uint8_t* rgb565_input, 
                             uint16_t width, 
                             uint16_t height,
                             int8_t* output_buffer)
{
    if (!rgb565_input || !output_buffer) {
        return -1;
    }
    
    /* Calculate scaling factors for resize */
    float scale_x = (float)width / YOLO_INPUT_WIDTH;
    float scale_y = (float)height / YOLO_INPUT_HEIGHT;
    
    /* Process each pixel with bilinear interpolation */
    for (int y = 0; y < YOLO_INPUT_HEIGHT; y++) {
        float src_y = y * scale_y;
        int y0 = (int)src_y;
        int y1 = (y0 < height - 1) ? y0 + 1 : y0;
        float dy = src_y - y0;
        
        for (int x = 0; x < YOLO_INPUT_WIDTH; x++) {
            float src_x = x * scale_x;
            int x0 = (int)src_x;
            int x1 = (x0 < width - 1) ? x0 + 1 : x0;
            float dx = src_x - x0;
            
            /* Get 4 surrounding pixels for bilinear interpolation */
            uint16_t p00 = ((uint16_t*)rgb565_input)[y0 * width + x0];
            uint16_t p01 = ((uint16_t*)rgb565_input)[y0 * width + x1];
            uint16_t p10 = ((uint16_t*)rgb565_input)[y1 * width + x0];
            uint16_t p11 = ((uint16_t*)rgb565_input)[y1 * width + x1];
            
            /* Extract and interpolate RGB components */
            for (int c = 0; c < 3; c++) {
                float v00, v01, v10, v11;
                
                if (c == 0) { /* Red channel */
                    v00 = ((p00 >> 11) & 0x1F) * 8.225f;  /* 5-bit to 8-bit */
                    v01 = ((p01 >> 11) & 0x1F) * 8.225f;
                    v10 = ((p10 >> 11) & 0x1F) * 8.225f;
                    v11 = ((p11 >> 11) & 0x1F) * 8.225f;
                } else if (c == 1) { /* Green channel */
                    v00 = ((p00 >> 5) & 0x3F) * 4.047f;   /* 6-bit to 8-bit */
                    v01 = ((p01 >> 5) & 0x3F) * 4.047f;
                    v10 = ((p10 >> 5) & 0x3F) * 4.047f;
                    v11 = ((p11 >> 5) & 0x3F) * 4.047f;
                } else { /* Blue channel */
                    v00 = (p00 & 0x1F) * 8.225f;          /* 5-bit to 8-bit */
                    v01 = (p01 & 0x1F) * 8.225f;
                    v10 = (p10 & 0x1F) * 8.225f;
                    v11 = (p11 & 0x1F) * 8.225f;
                }
                
                /* Bilinear interpolation */
                float v0 = v00 * (1 - dx) + v01 * dx;
                float v1 = v10 * (1 - dx) + v11 * dx;
                float value = v0 * (1 - dy) + v1 * dy;
                
                /* Normalize to [0, 1] then quantize to INT8 */
                value = value / 255.0f;
                
                /* Store in CHW format for YOLOv8 */
                int idx = c * YOLO_INPUT_WIDTH * YOLO_INPUT_HEIGHT + y * YOLO_INPUT_WIDTH + x;
                output_buffer[idx] = YOLO_QuantizeFloat(value, INPUT_SCALE, INPUT_ZERO_POINT);
            }
        }
    }
    
    return 0;
}

/**
 * Run YOLO inference
 */
int32_t YOLO_RunInference(yolo_model_t* model, 
                          const int8_t* input_data,
                          int8_t* output_data)
{
    if (!model || !model->initialized || !input_data || !output_data) {
        return -1;
    }
    
    /* Set up input buffer */
    ai_buffer input_buffer = {
    .format = AI_BUFFER_FORMAT_FLOAT,
    .data = NULL,
    .meta_info = NULL,
    .flags = 0,
    .size = 0,
    .data = NULL
};
    
    /* Set up output buffer */
    ai_buffer output_buffer = {
        .format = AI_BUFFER_FORMAT_S8,  /* INT8 format */
        .data = (ai_handle)output_data,
        .meta_info = NULL,
        .flags = 0,
        .size = YOLO_OUTPUT_SIZE,
        .data = (ai_handle)output_data
    };
    
    /* Run inference */
    ai_i32 result = ai_yolo_deer_run(model->network, &input_buffer, &output_buffer);
    
    if (result == 1) {
        model->total_inferences++;
        return 0;
    }
    
    return -2;
}

/**
 * Sigmoid activation function
 */
float YOLO_Sigmoid(float x)
{
    if (x > 20.0f) return 1.0f;
    if (x < -20.0f) return 0.0f;
    return 1.0f / (1.0f + expf(-x));
}

/**
 * Decode YOLOv8 output format to bounding boxes
 */
void YOLO_DecodeOutput(const int8_t* raw_output,
                      detection_t* detections,
                      uint8_t* num_detections)
{
    *num_detections = 0;
    
    /* YOLOv8 output format for single class detection:
     * Output shape: [1, 5, 8400] where 5 = cx, cy, w, h, confidence
     */
    
    for (int i = 0; i < YOLO_GRID_SIZE && *num_detections < MAX_DETECTIONS; i++) {
        /* Dequantize confidence score */
        float confidence = YOLO_DequantizeInt8(
            raw_output[i * 5 + 4], 
            OUTPUT_SCALE, 
            OUTPUT_ZERO_POINT
        );
        confidence = YOLO_Sigmoid(confidence);
        
        if (confidence > CONFIDENCE_THRESHOLD) {
            /* Dequantize bounding box coordinates */
            float cx = YOLO_DequantizeInt8(raw_output[i * 5 + 0], OUTPUT_SCALE, OUTPUT_ZERO_POINT);
            float cy = YOLO_DequantizeInt8(raw_output[i * 5 + 1], OUTPUT_SCALE, OUTPUT_ZERO_POINT);
            float w = YOLO_DequantizeInt8(raw_output[i * 5 + 2], OUTPUT_SCALE, OUTPUT_ZERO_POINT);
            float h = YOLO_DequantizeInt8(raw_output[i * 5 + 3], OUTPUT_SCALE, OUTPUT_ZERO_POINT);
            
            /* Apply sigmoid to coordinates */
            cx = YOLO_Sigmoid(cx);
            cy = YOLO_Sigmoid(cy);
            
            /* Ensure positive dimensions */
            w = fabsf(w) / YOLO_INPUT_WIDTH;
            h = fabsf(h) / YOLO_INPUT_HEIGHT;
            
            /* Normalize coordinates */
            detections[*num_detections].x = cx;
            detections[*num_detections].y = cy;
            detections[*num_detections].width = w;
            detections[*num_detections].height = h;
            detections[*num_detections].confidence = confidence;
            detections[*num_detections].class_id = 0;  /* Deer class */
            
            (*num_detections)++;
        }
    }
}

/**
 * Calculate Intersection over Union (IoU)
 */
float YOLO_IoU(const detection_t* box1, const detection_t* box2)
{
    /* Convert to corner coordinates */
    float x1_min = box1->x - box1->width / 2.0f;
    float y1_min = box1->y - box1->height / 2.0f;
    float x1_max = box1->x + box1->width / 2.0f;
    float y1_max = box1->y + box1->height / 2.0f;
    
    float x2_min = box2->x - box2->width / 2.0f;
    float y2_min = box2->y - box2->height / 2.0f;
    float x2_max = box2->x + box2->width / 2.0f;
    float y2_max = box2->y + box2->height / 2.0f;
    
    /* Calculate intersection area */
    float inter_x_min = fmaxf(x1_min, x2_min);
    float inter_y_min = fmaxf(y1_min, y2_min);
    float inter_x_max = fminf(x1_max, x2_max);
    float inter_y_max = fminf(y1_max, y2_max);
    
    float inter_area = 0;
    if (inter_x_max > inter_x_min && inter_y_max > inter_y_min) {
        inter_area = (inter_x_max - inter_x_min) * (inter_y_max - inter_y_min);
    }
    
    /* Calculate union area */
    float box1_area = box1->width * box1->height;
    float box2_area = box2->width * box2->height;
    float union_area = box1_area + box2_area - inter_area;
    
    return (union_area > 0) ? (inter_area / union_area) : 0;
}

/**
 * Non-Maximum Suppression
 */
void YOLO_NMS(detection_t* detections, 
              uint8_t* num_detections,
              float nms_threshold)
{
    /* Sort detections by confidence (insertion sort for small arrays) */
    for (int i = 1; i < *num_detections; i++) {
        detection_t key = detections[i];
        int j = i - 1;
        while (j >= 0 && detections[j].confidence < key.confidence) {
            detections[j + 1] = detections[j];
            j--;
        }
        detections[j + 1] = key;
    }
    
    /* Apply NMS */
    uint8_t final_count = 0;
    bool suppressed[MAX_DETECTIONS] = {false};
    
    for (int i = 0; i < *num_detections; i++) {
        if (!suppressed[i]) {
            /* Keep this detection */
            if (i != final_count) {
                detections[final_count] = detections[i];
            }
            final_count++;
            
            /* Suppress overlapping detections */
            for (int j = i + 1; j < *num_detections; j++) {
                if (!suppressed[j]) {
                    float iou = YOLO_IoU(&detections[i], &detections[j]);
                    if (iou > nms_threshold) {
                        suppressed[j] = true;
                    }
                }
            }
        }
    }
    
    *num_detections = final_count;
}

/**
 * Post-process YOLO output to get detections
 */
int32_t YOLO_PostProcess(const int8_t* raw_output,
                         detection_result_t* result)
{
    if (!raw_output || !result) {
        return -1;
    }
    
    /* Clear result structure */
    memset(result, 0, sizeof(detection_result_t));
    
    /* Record start time */
    uint32_t start_time = HAL_GetTick();
    
    /* Decode raw output to detections */
    YOLO_DecodeOutput(raw_output, result->detections, &result->num_detections);
    
    /* Apply Non-Maximum Suppression */
    YOLO_NMS(result->detections, &result->num_detections, NMS_THRESHOLD);
    
    /* Record processing time */
    result->postprocessing_time_ms = HAL_GetTick() - start_time;
    
    return 0;
}

/**
 * Draw bounding boxes on display buffer
 */
void YOLO_DrawDetections(uint16_t* display_buffer,
                        uint16_t width,
                        uint16_t height,
                        const detection_result_t* result)
{
    if (!display_buffer || !result) {
        return;
    }
    
    /* Define colors in RGB565 */
    const uint16_t HIGH_CONF_COLOR = 0x07E0;  /* Green for high confidence */
    const uint16_t MED_CONF_COLOR = 0xFFE0;   /* Yellow for medium confidence */
    const uint16_t LOW_CONF_COLOR = 0xF800;   /* Red for low confidence */
    const uint16_t TEXT_COLOR = 0xFFFF;       /* White for text */
    
    for (int i = 0; i < result->num_detections; i++) {
        const detection_t* det = &result->detections[i];
        
        /* Choose color based on confidence */
        uint16_t box_color;
        if (det->confidence > 0.7f) {
            box_color = HIGH_CONF_COLOR;
        } else if (det->confidence > 0.55f) {
            box_color = MED_CONF_COLOR;
        } else {
            box_color = LOW_CONF_COLOR;
        }
        
        /* Convert normalized coordinates to pixel coordinates */
        int x_min = (int)((det->x - det->width / 2.0f) * width);
        int y_min = (int)((det->y - det->height / 2.0f) * height);
        int x_max = (int)((det->x + det->width / 2.0f) * width);
        int y_max = (int)((det->y + det->height / 2.0f) * height);
        
        /* Clamp to screen boundaries */
        x_min = x_min < 0 ? 0 : (x_min >= width ? width - 1 : x_min);
        y_min = y_min < 0 ? 0 : (y_min >= height ? height - 1 : y_min);
        x_max = x_max < 0 ? 0 : (x_max >= width ? width - 1 : x_max);
        y_max = y_max < 0 ? 0 : (y_max >= height ? height - 1 : y_max);
        
        /* Draw box with 2-pixel width for visibility */
        for (int t = 0; t < 2; t++) {
            /* Top and bottom lines */
            for (int x = x_min; x <= x_max; x++) {
                if (y_min + t < height) display_buffer[(y_min + t) * width + x] = box_color;
                if (y_max - t >= 0) display_buffer[(y_max - t) * width + x] = box_color;
            }
            
            /* Left and right lines */
            for (int y = y_min; y <= y_max; y++) {
                if (x_min + t < width) display_buffer[y * width + (x_min + t)] = box_color;
                if (x_max - t >= 0) display_buffer[y * width + (x_max - t)] = box_color;
            }
        }
        
        /* Draw confidence indicator (small filled rectangle) */
        int conf_width = (int)(20 * det->confidence);
        for (int y = y_min; y < y_min + 5 && y < height; y++) {
            for (int x = x_min; x < x_min + conf_width && x < width; x++) {
                display_buffer[y * width + x] = TEXT_COLOR;
            }
        }
        
        /* Draw "DEER" label background */
        for (int y = y_min - 15; y < y_min && y >= 0; y++) {
            for (int x = x_min; x < x_min + 40 && x < width; x++) {
                display_buffer[y * width + x] = box_color;
            }
        }
    }
}

/**
 * Print detection for debugging
 */
void YOLO_PrintDetection(const detection_t* detection)
{
    printf("Deer detected: x=%.3f, y=%.3f, w=%.3f, h=%.3f, conf=%.3f\n",
           detection->x, detection->y, 
           detection->width, detection->height, 
           detection->confidence);
}

/**
 * Print model statistics
 */
void YOLO_PrintStats(const yolo_model_t* model)
{
    if (model && model->initialized) {
        printf("YOLO Model Statistics:\n");
        printf("  Status: Initialized\n");
        printf("  Model: YOLOv8 nano INT8\n");
        printf("  Weights size: %d KB\n", AI_NETWORK_DATA_WEIGHTS_SIZE / 1024);
        printf("  Activations size: %d KB\n", AI_NETWORK_DATA_ACTIVATIONS_SIZE / 1024);
        printf("  Input: %dx%dx%d (INT8)\n", YOLO_INPUT_WIDTH, YOLO_INPUT_HEIGHT, YOLO_INPUT_CHANNELS);
        printf("  Output: %d elements (INT8)\n", YOLO_OUTPUT_SIZE);
        printf("  Total inferences: %lu\n", model->total_inferences);
        printf("  Total detections: %lu\n", model->total_detections);
        
        if (model->total_inferences > 0) {
            float detection_rate = (float)model->total_detections / model->total_inferences * 100;
            printf("  Detection rate: %d%%\n", (int)(detection_rate));
        }
    } else {
        printf("YOLO Model not initialized\n");
    }
}





