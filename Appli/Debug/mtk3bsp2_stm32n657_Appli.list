
mtk3bsp2_stm32n657_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d36c  3400074c  3400074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000628  3400dab8  3400dab8  0000dab8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  3400e0e0  3400e0e0  0000f160  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  3400e0e0  3400e0e0  0000f160  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  3400e0e0  3400f160  0000f160  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  3400e0e0  3400e0e0  0000e0e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  3400e0e4  3400e0e4  0000e0e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000054  3400e0e8  3400e0e8  0000e0e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .mtk_exctbl   00000d40  3400e400  3400e400  0000e400  2**10
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000000  3400f140  3400f140  0000f160  2**0
                  CONTENTS
 11 .gnu.sgstubs  00000020  3400f140  3400f140  0000f140  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00000594  3400f160  3400f160  0000f160  2**2
                  ALLOC
 13 .noinit       000022d8  3400f6f8  3400f6f8  0000f160  2**3
                  ALLOC
 14 ._user_heap_stack 00000a00  340119d0  340119d0  0000f160  2**0
                  ALLOC
 15 .ARM.attributes 0000003a  00000000  00000000  0000f160  2**0
                  CONTENTS, READONLY
 16 .debug_info   0003223a  00000000  00000000  0000f19a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00007d92  00000000  00000000  000413d4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00002c98  00000000  00000000  00049168  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 0000216c  00000000  00000000  0004be00  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0005b926  00000000  00000000  0004df6c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   00043ce0  00000000  00000000  000a9892  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    00220c75  00000000  00000000  000ed572  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  0030e1e7  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0000b5ac  00000000  00000000  0030e22c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000ad  00000000  00000000  003197d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3400074c <__do_global_dtors_aux>:
3400074c:	b510      	push	{r4, lr}
3400074e:	4c05      	ldr	r4, [pc, #20]	@ (34000764 <__do_global_dtors_aux+0x18>)
34000750:	7823      	ldrb	r3, [r4, #0]
34000752:	b933      	cbnz	r3, 34000762 <__do_global_dtors_aux+0x16>
34000754:	4b04      	ldr	r3, [pc, #16]	@ (34000768 <__do_global_dtors_aux+0x1c>)
34000756:	b113      	cbz	r3, 3400075e <__do_global_dtors_aux+0x12>
34000758:	4804      	ldr	r0, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x20>)
3400075a:	f3af 8000 	nop.w
3400075e:	2301      	movs	r3, #1
34000760:	7023      	strb	r3, [r4, #0]
34000762:	bd10      	pop	{r4, pc}
34000764:	3400f160 	.word	0x3400f160
34000768:	00000000 	.word	0x00000000
3400076c:	3400daa0 	.word	0x3400daa0

34000770 <frame_dummy>:
34000770:	b508      	push	{r3, lr}
34000772:	4b03      	ldr	r3, [pc, #12]	@ (34000780 <frame_dummy+0x10>)
34000774:	b11b      	cbz	r3, 3400077e <frame_dummy+0xe>
34000776:	4903      	ldr	r1, [pc, #12]	@ (34000784 <frame_dummy+0x14>)
34000778:	4803      	ldr	r0, [pc, #12]	@ (34000788 <frame_dummy+0x18>)
3400077a:	f3af 8000 	nop.w
3400077e:	bd08      	pop	{r3, pc}
34000780:	00000000 	.word	0x00000000
34000784:	3400f164 	.word	0x3400f164
34000788:	3400daa0 	.word	0x3400daa0

3400078c <knl_dispatch_entry>:
	.thumb_func
	.globl Csym(knl_dispatch_entry)

Csym(knl_dispatch_entry):	
/*----------------- Start dispatch processing. -----------------*/
	ldr	r0, =Csym(knl_dispatch_disabled)
3400078c:	4828      	ldr	r0, [pc, #160]	@ (34000830 <l_dispatch_200+0x16>)
	ldr	r1, =1
3400078e:	f04f 0101 	mov.w	r1, #1
	str	r1, [r0]			// Dispatch disable
34000792:	6001      	str	r1, [r0, #0]

	ldr	r0, =Csym(knl_ctxtsk)
34000794:	4827      	ldr	r0, [pc, #156]	@ (34000834 <l_dispatch_200+0x1a>)
	ldr	r1, [r0]			// R1 = ctxtsk
34000796:	6801      	ldr	r1, [r0, #0]
	cmp	r1, #0
34000798:	2900      	cmp	r1, #0
	bne	l_dispatch_000
3400079a:	d102      	bne.n	340007a2 <l_dispatch_000>
#if USE_SPMON
	ldr	r2, =INTERNAL_RAM_START
	msr	msplim, r2
#endif
	// Set temporal stack
	ldr	sp, =(Csym(knl_tmp_stack) + TMP_STACK_SIZE)
3400079c:	f8df d098 	ldr.w	sp, [pc, #152]	@ 34000838 <l_dispatch_200+0x1e>
#if USE_SPMON
	ldr	r2, =Csym(knl_tmp_stack)
	msr	msplim, r2
#endif

	b	l_dispatch_100
340007a0:	e011      	b.n	340007c6 <l_dispatch_100>

340007a2 <l_dispatch_000>:

/*----------------- Save "ctxtsk" context. -----------------*/
l_dispatch_000: 
	push	{r4-r11}
340007a2:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	push	{lr}
340007a6:	b500      	push	{lr}

#if USE_FPU			// Save FPU register
	ldr	r2, [r1, #TCB_tskatr]
340007a8:	690a      	ldr	r2, [r1, #16]
	ands	r2, r2, #TA_FPU
340007aa:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
	beq	l_dispatch_010			// ctxtsk is not a TA_FPU attribute.
340007ae:	d005      	beq.n	340007bc <l_dispatch_010>

	ands	r3,lr, #EXPRN_NO_FPU
340007b0:	f01e 0310 	ands.w	r3, lr, #16
	bne	l_dispatch_010			// ctxtsk does not execute FPU instructions.
340007b4:	d102      	bne.n	340007bc <l_dispatch_010>

	vpush	{s16-s31}			// Push FPU register (S16-S31)
340007b6:	ed2d 8a10 	vpush	{s16-s31}
	push	{r3}				//FPU usage flag
340007ba:	b408      	push	{r3}

340007bc <l_dispatch_010>:

l_dispatch_010:			// End of FPU register save process
#endif /* USE_FPU */

	str	sp, [r1, #TCB_tskctxb + CTXB_ssp]	// Save 'ssp' to TCB
340007bc:	f8c1 d018 	str.w	sp, [r1, #24]

	ldr	r2, =0
340007c0:	f04f 0200 	mov.w	r2, #0
	str	r2, [r0]			// ctxtsk = NULL
340007c4:	6002      	str	r2, [r0, #0]

340007c6 <l_dispatch_100>:


/*----------------- Dispatch from "ctxtsk" to "schedtsk" -----------------*/
l_dispatch_100:
	ldr	r4, =Csym(knl_ctxtsk)
340007c6:	4c1b      	ldr	r4, [pc, #108]	@ (34000834 <l_dispatch_200+0x1a>)
	ldr	r5, =Csym(knl_schedtsk)		// R5 = &schedtsk
340007c8:	4d1c      	ldr	r5, [pc, #112]	@ (3400083c <l_dispatch_200+0x22>)
	ldr	r6, =Csym(knl_lowpow_discnt)	// R6 = &lowpow_discnt
340007ca:	4e1d      	ldr	r6, [pc, #116]	@ (34000840 <l_dispatch_200+0x26>)

340007cc <l_dispatch_110>:

l_dispatch_110:
	ldr	r2, =INTPRI_VAL(INTPRI_MAX_EXTINT_PRI)	// Disable interruput
340007cc:	f04f 0210 	mov.w	r2, #16
	msr	basepri, r2
340007d0:	f382 8811 	msr	BASEPRI, r2

	ldr	r8, [r5]			// R8 = schedtsk
340007d4:	f8d5 8000 	ldr.w	r8, [r5]
	cmp	r8, #0				// Is there 'schedtsk'?
340007d8:	f1b8 0f00 	cmp.w	r8, #0
	bne	l_dispatch_120
340007dc:	d10d      	bne.n	340007fa <l_dispatch_120>

	/* Moves to power saving mode because there are no tasks that can be run. */
	ldr	ip, [r6]			// Is 'low_pow' disabled?
340007de:	f8d6 c000 	ldr.w	ip, [r6]
	cmp	ip, #0
340007e2:	f1bc 0f00 	cmp.w	ip, #0
	it	eq
340007e6:	bf08      	it	eq
	bleq	Csym(low_pow)			// call low_pow()
340007e8:	f00d f8aa 	bleq	3400d940 <low_pow>

	ldr	r2, =0
340007ec:	f04f 0200 	mov.w	r2, #0
	msr	basepri, r2			// Enable interruput
340007f0:	f382 8811 	msr	BASEPRI, r2
	isb
340007f4:	f3bf 8f6f 	isb	sy

	b	l_dispatch_110
340007f8:	e7e8      	b.n	340007cc <l_dispatch_110>

340007fa <l_dispatch_120>:

l_dispatch_120:			// Switch to 'schedtsk'
	str	r8, [r4]			// ctxtsk = schedtsk
340007fa:	f8c4 8000 	str.w	r8, [r4]
#if USE_SPMON
	ldr	r2, =INTERNAL_RAM_START
	msr	msplim, r2
#endif

	ldr	sp, [r8, #TCB_tskctxb + CTXB_ssp]	// Restore 'ssp' from TCB
340007fe:	f8d8 d018 	ldr.w	sp, [r8, #24]
#endif

/*----------------- Restore "schedtsk" context. -----------------*/

#if USE_FPU			// Restore FPU context
	ldr	r0, [r8, #TCB_tskatr]
34000802:	f8d8 0010 	ldr.w	r0, [r8, #16]
	ands	r0, r0, #TA_FPU
34000806:	f410 5080 	ands.w	r0, r0, #4096	@ 0x1000
	beq	l_dispatch_200			// schedtsk is not a TA_FPU attribute.
3400080a:	d006      	beq.n	3400081a <l_dispatch_200>

	ldr	r3,[sp]				// load FPU usage flag
3400080c:	9b00      	ldr	r3, [sp, #0]
	ands	r3, r3, #EXPRN_NO_FPU
3400080e:	f013 0310 	ands.w	r3, r3, #16
	bne	l_dispatch_200			// schedtsk does not execute FPU instructions.
34000812:	d102      	bne.n	3400081a <l_dispatch_200>

	pop	{r3}
34000814:	bc08      	pop	{r3}
	vpop	{s16-s31}			// Pop FPU register (S16-S31)
34000816:	ecbd 8a10 	vpop	{s16-s31}

3400081a <l_dispatch_200>:

l_dispatch_200:			//  End of FPU register restore process
#endif	/* USE_FPU */

	pop	{lr}
3400081a:	f85d eb04 	ldr.w	lr, [sp], #4
	pop	{r4-r11}
3400081e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}

	ldr	r0, =Csym(knl_dispatch_disabled)
34000822:	4803      	ldr	r0, [pc, #12]	@ (34000830 <l_dispatch_200+0x16>)
	ldr	r1, =0
34000824:	f04f 0100 	mov.w	r1, #0
	str	r1, [r0]			// Dispatch enable
34000828:	6001      	str	r1, [r0, #0]

	msr	basepri, r1			// Enable inperrupt
3400082a:	f381 8811 	msr	BASEPRI, r1

	bx	lr
3400082e:	4770      	bx	lr
	ldr	r0, =Csym(knl_dispatch_disabled)
34000830:	340109c4 	.word	0x340109c4
	ldr	r0, =Csym(knl_ctxtsk)
34000834:	340109c8 	.word	0x340109c8
	ldr	sp, =(Csym(knl_tmp_stack) + TMP_STACK_SIZE)
34000838:	3400f6b0 	.word	0x3400f6b0
	ldr	r5, =Csym(knl_schedtsk)		// R5 = &schedtsk
3400083c:	340109cc 	.word	0x340109cc
	ldr	r6, =Csym(knl_lowpow_discnt)	// R6 = &lowpow_discnt
34000840:	3400f2ac 	.word	0x3400f2ac

34000844 <out_h>:
Inline void out_w( UW port, UW data )
{
	*(_UW*)port = data;
}
Inline void out_h( UW port, UH data )
{
34000844:	b480      	push	{r7}
34000846:	b083      	sub	sp, #12
34000848:	af00      	add	r7, sp, #0
3400084a:	6078      	str	r0, [r7, #4]
3400084c:	460b      	mov	r3, r1
3400084e:	807b      	strh	r3, [r7, #2]
	*(_UH*)port = data;
34000850:	687b      	ldr	r3, [r7, #4]
34000852:	887a      	ldrh	r2, [r7, #2]
34000854:	801a      	strh	r2, [r3, #0]
}
34000856:	bf00      	nop
34000858:	370c      	adds	r7, #12
3400085a:	46bd      	mov	sp, r7
3400085c:	f85d 7b04 	ldr.w	r7, [sp], #4
34000860:	4770      	bx	lr

34000862 <in_h>:
Inline UW in_w( UW port )
{
	return *(_UW*)port;
}
Inline UH in_h( UW port )
{
34000862:	b480      	push	{r7}
34000864:	b083      	sub	sp, #12
34000866:	af00      	add	r7, sp, #0
34000868:	6078      	str	r0, [r7, #4]
	return *(_UH*)port;
3400086a:	687b      	ldr	r3, [r7, #4]
3400086c:	881b      	ldrh	r3, [r3, #0]
3400086e:	b29b      	uxth	r3, r3
}
34000870:	4618      	mov	r0, r3
34000872:	370c      	adds	r7, #12
34000874:	46bd      	mov	sp, r7
34000876:	f85d 7b04 	ldr.w	r7, [sp], #4
3400087a:	4770      	bx	lr

3400087c <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
3400087c:	b480      	push	{r7}
3400087e:	b085      	sub	sp, #20
34000880:	af00      	add	r7, sp, #0
34000882:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000884:	4a07      	ldr	r2, [pc, #28]	@ (340008a4 <LL_AHB4_GRP1_EnableClock+0x28>)
34000886:	687b      	ldr	r3, [r7, #4]
34000888:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
3400088c:	4b05      	ldr	r3, [pc, #20]	@ (340008a4 <LL_AHB4_GRP1_EnableClock+0x28>)
3400088e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000892:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000894:	68fb      	ldr	r3, [r7, #12]
}
34000896:	bf00      	nop
34000898:	3714      	adds	r7, #20
3400089a:	46bd      	mov	sp, r7
3400089c:	f85d 7b04 	ldr.w	r7, [sp], #4
340008a0:	4770      	bx	lr
340008a2:	bf00      	nop
340008a4:	56028000 	.word	0x56028000

340008a8 <led_on>:
	.tskatr		= TA_HLNG | TA_RNG3,
};

/* LED control using direct register access */
LOCAL void led_on(void)
{
340008a8:	b580      	push	{r7, lr}
340008aa:	af00      	add	r7, sp, #0
	/* Set PO1 high using ODR register */
	out_h(GPIO_ODR(O), in_h(GPIO_ODR(O)) | LED_PIN);
340008ac:	4806      	ldr	r0, [pc, #24]	@ (340008c8 <led_on+0x20>)
340008ae:	f7ff ffd8 	bl	34000862 <in_h>
340008b2:	4603      	mov	r3, r0
340008b4:	f043 0302 	orr.w	r3, r3, #2
340008b8:	b29b      	uxth	r3, r3
340008ba:	4619      	mov	r1, r3
340008bc:	4802      	ldr	r0, [pc, #8]	@ (340008c8 <led_on+0x20>)
340008be:	f7ff ffc1 	bl	34000844 <out_h>
}
340008c2:	bf00      	nop
340008c4:	bd80      	pop	{r7, pc}
340008c6:	bf00      	nop
340008c8:	56023814 	.word	0x56023814

340008cc <led_off>:

LOCAL void led_off(void)
{
340008cc:	b580      	push	{r7, lr}
340008ce:	af00      	add	r7, sp, #0
	/* Set PO1 low using ODR register */
	out_h(GPIO_ODR(O), in_h(GPIO_ODR(O)) & ~LED_PIN);
340008d0:	4806      	ldr	r0, [pc, #24]	@ (340008ec <led_off+0x20>)
340008d2:	f7ff ffc6 	bl	34000862 <in_h>
340008d6:	4603      	mov	r3, r0
340008d8:	f023 0302 	bic.w	r3, r3, #2
340008dc:	b29b      	uxth	r3, r3
340008de:	4619      	mov	r1, r3
340008e0:	4802      	ldr	r0, [pc, #8]	@ (340008ec <led_off+0x20>)
340008e2:	f7ff ffaf 	bl	34000844 <out_h>
}
340008e6:	bf00      	nop
340008e8:	bd80      	pop	{r7, pc}
340008ea:	bf00      	nop
340008ec:	56023814 	.word	0x56023814

340008f0 <led_toggle>:

LOCAL void led_toggle(void)
{
340008f0:	b580      	push	{r7, lr}
340008f2:	af00      	add	r7, sp, #0
	/* Toggle PO1 using ODR register */
	out_h(GPIO_ODR(O), in_h(GPIO_ODR(O)) ^ LED_PIN);
340008f4:	4806      	ldr	r0, [pc, #24]	@ (34000910 <led_toggle+0x20>)
340008f6:	f7ff ffb4 	bl	34000862 <in_h>
340008fa:	4603      	mov	r3, r0
340008fc:	f083 0302 	eor.w	r3, r3, #2
34000900:	b29b      	uxth	r3, r3
34000902:	4619      	mov	r1, r3
34000904:	4802      	ldr	r0, [pc, #8]	@ (34000910 <led_toggle+0x20>)
34000906:	f7ff ff9d 	bl	34000844 <out_h>
}
3400090a:	bf00      	nop
3400090c:	bd80      	pop	{r7, pc}
3400090e:	bf00      	nop
34000910:	56023814 	.word	0x56023814

34000914 <led_hal_toggle>:

/* Alternative LED control using HAL (if available) */
LOCAL void led_hal_toggle(void)
{
34000914:	b580      	push	{r7, lr}
34000916:	b082      	sub	sp, #8
34000918:	af00      	add	r7, sp, #0
	GPIO_TypeDef* gpio_port = (GPIO_TypeDef*)GPIOO_BASE;
3400091a:	4b05      	ldr	r3, [pc, #20]	@ (34000930 <led_hal_toggle+0x1c>)
3400091c:	607b      	str	r3, [r7, #4]
	HAL_GPIO_TogglePin(gpio_port, GPIO_PIN_1);
3400091e:	2102      	movs	r1, #2
34000920:	6878      	ldr	r0, [r7, #4]
34000922:	f003 fb4d 	bl	34003fc0 <HAL_GPIO_TogglePin>
}
34000926:	bf00      	nop
34000928:	3708      	adds	r7, #8
3400092a:	46bd      	mov	sp, r7
3400092c:	bd80      	pop	{r7, pc}
3400092e:	bf00      	nop
34000930:	56023800 	.word	0x56023800

34000934 <task_led>:

LOCAL void task_led(INT stacd, void *exinf)
{
34000934:	b580      	push	{r7, lr}
34000936:	b084      	sub	sp, #16
34000938:	af00      	add	r7, sp, #0
3400093a:	6078      	str	r0, [r7, #4]
3400093c:	6039      	str	r1, [r7, #0]
	UINT counter = 0;
3400093e:	2300      	movs	r3, #0
34000940:	60fb      	str	r3, [r7, #12]
	
	tm_printf((UB*)"LED task started\n");
34000942:	4818      	ldr	r0, [pc, #96]	@ (340009a4 <task_led+0x70>)
34000944:	f00c f8a0 	bl	3400ca88 <tm_printf>
	
	while(1) {
		/* Method 1: Direct register access using macros */
		if(counter % 4 == 0) {
34000948:	68fb      	ldr	r3, [r7, #12]
3400094a:	f003 0303 	and.w	r3, r3, #3
3400094e:	2b00      	cmp	r3, #0
34000950:	d105      	bne.n	3400095e <task_led+0x2a>
			tm_printf((UB*)"LED ON (direct)\n");
34000952:	4815      	ldr	r0, [pc, #84]	@ (340009a8 <task_led+0x74>)
34000954:	f00c f898 	bl	3400ca88 <tm_printf>
			led_on();
34000958:	f7ff ffa6 	bl	340008a8 <led_on>
3400095c:	e01a      	b.n	34000994 <task_led+0x60>
		} else if(counter % 4 == 1) {
3400095e:	68fb      	ldr	r3, [r7, #12]
34000960:	f003 0303 	and.w	r3, r3, #3
34000964:	2b01      	cmp	r3, #1
34000966:	d105      	bne.n	34000974 <task_led+0x40>
			tm_printf((UB*)"LED OFF (direct)\n");
34000968:	4810      	ldr	r0, [pc, #64]	@ (340009ac <task_led+0x78>)
3400096a:	f00c f88d 	bl	3400ca88 <tm_printf>
			led_off();
3400096e:	f7ff ffad 	bl	340008cc <led_off>
34000972:	e00f      	b.n	34000994 <task_led+0x60>
		} else if(counter % 4 == 2) {
34000974:	68fb      	ldr	r3, [r7, #12]
34000976:	f003 0303 	and.w	r3, r3, #3
3400097a:	2b02      	cmp	r3, #2
3400097c:	d105      	bne.n	3400098a <task_led+0x56>
			tm_printf((UB*)"LED Toggle (direct)\n");
3400097e:	480c      	ldr	r0, [pc, #48]	@ (340009b0 <task_led+0x7c>)
34000980:	f00c f882 	bl	3400ca88 <tm_printf>
			led_toggle();
34000984:	f7ff ffb4 	bl	340008f0 <led_toggle>
34000988:	e004      	b.n	34000994 <task_led+0x60>
		} else {
			tm_printf((UB*)"LED Toggle (HAL)\n");
3400098a:	480a      	ldr	r0, [pc, #40]	@ (340009b4 <task_led+0x80>)
3400098c:	f00c f87c 	bl	3400ca88 <tm_printf>
			led_hal_toggle();
34000990:	f7ff ffc0 	bl	34000914 <led_hal_toggle>
		}
		
		counter++;
34000994:	68fb      	ldr	r3, [r7, #12]
34000996:	3301      	adds	r3, #1
34000998:	60fb      	str	r3, [r7, #12]
		tk_dly_tsk(500);
3400099a:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
3400099e:	f00a fd53 	bl	3400b448 <tk_dly_tsk>
		if(counter % 4 == 0) {
340009a2:	e7d1      	b.n	34000948 <task_led+0x14>
340009a4:	3400dab8 	.word	0x3400dab8
340009a8:	3400dacc 	.word	0x3400dacc
340009ac:	3400dae0 	.word	0x3400dae0
340009b0:	3400daf4 	.word	0x3400daf4
340009b4:	3400db0c 	.word	0x3400db0c

340009b8 <task_msg>:
	}
}

LOCAL void task_msg(INT stacd, void *exinf)
{
340009b8:	b580      	push	{r7, lr}
340009ba:	b084      	sub	sp, #16
340009bc:	af00      	add	r7, sp, #0
340009be:	6078      	str	r0, [r7, #4]
340009c0:	6039      	str	r1, [r7, #0]
	UINT msg_count = 0;
340009c2:	2300      	movs	r3, #0
340009c4:	60fb      	str	r3, [r7, #12]
	
	tm_printf((UB*)"Message task started\n");
340009c6:	4810      	ldr	r0, [pc, #64]	@ (34000a08 <task_msg+0x50>)
340009c8:	f00c f85e 	bl	3400ca88 <tm_printf>
	
	while(1) {
		tm_printf((UB*)"Message %d - System running\n", msg_count++);
340009cc:	68fb      	ldr	r3, [r7, #12]
340009ce:	1c5a      	adds	r2, r3, #1
340009d0:	60fa      	str	r2, [r7, #12]
340009d2:	4619      	mov	r1, r3
340009d4:	480d      	ldr	r0, [pc, #52]	@ (34000a0c <task_msg+0x54>)
340009d6:	f00c f857 	bl	3400ca88 <tm_printf>
		
		/* Check GPIO status */
		UINT gpio_status = in_h(GPIO_ODR(O));
340009da:	480d      	ldr	r0, [pc, #52]	@ (34000a10 <task_msg+0x58>)
340009dc:	f7ff ff41 	bl	34000862 <in_h>
340009e0:	4603      	mov	r3, r0
340009e2:	60bb      	str	r3, [r7, #8]
		tm_printf((UB*)"GPIO Port O ODR: 0x%08X, LED is %s\n", 
			gpio_status, 
			(gpio_status & LED_PIN) ? "ON" : "OFF");
340009e4:	68bb      	ldr	r3, [r7, #8]
340009e6:	f003 0302 	and.w	r3, r3, #2
		tm_printf((UB*)"GPIO Port O ODR: 0x%08X, LED is %s\n", 
340009ea:	2b00      	cmp	r3, #0
340009ec:	d001      	beq.n	340009f2 <task_msg+0x3a>
340009ee:	4b09      	ldr	r3, [pc, #36]	@ (34000a14 <task_msg+0x5c>)
340009f0:	e000      	b.n	340009f4 <task_msg+0x3c>
340009f2:	4b09      	ldr	r3, [pc, #36]	@ (34000a18 <task_msg+0x60>)
340009f4:	461a      	mov	r2, r3
340009f6:	68b9      	ldr	r1, [r7, #8]
340009f8:	4808      	ldr	r0, [pc, #32]	@ (34000a1c <task_msg+0x64>)
340009fa:	f00c f845 	bl	3400ca88 <tm_printf>
		
		tk_dly_tsk(700);
340009fe:	f44f 702f 	mov.w	r0, #700	@ 0x2bc
34000a02:	f00a fd21 	bl	3400b448 <tk_dly_tsk>
	while(1) {
34000a06:	e7e1      	b.n	340009cc <task_msg+0x14>
34000a08:	3400db20 	.word	0x3400db20
34000a0c:	3400db38 	.word	0x3400db38
34000a10:	56023814 	.word	0x56023814
34000a14:	3400db58 	.word	0x3400db58
34000a18:	3400db5c 	.word	0x3400db5c
34000a1c:	3400db60 	.word	0x3400db60

34000a20 <init_led_gpio>:
	}
}

/* Initialize GPIO for LED */
LOCAL void init_led_gpio(void)
{
34000a20:	b580      	push	{r7, lr}
34000a22:	b086      	sub	sp, #24
34000a24:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStruct = {0};
34000a26:	463b      	mov	r3, r7
34000a28:	2200      	movs	r2, #0
34000a2a:	601a      	str	r2, [r3, #0]
34000a2c:	605a      	str	r2, [r3, #4]
34000a2e:	609a      	str	r2, [r3, #8]
34000a30:	60da      	str	r2, [r3, #12]
34000a32:	611a      	str	r2, [r3, #16]
	GPIO_TypeDef* gpio_port = (GPIO_TypeDef*)GPIOO_BASE;
34000a34:	4b10      	ldr	r3, [pc, #64]	@ (34000a78 <init_led_gpio+0x58>)
34000a36:	617b      	str	r3, [r7, #20]
	
	/* Enable GPIO Port O clock */
	__HAL_RCC_GPIOO_CLK_ENABLE();
34000a38:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34000a3c:	f7ff ff1e 	bl	3400087c <LL_AHB4_GRP1_EnableClock>
	
	/* Enable VDDIO2 power supply for Port O */
	HAL_PWREx_EnableVddIO2();
34000a40:	f005 f9a8 	bl	34005d94 <HAL_PWREx_EnableVddIO2>
	
	/* Configure PO1 as output */
	HAL_GPIO_WritePin(gpio_port, GPIO_PIN_1, GPIO_PIN_RESET);
34000a44:	2200      	movs	r2, #0
34000a46:	2102      	movs	r1, #2
34000a48:	6978      	ldr	r0, [r7, #20]
34000a4a:	f003 faa1 	bl	34003f90 <HAL_GPIO_WritePin>
	
	GPIO_InitStruct.Pin = GPIO_PIN_1;
34000a4e:	2302      	movs	r3, #2
34000a50:	603b      	str	r3, [r7, #0]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34000a52:	2301      	movs	r3, #1
34000a54:	607b      	str	r3, [r7, #4]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
34000a56:	2300      	movs	r3, #0
34000a58:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34000a5a:	2300      	movs	r3, #0
34000a5c:	60fb      	str	r3, [r7, #12]
	HAL_GPIO_Init(gpio_port, &GPIO_InitStruct);
34000a5e:	463b      	mov	r3, r7
34000a60:	4619      	mov	r1, r3
34000a62:	6978      	ldr	r0, [r7, #20]
34000a64:	f003 f8e2 	bl	34003c2c <HAL_GPIO_Init>
	
	tm_putstring((UB*)"LED GPIO initialized (PO1)\n");
34000a68:	4804      	ldr	r0, [pc, #16]	@ (34000a7c <init_led_gpio+0x5c>)
34000a6a:	f00b fc6d 	bl	3400c348 <tm_putstring>
}
34000a6e:	bf00      	nop
34000a70:	3718      	adds	r7, #24
34000a72:	46bd      	mov	sp, r7
34000a74:	bd80      	pop	{r7, pc}
34000a76:	bf00      	nop
34000a78:	56023800 	.word	0x56023800
34000a7c:	3400db84 	.word	0x3400db84

34000a80 <usermain>:

/* usermain髢｢謨ｰ */
EXPORT INT usermain(void)
{
34000a80:	b580      	push	{r7, lr}
34000a82:	b082      	sub	sp, #8
34000a84:	af00      	add	r7, sp, #0
	tm_putstring((UB*)"================================\n");
34000a86:	4834      	ldr	r0, [pc, #208]	@ (34000b58 <usermain+0xd8>)
34000a88:	f00b fc5e 	bl	3400c348 <tm_putstring>
	tm_putstring((UB*)"Start User-main program.\n");
34000a8c:	4833      	ldr	r0, [pc, #204]	@ (34000b5c <usermain+0xdc>)
34000a8e:	f00b fc5b 	bl	3400c348 <tm_putstring>
	tm_putstring((UB*)"STM32N6570-DK ﾎｼT-Kernel 3.0 BSP2\n");
34000a92:	4833      	ldr	r0, [pc, #204]	@ (34000b60 <usermain+0xe0>)
34000a94:	f00b fc58 	bl	3400c348 <tm_putstring>
	tm_putstring((UB*)"LED Control Demo\n");
34000a98:	4832      	ldr	r0, [pc, #200]	@ (34000b64 <usermain+0xe4>)
34000a9a:	f00b fc55 	bl	3400c348 <tm_putstring>
	tm_putstring((UB*)"================================\n");
34000a9e:	482e      	ldr	r0, [pc, #184]	@ (34000b58 <usermain+0xd8>)
34000aa0:	f00b fc52 	bl	3400c348 <tm_putstring>

	/* Initialize LED GPIO */
	init_led_gpio();
34000aa4:	f7ff ffbc 	bl	34000a20 <init_led_gpio>
	
	/* Turn off the LED initially */
	led_off();
34000aa8:	f7ff ff10 	bl	340008cc <led_off>
	tm_putstring((UB*)"LED turned OFF initially\n");
34000aac:	482e      	ldr	r0, [pc, #184]	@ (34000b68 <usermain+0xe8>)
34000aae:	f00b fc4b 	bl	3400c348 <tm_putstring>
	
	/* Test LED by blinking 3 times */
	tm_putstring((UB*)"Testing LED...\n");
34000ab2:	482e      	ldr	r0, [pc, #184]	@ (34000b6c <usermain+0xec>)
34000ab4:	f00b fc48 	bl	3400c348 <tm_putstring>
	for(int i = 0; i < 3; i++) {
34000ab8:	2300      	movs	r3, #0
34000aba:	607b      	str	r3, [r7, #4]
34000abc:	e00c      	b.n	34000ad8 <usermain+0x58>
		led_on();
34000abe:	f7ff fef3 	bl	340008a8 <led_on>
		tk_dly_tsk(200);
34000ac2:	20c8      	movs	r0, #200	@ 0xc8
34000ac4:	f00a fcc0 	bl	3400b448 <tk_dly_tsk>
		led_off();
34000ac8:	f7ff ff00 	bl	340008cc <led_off>
		tk_dly_tsk(200);
34000acc:	20c8      	movs	r0, #200	@ 0xc8
34000ace:	f00a fcbb 	bl	3400b448 <tk_dly_tsk>
	for(int i = 0; i < 3; i++) {
34000ad2:	687b      	ldr	r3, [r7, #4]
34000ad4:	3301      	adds	r3, #1
34000ad6:	607b      	str	r3, [r7, #4]
34000ad8:	687b      	ldr	r3, [r7, #4]
34000ada:	2b02      	cmp	r3, #2
34000adc:	ddef      	ble.n	34000abe <usermain+0x3e>
	}
	tm_putstring((UB*)"LED test complete\n");
34000ade:	4824      	ldr	r0, [pc, #144]	@ (34000b70 <usermain+0xf0>)
34000ae0:	f00b fc32 	bl	3400c348 <tm_putstring>

	/* Create & Start LED control task */
	tskid_led = tk_cre_tsk(&ctsk_led);
34000ae4:	4823      	ldr	r0, [pc, #140]	@ (34000b74 <usermain+0xf4>)
34000ae6:	f00a faef 	bl	3400b0c8 <tk_cre_tsk>
34000aea:	4603      	mov	r3, r0
34000aec:	4a22      	ldr	r2, [pc, #136]	@ (34000b78 <usermain+0xf8>)
34000aee:	6013      	str	r3, [r2, #0]
	if(tskid_led > 0) {
34000af0:	4b21      	ldr	r3, [pc, #132]	@ (34000b78 <usermain+0xf8>)
34000af2:	681b      	ldr	r3, [r3, #0]
34000af4:	2b00      	cmp	r3, #0
34000af6:	dd09      	ble.n	34000b0c <usermain+0x8c>
		tk_sta_tsk(tskid_led, 0);
34000af8:	4b1f      	ldr	r3, [pc, #124]	@ (34000b78 <usermain+0xf8>)
34000afa:	681b      	ldr	r3, [r3, #0]
34000afc:	2100      	movs	r1, #0
34000afe:	4618      	mov	r0, r3
34000b00:	f00a fb90 	bl	3400b224 <tk_sta_tsk>
		tm_putstring((UB*)"LED task created and started\n");
34000b04:	481d      	ldr	r0, [pc, #116]	@ (34000b7c <usermain+0xfc>)
34000b06:	f00b fc1f 	bl	3400c348 <tm_putstring>
34000b0a:	e002      	b.n	34000b12 <usermain+0x92>
	} else {
		tm_putstring((UB*)"ERROR: Failed to create LED task\n");
34000b0c:	481c      	ldr	r0, [pc, #112]	@ (34000b80 <usermain+0x100>)
34000b0e:	f00b fc1b 	bl	3400c348 <tm_putstring>
	}

	/* Create & Start message task */
	tskid_msg = tk_cre_tsk(&ctsk_msg);
34000b12:	481c      	ldr	r0, [pc, #112]	@ (34000b84 <usermain+0x104>)
34000b14:	f00a fad8 	bl	3400b0c8 <tk_cre_tsk>
34000b18:	4603      	mov	r3, r0
34000b1a:	4a1b      	ldr	r2, [pc, #108]	@ (34000b88 <usermain+0x108>)
34000b1c:	6013      	str	r3, [r2, #0]
	if(tskid_msg > 0) {
34000b1e:	4b1a      	ldr	r3, [pc, #104]	@ (34000b88 <usermain+0x108>)
34000b20:	681b      	ldr	r3, [r3, #0]
34000b22:	2b00      	cmp	r3, #0
34000b24:	dd09      	ble.n	34000b3a <usermain+0xba>
		tk_sta_tsk(tskid_msg, 0);
34000b26:	4b18      	ldr	r3, [pc, #96]	@ (34000b88 <usermain+0x108>)
34000b28:	681b      	ldr	r3, [r3, #0]
34000b2a:	2100      	movs	r1, #0
34000b2c:	4618      	mov	r0, r3
34000b2e:	f00a fb79 	bl	3400b224 <tk_sta_tsk>
		tm_putstring((UB*)"Message task created and started\n");
34000b32:	4816      	ldr	r0, [pc, #88]	@ (34000b8c <usermain+0x10c>)
34000b34:	f00b fc08 	bl	3400c348 <tm_putstring>
34000b38:	e002      	b.n	34000b40 <usermain+0xc0>
	} else {
		tm_putstring((UB*)"ERROR: Failed to create message task\n");
34000b3a:	4815      	ldr	r0, [pc, #84]	@ (34000b90 <usermain+0x110>)
34000b3c:	f00b fc04 	bl	3400c348 <tm_putstring>
	}

	tm_putstring((UB*)"Main task entering sleep mode\n");
34000b40:	4814      	ldr	r0, [pc, #80]	@ (34000b94 <usermain+0x114>)
34000b42:	f00b fc01 	bl	3400c348 <tm_putstring>
	tk_slp_tsk(TMO_FEVR);
34000b46:	f04f 30ff 	mov.w	r0, #4294967295
34000b4a:	f00a fc11 	bl	3400b370 <tk_slp_tsk>

	return 0;
34000b4e:	2300      	movs	r3, #0
}
34000b50:	4618      	mov	r0, r3
34000b52:	3708      	adds	r7, #8
34000b54:	46bd      	mov	sp, r7
34000b56:	bd80      	pop	{r7, pc}
34000b58:	3400dba0 	.word	0x3400dba0
34000b5c:	3400dbc4 	.word	0x3400dbc4
34000b60:	3400dbe0 	.word	0x3400dbe0
34000b64:	3400dc08 	.word	0x3400dc08
34000b68:	3400dc1c 	.word	0x3400dc1c
34000b6c:	3400dc38 	.word	0x3400dc38
34000b70:	3400dc48 	.word	0x3400dc48
34000b74:	3400e0e8 	.word	0x3400e0e8
34000b78:	3400f17c 	.word	0x3400f17c
34000b7c:	3400dc5c 	.word	0x3400dc5c
34000b80:	3400dc7c 	.word	0x3400dc7c
34000b84:	3400e100 	.word	0x3400e100
34000b88:	3400f180 	.word	0x3400f180
34000b8c:	3400dca0 	.word	0x3400dca0
34000b90:	3400dcc4 	.word	0x3400dcc4
34000b94:	3400dcec 	.word	0x3400dcec

34000b98 <LL_AHB3_GRP1_EnableClock>:
{
34000b98:	b480      	push	{r7}
34000b9a:	b085      	sub	sp, #20
34000b9c:	af00      	add	r7, sp, #0
34000b9e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34000ba0:	4a07      	ldr	r2, [pc, #28]	@ (34000bc0 <LL_AHB3_GRP1_EnableClock+0x28>)
34000ba2:	687b      	ldr	r3, [r7, #4]
34000ba4:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  tmpreg = READ_REG(RCC->AHB3ENR);
34000ba8:	4b05      	ldr	r3, [pc, #20]	@ (34000bc0 <LL_AHB3_GRP1_EnableClock+0x28>)
34000baa:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
34000bae:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000bb0:	68fb      	ldr	r3, [r7, #12]
}
34000bb2:	bf00      	nop
34000bb4:	3714      	adds	r7, #20
34000bb6:	46bd      	mov	sp, r7
34000bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34000bbc:	4770      	bx	lr
34000bbe:	bf00      	nop
34000bc0:	56028000 	.word	0x56028000

34000bc4 <LL_AHB4_GRP1_EnableClock>:
{
34000bc4:	b480      	push	{r7}
34000bc6:	b085      	sub	sp, #20
34000bc8:	af00      	add	r7, sp, #0
34000bca:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000bcc:	4a07      	ldr	r2, [pc, #28]	@ (34000bec <LL_AHB4_GRP1_EnableClock+0x28>)
34000bce:	687b      	ldr	r3, [r7, #4]
34000bd0:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34000bd4:	4b05      	ldr	r3, [pc, #20]	@ (34000bec <LL_AHB4_GRP1_EnableClock+0x28>)
34000bd6:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000bda:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000bdc:	68fb      	ldr	r3, [r7, #12]
}
34000bde:	bf00      	nop
34000be0:	3714      	adds	r7, #20
34000be2:	46bd      	mov	sp, r7
34000be4:	f85d 7b04 	ldr.w	r7, [sp], #4
34000be8:	4770      	bx	lr
34000bea:	bf00      	nop
34000bec:	56028000 	.word	0x56028000

34000bf0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34000bf0:	b580      	push	{r7, lr}
34000bf2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34000bf4:	f000 fe49 	bl	3400188a <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34000bf8:	f000 f954 	bl	34000ea4 <MX_GPIO_Init>
  MX_ADC1_Init();
34000bfc:	f000 f808 	bl	34000c10 <MX_ADC1_Init>
  MX_ADC2_Init();
34000c00:	f000 f89a 	bl	34000d38 <MX_ADC2_Init>
  MX_I2C1_Init();
34000c04:	f000 f90e 	bl	34000e24 <MX_I2C1_Init>
  /* USER CODE BEGIN 2 */
  /* Start mT-Kernel 3.0 */
  void knl_start_mtkernel(void);
  knl_start_mtkernel();
34000c08:	f00c f870 	bl	3400ccec <knl_start_mtkernel>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34000c0c:	bf00      	nop
34000c0e:	e7fd      	b.n	34000c0c <main+0x1c>

34000c10 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
34000c10:	b580      	push	{r7, lr}
34000c12:	b092      	sub	sp, #72	@ 0x48
34000c14:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
34000c16:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34000c1a:	2200      	movs	r2, #0
34000c1c:	601a      	str	r2, [r3, #0]
34000c1e:	605a      	str	r2, [r3, #4]
34000c20:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
34000c22:	f107 031c 	add.w	r3, r7, #28
34000c26:	2220      	movs	r2, #32
34000c28:	2100      	movs	r1, #0
34000c2a:	4618      	mov	r0, r3
34000c2c:	f00c ff0c 	bl	3400da48 <memset>
  ADC_AnalogWDGConfTypeDef AnalogWDGConfig = {0};
34000c30:	463b      	mov	r3, r7
34000c32:	2200      	movs	r2, #0
34000c34:	601a      	str	r2, [r3, #0]
34000c36:	605a      	str	r2, [r3, #4]
34000c38:	609a      	str	r2, [r3, #8]
34000c3a:	60da      	str	r2, [r3, #12]
34000c3c:	611a      	str	r2, [r3, #16]
34000c3e:	615a      	str	r2, [r3, #20]
34000c40:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN ADC1_Init 1 */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34000c42:	f44f 7000 	mov.w	r0, #512	@ 0x200
34000c46:	f7ff ffa7 	bl	34000b98 <LL_AHB3_GRP1_EnableClock>
  RIFSC->RISC_SECCFGRx[2] |= 0x1;
34000c4a:	4b38      	ldr	r3, [pc, #224]	@ (34000d2c <MX_ADC1_Init+0x11c>)
34000c4c:	699b      	ldr	r3, [r3, #24]
34000c4e:	4a37      	ldr	r2, [pc, #220]	@ (34000d2c <MX_ADC1_Init+0x11c>)
34000c50:	f043 0301 	orr.w	r3, r3, #1
34000c54:	6193      	str	r3, [r2, #24]
  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
34000c56:	4b36      	ldr	r3, [pc, #216]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c58:	4a36      	ldr	r2, [pc, #216]	@ (34000d34 <MX_ADC1_Init+0x124>)
34000c5a:	601a      	str	r2, [r3, #0]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
34000c5c:	4b34      	ldr	r3, [pc, #208]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c5e:	2200      	movs	r2, #0
34000c60:	605a      	str	r2, [r3, #4]
  hadc1.Init.GainCompensation = 0;
34000c62:	4b33      	ldr	r3, [pc, #204]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c64:	2200      	movs	r2, #0
34000c66:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
34000c68:	4b31      	ldr	r3, [pc, #196]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c6a:	2200      	movs	r2, #0
34000c6c:	60da      	str	r2, [r3, #12]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
34000c6e:	4b30      	ldr	r3, [pc, #192]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c70:	2204      	movs	r2, #4
34000c72:	611a      	str	r2, [r3, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
34000c74:	4b2e      	ldr	r3, [pc, #184]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c76:	2200      	movs	r2, #0
34000c78:	751a      	strb	r2, [r3, #20]
  hadc1.Init.ContinuousConvMode = DISABLE;
34000c7a:	4b2d      	ldr	r3, [pc, #180]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c7c:	2200      	movs	r2, #0
34000c7e:	755a      	strb	r2, [r3, #21]
  hadc1.Init.NbrOfConversion = 1;
34000c80:	4b2b      	ldr	r3, [pc, #172]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c82:	2201      	movs	r2, #1
34000c84:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
34000c86:	4b2a      	ldr	r3, [pc, #168]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c88:	2200      	movs	r2, #0
34000c8a:	771a      	strb	r2, [r3, #28]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
34000c8c:	4b28      	ldr	r3, [pc, #160]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c8e:	2200      	movs	r2, #0
34000c90:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
34000c92:	4b27      	ldr	r3, [pc, #156]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c94:	2200      	movs	r2, #0
34000c96:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
34000c98:	4b25      	ldr	r3, [pc, #148]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000c9a:	2200      	movs	r2, #0
34000c9c:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
34000c9e:	4b24      	ldr	r3, [pc, #144]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000ca0:	2200      	movs	r2, #0
34000ca2:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
34000ca4:	4b22      	ldr	r3, [pc, #136]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000ca6:	2200      	movs	r2, #0
34000ca8:	639a      	str	r2, [r3, #56]	@ 0x38
  hadc1.Init.OversamplingMode = DISABLE;
34000caa:	4b21      	ldr	r3, [pc, #132]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000cac:	2200      	movs	r2, #0
34000cae:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
34000cb2:	481f      	ldr	r0, [pc, #124]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000cb4:	f001 fb3c 	bl	34002330 <HAL_ADC_Init>
34000cb8:	4603      	mov	r3, r0
34000cba:	2b00      	cmp	r3, #0
34000cbc:	d001      	beq.n	34000cc2 <MX_ADC1_Init+0xb2>
  {
    Error_Handler();
34000cbe:	f000 f929 	bl	34000f14 <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
34000cc2:	2300      	movs	r3, #0
34000cc4:	63fb      	str	r3, [r7, #60]	@ 0x3c
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
34000cc6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34000cca:	4619      	mov	r1, r3
34000ccc:	4818      	ldr	r0, [pc, #96]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000cce:	f002 fda5 	bl	3400381c <HAL_ADCEx_MultiModeConfigChannel>
34000cd2:	4603      	mov	r3, r0
34000cd4:	2b00      	cmp	r3, #0
34000cd6:	d001      	beq.n	34000cdc <MX_ADC1_Init+0xcc>
  {
    Error_Handler();
34000cd8:	f000 f91c 	bl	34000f14 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_12;
34000cdc:	230c      	movs	r3, #12
34000cde:	61fb      	str	r3, [r7, #28]
  sConfig.Rank = ADC_REGULAR_RANK_1;
34000ce0:	2306      	movs	r3, #6
34000ce2:	623b      	str	r3, [r7, #32]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
34000ce4:	2300      	movs	r3, #0
34000ce6:	627b      	str	r3, [r7, #36]	@ 0x24
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
34000ce8:	f240 33ff 	movw	r3, #1023	@ 0x3ff
34000cec:	62bb      	str	r3, [r7, #40]	@ 0x28
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
34000cee:	2304      	movs	r3, #4
34000cf0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sConfig.Offset = 0;
34000cf2:	2300      	movs	r3, #0
34000cf4:	633b      	str	r3, [r7, #48]	@ 0x30
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
34000cf6:	f107 031c 	add.w	r3, r7, #28
34000cfa:	4619      	mov	r1, r3
34000cfc:	480c      	ldr	r0, [pc, #48]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000cfe:	f001 ffa9 	bl	34002c54 <HAL_ADC_ConfigChannel>
34000d02:	4603      	mov	r3, r0
34000d04:	2b00      	cmp	r3, #0
34000d06:	d001      	beq.n	34000d0c <MX_ADC1_Init+0xfc>
  {
    Error_Handler();
34000d08:	f000 f904 	bl	34000f14 <Error_Handler>
  }

  /** Configure the regular channel to be monitored by WatchDog 2 or 3
  */
  AnalogWDGConfig.FilteringConfig = ADC_AWD_FILTERING_NONE;
34000d0c:	2300      	movs	r3, #0
34000d0e:	61bb      	str	r3, [r7, #24]

  if (HAL_ADC_AnalogWDGConfig(&hadc1, &AnalogWDGConfig) != HAL_OK)
34000d10:	463b      	mov	r3, r7
34000d12:	4619      	mov	r1, r3
34000d14:	4806      	ldr	r0, [pc, #24]	@ (34000d30 <MX_ADC1_Init+0x120>)
34000d16:	f002 f99f 	bl	34003058 <HAL_ADC_AnalogWDGConfig>
34000d1a:	4603      	mov	r3, r0
34000d1c:	2b00      	cmp	r3, #0
34000d1e:	d001      	beq.n	34000d24 <MX_ADC1_Init+0x114>
  {
    Error_Handler();
34000d20:	f000 f8f8 	bl	34000f14 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
34000d24:	bf00      	nop
34000d26:	3748      	adds	r7, #72	@ 0x48
34000d28:	46bd      	mov	sp, r7
34000d2a:	bd80      	pop	{r7, pc}
34000d2c:	54024000 	.word	0x54024000
34000d30:	3400f184 	.word	0x3400f184
34000d34:	50022000 	.word	0x50022000

34000d38 <MX_ADC2_Init>:
  * @brief ADC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC2_Init(void)
{
34000d38:	b580      	push	{r7, lr}
34000d3a:	b090      	sub	sp, #64	@ 0x40
34000d3c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC2_Init 0 */

  /* USER CODE END ADC2_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
34000d3e:	f107 0320 	add.w	r3, r7, #32
34000d42:	2220      	movs	r2, #32
34000d44:	2100      	movs	r1, #0
34000d46:	4618      	mov	r0, r3
34000d48:	f00c fe7e 	bl	3400da48 <memset>
  ADC_AnalogWDGConfTypeDef AnalogWDGConfig = {0};
34000d4c:	1d3b      	adds	r3, r7, #4
34000d4e:	2200      	movs	r2, #0
34000d50:	601a      	str	r2, [r3, #0]
34000d52:	605a      	str	r2, [r3, #4]
34000d54:	609a      	str	r2, [r3, #8]
34000d56:	60da      	str	r2, [r3, #12]
34000d58:	611a      	str	r2, [r3, #16]
34000d5a:	615a      	str	r2, [r3, #20]
34000d5c:	619a      	str	r2, [r3, #24]

  /* USER CODE END ADC2_Init 1 */

  /** Common config
  */
  hadc2.Instance = ADC2;
34000d5e:	4b2f      	ldr	r3, [pc, #188]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d60:	4a2f      	ldr	r2, [pc, #188]	@ (34000e20 <MX_ADC2_Init+0xe8>)
34000d62:	601a      	str	r2, [r3, #0]
  hadc2.Init.Resolution = ADC_RESOLUTION_12B;
34000d64:	4b2d      	ldr	r3, [pc, #180]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d66:	2200      	movs	r2, #0
34000d68:	605a      	str	r2, [r3, #4]
  hadc2.Init.GainCompensation = 0;
34000d6a:	4b2c      	ldr	r3, [pc, #176]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d6c:	2200      	movs	r2, #0
34000d6e:	609a      	str	r2, [r3, #8]
  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
34000d70:	4b2a      	ldr	r3, [pc, #168]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d72:	2200      	movs	r2, #0
34000d74:	60da      	str	r2, [r3, #12]
  hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
34000d76:	4b29      	ldr	r3, [pc, #164]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d78:	2204      	movs	r2, #4
34000d7a:	611a      	str	r2, [r3, #16]
  hadc2.Init.LowPowerAutoWait = DISABLE;
34000d7c:	4b27      	ldr	r3, [pc, #156]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d7e:	2200      	movs	r2, #0
34000d80:	751a      	strb	r2, [r3, #20]
  hadc2.Init.ContinuousConvMode = DISABLE;
34000d82:	4b26      	ldr	r3, [pc, #152]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d84:	2200      	movs	r2, #0
34000d86:	755a      	strb	r2, [r3, #21]
  hadc2.Init.NbrOfConversion = 1;
34000d88:	4b24      	ldr	r3, [pc, #144]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d8a:	2201      	movs	r2, #1
34000d8c:	619a      	str	r2, [r3, #24]
  hadc2.Init.DiscontinuousConvMode = DISABLE;
34000d8e:	4b23      	ldr	r3, [pc, #140]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d90:	2200      	movs	r2, #0
34000d92:	771a      	strb	r2, [r3, #28]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
34000d94:	4b21      	ldr	r3, [pc, #132]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d96:	2200      	movs	r2, #0
34000d98:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
34000d9a:	4b20      	ldr	r3, [pc, #128]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000d9c:	2200      	movs	r2, #0
34000d9e:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc2.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
34000da0:	4b1e      	ldr	r3, [pc, #120]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000da2:	2200      	movs	r2, #0
34000da4:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
34000da6:	4b1d      	ldr	r3, [pc, #116]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000da8:	2200      	movs	r2, #0
34000daa:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc2.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
34000dac:	4b1b      	ldr	r3, [pc, #108]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000dae:	2200      	movs	r2, #0
34000db0:	639a      	str	r2, [r3, #56]	@ 0x38
  hadc2.Init.OversamplingMode = DISABLE;
34000db2:	4b1a      	ldr	r3, [pc, #104]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000db4:	2200      	movs	r2, #0
34000db6:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
34000dba:	4818      	ldr	r0, [pc, #96]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000dbc:	f001 fab8 	bl	34002330 <HAL_ADC_Init>
34000dc0:	4603      	mov	r3, r0
34000dc2:	2b00      	cmp	r3, #0
34000dc4:	d001      	beq.n	34000dca <MX_ADC2_Init+0x92>
  {
    Error_Handler();
34000dc6:	f000 f8a5 	bl	34000f14 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_18;
34000dca:	2312      	movs	r3, #18
34000dcc:	623b      	str	r3, [r7, #32]
  sConfig.Rank = ADC_REGULAR_RANK_1;
34000dce:	2306      	movs	r3, #6
34000dd0:	627b      	str	r3, [r7, #36]	@ 0x24
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
34000dd2:	2300      	movs	r3, #0
34000dd4:	62bb      	str	r3, [r7, #40]	@ 0x28
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
34000dd6:	f240 33ff 	movw	r3, #1023	@ 0x3ff
34000dda:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
34000ddc:	2304      	movs	r3, #4
34000dde:	633b      	str	r3, [r7, #48]	@ 0x30
  sConfig.Offset = 0;
34000de0:	2300      	movs	r3, #0
34000de2:	637b      	str	r3, [r7, #52]	@ 0x34
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
34000de4:	f107 0320 	add.w	r3, r7, #32
34000de8:	4619      	mov	r1, r3
34000dea:	480c      	ldr	r0, [pc, #48]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000dec:	f001 ff32 	bl	34002c54 <HAL_ADC_ConfigChannel>
34000df0:	4603      	mov	r3, r0
34000df2:	2b00      	cmp	r3, #0
34000df4:	d001      	beq.n	34000dfa <MX_ADC2_Init+0xc2>
  {
    Error_Handler();
34000df6:	f000 f88d 	bl	34000f14 <Error_Handler>
  }

  /** Configure the regular channel to be monitored by WatchDog 2 or 3
  */
  AnalogWDGConfig.FilteringConfig = ADC_AWD_FILTERING_NONE;
34000dfa:	2300      	movs	r3, #0
34000dfc:	61fb      	str	r3, [r7, #28]

  if (HAL_ADC_AnalogWDGConfig(&hadc2, &AnalogWDGConfig) != HAL_OK)
34000dfe:	1d3b      	adds	r3, r7, #4
34000e00:	4619      	mov	r1, r3
34000e02:	4806      	ldr	r0, [pc, #24]	@ (34000e1c <MX_ADC2_Init+0xe4>)
34000e04:	f002 f928 	bl	34003058 <HAL_ADC_AnalogWDGConfig>
34000e08:	4603      	mov	r3, r0
34000e0a:	2b00      	cmp	r3, #0
34000e0c:	d001      	beq.n	34000e12 <MX_ADC2_Init+0xda>
  {
    Error_Handler();
34000e0e:	f000 f881 	bl	34000f14 <Error_Handler>
  }
  /* USER CODE BEGIN ADC2_Init 2 */

  /* USER CODE END ADC2_Init 2 */

}
34000e12:	bf00      	nop
34000e14:	3740      	adds	r7, #64	@ 0x40
34000e16:	46bd      	mov	sp, r7
34000e18:	bd80      	pop	{r7, pc}
34000e1a:	bf00      	nop
34000e1c:	3400f1e4 	.word	0x3400f1e4
34000e20:	50022100 	.word	0x50022100

34000e24 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
34000e24:	b580      	push	{r7, lr}
34000e26:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
34000e28:	4b1b      	ldr	r3, [pc, #108]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e2a:	4a1c      	ldr	r2, [pc, #112]	@ (34000e9c <MX_I2C1_Init+0x78>)
34000e2c:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x30C0EDFF;
34000e2e:	4b1a      	ldr	r3, [pc, #104]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e30:	4a1b      	ldr	r2, [pc, #108]	@ (34000ea0 <MX_I2C1_Init+0x7c>)
34000e32:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
34000e34:	4b18      	ldr	r3, [pc, #96]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e36:	2200      	movs	r2, #0
34000e38:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
34000e3a:	4b17      	ldr	r3, [pc, #92]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e3c:	2201      	movs	r2, #1
34000e3e:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
34000e40:	4b15      	ldr	r3, [pc, #84]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e42:	2200      	movs	r2, #0
34000e44:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
34000e46:	4b14      	ldr	r3, [pc, #80]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e48:	2200      	movs	r2, #0
34000e4a:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
34000e4c:	4b12      	ldr	r3, [pc, #72]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e4e:	2200      	movs	r2, #0
34000e50:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
34000e52:	4b11      	ldr	r3, [pc, #68]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e54:	2200      	movs	r2, #0
34000e56:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
34000e58:	4b0f      	ldr	r3, [pc, #60]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e5a:	2200      	movs	r2, #0
34000e5c:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
34000e5e:	480e      	ldr	r0, [pc, #56]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e60:	f003 f8c8 	bl	34003ff4 <HAL_I2C_Init>
34000e64:	4603      	mov	r3, r0
34000e66:	2b00      	cmp	r3, #0
34000e68:	d001      	beq.n	34000e6e <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
34000e6a:	f000 f853 	bl	34000f14 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
34000e6e:	2100      	movs	r1, #0
34000e70:	4809      	ldr	r0, [pc, #36]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e72:	f004 fef7 	bl	34005c64 <HAL_I2CEx_ConfigAnalogFilter>
34000e76:	4603      	mov	r3, r0
34000e78:	2b00      	cmp	r3, #0
34000e7a:	d001      	beq.n	34000e80 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
34000e7c:	f000 f84a 	bl	34000f14 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
34000e80:	2100      	movs	r1, #0
34000e82:	4805      	ldr	r0, [pc, #20]	@ (34000e98 <MX_I2C1_Init+0x74>)
34000e84:	f004 ff39 	bl	34005cfa <HAL_I2CEx_ConfigDigitalFilter>
34000e88:	4603      	mov	r3, r0
34000e8a:	2b00      	cmp	r3, #0
34000e8c:	d001      	beq.n	34000e92 <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
34000e8e:	f000 f841 	bl	34000f14 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
34000e92:	bf00      	nop
34000e94:	bd80      	pop	{r7, pc}
34000e96:	bf00      	nop
34000e98:	3400f244 	.word	0x3400f244
34000e9c:	50005400 	.word	0x50005400
34000ea0:	30c0edff 	.word	0x30c0edff

34000ea4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34000ea4:	b580      	push	{r7, lr}
34000ea6:	b086      	sub	sp, #24
34000ea8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34000eaa:	1d3b      	adds	r3, r7, #4
34000eac:	2200      	movs	r2, #0
34000eae:	601a      	str	r2, [r3, #0]
34000eb0:	605a      	str	r2, [r3, #4]
34000eb2:	609a      	str	r2, [r3, #8]
34000eb4:	60da      	str	r2, [r3, #12]
34000eb6:	611a      	str	r2, [r3, #16]
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* Enable VDDIO2 power supply for GPIO Port O (LED control) */
  HAL_PWREx_EnableVddIO2();
34000eb8:	f004 ff6c 	bl	34005d94 <HAL_PWREx_EnableVddIO2>
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
34000ebc:	2004      	movs	r0, #4
34000ebe:	f7ff fe81 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34000ec2:	2080      	movs	r0, #128	@ 0x80
34000ec4:	f7ff fe7e 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34000ec8:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34000ecc:	f7ff fe7a 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOF_CLK_ENABLE();
34000ed0:	2020      	movs	r0, #32
34000ed2:	f7ff fe77 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
34000ed6:	2001      	movs	r0, #1
34000ed8:	f7ff fe74 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
34000edc:	2002      	movs	r0, #2
34000ede:	f7ff fe71 	bl	34000bc4 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOO, GPIO_PIN_1, GPIO_PIN_RESET);
34000ee2:	2200      	movs	r2, #0
34000ee4:	2102      	movs	r1, #2
34000ee6:	480a      	ldr	r0, [pc, #40]	@ (34000f10 <MX_GPIO_Init+0x6c>)
34000ee8:	f003 f852 	bl	34003f90 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PO1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
34000eec:	2302      	movs	r3, #2
34000eee:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34000ef0:	2301      	movs	r3, #1
34000ef2:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34000ef4:	2300      	movs	r3, #0
34000ef6:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34000ef8:	2300      	movs	r3, #0
34000efa:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34000efc:	1d3b      	adds	r3, r7, #4
34000efe:	4619      	mov	r1, r3
34000f00:	4803      	ldr	r0, [pc, #12]	@ (34000f10 <MX_GPIO_Init+0x6c>)
34000f02:	f002 fe93 	bl	34003c2c <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
34000f06:	bf00      	nop
34000f08:	3718      	adds	r7, #24
34000f0a:	46bd      	mov	sp, r7
34000f0c:	bd80      	pop	{r7, pc}
34000f0e:	bf00      	nop
34000f10:	56023800 	.word	0x56023800

34000f14 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34000f14:	b480      	push	{r7}
34000f16:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34000f18:	b672      	cpsid	i
}
34000f1a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34000f1c:	bf00      	nop
34000f1e:	e7fd      	b.n	34000f1c <Error_Handler+0x8>

34000f20 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
34000f20:	b2c0      	uxtb	r0, r0
34000f22:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34000f26:	b480      	push	{r7}
34000f28:	b082      	sub	sp, #8
34000f2a:	af00      	add	r7, sp, #0
34000f2c:	4603      	mov	r3, r0
34000f2e:	6039      	str	r1, [r7, #0]
34000f30:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
34000f32:	683b      	ldr	r3, [r7, #0]
34000f34:	2b00      	cmp	r3, #0
34000f36:	d00d      	beq.n	34000f54 <__acle_se_SECURE_RegisterCallback+0x34>
  {
    switch(CallbackId)
34000f38:	79fb      	ldrb	r3, [r7, #7]
34000f3a:	2b00      	cmp	r3, #0
34000f3c:	d002      	beq.n	34000f44 <__acle_se_SECURE_RegisterCallback+0x24>
34000f3e:	2b01      	cmp	r3, #1
34000f40:	d004      	beq.n	34000f4c <__acle_se_SECURE_RegisterCallback+0x2c>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
34000f42:	e007      	b.n	34000f54 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureFaultCallback = func;
34000f44:	4a09      	ldr	r2, [pc, #36]	@ (34000f6c <__acle_se_SECURE_RegisterCallback+0x4c>)
34000f46:	683b      	ldr	r3, [r7, #0]
34000f48:	6013      	str	r3, [r2, #0]
        break;
34000f4a:	e003      	b.n	34000f54 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureErrorCallback = func;
34000f4c:	4a08      	ldr	r2, [pc, #32]	@ (34000f70 <__acle_se_SECURE_RegisterCallback+0x50>)
34000f4e:	683b      	ldr	r3, [r7, #0]
34000f50:	6013      	str	r3, [r2, #0]
        break;
34000f52:	bf00      	nop
    }
  }
}
34000f54:	bf00      	nop
34000f56:	3708      	adds	r7, #8
34000f58:	46bd      	mov	sp, r7
34000f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f5e:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34000f62:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
34000f66:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34000f6a:	4774      	bxns	lr
34000f6c:	3400f298 	.word	0x3400f298
34000f70:	3400f29c 	.word	0x3400f29c

34000f74 <LL_AHB1_GRP1_EnableClock>:
{
34000f74:	b480      	push	{r7}
34000f76:	b085      	sub	sp, #20
34000f78:	af00      	add	r7, sp, #0
34000f7a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB1ENSR, Periphs);
34000f7c:	4a07      	ldr	r2, [pc, #28]	@ (34000f9c <LL_AHB1_GRP1_EnableClock+0x28>)
34000f7e:	687b      	ldr	r3, [r7, #4]
34000f80:	f8c2 3a50 	str.w	r3, [r2, #2640]	@ 0xa50
  tmpreg = READ_REG(RCC->AHB1ENR);
34000f84:	4b05      	ldr	r3, [pc, #20]	@ (34000f9c <LL_AHB1_GRP1_EnableClock+0x28>)
34000f86:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
34000f8a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000f8c:	68fb      	ldr	r3, [r7, #12]
}
34000f8e:	bf00      	nop
34000f90:	3714      	adds	r7, #20
34000f92:	46bd      	mov	sp, r7
34000f94:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f98:	4770      	bx	lr
34000f9a:	bf00      	nop
34000f9c:	56028000 	.word	0x56028000

34000fa0 <LL_AHB4_GRP1_EnableClock>:
{
34000fa0:	b480      	push	{r7}
34000fa2:	b085      	sub	sp, #20
34000fa4:	af00      	add	r7, sp, #0
34000fa6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000fa8:	4a07      	ldr	r2, [pc, #28]	@ (34000fc8 <LL_AHB4_GRP1_EnableClock+0x28>)
34000faa:	687b      	ldr	r3, [r7, #4]
34000fac:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34000fb0:	4b05      	ldr	r3, [pc, #20]	@ (34000fc8 <LL_AHB4_GRP1_EnableClock+0x28>)
34000fb2:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000fb6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000fb8:	68fb      	ldr	r3, [r7, #12]
}
34000fba:	bf00      	nop
34000fbc:	3714      	adds	r7, #20
34000fbe:	46bd      	mov	sp, r7
34000fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
34000fc4:	4770      	bx	lr
34000fc6:	bf00      	nop
34000fc8:	56028000 	.word	0x56028000

34000fcc <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_UART8
  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
34000fcc:	b480      	push	{r7}
34000fce:	b085      	sub	sp, #20
34000fd0:	af00      	add	r7, sp, #0
34000fd2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34000fd4:	4a07      	ldr	r2, [pc, #28]	@ (34000ff4 <LL_APB1_GRP1_EnableClock+0x28>)
34000fd6:	687b      	ldr	r3, [r7, #4]
34000fd8:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1ENR1);
34000fdc:	4b05      	ldr	r3, [pc, #20]	@ (34000ff4 <LL_APB1_GRP1_EnableClock+0x28>)
34000fde:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
34000fe2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000fe4:	68fb      	ldr	r3, [r7, #12]
}
34000fe6:	bf00      	nop
34000fe8:	3714      	adds	r7, #20
34000fea:	46bd      	mov	sp, r7
34000fec:	f85d 7b04 	ldr.w	r7, [sp], #4
34000ff0:	4770      	bx	lr
34000ff2:	bf00      	nop
34000ff4:	56028000 	.word	0x56028000

34000ff8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34000ff8:	b580      	push	{r7, lr}
34000ffa:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34000ffc:	f004 feca 	bl	34005d94 <HAL_PWREx_EnableVddIO2>

  HAL_PWREx_EnableVddIO3();
34001000:	f004 fed8 	bl	34005db4 <HAL_PWREx_EnableVddIO3>

  HAL_PWREx_EnableVddIO4();
34001004:	f004 fee6 	bl	34005dd4 <HAL_PWREx_EnableVddIO4>

  HAL_PWREx_EnableVddIO5();
34001008:	f004 fef4 	bl	34005df4 <HAL_PWREx_EnableVddIO5>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
3400100c:	bf00      	nop
3400100e:	bd80      	pop	{r7, pc}

34001010 <HAL_ADC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
34001010:	b580      	push	{r7, lr}
34001012:	b0ec      	sub	sp, #432	@ 0x1b0
34001014:	af00      	add	r7, sp, #0
34001016:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400101a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400101e:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34001020:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001024:	2200      	movs	r2, #0
34001026:	601a      	str	r2, [r3, #0]
34001028:	605a      	str	r2, [r3, #4]
3400102a:	609a      	str	r2, [r3, #8]
3400102c:	60da      	str	r2, [r3, #12]
3400102e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34001030:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001034:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001038:	4618      	mov	r0, r3
3400103a:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3400103e:	461a      	mov	r2, r3
34001040:	2100      	movs	r1, #0
34001042:	f00c fd01 	bl	3400da48 <memset>
  if(hadc->Instance==ADC1)
34001046:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400104a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400104e:	681b      	ldr	r3, [r3, #0]
34001050:	681b      	ldr	r3, [r3, #0]
34001052:	4a64      	ldr	r2, [pc, #400]	@ (340011e4 <HAL_ADC_MspInit+0x1d4>)
34001054:	4293      	cmp	r3, r2
34001056:	d16e      	bne.n	34001136 <HAL_ADC_MspInit+0x126>

    /* USER CODE END ADC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
34001058:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400105c:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34001060:	f04f 0201 	mov.w	r2, #1
34001064:	f04f 0300 	mov.w	r3, #0
34001068:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_HCLK;
3400106c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001070:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001074:	2200      	movs	r2, #0
34001076:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    PeriphClkInitStruct.AdcDivider = 2;
3400107a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400107e:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001082:	2202      	movs	r2, #2
34001084:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001088:	f107 0308 	add.w	r3, r7, #8
3400108c:	4618      	mov	r0, r3
3400108e:	f005 f9ff 	bl	34006490 <HAL_RCCEx_PeriphCLKConfig>
34001092:	4603      	mov	r3, r0
34001094:	2b00      	cmp	r3, #0
34001096:	d001      	beq.n	3400109c <HAL_ADC_MspInit+0x8c>
    {
      Error_Handler();
34001098:	f7ff ff3c 	bl	34000f14 <Error_Handler>
    }

    /* Peripheral clock enable */
    HAL_RCC_ADC12_CLK_ENABLED++;
3400109c:	4b52      	ldr	r3, [pc, #328]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
3400109e:	681b      	ldr	r3, [r3, #0]
340010a0:	3301      	adds	r3, #1
340010a2:	4a51      	ldr	r2, [pc, #324]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
340010a4:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
340010a6:	4b50      	ldr	r3, [pc, #320]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
340010a8:	681b      	ldr	r3, [r3, #0]
340010aa:	2b01      	cmp	r3, #1
340010ac:	d102      	bne.n	340010b4 <HAL_ADC_MspInit+0xa4>
      __HAL_RCC_ADC12_CLK_ENABLE();
340010ae:	2020      	movs	r0, #32
340010b0:	f7ff ff60 	bl	34000f74 <LL_AHB1_GRP1_EnableClock>
    }

    __HAL_RCC_GPIOF_CLK_ENABLE();
340010b4:	2020      	movs	r0, #32
340010b6:	f7ff ff73 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
340010ba:	2001      	movs	r0, #1
340010bc:	f7ff ff70 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
340010c0:	2002      	movs	r0, #2
340010c2:	f7ff ff6d 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    PA10     ------> ADC1_INP11
    PA11     ------> ADC1_INP12
    PA12     ------> ADC1_INP13
    PB10     ------> ADC1_INP8
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3;
340010c6:	2308      	movs	r3, #8
340010c8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
340010cc:	2303      	movs	r3, #3
340010ce:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340010d2:	2300      	movs	r3, #0
340010d4:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
340010d8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340010dc:	4619      	mov	r1, r3
340010de:	4843      	ldr	r0, [pc, #268]	@ (340011ec <HAL_ADC_MspInit+0x1dc>)
340010e0:	f002 fda4 	bl	34003c2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|UCPD1_VSENSE_Pin|GPIO_PIN_12;
340010e4:	f44f 53f0 	mov.w	r3, #7680	@ 0x1e00
340010e8:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
340010ec:	2303      	movs	r3, #3
340010ee:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340010f2:	2300      	movs	r3, #0
340010f4:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
340010f8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340010fc:	4619      	mov	r1, r3
340010fe:	483c      	ldr	r0, [pc, #240]	@ (340011f0 <HAL_ADC_MspInit+0x1e0>)
34001100:	f002 fd94 	bl	34003c2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
34001104:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34001108:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
3400110c:	2303      	movs	r3, #3
3400110e:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34001112:	2300      	movs	r3, #0
34001114:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
34001118:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400111c:	4619      	mov	r1, r3
3400111e:	4835      	ldr	r0, [pc, #212]	@ (340011f4 <HAL_ADC_MspInit+0x1e4>)
34001120:	f002 fd84 	bl	34003c2c <HAL_GPIO_Init>

    /* ADC1 interrupt Init */
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 10, 0);
34001124:	2200      	movs	r2, #0
34001126:	210a      	movs	r1, #10
34001128:	202e      	movs	r0, #46	@ 0x2e
3400112a:	f002 fd02 	bl	34003b32 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
3400112e:	202e      	movs	r0, #46	@ 0x2e
34001130:	f002 fd1c 	bl	34003b6c <HAL_NVIC_EnableIRQ>
    /* USER CODE BEGIN ADC2_MspInit 1 */

    /* USER CODE END ADC2_MspInit 1 */
  }

}
34001134:	e050      	b.n	340011d8 <HAL_ADC_MspInit+0x1c8>
  else if(hadc->Instance==ADC2)
34001136:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400113a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400113e:	681b      	ldr	r3, [r3, #0]
34001140:	681b      	ldr	r3, [r3, #0]
34001142:	4a2d      	ldr	r2, [pc, #180]	@ (340011f8 <HAL_ADC_MspInit+0x1e8>)
34001144:	4293      	cmp	r3, r2
34001146:	d147      	bne.n	340011d8 <HAL_ADC_MspInit+0x1c8>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
34001148:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400114c:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34001150:	f04f 0201 	mov.w	r2, #1
34001154:	f04f 0300 	mov.w	r3, #0
34001158:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_HCLK;
3400115c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001160:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001164:	2200      	movs	r2, #0
34001166:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    PeriphClkInitStruct.AdcDivider = 2;
3400116a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400116e:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001172:	2202      	movs	r2, #2
34001174:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001178:	f107 0308 	add.w	r3, r7, #8
3400117c:	4618      	mov	r0, r3
3400117e:	f005 f987 	bl	34006490 <HAL_RCCEx_PeriphCLKConfig>
34001182:	4603      	mov	r3, r0
34001184:	2b00      	cmp	r3, #0
34001186:	d001      	beq.n	3400118c <HAL_ADC_MspInit+0x17c>
      Error_Handler();
34001188:	f7ff fec4 	bl	34000f14 <Error_Handler>
    HAL_RCC_ADC12_CLK_ENABLED++;
3400118c:	4b16      	ldr	r3, [pc, #88]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
3400118e:	681b      	ldr	r3, [r3, #0]
34001190:	3301      	adds	r3, #1
34001192:	4a15      	ldr	r2, [pc, #84]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
34001194:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
34001196:	4b14      	ldr	r3, [pc, #80]	@ (340011e8 <HAL_ADC_MspInit+0x1d8>)
34001198:	681b      	ldr	r3, [r3, #0]
3400119a:	2b01      	cmp	r3, #1
3400119c:	d102      	bne.n	340011a4 <HAL_ADC_MspInit+0x194>
      __HAL_RCC_ADC12_CLK_ENABLE();
3400119e:	2020      	movs	r0, #32
340011a0:	f7ff fee8 	bl	34000f74 <LL_AHB1_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
340011a4:	2001      	movs	r0, #1
340011a6:	f7ff fefb 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_5;
340011aa:	2320      	movs	r3, #32
340011ac:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
340011b0:	2303      	movs	r3, #3
340011b2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340011b6:	2300      	movs	r3, #0
340011b8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
340011bc:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340011c0:	4619      	mov	r1, r3
340011c2:	480b      	ldr	r0, [pc, #44]	@ (340011f0 <HAL_ADC_MspInit+0x1e0>)
340011c4:	f002 fd32 	bl	34003c2c <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 10, 0);
340011c8:	2200      	movs	r2, #0
340011ca:	210a      	movs	r1, #10
340011cc:	202e      	movs	r0, #46	@ 0x2e
340011ce:	f002 fcb0 	bl	34003b32 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
340011d2:	202e      	movs	r0, #46	@ 0x2e
340011d4:	f002 fcca 	bl	34003b6c <HAL_NVIC_EnableIRQ>
}
340011d8:	bf00      	nop
340011da:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
340011de:	46bd      	mov	sp, r7
340011e0:	bd80      	pop	{r7, pc}
340011e2:	bf00      	nop
340011e4:	50022000 	.word	0x50022000
340011e8:	3400f2a0 	.word	0x3400f2a0
340011ec:	56021400 	.word	0x56021400
340011f0:	56020000 	.word	0x56020000
340011f4:	56020400 	.word	0x56020400
340011f8:	50022100 	.word	0x50022100

340011fc <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
340011fc:	b580      	push	{r7, lr}
340011fe:	b0ec      	sub	sp, #432	@ 0x1b0
34001200:	af00      	add	r7, sp, #0
34001202:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001206:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400120a:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
3400120c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001210:	2200      	movs	r2, #0
34001212:	601a      	str	r2, [r3, #0]
34001214:	605a      	str	r2, [r3, #4]
34001216:	609a      	str	r2, [r3, #8]
34001218:	60da      	str	r2, [r3, #12]
3400121a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
3400121c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001220:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001224:	4618      	mov	r0, r3
34001226:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3400122a:	461a      	mov	r2, r3
3400122c:	2100      	movs	r1, #0
3400122e:	f00c fc0b 	bl	3400da48 <memset>
  if(hi2c->Instance==I2C1)
34001232:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001236:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400123a:	681b      	ldr	r3, [r3, #0]
3400123c:	681b      	ldr	r3, [r3, #0]
3400123e:	4a34      	ldr	r2, [pc, #208]	@ (34001310 <HAL_I2C_MspInit+0x114>)
34001240:	4293      	cmp	r3, r2
34001242:	d15f      	bne.n	34001304 <HAL_I2C_MspInit+0x108>

    /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
34001244:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001248:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
3400124c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34001250:	f04f 0300 	mov.w	r3, #0
34001254:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
34001258:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400125c:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34001260:	4a2c      	ldr	r2, [pc, #176]	@ (34001314 <HAL_I2C_MspInit+0x118>)
34001262:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001266:	f107 0308 	add.w	r3, r7, #8
3400126a:	4618      	mov	r0, r3
3400126c:	f005 f910 	bl	34006490 <HAL_RCCEx_PeriphCLKConfig>
34001270:	4603      	mov	r3, r0
34001272:	2b00      	cmp	r3, #0
34001274:	d001      	beq.n	3400127a <HAL_I2C_MspInit+0x7e>
    {
      Error_Handler();
34001276:	f7ff fe4d 	bl	34000f14 <Error_Handler>
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
3400127a:	2004      	movs	r0, #4
3400127c:	f7ff fe90 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
34001280:	2080      	movs	r0, #128	@ 0x80
34001282:	f7ff fe8d 	bl	34000fa0 <LL_AHB4_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = I2C1_SDA_Pin;
34001286:	2302      	movs	r3, #2
34001288:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
3400128c:	2312      	movs	r3, #18
3400128e:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34001292:	2300      	movs	r3, #0
34001294:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001298:	2300      	movs	r3, #0
3400129a:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
3400129e:	2304      	movs	r3, #4
340012a0:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(I2C1_SDA_GPIO_Port, &GPIO_InitStruct);
340012a4:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340012a8:	4619      	mov	r1, r3
340012aa:	481b      	ldr	r0, [pc, #108]	@ (34001318 <HAL_I2C_MspInit+0x11c>)
340012ac:	f002 fcbe 	bl	34003c2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = I2C1_SCL_Pin;
340012b0:	f44f 7300 	mov.w	r3, #512	@ 0x200
340012b4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
340012b8:	2312      	movs	r3, #18
340012ba:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340012be:	2300      	movs	r3, #0
340012c0:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
340012c4:	2300      	movs	r3, #0
340012c6:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
340012ca:	2304      	movs	r3, #4
340012cc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(I2C1_SCL_GPIO_Port, &GPIO_InitStruct);
340012d0:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340012d4:	4619      	mov	r1, r3
340012d6:	4811      	ldr	r0, [pc, #68]	@ (3400131c <HAL_I2C_MspInit+0x120>)
340012d8:	f002 fca8 	bl	34003c2c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
340012dc:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
340012e0:	f7ff fe74 	bl	34000fcc <LL_APB1_GRP1_EnableClock>
    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 10, 0);
340012e4:	2200      	movs	r2, #0
340012e6:	210a      	movs	r1, #10
340012e8:	2064      	movs	r0, #100	@ 0x64
340012ea:	f002 fc22 	bl	34003b32 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
340012ee:	2064      	movs	r0, #100	@ 0x64
340012f0:	f002 fc3c 	bl	34003b6c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 10, 0);
340012f4:	2200      	movs	r2, #0
340012f6:	210a      	movs	r1, #10
340012f8:	2065      	movs	r0, #101	@ 0x65
340012fa:	f002 fc1a 	bl	34003b32 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
340012fe:	2065      	movs	r0, #101	@ 0x65
34001300:	f002 fc34 	bl	34003b6c <HAL_NVIC_EnableIRQ>

    /* USER CODE END I2C1_MspInit 1 */

  }

}
34001304:	bf00      	nop
34001306:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
3400130a:	46bd      	mov	sp, r7
3400130c:	bd80      	pop	{r7, pc}
3400130e:	bf00      	nop
34001310:	50005400 	.word	0x50005400
34001314:	0700000c 	.word	0x0700000c
34001318:	56020800 	.word	0x56020800
3400131c:	56021c00 	.word	0x56021c00

34001320 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34001320:	b480      	push	{r7}
34001322:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34001324:	bf00      	nop
34001326:	e7fd      	b.n	34001324 <NMI_Handler+0x4>

34001328 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34001328:	b480      	push	{r7}
3400132a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
3400132c:	bf00      	nop
3400132e:	e7fd      	b.n	3400132c <HardFault_Handler+0x4>

34001330 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34001330:	b480      	push	{r7}
34001332:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34001334:	bf00      	nop
34001336:	e7fd      	b.n	34001334 <MemManage_Handler+0x4>

34001338 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34001338:	b480      	push	{r7}
3400133a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
3400133c:	bf00      	nop
3400133e:	e7fd      	b.n	3400133c <BusFault_Handler+0x4>

34001340 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34001340:	b480      	push	{r7}
34001342:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34001344:	bf00      	nop
34001346:	e7fd      	b.n	34001344 <UsageFault_Handler+0x4>

34001348 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34001348:	b480      	push	{r7}
3400134a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
3400134c:	bf00      	nop
3400134e:	e7fd      	b.n	3400134c <SecureFault_Handler+0x4>

34001350 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34001350:	b480      	push	{r7}
34001352:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34001354:	bf00      	nop
34001356:	46bd      	mov	sp, r7
34001358:	f85d 7b04 	ldr.w	r7, [sp], #4
3400135c:	4770      	bx	lr

3400135e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
3400135e:	b480      	push	{r7}
34001360:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34001362:	bf00      	nop
34001364:	46bd      	mov	sp, r7
34001366:	f85d 7b04 	ldr.w	r7, [sp], #4
3400136a:	4770      	bx	lr

3400136c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
3400136c:	b480      	push	{r7}
3400136e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
34001370:	bf00      	nop
34001372:	46bd      	mov	sp, r7
34001374:	f85d 7b04 	ldr.w	r7, [sp], #4
34001378:	4770      	bx	lr

3400137a <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
3400137a:	b580      	push	{r7, lr}
3400137c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
3400137e:	f000 facf 	bl	34001920 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
34001382:	bf00      	nop
34001384:	bd80      	pop	{r7, pc}
	...

34001388 <ADC1_2_IRQHandler>:

/**
  * @brief This function handles ADC1 and ADC2 global interrupt.
  */
void ADC1_2_IRQHandler(void)
{
34001388:	b580      	push	{r7, lr}
3400138a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN ADC1_2_IRQn 0 */

  /* USER CODE END ADC1_2_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
3400138c:	4803      	ldr	r0, [pc, #12]	@ (3400139c <ADC1_2_IRQHandler+0x14>)
3400138e:	f001 fa61 	bl	34002854 <HAL_ADC_IRQHandler>
  HAL_ADC_IRQHandler(&hadc2);
34001392:	4803      	ldr	r0, [pc, #12]	@ (340013a0 <ADC1_2_IRQHandler+0x18>)
34001394:	f001 fa5e 	bl	34002854 <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC1_2_IRQn 1 */

  /* USER CODE END ADC1_2_IRQn 1 */
}
34001398:	bf00      	nop
3400139a:	bd80      	pop	{r7, pc}
3400139c:	3400f184 	.word	0x3400f184
340013a0:	3400f1e4 	.word	0x3400f1e4

340013a4 <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 Event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
340013a4:	b580      	push	{r7, lr}
340013a6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
340013a8:	4802      	ldr	r0, [pc, #8]	@ (340013b4 <I2C1_EV_IRQHandler+0x10>)
340013aa:	f003 f85d 	bl	34004468 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
340013ae:	bf00      	nop
340013b0:	bd80      	pop	{r7, pc}
340013b2:	bf00      	nop
340013b4:	3400f244 	.word	0x3400f244

340013b8 <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 Error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
340013b8:	b580      	push	{r7, lr}
340013ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
340013bc:	4802      	ldr	r0, [pc, #8]	@ (340013c8 <I2C1_ER_IRQHandler+0x10>)
340013be:	f003 f86d 	bl	3400449c <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
340013c2:	bf00      	nop
340013c4:	bd80      	pop	{r7, pc}
340013c6:	bf00      	nop
340013c8:	3400f244 	.word	0x3400f244

340013cc <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
340013cc:	b480      	push	{r7}
340013ce:	af00      	add	r7, sp, #0
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
340013d0:	4b18      	ldr	r3, [pc, #96]	@ (34001434 <TZ_SAU_Setup+0x68>)
340013d2:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340013d6:	4a17      	ldr	r2, [pc, #92]	@ (34001434 <TZ_SAU_Setup+0x68>)
340013d8:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
340013dc:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340013e0:	4b15      	ldr	r3, [pc, #84]	@ (34001438 <TZ_SAU_Setup+0x6c>)
340013e2:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
340013e4:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340013e8:	4a13      	ldr	r2, [pc, #76]	@ (34001438 <TZ_SAU_Setup+0x6c>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
340013ea:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340013ee:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
340013f0:	4b12      	ldr	r3, [pc, #72]	@ (3400143c <TZ_SAU_Setup+0x70>)
340013f2:	2200      	movs	r2, #0
340013f4:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
340013f8:	4b10      	ldr	r3, [pc, #64]	@ (3400143c <TZ_SAU_Setup+0x70>)
340013fa:	2200      	movs	r2, #0
340013fc:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
34001400:	4b0e      	ldr	r3, [pc, #56]	@ (3400143c <TZ_SAU_Setup+0x70>)
34001402:	2200      	movs	r2, #0
34001404:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
34001408:	4b0c      	ldr	r3, [pc, #48]	@ (3400143c <TZ_SAU_Setup+0x70>)
3400140a:	2200      	movs	r2, #0
3400140c:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
34001410:	4b0a      	ldr	r3, [pc, #40]	@ (3400143c <TZ_SAU_Setup+0x70>)
34001412:	2200      	movs	r2, #0
34001414:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
34001418:	4b08      	ldr	r3, [pc, #32]	@ (3400143c <TZ_SAU_Setup+0x70>)
3400141a:	2200      	movs	r2, #0
3400141c:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
34001420:	4b06      	ldr	r3, [pc, #24]	@ (3400143c <TZ_SAU_Setup+0x70>)
34001422:	2200      	movs	r2, #0
34001424:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
  #endif

}
34001428:	bf00      	nop
3400142a:	46bd      	mov	sp, r7
3400142c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001430:	4770      	bx	lr
34001432:	bf00      	nop
34001434:	e000ed00 	.word	0xe000ed00
34001438:	e000ef30 	.word	0xe000ef30
3400143c:	e000e100 	.word	0xe000e100

34001440 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34001440:	b580      	push	{r7, lr}
34001442:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
34001444:	f7ff ffc2 	bl	340013cc <TZ_SAU_Setup>

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34001448:	4b14      	ldr	r3, [pc, #80]	@ (3400149c <SystemInit+0x5c>)
3400144a:	4a15      	ldr	r2, [pc, #84]	@ (340014a0 <SystemInit+0x60>)
3400144c:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
3400144e:	4b15      	ldr	r3, [pc, #84]	@ (340014a4 <SystemInit+0x64>)
34001450:	2201      	movs	r2, #1
34001452:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34001456:	4b13      	ldr	r3, [pc, #76]	@ (340014a4 <SystemInit+0x64>)
34001458:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
3400145c:	4b0f      	ldr	r3, [pc, #60]	@ (3400149c <SystemInit+0x5c>)
3400145e:	4a12      	ldr	r2, [pc, #72]	@ (340014a8 <SystemInit+0x68>)
34001460:	689b      	ldr	r3, [r3, #8]
34001462:	6113      	str	r3, [r2, #16]
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34001464:	4b10      	ldr	r3, [pc, #64]	@ (340014a8 <SystemInit+0x68>)
34001466:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34001468:	4b0e      	ldr	r3, [pc, #56]	@ (340014a4 <SystemInit+0x64>)
3400146a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400146e:	461a      	mov	r2, r3
34001470:	2301      	movs	r3, #1
34001472:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34001476:	4b09      	ldr	r3, [pc, #36]	@ (3400149c <SystemInit+0x5c>)
34001478:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400147c:	4a07      	ldr	r2, [pc, #28]	@ (3400149c <SystemInit+0x5c>)
3400147e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34001482:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34001486:	4b09      	ldr	r3, [pc, #36]	@ (340014ac <SystemInit+0x6c>)
34001488:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400148c:	4a07      	ldr	r2, [pc, #28]	@ (340014ac <SystemInit+0x6c>)
3400148e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34001492:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34001496:	bf00      	nop
34001498:	bd80      	pop	{r7, pc}
3400149a:	bf00      	nop
3400149c:	e000ed00 	.word	0xe000ed00
340014a0:	34000400 	.word	0x34000400
340014a4:	56028000 	.word	0x56028000
340014a8:	56008000 	.word	0x56008000
340014ac:	e002ed00 	.word	0xe002ed00

340014b0 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
340014b0:	b480      	push	{r7}
340014b2:	b08d      	sub	sp, #52	@ 0x34
340014b4:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
340014b6:	2300      	movs	r3, #0
340014b8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
340014ba:	2300      	movs	r3, #0
340014bc:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
340014be:	2300      	movs	r3, #0
340014c0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
340014c2:	2300      	movs	r3, #0
340014c4:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
340014c6:	2300      	movs	r3, #0
340014c8:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
340014ca:	2300      	movs	r3, #0
340014cc:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
340014ce:	4b9b      	ldr	r3, [pc, #620]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
340014d0:	6a1b      	ldr	r3, [r3, #32]
340014d2:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
340014d6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340014da:	d029      	beq.n	34001530 <SystemCoreClockUpdate+0x80>
340014dc:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
340014e0:	f200 8180 	bhi.w	340017e4 <SystemCoreClockUpdate+0x334>
340014e4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340014e8:	d01f      	beq.n	3400152a <SystemCoreClockUpdate+0x7a>
340014ea:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340014ee:	f200 8179 	bhi.w	340017e4 <SystemCoreClockUpdate+0x334>
340014f2:	2b00      	cmp	r3, #0
340014f4:	d003      	beq.n	340014fe <SystemCoreClockUpdate+0x4e>
340014f6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340014fa:	d00a      	beq.n	34001512 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
340014fc:	e172      	b.n	340017e4 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
340014fe:	4b8f      	ldr	r3, [pc, #572]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001500:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34001502:	09db      	lsrs	r3, r3, #7
34001504:	f003 0303 	and.w	r3, r3, #3
34001508:	4a8d      	ldr	r2, [pc, #564]	@ (34001740 <SystemCoreClockUpdate+0x290>)
3400150a:	fa22 f303 	lsr.w	r3, r2, r3
3400150e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001510:	e169      	b.n	340017e6 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34001512:	4b8a      	ldr	r3, [pc, #552]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001514:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34001516:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400151a:	2b00      	cmp	r3, #0
3400151c:	d102      	bne.n	34001524 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
3400151e:	4b89      	ldr	r3, [pc, #548]	@ (34001744 <SystemCoreClockUpdate+0x294>)
34001520:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001522:	e160      	b.n	340017e6 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34001524:	4b88      	ldr	r3, [pc, #544]	@ (34001748 <SystemCoreClockUpdate+0x298>)
34001526:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001528:	e15d      	b.n	340017e6 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
3400152a:	4b88      	ldr	r3, [pc, #544]	@ (3400174c <SystemCoreClockUpdate+0x29c>)
3400152c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3400152e:	e15a      	b.n	340017e6 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34001530:	4b82      	ldr	r3, [pc, #520]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001532:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34001536:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
3400153a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400153e:	d066      	beq.n	3400160e <SystemCoreClockUpdate+0x15e>
34001540:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34001544:	f200 8091 	bhi.w	3400166a <SystemCoreClockUpdate+0x1ba>
34001548:	2b00      	cmp	r3, #0
3400154a:	d003      	beq.n	34001554 <SystemCoreClockUpdate+0xa4>
3400154c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34001550:	d02f      	beq.n	340015b2 <SystemCoreClockUpdate+0x102>
34001552:	e08a      	b.n	3400166a <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34001554:	4b79      	ldr	r3, [pc, #484]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001556:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400155a:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
3400155c:	68fb      	ldr	r3, [r7, #12]
3400155e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34001562:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34001564:	68fb      	ldr	r3, [r7, #12]
34001566:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400156a:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3400156c:	693b      	ldr	r3, [r7, #16]
3400156e:	2b00      	cmp	r3, #0
34001570:	f040 80a9 	bne.w	340016c6 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34001574:	68fb      	ldr	r3, [r7, #12]
34001576:	0d1b      	lsrs	r3, r3, #20
34001578:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3400157c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
3400157e:	68fb      	ldr	r3, [r7, #12]
34001580:	0a1b      	lsrs	r3, r3, #8
34001582:	f3c3 030b 	ubfx	r3, r3, #0, #12
34001586:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34001588:	4b6c      	ldr	r3, [pc, #432]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
3400158a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400158e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34001592:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34001594:	4b69      	ldr	r3, [pc, #420]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001596:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400159a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
3400159c:	68fb      	ldr	r3, [r7, #12]
3400159e:	0edb      	lsrs	r3, r3, #27
340015a0:	f003 0307 	and.w	r3, r3, #7
340015a4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
340015a6:	68fb      	ldr	r3, [r7, #12]
340015a8:	0e1b      	lsrs	r3, r3, #24
340015aa:	f003 0307 	and.w	r3, r3, #7
340015ae:	61bb      	str	r3, [r7, #24]
      break;
340015b0:	e089      	b.n	340016c6 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
340015b2:	4b62      	ldr	r3, [pc, #392]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
340015b4:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340015b8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
340015ba:	68fb      	ldr	r3, [r7, #12]
340015bc:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340015c0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
340015c2:	68fb      	ldr	r3, [r7, #12]
340015c4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340015c8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340015ca:	693b      	ldr	r3, [r7, #16]
340015cc:	2b00      	cmp	r3, #0
340015ce:	d17c      	bne.n	340016ca <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
340015d0:	68fb      	ldr	r3, [r7, #12]
340015d2:	0d1b      	lsrs	r3, r3, #20
340015d4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340015d8:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
340015da:	68fb      	ldr	r3, [r7, #12]
340015dc:	0a1b      	lsrs	r3, r3, #8
340015de:	f3c3 030b 	ubfx	r3, r3, #0, #12
340015e2:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
340015e4:	4b55      	ldr	r3, [pc, #340]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
340015e6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
340015ea:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340015ee:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
340015f0:	4b52      	ldr	r3, [pc, #328]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
340015f2:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
340015f6:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
340015f8:	68fb      	ldr	r3, [r7, #12]
340015fa:	0edb      	lsrs	r3, r3, #27
340015fc:	f003 0307 	and.w	r3, r3, #7
34001600:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34001602:	68fb      	ldr	r3, [r7, #12]
34001604:	0e1b      	lsrs	r3, r3, #24
34001606:	f003 0307 	and.w	r3, r3, #7
3400160a:	61bb      	str	r3, [r7, #24]
      break;
3400160c:	e05d      	b.n	340016ca <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
3400160e:	4b4b      	ldr	r3, [pc, #300]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001610:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34001614:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34001616:	68fb      	ldr	r3, [r7, #12]
34001618:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3400161c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
3400161e:	68fb      	ldr	r3, [r7, #12]
34001620:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34001624:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34001626:	693b      	ldr	r3, [r7, #16]
34001628:	2b00      	cmp	r3, #0
3400162a:	d150      	bne.n	340016ce <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
3400162c:	68fb      	ldr	r3, [r7, #12]
3400162e:	0d1b      	lsrs	r3, r3, #20
34001630:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34001634:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34001636:	68fb      	ldr	r3, [r7, #12]
34001638:	0a1b      	lsrs	r3, r3, #8
3400163a:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400163e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34001640:	4b3e      	ldr	r3, [pc, #248]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001642:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34001646:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400164a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
3400164c:	4b3b      	ldr	r3, [pc, #236]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
3400164e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34001652:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34001654:	68fb      	ldr	r3, [r7, #12]
34001656:	0edb      	lsrs	r3, r3, #27
34001658:	f003 0307 	and.w	r3, r3, #7
3400165c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
3400165e:	68fb      	ldr	r3, [r7, #12]
34001660:	0e1b      	lsrs	r3, r3, #24
34001662:	f003 0307 	and.w	r3, r3, #7
34001666:	61bb      	str	r3, [r7, #24]
      break;
34001668:	e031      	b.n	340016ce <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
3400166a:	4b34      	ldr	r3, [pc, #208]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
3400166c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34001670:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34001672:	68fb      	ldr	r3, [r7, #12]
34001674:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34001678:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
3400167a:	68fb      	ldr	r3, [r7, #12]
3400167c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34001680:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34001682:	693b      	ldr	r3, [r7, #16]
34001684:	2b00      	cmp	r3, #0
34001686:	d124      	bne.n	340016d2 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34001688:	68fb      	ldr	r3, [r7, #12]
3400168a:	0d1b      	lsrs	r3, r3, #20
3400168c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34001690:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34001692:	68fb      	ldr	r3, [r7, #12]
34001694:	0a1b      	lsrs	r3, r3, #8
34001696:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400169a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
3400169c:	4b27      	ldr	r3, [pc, #156]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
3400169e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
340016a2:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340016a6:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
340016a8:	4b24      	ldr	r3, [pc, #144]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
340016aa:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340016ae:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
340016b0:	68fb      	ldr	r3, [r7, #12]
340016b2:	0edb      	lsrs	r3, r3, #27
340016b4:	f003 0307 	and.w	r3, r3, #7
340016b8:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
340016ba:	68fb      	ldr	r3, [r7, #12]
340016bc:	0e1b      	lsrs	r3, r3, #24
340016be:	f003 0307 	and.w	r3, r3, #7
340016c2:	61bb      	str	r3, [r7, #24]
      break;
340016c4:	e005      	b.n	340016d2 <SystemCoreClockUpdate+0x222>
      break;
340016c6:	bf00      	nop
340016c8:	e004      	b.n	340016d4 <SystemCoreClockUpdate+0x224>
      break;
340016ca:	bf00      	nop
340016cc:	e002      	b.n	340016d4 <SystemCoreClockUpdate+0x224>
      break;
340016ce:	bf00      	nop
340016d0:	e000      	b.n	340016d4 <SystemCoreClockUpdate+0x224>
      break;
340016d2:	bf00      	nop
    switch (pllsource)
340016d4:	697b      	ldr	r3, [r7, #20]
340016d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340016da:	d02c      	beq.n	34001736 <SystemCoreClockUpdate+0x286>
340016dc:	697b      	ldr	r3, [r7, #20]
340016de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340016e2:	d839      	bhi.n	34001758 <SystemCoreClockUpdate+0x2a8>
340016e4:	697b      	ldr	r3, [r7, #20]
340016e6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340016ea:	d021      	beq.n	34001730 <SystemCoreClockUpdate+0x280>
340016ec:	697b      	ldr	r3, [r7, #20]
340016ee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340016f2:	d831      	bhi.n	34001758 <SystemCoreClockUpdate+0x2a8>
340016f4:	697b      	ldr	r3, [r7, #20]
340016f6:	2b00      	cmp	r3, #0
340016f8:	d004      	beq.n	34001704 <SystemCoreClockUpdate+0x254>
340016fa:	697b      	ldr	r3, [r7, #20]
340016fc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34001700:	d00a      	beq.n	34001718 <SystemCoreClockUpdate+0x268>
      break;
34001702:	e029      	b.n	34001758 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34001704:	4b0d      	ldr	r3, [pc, #52]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
34001706:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34001708:	09db      	lsrs	r3, r3, #7
3400170a:	f003 0303 	and.w	r3, r3, #3
3400170e:	4a0c      	ldr	r2, [pc, #48]	@ (34001740 <SystemCoreClockUpdate+0x290>)
34001710:	fa22 f303 	lsr.w	r3, r2, r3
34001714:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001716:	e020      	b.n	3400175a <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34001718:	4b08      	ldr	r3, [pc, #32]	@ (3400173c <SystemCoreClockUpdate+0x28c>)
3400171a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400171c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34001720:	2b00      	cmp	r3, #0
34001722:	d102      	bne.n	3400172a <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34001724:	4b07      	ldr	r3, [pc, #28]	@ (34001744 <SystemCoreClockUpdate+0x294>)
34001726:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001728:	e017      	b.n	3400175a <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
3400172a:	4b07      	ldr	r3, [pc, #28]	@ (34001748 <SystemCoreClockUpdate+0x298>)
3400172c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400172e:	e014      	b.n	3400175a <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34001730:	4b06      	ldr	r3, [pc, #24]	@ (3400174c <SystemCoreClockUpdate+0x29c>)
34001732:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001734:	e011      	b.n	3400175a <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34001736:	4b06      	ldr	r3, [pc, #24]	@ (34001750 <SystemCoreClockUpdate+0x2a0>)
34001738:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400173a:	e00e      	b.n	3400175a <SystemCoreClockUpdate+0x2aa>
3400173c:	56028000 	.word	0x56028000
34001740:	03d09000 	.word	0x03d09000
34001744:	003d0900 	.word	0x003d0900
34001748:	00f42400 	.word	0x00f42400
3400174c:	016e3600 	.word	0x016e3600
34001750:	00bb8000 	.word	0x00bb8000
34001754:	4b800000 	.word	0x4b800000
      break;
34001758:	bf00      	nop
    if (pllbypass == 0U)
3400175a:	693b      	ldr	r3, [r7, #16]
3400175c:	2b00      	cmp	r3, #0
3400175e:	d134      	bne.n	340017ca <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34001760:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34001762:	ee07 3a90 	vmov	s15, r3
34001766:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3400176a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400176c:	ee07 3a90 	vmov	s15, r3
34001770:	eef8 6a67 	vcvt.f32.u32	s13, s15
34001774:	6a3b      	ldr	r3, [r7, #32]
34001776:	ee07 3a90 	vmov	s15, r3
3400177a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
3400177e:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34001754 <SystemCoreClockUpdate+0x2a4>
34001782:	eec6 7a25 	vdiv.f32	s15, s12, s11
34001786:	ee76 7aa7 	vadd.f32	s15, s13, s15
3400178a:	ee67 6a27 	vmul.f32	s13, s14, s15
3400178e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34001790:	ee07 3a90 	vmov	s15, r3
34001794:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34001798:	eec6 7a87 	vdiv.f32	s15, s13, s14
3400179c:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
340017a0:	69fb      	ldr	r3, [r7, #28]
340017a2:	ee07 3a90 	vmov	s15, r3
340017a6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340017aa:	69bb      	ldr	r3, [r7, #24]
340017ac:	ee07 3a90 	vmov	s15, r3
340017b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
340017b4:	ee27 7a27 	vmul.f32	s14, s14, s15
340017b8:	edd7 6a02 	vldr	s13, [r7, #8]
340017bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
340017c0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
340017c4:	ee17 3a90 	vmov	r3, s15
340017c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
340017ca:	4b0b      	ldr	r3, [pc, #44]	@ (340017f8 <SystemCoreClockUpdate+0x348>)
340017cc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340017d0:	0c1b      	lsrs	r3, r3, #16
340017d2:	b2db      	uxtb	r3, r3
340017d4:	3301      	adds	r3, #1
340017d6:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
340017d8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340017da:	687b      	ldr	r3, [r7, #4]
340017dc:	fbb2 f3f3 	udiv	r3, r2, r3
340017e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
340017e2:	e000      	b.n	340017e6 <SystemCoreClockUpdate+0x336>
    break;
340017e4:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
340017e6:	4a05      	ldr	r2, [pc, #20]	@ (340017fc <SystemCoreClockUpdate+0x34c>)
340017e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340017ea:	6013      	str	r3, [r2, #0]
}
340017ec:	bf00      	nop
340017ee:	3734      	adds	r7, #52	@ 0x34
340017f0:	46bd      	mov	sp, r7
340017f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340017f6:	4770      	bx	lr
340017f8:	56028000 	.word	0x56028000
340017fc:	3400e118 	.word	0x3400e118

34001800 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34001800:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34001804:	b588      	push	{r3, r7, lr}
34001806:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34001808:	f7ff fe52 	bl	340014b0 <SystemCoreClockUpdate>

  return SystemCoreClock;
3400180c:	4b06      	ldr	r3, [pc, #24]	@ (34001828 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
3400180e:	681b      	ldr	r3, [r3, #0]
}
34001810:	4618      	mov	r0, r3
34001812:	46bd      	mov	sp, r7
34001814:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34001818:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
3400181c:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34001820:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34001824:	4774      	bxns	lr
34001826:	bf00      	nop
34001828:	3400e118 	.word	0x3400e118

3400182c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
3400182c:	480f      	ldr	r0, [pc, #60]	@ (3400186c <LoopForever+0x4>)
  msr   MSPLIM, r0
3400182e:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34001832:	480f      	ldr	r0, [pc, #60]	@ (34001870 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34001834:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34001836:	f7ff fe03 	bl	34001440 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
3400183a:	480e      	ldr	r0, [pc, #56]	@ (34001874 <LoopForever+0xc>)
  ldr r1, =_edata
3400183c:	490e      	ldr	r1, [pc, #56]	@ (34001878 <LoopForever+0x10>)
  ldr r2, =_sidata
3400183e:	4a0f      	ldr	r2, [pc, #60]	@ (3400187c <LoopForever+0x14>)
  movs r3, #0
34001840:	2300      	movs	r3, #0
  b LoopCopyDataInit
34001842:	e002      	b.n	3400184a <LoopCopyDataInit>

34001844 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34001844:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34001846:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34001848:	3304      	adds	r3, #4

3400184a <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
3400184a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
3400184c:	428c      	cmp	r4, r1
  bcc CopyDataInit
3400184e:	d3f9      	bcc.n	34001844 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34001850:	4a0b      	ldr	r2, [pc, #44]	@ (34001880 <LoopForever+0x18>)
  ldr r4, =_ebss
34001852:	4c0c      	ldr	r4, [pc, #48]	@ (34001884 <LoopForever+0x1c>)
  movs r3, #0
34001854:	2300      	movs	r3, #0
  b LoopFillZerobss
34001856:	e001      	b.n	3400185c <LoopFillZerobss>

34001858 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34001858:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
3400185a:	3204      	adds	r2, #4

3400185c <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
3400185c:	42a2      	cmp	r2, r4
  bcc FillZerobss
3400185e:	d3fb      	bcc.n	34001858 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34001860:	f00c f8fa 	bl	3400da58 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34001864:	f7ff f9c4 	bl	34000bf0 <main>

34001868 <LoopForever>:

LoopForever:
  b LoopForever
34001868:	e7fe      	b.n	34001868 <LoopForever>
3400186a:	0000      	.short	0x0000
  ldr   r0, =_sstack
3400186c:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34001870:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34001874:	3400e0e8 	.word	0x3400e0e8
  ldr r1, =_edata
34001878:	3400e13c 	.word	0x3400e13c
  ldr r2, =_sidata
3400187c:	3400e0e8 	.word	0x3400e0e8
  ldr r2, =_sbss
34001880:	3400f160 	.word	0x3400f160
  ldr r4, =_ebss
34001884:	3400f6f4 	.word	0x3400f6f4

34001888 <ADF1_FLT0_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34001888:	e7fe      	b.n	34001888 <ADF1_FLT0_IRQHandler>

3400188a <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
3400188a:	b580      	push	{r7, lr}
3400188c:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
3400188e:	2003      	movs	r0, #3
34001890:	f002 f944 	bl	34003b1c <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34001894:	f7ff fe0c 	bl	340014b0 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34001898:	200f      	movs	r0, #15
3400189a:	f000 f80b 	bl	340018b4 <HAL_InitTick>
3400189e:	4603      	mov	r3, r0
340018a0:	2b00      	cmp	r3, #0
340018a2:	d001      	beq.n	340018a8 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
340018a4:	2301      	movs	r3, #1
340018a6:	e002      	b.n	340018ae <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
340018a8:	f7ff fba6 	bl	34000ff8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
340018ac:	2300      	movs	r3, #0
}
340018ae:	4618      	mov	r0, r3
340018b0:	bd80      	pop	{r7, pc}
	...

340018b4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
340018b4:	b580      	push	{r7, lr}
340018b6:	b082      	sub	sp, #8
340018b8:	af00      	add	r7, sp, #0
340018ba:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
340018bc:	4b15      	ldr	r3, [pc, #84]	@ (34001914 <HAL_InitTick+0x60>)
340018be:	781b      	ldrb	r3, [r3, #0]
340018c0:	2b00      	cmp	r3, #0
340018c2:	d101      	bne.n	340018c8 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
340018c4:	2301      	movs	r3, #1
340018c6:	e021      	b.n	3400190c <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
340018c8:	4b13      	ldr	r3, [pc, #76]	@ (34001918 <HAL_InitTick+0x64>)
340018ca:	681a      	ldr	r2, [r3, #0]
340018cc:	4b11      	ldr	r3, [pc, #68]	@ (34001914 <HAL_InitTick+0x60>)
340018ce:	781b      	ldrb	r3, [r3, #0]
340018d0:	4619      	mov	r1, r3
340018d2:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
340018d6:	fbb3 f3f1 	udiv	r3, r3, r1
340018da:	fbb2 f3f3 	udiv	r3, r2, r3
340018de:	4618      	mov	r0, r3
340018e0:	f002 f952 	bl	34003b88 <HAL_SYSTICK_Config>
340018e4:	4603      	mov	r3, r0
340018e6:	2b00      	cmp	r3, #0
340018e8:	d001      	beq.n	340018ee <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
340018ea:	2301      	movs	r3, #1
340018ec:	e00e      	b.n	3400190c <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
340018ee:	687b      	ldr	r3, [r7, #4]
340018f0:	2b0f      	cmp	r3, #15
340018f2:	d80a      	bhi.n	3400190a <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
340018f4:	2200      	movs	r2, #0
340018f6:	6879      	ldr	r1, [r7, #4]
340018f8:	f04f 30ff 	mov.w	r0, #4294967295
340018fc:	f002 f919 	bl	34003b32 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34001900:	4a06      	ldr	r2, [pc, #24]	@ (3400191c <HAL_InitTick+0x68>)
34001902:	687b      	ldr	r3, [r7, #4]
34001904:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
34001906:	2300      	movs	r3, #0
34001908:	e000      	b.n	3400190c <HAL_InitTick+0x58>
    return HAL_ERROR;
3400190a:	2301      	movs	r3, #1
}
3400190c:	4618      	mov	r0, r3
3400190e:	3708      	adds	r7, #8
34001910:	46bd      	mov	sp, r7
34001912:	bd80      	pop	{r7, pc}
34001914:	3400e120 	.word	0x3400e120
34001918:	3400e118 	.word	0x3400e118
3400191c:	3400e11c 	.word	0x3400e11c

34001920 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34001920:	b480      	push	{r7}
34001922:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34001924:	4b06      	ldr	r3, [pc, #24]	@ (34001940 <HAL_IncTick+0x20>)
34001926:	781b      	ldrb	r3, [r3, #0]
34001928:	461a      	mov	r2, r3
3400192a:	4b06      	ldr	r3, [pc, #24]	@ (34001944 <HAL_IncTick+0x24>)
3400192c:	681b      	ldr	r3, [r3, #0]
3400192e:	4413      	add	r3, r2
34001930:	4a04      	ldr	r2, [pc, #16]	@ (34001944 <HAL_IncTick+0x24>)
34001932:	6013      	str	r3, [r2, #0]
}
34001934:	bf00      	nop
34001936:	46bd      	mov	sp, r7
34001938:	f85d 7b04 	ldr.w	r7, [sp], #4
3400193c:	4770      	bx	lr
3400193e:	bf00      	nop
34001940:	3400e120 	.word	0x3400e120
34001944:	3400f2a4 	.word	0x3400f2a4

34001948 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34001948:	b480      	push	{r7}
3400194a:	af00      	add	r7, sp, #0
  return uwTick;
3400194c:	4b03      	ldr	r3, [pc, #12]	@ (3400195c <HAL_GetTick+0x14>)
3400194e:	681b      	ldr	r3, [r3, #0]
}
34001950:	4618      	mov	r0, r3
34001952:	46bd      	mov	sp, r7
34001954:	f85d 7b04 	ldr.w	r7, [sp], #4
34001958:	4770      	bx	lr
3400195a:	bf00      	nop
3400195c:	3400f2a4 	.word	0x3400f2a4

34001960 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
34001960:	b480      	push	{r7}
34001962:	b083      	sub	sp, #12
34001964:	af00      	add	r7, sp, #0
34001966:	6078      	str	r0, [r7, #4]
34001968:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN, PathInternal);
3400196a:	687b      	ldr	r3, [r7, #4]
3400196c:	689b      	ldr	r3, [r3, #8]
3400196e:	f023 72a0 	bic.w	r2, r3, #20971520	@ 0x1400000
34001972:	683b      	ldr	r3, [r7, #0]
34001974:	431a      	orrs	r2, r3
34001976:	687b      	ldr	r3, [r7, #4]
34001978:	609a      	str	r2, [r3, #8]
}
3400197a:	bf00      	nop
3400197c:	370c      	adds	r7, #12
3400197e:	46bd      	mov	sp, r7
34001980:	f85d 7b04 	ldr.w	r7, [sp], #4
34001984:	4770      	bx	lr

34001986 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(const ADC_Common_TypeDef *ADCxy_COMMON)
{
34001986:	b480      	push	{r7}
34001988:	b083      	sub	sp, #12
3400198a:	af00      	add	r7, sp, #0
3400198c:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN));
3400198e:	687b      	ldr	r3, [r7, #4]
34001990:	689b      	ldr	r3, [r3, #8]
34001992:	f003 73a0 	and.w	r3, r3, #20971520	@ 0x1400000
}
34001996:	4618      	mov	r0, r3
34001998:	370c      	adds	r7, #12
3400199a:	46bd      	mov	sp, r7
3400199c:	f85d 7b04 	ldr.w	r7, [sp], #4
340019a0:	4770      	bx	lr

340019a2 <LL_ADC_SetPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VDDCORE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetPathInternalCh(ADC_TypeDef *ADCx, uint32_t PathInternal)
{
340019a2:	b480      	push	{r7}
340019a4:	b083      	sub	sp, #12
340019a6:	af00      	add	r7, sp, #0
340019a8:	6078      	str	r0, [r7, #4]
340019aa:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->OR, ADC_OR_OP2, (PathInternal >> ADC_PATH_INTERNAL_POS));
340019ac:	687b      	ldr	r3, [r7, #4]
340019ae:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340019b2:	f023 0204 	bic.w	r2, r3, #4
340019b6:	683b      	ldr	r3, [r7, #0]
340019b8:	0c1b      	lsrs	r3, r3, #16
340019ba:	431a      	orrs	r2, r3
340019bc:	687b      	ldr	r3, [r7, #4]
340019be:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
340019c2:	bf00      	nop
340019c4:	370c      	adds	r7, #12
340019c6:	46bd      	mov	sp, r7
340019c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340019cc:	4770      	bx	lr

340019ce <LL_ADC_GetPathInternalCh>:
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VDDCORE
  */
__STATIC_INLINE uint32_t LL_ADC_GetPathInternalCh(const ADC_TypeDef *ADCx)
{
340019ce:	b480      	push	{r7}
340019d0:	b083      	sub	sp, #12
340019d2:	af00      	add	r7, sp, #0
340019d4:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->OR, ADC_OR_OP2)) << ADC_PATH_INTERNAL_POS;
340019d6:	687b      	ldr	r3, [r7, #4]
340019d8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340019dc:	041b      	lsls	r3, r3, #16
340019de:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
}
340019e2:	4618      	mov	r0, r3
340019e4:	370c      	adds	r7, #12
340019e6:	46bd      	mov	sp, r7
340019e8:	f85d 7b04 	ldr.w	r7, [sp], #4
340019ec:	4770      	bx	lr

340019ee <LL_ADC_GetResolution>:
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  */
__STATIC_INLINE uint32_t LL_ADC_GetResolution(const ADC_TypeDef *ADCx)
{
340019ee:	b480      	push	{r7}
340019f0:	b083      	sub	sp, #12
340019f2:	af00      	add	r7, sp, #0
340019f4:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_RES));
340019f6:	687b      	ldr	r3, [r7, #4]
340019f8:	68db      	ldr	r3, [r3, #12]
340019fa:	f003 030c 	and.w	r3, r3, #12
}
340019fe:	4618      	mov	r0, r3
34001a00:	370c      	adds	r7, #12
34001a02:	46bd      	mov	sp, r7
34001a04:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a08:	4770      	bx	lr

34001a0a <LL_ADC_SetOffsetChannel>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel)
{
34001a0a:	b480      	push	{r7}
34001a0c:	b087      	sub	sp, #28
34001a0e:	af00      	add	r7, sp, #0
34001a10:	60f8      	str	r0, [r7, #12]
34001a12:	60b9      	str	r1, [r7, #8]
34001a14:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_cfg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34001a16:	68fb      	ldr	r3, [r7, #12]
34001a18:	3350      	adds	r3, #80	@ 0x50
34001a1a:	461a      	mov	r2, r3
34001a1c:	68bb      	ldr	r3, [r7, #8]
34001a1e:	009b      	lsls	r3, r3, #2
34001a20:	4413      	add	r3, r2
34001a22:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg_offset_cfg,
34001a24:	697b      	ldr	r3, [r7, #20]
34001a26:	681b      	ldr	r3, [r3, #0]
34001a28:	f023 4278 	bic.w	r2, r3, #4160749568	@ 0xf8000000
34001a2c:	687b      	ldr	r3, [r7, #4]
34001a2e:	06db      	lsls	r3, r3, #27
34001a30:	431a      	orrs	r2, r3
34001a32:	697b      	ldr	r3, [r7, #20]
34001a34:	601a      	str	r2, [r3, #0]
             ADC_OFCFGR1_OFFSET_CH,
             (Channel & ADC_CHANNEL_NUMBER_MASK) << ADC_OFCFGR1_OFFSET_CH_Pos);
}
34001a36:	bf00      	nop
34001a38:	371c      	adds	r7, #28
34001a3a:	46bd      	mov	sp, r7
34001a3c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a40:	4770      	bx	lr

34001a42 <LL_ADC_GetOffsetChannel>:
  *         (3) For ADC channel read back from ADC register,
  *             comparison with internal channel parameter to be done
  *             using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
34001a42:	b480      	push	{r7}
34001a44:	b085      	sub	sp, #20
34001a46:	af00      	add	r7, sp, #0
34001a48:	6078      	str	r0, [r7, #4]
34001a4a:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34001a4c:	687b      	ldr	r3, [r7, #4]
34001a4e:	3350      	adds	r3, #80	@ 0x50
34001a50:	461a      	mov	r2, r3
34001a52:	683b      	ldr	r3, [r7, #0]
34001a54:	009b      	lsls	r3, r3, #2
34001a56:	4413      	add	r3, r2
34001a58:	60fb      	str	r3, [r7, #12]

  return (uint32_t) __LL_ADC_DECIMAL_NB_TO_CHANNEL(READ_BIT(*preg, ADC_OFCFGR1_OFFSET_CH) >> ADC_OFCFGR1_OFFSET_CH_Pos);
34001a5a:	68fb      	ldr	r3, [r7, #12]
34001a5c:	681b      	ldr	r3, [r3, #0]
34001a5e:	0edb      	lsrs	r3, r3, #27
34001a60:	f003 031f 	and.w	r3, r3, #31
}
34001a64:	4618      	mov	r0, r3
34001a66:	3714      	adds	r7, #20
34001a68:	46bd      	mov	sp, r7
34001a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a6e:	4770      	bx	lr

34001a70 <LL_ADC_SetOffsetLevel>:
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0x00FFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetLevel(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetLevel)
{
34001a70:	b480      	push	{r7}
34001a72:	b087      	sub	sp, #28
34001a74:	af00      	add	r7, sp, #0
34001a76:	60f8      	str	r0, [r7, #12]
34001a78:	60b9      	str	r1, [r7, #8]
34001a7a:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_val = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
34001a7c:	68fb      	ldr	r3, [r7, #12]
34001a7e:	3360      	adds	r3, #96	@ 0x60
34001a80:	461a      	mov	r2, r3
34001a82:	68bb      	ldr	r3, [r7, #8]
34001a84:	009b      	lsls	r3, r3, #2
34001a86:	4413      	add	r3, r2
34001a88:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg_offset_val,
34001a8a:	697b      	ldr	r3, [r7, #20]
34001a8c:	681b      	ldr	r3, [r3, #0]
34001a8e:	0d9b      	lsrs	r3, r3, #22
34001a90:	059b      	lsls	r3, r3, #22
34001a92:	687a      	ldr	r2, [r7, #4]
34001a94:	431a      	orrs	r2, r3
34001a96:	697b      	ldr	r3, [r7, #20]
34001a98:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET,
             OffsetLevel);
}
34001a9a:	bf00      	nop
34001a9c:	371c      	adds	r7, #28
34001a9e:	46bd      	mov	sp, r7
34001aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
34001aa4:	4770      	bx	lr

34001aa6 <LL_ADC_SetOffsetSign>:
  *         @arg @ref LL_ADC_OFFSET_SIGN_NEGATIVE
  *         @arg @ref LL_ADC_OFFSET_SIGN_POSITIVE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSign(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSign)
{
34001aa6:	b480      	push	{r7}
34001aa8:	b087      	sub	sp, #28
34001aaa:	af00      	add	r7, sp, #0
34001aac:	60f8      	str	r0, [r7, #12]
34001aae:	60b9      	str	r1, [r7, #8]
34001ab0:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34001ab2:	68fb      	ldr	r3, [r7, #12]
34001ab4:	3350      	adds	r3, #80	@ 0x50
34001ab6:	461a      	mov	r2, r3
34001ab8:	68bb      	ldr	r3, [r7, #8]
34001aba:	009b      	lsls	r3, r3, #2
34001abc:	4413      	add	r3, r2
34001abe:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
34001ac0:	697b      	ldr	r3, [r7, #20]
34001ac2:	681b      	ldr	r3, [r3, #0]
34001ac4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34001ac8:	687b      	ldr	r3, [r7, #4]
34001aca:	431a      	orrs	r2, r3
34001acc:	697b      	ldr	r3, [r7, #20]
34001ace:	601a      	str	r2, [r3, #0]
             ADC_OFCFGR1_POSOFF,
             OffsetSign);
}
34001ad0:	bf00      	nop
34001ad2:	371c      	adds	r7, #28
34001ad4:	46bd      	mov	sp, r7
34001ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
34001ada:	4770      	bx	lr

34001adc <LL_ADC_SetOffsetSignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SAT_DISABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety,
                                                      uint32_t OffsetSignedSaturation)
{
34001adc:	b480      	push	{r7}
34001ade:	b087      	sub	sp, #28
34001ae0:	af00      	add	r7, sp, #0
34001ae2:	60f8      	str	r0, [r7, #12]
34001ae4:	60b9      	str	r1, [r7, #8]
34001ae6:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34001ae8:	68fb      	ldr	r3, [r7, #12]
34001aea:	3350      	adds	r3, #80	@ 0x50
34001aec:	461a      	mov	r2, r3
34001aee:	68bb      	ldr	r3, [r7, #8]
34001af0:	009b      	lsls	r3, r3, #2
34001af2:	4413      	add	r3, r2
34001af4:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_SSAT, OffsetSignedSaturation);
34001af6:	697b      	ldr	r3, [r7, #20]
34001af8:	681b      	ldr	r3, [r3, #0]
34001afa:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
34001afe:	687b      	ldr	r3, [r7, #4]
34001b00:	431a      	orrs	r2, r3
34001b02:	697b      	ldr	r3, [r7, #20]
34001b04:	601a      	str	r2, [r3, #0]
}
34001b06:	bf00      	nop
34001b08:	371c      	adds	r7, #28
34001b0a:	46bd      	mov	sp, r7
34001b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b10:	4770      	bx	lr

34001b12 <LL_ADC_SetOffsetUnsignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_UNSIGNED_SAT_DISABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetUnsignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety,
                                                        uint32_t OffsetUnsignedSaturation)
{
34001b12:	b480      	push	{r7}
34001b14:	b087      	sub	sp, #28
34001b16:	af00      	add	r7, sp, #0
34001b18:	60f8      	str	r0, [r7, #12]
34001b1a:	60b9      	str	r1, [r7, #8]
34001b1c:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34001b1e:	68fb      	ldr	r3, [r7, #12]
34001b20:	3350      	adds	r3, #80	@ 0x50
34001b22:	461a      	mov	r2, r3
34001b24:	68bb      	ldr	r3, [r7, #8]
34001b26:	009b      	lsls	r3, r3, #2
34001b28:	4413      	add	r3, r2
34001b2a:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_USAT, OffsetUnsignedSaturation);
34001b2c:	697b      	ldr	r3, [r7, #20]
34001b2e:	681b      	ldr	r3, [r3, #0]
34001b30:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34001b34:	687b      	ldr	r3, [r7, #4]
34001b36:	431a      	orrs	r2, r3
34001b38:	697b      	ldr	r3, [r7, #20]
34001b3a:	601a      	str	r2, [r3, #0]
}
34001b3c:	bf00      	nop
34001b3e:	371c      	adds	r7, #28
34001b40:	46bd      	mov	sp, r7
34001b42:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b46:	4770      	bx	lr

34001b48 <LL_ADC_SetGainCompensation>:
  *         0           Gain compensation will be disabled and value set to 0
  *         1 -> 16393  Gain compensation will be enabled with specified value
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetGainCompensation(ADC_TypeDef *ADCx, uint32_t GainCompensation)
{
34001b48:	b480      	push	{r7}
34001b4a:	b083      	sub	sp, #12
34001b4c:	af00      	add	r7, sp, #0
34001b4e:	6078      	str	r0, [r7, #4]
34001b50:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMPCOEFF, GainCompensation);
34001b52:	687b      	ldr	r3, [r7, #4]
34001b54:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34001b56:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
34001b5a:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34001b5e:	683a      	ldr	r2, [r7, #0]
34001b60:	431a      	orrs	r2, r3
34001b62:	687b      	ldr	r3, [r7, #4]
34001b64:	671a      	str	r2, [r3, #112]	@ 0x70
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMP, ((GainCompensation == 0UL) ? 0UL : 1UL) << ADC_GCOMP_GCOMP_Pos);
34001b66:	687b      	ldr	r3, [r7, #4]
34001b68:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34001b6a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34001b6e:	683a      	ldr	r2, [r7, #0]
34001b70:	2a00      	cmp	r2, #0
34001b72:	d002      	beq.n	34001b7a <LL_ADC_SetGainCompensation+0x32>
34001b74:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34001b78:	e000      	b.n	34001b7c <LL_ADC_SetGainCompensation+0x34>
34001b7a:	2200      	movs	r2, #0
34001b7c:	431a      	orrs	r2, r3
34001b7e:	687b      	ldr	r3, [r7, #4]
34001b80:	671a      	str	r2, [r3, #112]	@ 0x70
}
34001b82:	bf00      	nop
34001b84:	370c      	adds	r7, #12
34001b86:	46bd      	mov	sp, r7
34001b88:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b8c:	4770      	bx	lr

34001b8e <LL_ADC_REG_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
34001b8e:	b480      	push	{r7}
34001b90:	b083      	sub	sp, #12
34001b92:	af00      	add	r7, sp, #0
34001b94:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
34001b96:	687b      	ldr	r3, [r7, #4]
34001b98:	68db      	ldr	r3, [r3, #12]
34001b9a:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
34001b9e:	2b00      	cmp	r3, #0
34001ba0:	d101      	bne.n	34001ba6 <LL_ADC_REG_IsTriggerSourceSWStart+0x18>
34001ba2:	2301      	movs	r3, #1
34001ba4:	e000      	b.n	34001ba8 <LL_ADC_REG_IsTriggerSourceSWStart+0x1a>
34001ba6:	2300      	movs	r3, #0
}
34001ba8:	4618      	mov	r0, r3
34001baa:	370c      	adds	r7, #12
34001bac:	46bd      	mov	sp, r7
34001bae:	f85d 7b04 	ldr.w	r7, [sp], #4
34001bb2:	4770      	bx	lr

34001bb4 <LL_ADC_REG_SetSequencerRanks>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
34001bb4:	b480      	push	{r7}
34001bb6:	b087      	sub	sp, #28
34001bb8:	af00      	add	r7, sp, #0
34001bba:	60f8      	str	r0, [r7, #12]
34001bbc:	60b9      	str	r1, [r7, #8]
34001bbe:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
34001bc0:	68fb      	ldr	r3, [r7, #12]
34001bc2:	3330      	adds	r3, #48	@ 0x30
34001bc4:	461a      	mov	r2, r3
34001bc6:	68bb      	ldr	r3, [r7, #8]
34001bc8:	0a1b      	lsrs	r3, r3, #8
34001bca:	009b      	lsls	r3, r3, #2
34001bcc:	f003 030c 	and.w	r3, r3, #12
34001bd0:	4413      	add	r3, r2
34001bd2:	617b      	str	r3, [r7, #20]
                                             ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
34001bd4:	697b      	ldr	r3, [r7, #20]
34001bd6:	681a      	ldr	r2, [r3, #0]
34001bd8:	68bb      	ldr	r3, [r7, #8]
34001bda:	f003 031f 	and.w	r3, r3, #31
34001bde:	211f      	movs	r1, #31
34001be0:	fa01 f303 	lsl.w	r3, r1, r3
34001be4:	43db      	mvns	r3, r3
34001be6:	401a      	ands	r2, r3
34001be8:	687b      	ldr	r3, [r7, #4]
34001bea:	f003 011f 	and.w	r1, r3, #31
34001bee:	68bb      	ldr	r3, [r7, #8]
34001bf0:	f003 031f 	and.w	r3, r3, #31
34001bf4:	fa01 f303 	lsl.w	r3, r1, r3
34001bf8:	431a      	orrs	r2, r3
34001bfa:	697b      	ldr	r3, [r7, #20]
34001bfc:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             (Channel & ADC_CHANNEL_NUMBER_MASK) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
34001bfe:	bf00      	nop
34001c00:	371c      	adds	r7, #28
34001c02:	46bd      	mov	sp, r7
34001c04:	f85d 7b04 	ldr.w	r7, [sp], #4
34001c08:	4770      	bx	lr

34001c0a <LL_ADC_SetChannelPreselection>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelPreselection(ADC_TypeDef *ADCx, uint32_t Channel)
{
34001c0a:	b480      	push	{r7}
34001c0c:	b085      	sub	sp, #20
34001c0e:	af00      	add	r7, sp, #0
34001c10:	6078      	str	r0, [r7, #4]
34001c12:	6039      	str	r1, [r7, #0]
  __IO uint32_t channel_preselectione = READ_REG(ADCx->PCSEL);
34001c14:	687b      	ldr	r3, [r7, #4]
34001c16:	69db      	ldr	r3, [r3, #28]
34001c18:	60fb      	str	r3, [r7, #12]
  WRITE_REG(ADCx->PCSEL,
34001c1a:	683b      	ldr	r3, [r7, #0]
34001c1c:	f003 031f 	and.w	r3, r3, #31
34001c20:	2201      	movs	r2, #1
34001c22:	409a      	lsls	r2, r3
34001c24:	68fb      	ldr	r3, [r7, #12]
34001c26:	431a      	orrs	r2, r3
34001c28:	687b      	ldr	r3, [r7, #4]
34001c2a:	61da      	str	r2, [r3, #28]
            channel_preselectione | (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)Channel) & 0x1FUL)));
}
34001c2c:	bf00      	nop
34001c2e:	3714      	adds	r7, #20
34001c30:	46bd      	mov	sp, r7
34001c32:	f85d 7b04 	ldr.w	r7, [sp], #4
34001c36:	4770      	bx	lr

34001c38 <LL_ADC_INJ_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
34001c38:	b480      	push	{r7}
34001c3a:	b083      	sub	sp, #12
34001c3c:	af00      	add	r7, sp, #0
34001c3e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
34001c40:	687b      	ldr	r3, [r7, #4]
34001c42:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34001c44:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
34001c48:	2b00      	cmp	r3, #0
34001c4a:	d101      	bne.n	34001c50 <LL_ADC_INJ_IsTriggerSourceSWStart+0x18>
34001c4c:	2301      	movs	r3, #1
34001c4e:	e000      	b.n	34001c52 <LL_ADC_INJ_IsTriggerSourceSWStart+0x1a>
34001c50:	2300      	movs	r3, #0
}
34001c52:	4618      	mov	r0, r3
34001c54:	370c      	adds	r7, #12
34001c56:	46bd      	mov	sp, r7
34001c58:	f85d 7b04 	ldr.w	r7, [sp], #4
34001c5c:	4770      	bx	lr
	...

34001c60 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_246CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_1499CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
34001c60:	b480      	push	{r7}
34001c62:	b087      	sub	sp, #28
34001c64:	af00      	add	r7, sp, #0
34001c66:	60f8      	str	r0, [r7, #12]
34001c68:	60b9      	str	r1, [r7, #8]
34001c6a:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
34001c6c:	68bb      	ldr	r3, [r7, #8]
34001c6e:	f003 031f 	and.w	r3, r3, #31
34001c72:	2b00      	cmp	r3, #0
34001c74:	f000 8087 	beq.w	34001d86 <LL_ADC_SetChannelSamplingTime+0x126>
34001c78:	68bb      	ldr	r3, [r7, #8]
34001c7a:	f003 031f 	and.w	r3, r3, #31
34001c7e:	2b01      	cmp	r3, #1
34001c80:	d07f      	beq.n	34001d82 <LL_ADC_SetChannelSamplingTime+0x122>
34001c82:	68bb      	ldr	r3, [r7, #8]
34001c84:	f003 031f 	and.w	r3, r3, #31
34001c88:	2b02      	cmp	r3, #2
34001c8a:	d078      	beq.n	34001d7e <LL_ADC_SetChannelSamplingTime+0x11e>
34001c8c:	68bb      	ldr	r3, [r7, #8]
34001c8e:	f003 031f 	and.w	r3, r3, #31
34001c92:	2b03      	cmp	r3, #3
34001c94:	d071      	beq.n	34001d7a <LL_ADC_SetChannelSamplingTime+0x11a>
34001c96:	68bb      	ldr	r3, [r7, #8]
34001c98:	f003 031f 	and.w	r3, r3, #31
34001c9c:	2b04      	cmp	r3, #4
34001c9e:	d06a      	beq.n	34001d76 <LL_ADC_SetChannelSamplingTime+0x116>
34001ca0:	68bb      	ldr	r3, [r7, #8]
34001ca2:	f003 031f 	and.w	r3, r3, #31
34001ca6:	2b05      	cmp	r3, #5
34001ca8:	d063      	beq.n	34001d72 <LL_ADC_SetChannelSamplingTime+0x112>
34001caa:	68bb      	ldr	r3, [r7, #8]
34001cac:	f003 031f 	and.w	r3, r3, #31
34001cb0:	2b06      	cmp	r3, #6
34001cb2:	d05c      	beq.n	34001d6e <LL_ADC_SetChannelSamplingTime+0x10e>
34001cb4:	68bb      	ldr	r3, [r7, #8]
34001cb6:	f003 031f 	and.w	r3, r3, #31
34001cba:	2b07      	cmp	r3, #7
34001cbc:	d055      	beq.n	34001d6a <LL_ADC_SetChannelSamplingTime+0x10a>
34001cbe:	68bb      	ldr	r3, [r7, #8]
34001cc0:	f003 031f 	and.w	r3, r3, #31
34001cc4:	2b08      	cmp	r3, #8
34001cc6:	d04e      	beq.n	34001d66 <LL_ADC_SetChannelSamplingTime+0x106>
34001cc8:	68bb      	ldr	r3, [r7, #8]
34001cca:	f003 031f 	and.w	r3, r3, #31
34001cce:	2b09      	cmp	r3, #9
34001cd0:	d047      	beq.n	34001d62 <LL_ADC_SetChannelSamplingTime+0x102>
34001cd2:	68bb      	ldr	r3, [r7, #8]
34001cd4:	f003 031f 	and.w	r3, r3, #31
34001cd8:	2b0a      	cmp	r3, #10
34001cda:	d040      	beq.n	34001d5e <LL_ADC_SetChannelSamplingTime+0xfe>
34001cdc:	68bb      	ldr	r3, [r7, #8]
34001cde:	f003 031f 	and.w	r3, r3, #31
34001ce2:	2b0b      	cmp	r3, #11
34001ce4:	d039      	beq.n	34001d5a <LL_ADC_SetChannelSamplingTime+0xfa>
34001ce6:	68bb      	ldr	r3, [r7, #8]
34001ce8:	f003 031f 	and.w	r3, r3, #31
34001cec:	2b0c      	cmp	r3, #12
34001cee:	d032      	beq.n	34001d56 <LL_ADC_SetChannelSamplingTime+0xf6>
34001cf0:	68bb      	ldr	r3, [r7, #8]
34001cf2:	f003 031f 	and.w	r3, r3, #31
34001cf6:	2b0d      	cmp	r3, #13
34001cf8:	d02b      	beq.n	34001d52 <LL_ADC_SetChannelSamplingTime+0xf2>
34001cfa:	68bb      	ldr	r3, [r7, #8]
34001cfc:	f003 031f 	and.w	r3, r3, #31
34001d00:	2b0e      	cmp	r3, #14
34001d02:	d024      	beq.n	34001d4e <LL_ADC_SetChannelSamplingTime+0xee>
34001d04:	68bb      	ldr	r3, [r7, #8]
34001d06:	f003 031f 	and.w	r3, r3, #31
34001d0a:	2b0f      	cmp	r3, #15
34001d0c:	d01d      	beq.n	34001d4a <LL_ADC_SetChannelSamplingTime+0xea>
34001d0e:	68bb      	ldr	r3, [r7, #8]
34001d10:	f003 031f 	and.w	r3, r3, #31
34001d14:	2b10      	cmp	r3, #16
34001d16:	d016      	beq.n	34001d46 <LL_ADC_SetChannelSamplingTime+0xe6>
34001d18:	68bb      	ldr	r3, [r7, #8]
34001d1a:	f003 031f 	and.w	r3, r3, #31
34001d1e:	2b11      	cmp	r3, #17
34001d20:	d00f      	beq.n	34001d42 <LL_ADC_SetChannelSamplingTime+0xe2>
34001d22:	68bb      	ldr	r3, [r7, #8]
34001d24:	f003 031f 	and.w	r3, r3, #31
34001d28:	2b12      	cmp	r3, #18
34001d2a:	d008      	beq.n	34001d3e <LL_ADC_SetChannelSamplingTime+0xde>
34001d2c:	68bb      	ldr	r3, [r7, #8]
34001d2e:	f003 031f 	and.w	r3, r3, #31
34001d32:	2b13      	cmp	r3, #19
34001d34:	d101      	bne.n	34001d3a <LL_ADC_SetChannelSamplingTime+0xda>
34001d36:	2313      	movs	r3, #19
34001d38:	e026      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d3a:	2300      	movs	r3, #0
34001d3c:	e024      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d3e:	2312      	movs	r3, #18
34001d40:	e022      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d42:	2311      	movs	r3, #17
34001d44:	e020      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d46:	2310      	movs	r3, #16
34001d48:	e01e      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d4a:	230f      	movs	r3, #15
34001d4c:	e01c      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d4e:	230e      	movs	r3, #14
34001d50:	e01a      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d52:	230d      	movs	r3, #13
34001d54:	e018      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d56:	230c      	movs	r3, #12
34001d58:	e016      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d5a:	230b      	movs	r3, #11
34001d5c:	e014      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d5e:	230a      	movs	r3, #10
34001d60:	e012      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d62:	2309      	movs	r3, #9
34001d64:	e010      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d66:	2308      	movs	r3, #8
34001d68:	e00e      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d6a:	2307      	movs	r3, #7
34001d6c:	e00c      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d6e:	2306      	movs	r3, #6
34001d70:	e00a      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d72:	2305      	movs	r3, #5
34001d74:	e008      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d76:	2304      	movs	r3, #4
34001d78:	e006      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d7a:	2303      	movs	r3, #3
34001d7c:	e004      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d7e:	2302      	movs	r3, #2
34001d80:	e002      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d82:	2301      	movs	r3, #1
34001d84:	e000      	b.n	34001d88 <LL_ADC_SetChannelSamplingTime+0x128>
34001d86:	2300      	movs	r3, #0
34001d88:	617b      	str	r3, [r7, #20]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
34001d8a:	68fb      	ldr	r3, [r7, #12]
34001d8c:	3314      	adds	r3, #20
34001d8e:	4619      	mov	r1, r3
34001d90:	4a15      	ldr	r2, [pc, #84]	@ (34001de8 <LL_ADC_SetChannelSamplingTime+0x188>)
34001d92:	697b      	ldr	r3, [r7, #20]
34001d94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34001d98:	0e5b      	lsrs	r3, r3, #25
34001d9a:	009b      	lsls	r3, r3, #2
34001d9c:	f003 0304 	and.w	r3, r3, #4
34001da0:	440b      	add	r3, r1
34001da2:	613b      	str	r3, [r7, #16]
                                             ((ADC_CHANNEL_LUT[iChannel]
                                               & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
  MODIFY_REG(*preg,
34001da4:	693b      	ldr	r3, [r7, #16]
34001da6:	681a      	ldr	r2, [r3, #0]
34001da8:	490f      	ldr	r1, [pc, #60]	@ (34001de8 <LL_ADC_SetChannelSamplingTime+0x188>)
34001daa:	697b      	ldr	r3, [r7, #20]
34001dac:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34001db0:	0d1b      	lsrs	r3, r3, #20
34001db2:	f003 031f 	and.w	r3, r3, #31
34001db6:	2107      	movs	r1, #7
34001db8:	fa01 f303 	lsl.w	r3, r1, r3
34001dbc:	43db      	mvns	r3, r3
34001dbe:	401a      	ands	r2, r3
34001dc0:	4909      	ldr	r1, [pc, #36]	@ (34001de8 <LL_ADC_SetChannelSamplingTime+0x188>)
34001dc2:	697b      	ldr	r3, [r7, #20]
34001dc4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34001dc8:	0d1b      	lsrs	r3, r3, #20
34001dca:	f003 031f 	and.w	r3, r3, #31
34001dce:	6879      	ldr	r1, [r7, #4]
34001dd0:	fa01 f303 	lsl.w	r3, r1, r3
34001dd4:	431a      	orrs	r2, r3
34001dd6:	693b      	ldr	r3, [r7, #16]
34001dd8:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((ADC_CHANNEL_LUT[iChannel] & ADC_CHANNEL_SMPx_BITOFFSET_MASK)
                                >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((ADC_CHANNEL_LUT[iChannel] & ADC_CHANNEL_SMPx_BITOFFSET_MASK)
                                >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
34001dda:	bf00      	nop
34001ddc:	371c      	adds	r7, #28
34001dde:	46bd      	mov	sp, r7
34001de0:	f85d 7b04 	ldr.w	r7, [sp], #4
34001de4:	4770      	bx	lr
34001de6:	bf00      	nop
34001de8:	3400df94 	.word	0x3400df94

34001dec <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
34001dec:	b480      	push	{r7}
34001dee:	b087      	sub	sp, #28
34001df0:	af00      	add	r7, sp, #0
34001df2:	60f8      	str	r0, [r7, #12]
34001df4:	60b9      	str	r1, [r7, #8]
34001df6:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
34001df8:	68bb      	ldr	r3, [r7, #8]
34001dfa:	f003 031f 	and.w	r3, r3, #31
34001dfe:	2b00      	cmp	r3, #0
34001e00:	f000 8087 	beq.w	34001f12 <LL_ADC_SetChannelSingleDiff+0x126>
34001e04:	68bb      	ldr	r3, [r7, #8]
34001e06:	f003 031f 	and.w	r3, r3, #31
34001e0a:	2b01      	cmp	r3, #1
34001e0c:	d07f      	beq.n	34001f0e <LL_ADC_SetChannelSingleDiff+0x122>
34001e0e:	68bb      	ldr	r3, [r7, #8]
34001e10:	f003 031f 	and.w	r3, r3, #31
34001e14:	2b02      	cmp	r3, #2
34001e16:	d078      	beq.n	34001f0a <LL_ADC_SetChannelSingleDiff+0x11e>
34001e18:	68bb      	ldr	r3, [r7, #8]
34001e1a:	f003 031f 	and.w	r3, r3, #31
34001e1e:	2b03      	cmp	r3, #3
34001e20:	d071      	beq.n	34001f06 <LL_ADC_SetChannelSingleDiff+0x11a>
34001e22:	68bb      	ldr	r3, [r7, #8]
34001e24:	f003 031f 	and.w	r3, r3, #31
34001e28:	2b04      	cmp	r3, #4
34001e2a:	d06a      	beq.n	34001f02 <LL_ADC_SetChannelSingleDiff+0x116>
34001e2c:	68bb      	ldr	r3, [r7, #8]
34001e2e:	f003 031f 	and.w	r3, r3, #31
34001e32:	2b05      	cmp	r3, #5
34001e34:	d063      	beq.n	34001efe <LL_ADC_SetChannelSingleDiff+0x112>
34001e36:	68bb      	ldr	r3, [r7, #8]
34001e38:	f003 031f 	and.w	r3, r3, #31
34001e3c:	2b06      	cmp	r3, #6
34001e3e:	d05c      	beq.n	34001efa <LL_ADC_SetChannelSingleDiff+0x10e>
34001e40:	68bb      	ldr	r3, [r7, #8]
34001e42:	f003 031f 	and.w	r3, r3, #31
34001e46:	2b07      	cmp	r3, #7
34001e48:	d055      	beq.n	34001ef6 <LL_ADC_SetChannelSingleDiff+0x10a>
34001e4a:	68bb      	ldr	r3, [r7, #8]
34001e4c:	f003 031f 	and.w	r3, r3, #31
34001e50:	2b08      	cmp	r3, #8
34001e52:	d04e      	beq.n	34001ef2 <LL_ADC_SetChannelSingleDiff+0x106>
34001e54:	68bb      	ldr	r3, [r7, #8]
34001e56:	f003 031f 	and.w	r3, r3, #31
34001e5a:	2b09      	cmp	r3, #9
34001e5c:	d047      	beq.n	34001eee <LL_ADC_SetChannelSingleDiff+0x102>
34001e5e:	68bb      	ldr	r3, [r7, #8]
34001e60:	f003 031f 	and.w	r3, r3, #31
34001e64:	2b0a      	cmp	r3, #10
34001e66:	d040      	beq.n	34001eea <LL_ADC_SetChannelSingleDiff+0xfe>
34001e68:	68bb      	ldr	r3, [r7, #8]
34001e6a:	f003 031f 	and.w	r3, r3, #31
34001e6e:	2b0b      	cmp	r3, #11
34001e70:	d039      	beq.n	34001ee6 <LL_ADC_SetChannelSingleDiff+0xfa>
34001e72:	68bb      	ldr	r3, [r7, #8]
34001e74:	f003 031f 	and.w	r3, r3, #31
34001e78:	2b0c      	cmp	r3, #12
34001e7a:	d032      	beq.n	34001ee2 <LL_ADC_SetChannelSingleDiff+0xf6>
34001e7c:	68bb      	ldr	r3, [r7, #8]
34001e7e:	f003 031f 	and.w	r3, r3, #31
34001e82:	2b0d      	cmp	r3, #13
34001e84:	d02b      	beq.n	34001ede <LL_ADC_SetChannelSingleDiff+0xf2>
34001e86:	68bb      	ldr	r3, [r7, #8]
34001e88:	f003 031f 	and.w	r3, r3, #31
34001e8c:	2b0e      	cmp	r3, #14
34001e8e:	d024      	beq.n	34001eda <LL_ADC_SetChannelSingleDiff+0xee>
34001e90:	68bb      	ldr	r3, [r7, #8]
34001e92:	f003 031f 	and.w	r3, r3, #31
34001e96:	2b0f      	cmp	r3, #15
34001e98:	d01d      	beq.n	34001ed6 <LL_ADC_SetChannelSingleDiff+0xea>
34001e9a:	68bb      	ldr	r3, [r7, #8]
34001e9c:	f003 031f 	and.w	r3, r3, #31
34001ea0:	2b10      	cmp	r3, #16
34001ea2:	d016      	beq.n	34001ed2 <LL_ADC_SetChannelSingleDiff+0xe6>
34001ea4:	68bb      	ldr	r3, [r7, #8]
34001ea6:	f003 031f 	and.w	r3, r3, #31
34001eaa:	2b11      	cmp	r3, #17
34001eac:	d00f      	beq.n	34001ece <LL_ADC_SetChannelSingleDiff+0xe2>
34001eae:	68bb      	ldr	r3, [r7, #8]
34001eb0:	f003 031f 	and.w	r3, r3, #31
34001eb4:	2b12      	cmp	r3, #18
34001eb6:	d008      	beq.n	34001eca <LL_ADC_SetChannelSingleDiff+0xde>
34001eb8:	68bb      	ldr	r3, [r7, #8]
34001eba:	f003 031f 	and.w	r3, r3, #31
34001ebe:	2b13      	cmp	r3, #19
34001ec0:	d101      	bne.n	34001ec6 <LL_ADC_SetChannelSingleDiff+0xda>
34001ec2:	2313      	movs	r3, #19
34001ec4:	e026      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ec6:	2300      	movs	r3, #0
34001ec8:	e024      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001eca:	2312      	movs	r3, #18
34001ecc:	e022      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ece:	2311      	movs	r3, #17
34001ed0:	e020      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ed2:	2310      	movs	r3, #16
34001ed4:	e01e      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ed6:	230f      	movs	r3, #15
34001ed8:	e01c      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001eda:	230e      	movs	r3, #14
34001edc:	e01a      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ede:	230d      	movs	r3, #13
34001ee0:	e018      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ee2:	230c      	movs	r3, #12
34001ee4:	e016      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ee6:	230b      	movs	r3, #11
34001ee8:	e014      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001eea:	230a      	movs	r3, #10
34001eec:	e012      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001eee:	2309      	movs	r3, #9
34001ef0:	e010      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ef2:	2308      	movs	r3, #8
34001ef4:	e00e      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001ef6:	2307      	movs	r3, #7
34001ef8:	e00c      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001efa:	2306      	movs	r3, #6
34001efc:	e00a      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001efe:	2305      	movs	r3, #5
34001f00:	e008      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001f02:	2304      	movs	r3, #4
34001f04:	e006      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001f06:	2303      	movs	r3, #3
34001f08:	e004      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001f0a:	2302      	movs	r3, #2
34001f0c:	e002      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001f0e:	2301      	movs	r3, #1
34001f10:	e000      	b.n	34001f14 <LL_ADC_SetChannelSingleDiff+0x128>
34001f12:	2300      	movs	r3, #0
34001f14:	617b      	str	r3, [r7, #20]
  MODIFY_REG(ADCx->DIFSEL,
34001f16:	68fb      	ldr	r3, [r7, #12]
34001f18:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
34001f1c:	490f      	ldr	r1, [pc, #60]	@ (34001f5c <LL_ADC_SetChannelSingleDiff+0x170>)
34001f1e:	697b      	ldr	r3, [r7, #20]
34001f20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34001f24:	f3c3 0313 	ubfx	r3, r3, #0, #20
34001f28:	43db      	mvns	r3, r3
34001f2a:	401a      	ands	r2, r3
34001f2c:	490b      	ldr	r1, [pc, #44]	@ (34001f5c <LL_ADC_SetChannelSingleDiff+0x170>)
34001f2e:	697b      	ldr	r3, [r7, #20]
34001f30:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34001f34:	687b      	ldr	r3, [r7, #4]
34001f36:	f003 0318 	and.w	r3, r3, #24
34001f3a:	4809      	ldr	r0, [pc, #36]	@ (34001f60 <LL_ADC_SetChannelSingleDiff+0x174>)
34001f3c:	fa20 f303 	lsr.w	r3, r0, r3
34001f40:	400b      	ands	r3, r1
34001f42:	f3c3 0313 	ubfx	r3, r3, #0, #20
34001f46:	431a      	orrs	r2, r3
34001f48:	68fb      	ldr	r3, [r7, #12]
34001f4a:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
             ADC_CHANNEL_LUT[iChannel] & ADC_SINGLEDIFF_CHANNEL_MASK,
             (ADC_CHANNEL_LUT[iChannel] & ADC_SINGLEDIFF_CHANNEL_MASK)
             & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
34001f4e:	bf00      	nop
34001f50:	371c      	adds	r7, #28
34001f52:	46bd      	mov	sp, r7
34001f54:	f85d 7b04 	ldr.w	r7, [sp], #4
34001f58:	4770      	bx	lr
34001f5a:	bf00      	nop
34001f5c:	3400df94 	.word	0x3400df94
34001f60:	000fffff 	.word	0x000fffff

34001f64 <LL_ADC_SetAnalogWDMonitChannels>:
  *         (0) On this STM32 series, parameter available only on analog watchdog instance: AWD1.\n
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC2, ADC3.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
{
34001f64:	b480      	push	{r7}
34001f66:	b087      	sub	sp, #28
34001f68:	af00      	add	r7, sp, #0
34001f6a:	60f8      	str	r0, [r7, #12]
34001f6c:	60b9      	str	r1, [r7, #8]
34001f6e:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "AWDChannelGroup" with bits position  */
  /* in register and register position depending on parameter "AWDy".         */
  /* Parameters "AWDChannelGroup" and "AWDy" are used with masks because      */
  /* containing other bits reserved for other purpose.                        */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR1,
34001f70:	68fb      	ldr	r3, [r7, #12]
34001f72:	330c      	adds	r3, #12
34001f74:	4618      	mov	r0, r3
34001f76:	68bb      	ldr	r3, [r7, #8]
34001f78:	0d1b      	lsrs	r3, r3, #20
34001f7a:	f003 0103 	and.w	r1, r3, #3
34001f7e:	68bb      	ldr	r3, [r7, #8]
34001f80:	f003 0201 	and.w	r2, r3, #1
34001f84:	4613      	mov	r3, r2
34001f86:	00db      	lsls	r3, r3, #3
34001f88:	4413      	add	r3, r2
34001f8a:	009b      	lsls	r3, r3, #2
34001f8c:	440b      	add	r3, r1
34001f8e:	009b      	lsls	r3, r3, #2
34001f90:	4403      	add	r3, r0
34001f92:	617b      	str	r3, [r7, #20]
                                             ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK)
                                                * ADC_AWD_CR12_REGOFFSETGAP_VAL));

  MODIFY_REG(*preg,
34001f94:	697b      	ldr	r3, [r7, #20]
34001f96:	681a      	ldr	r2, [r3, #0]
34001f98:	68bb      	ldr	r3, [r7, #8]
34001f9a:	f023 4302 	bic.w	r3, r3, #2181038080	@ 0x82000000
34001f9e:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
34001fa2:	43db      	mvns	r3, r3
34001fa4:	401a      	ands	r2, r3
34001fa6:	6879      	ldr	r1, [r7, #4]
34001fa8:	68bb      	ldr	r3, [r7, #8]
34001faa:	400b      	ands	r3, r1
34001fac:	431a      	orrs	r2, r3
34001fae:	697b      	ldr	r3, [r7, #20]
34001fb0:	601a      	str	r2, [r3, #0]
             (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
             AWDChannelGroup & AWDy);
}
34001fb2:	bf00      	nop
34001fb4:	371c      	adds	r7, #28
34001fb6:	46bd      	mov	sp, r7
34001fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34001fbc:	4770      	bx	lr
	...

34001fc0 <LL_ADC_SetAnalogWDThresholds>:
  * @param  AWDThresholdValue Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow,
                                                  uint32_t AWDThresholdValue)
{
34001fc0:	b480      	push	{r7}
34001fc2:	b087      	sub	sp, #28
34001fc4:	af00      	add	r7, sp, #0
34001fc6:	60f8      	str	r0, [r7, #12]
34001fc8:	60b9      	str	r1, [r7, #8]
34001fca:	607a      	str	r2, [r7, #4]
34001fcc:	603b      	str	r3, [r7, #0]
  /* Set bits with content of parameter "AWDThresholdValue" with bits         */
  /* position in register and register position depending on parameters       */
  /* "AWDThresholdsHighLow" and "AWDy".                                       */
  /* Parameters "AWDy" and "AWDThresholdValue" are used with masks because    */
  /* containing other bits reserved for other purpose.                        */
  if (AWDy == LL_ADC_AWD1)
34001fce:	68bb      	ldr	r3, [r7, #8]
34001fd0:	4a12      	ldr	r2, [pc, #72]	@ (3400201c <LL_ADC_SetAnalogWDThresholds+0x5c>)
34001fd2:	4293      	cmp	r3, r2
34001fd4:	d107      	bne.n	34001fe6 <LL_ADC_SetAnalogWDThresholds+0x26>
  {
    preg = __ADC_PTR_REG_OFFSET(ADCx->AWD1LTR, (AWDThresholdsHighLow));
34001fd6:	68fb      	ldr	r3, [r7, #12]
34001fd8:	33a8      	adds	r3, #168	@ 0xa8
34001fda:	461a      	mov	r2, r3
34001fdc:	687b      	ldr	r3, [r7, #4]
34001fde:	009b      	lsls	r3, r3, #2
34001fe0:	4413      	add	r3, r2
34001fe2:	617b      	str	r3, [r7, #20]
34001fe4:	e00c      	b.n	34002000 <LL_ADC_SetAnalogWDThresholds+0x40>
  }
  else
  {
    preg = __ADC_PTR_REG_OFFSET(ADCx->AWD1LTR, (((AWDy & ADC_AWD_TRX_REGOFFSET_MASK)
34001fe6:	68fb      	ldr	r3, [r7, #12]
34001fe8:	33a8      	adds	r3, #168	@ 0xa8
34001fea:	4619      	mov	r1, r3
34001fec:	68bb      	ldr	r3, [r7, #8]
34001fee:	0d1b      	lsrs	r3, r3, #20
34001ff0:	f003 0303 	and.w	r3, r3, #3
34001ff4:	005a      	lsls	r2, r3, #1
34001ff6:	687b      	ldr	r3, [r7, #4]
34001ff8:	4413      	add	r3, r2
34001ffa:	009b      	lsls	r3, r3, #2
34001ffc:	440b      	add	r3, r1
34001ffe:	617b      	str	r3, [r7, #20]
                                                 >> ADC_AWD_TRX_REGOFFSET_POS) * 2UL)
                                + (AWDThresholdsHighLow));
  }

  MODIFY_REG(*preg, ADC_AWD1LTR_LTR, AWDThresholdValue);
34002000:	697b      	ldr	r3, [r7, #20]
34002002:	681b      	ldr	r3, [r3, #0]
34002004:	0ddb      	lsrs	r3, r3, #23
34002006:	05db      	lsls	r3, r3, #23
34002008:	683a      	ldr	r2, [r7, #0]
3400200a:	431a      	orrs	r2, r3
3400200c:	697b      	ldr	r3, [r7, #20]
3400200e:	601a      	str	r2, [r3, #0]
}
34002010:	bf00      	nop
34002012:	371c      	adds	r7, #28
34002014:	46bd      	mov	sp, r7
34002016:	f85d 7b04 	ldr.w	r7, [sp], #4
3400201a:	4770      	bx	lr
3400201c:	7dc00000 	.word	0x7dc00000

34002020 <LL_ADC_SetAWDFilteringConfiguration>:
  *         @arg @ref LL_ADC_AWD_FILTERING_7SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_8SAMPLES
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAWDFilteringConfiguration(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t FilteringConfig)
{
34002020:	b480      	push	{r7}
34002022:	b085      	sub	sp, #20
34002024:	af00      	add	r7, sp, #0
34002026:	60f8      	str	r0, [r7, #12]
34002028:	60b9      	str	r1, [r7, #8]
3400202a:	607a      	str	r2, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  (void)(AWDy);
  MODIFY_REG(ADCx->AWD1HTR, ADC_AWD1HTR_AWDFILT, FilteringConfig);
3400202c:	68fb      	ldr	r3, [r7, #12]
3400202e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34002032:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
34002036:	687b      	ldr	r3, [r7, #4]
34002038:	431a      	orrs	r2, r3
3400203a:	68fb      	ldr	r3, [r7, #12]
3400203c:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
}
34002040:	bf00      	nop
34002042:	3714      	adds	r7, #20
34002044:	46bd      	mov	sp, r7
34002046:	f85d 7b04 	ldr.w	r7, [sp], #4
3400204a:	4770      	bx	lr

3400204c <LL_ADC_GetMultimode>:
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(const ADC_Common_TypeDef *ADCxy_COMMON)
{
3400204c:	b480      	push	{r7}
3400204e:	b083      	sub	sp, #12
34002050:	af00      	add	r7, sp, #0
34002052:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
34002054:	687b      	ldr	r3, [r7, #4]
34002056:	689b      	ldr	r3, [r3, #8]
34002058:	f003 031f 	and.w	r3, r3, #31
}
3400205c:	4618      	mov	r0, r3
3400205e:	370c      	adds	r7, #12
34002060:	46bd      	mov	sp, r7
34002062:	f85d 7b04 	ldr.w	r7, [sp], #4
34002066:	4770      	bx	lr

34002068 <LL_ADC_GetMultiDataFormat>:
  *         @arg @ref LL_ADC_MULTI_REG_DATA_EACH_ADC
  *         @arg @ref LL_ADC_MULTI_REG_DATA_COMMON_32B
  *         @arg @ref LL_ADC_MULTI_REG_DATA_COMMON_16B
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultiDataFormat(const ADC_Common_TypeDef *ADCxy_COMMON)
{
34002068:	b480      	push	{r7}
3400206a:	b083      	sub	sp, #12
3400206c:	af00      	add	r7, sp, #0
3400206e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DAMDF));
34002070:	687b      	ldr	r3, [r7, #4]
34002072:	689b      	ldr	r3, [r3, #8]
34002074:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
}
34002078:	4618      	mov	r0, r3
3400207a:	370c      	adds	r7, #12
3400207c:	46bd      	mov	sp, r7
3400207e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002082:	4770      	bx	lr

34002084 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
34002084:	b480      	push	{r7}
34002086:	b083      	sub	sp, #12
34002088:	af00      	add	r7, sp, #0
3400208a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
3400208c:	687b      	ldr	r3, [r7, #4]
3400208e:	689b      	ldr	r3, [r3, #8]
34002090:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
34002094:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002098:	687a      	ldr	r2, [r7, #4]
3400209a:	6093      	str	r3, [r2, #8]
}
3400209c:	bf00      	nop
3400209e:	370c      	adds	r7, #12
340020a0:	46bd      	mov	sp, r7
340020a2:	f85d 7b04 	ldr.w	r7, [sp], #4
340020a6:	4770      	bx	lr

340020a8 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(const ADC_TypeDef *ADCx)
{
340020a8:	b480      	push	{r7}
340020aa:	b083      	sub	sp, #12
340020ac:	af00      	add	r7, sp, #0
340020ae:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
340020b0:	687b      	ldr	r3, [r7, #4]
340020b2:	689b      	ldr	r3, [r3, #8]
340020b4:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
340020b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340020bc:	d101      	bne.n	340020c2 <LL_ADC_IsDeepPowerDownEnabled+0x1a>
340020be:	2301      	movs	r3, #1
340020c0:	e000      	b.n	340020c4 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
340020c2:	2300      	movs	r3, #0
}
340020c4:	4618      	mov	r0, r3
340020c6:	370c      	adds	r7, #12
340020c8:	46bd      	mov	sp, r7
340020ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340020ce:	4770      	bx	lr

340020d0 <LL_ADC_Enable>:
  * @rmtoll CR       ADEN           LL_ADC_Enable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
{
340020d0:	b480      	push	{r7}
340020d2:	b083      	sub	sp, #12
340020d4:	af00      	add	r7, sp, #0
340020d6:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
340020d8:	687b      	ldr	r3, [r7, #4]
340020da:	689b      	ldr	r3, [r3, #8]
340020dc:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
340020e0:	f043 0201 	orr.w	r2, r3, #1
340020e4:	687b      	ldr	r3, [r7, #4]
340020e6:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADEN);
}
340020e8:	bf00      	nop
340020ea:	370c      	adds	r7, #12
340020ec:	46bd      	mov	sp, r7
340020ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340020f2:	4770      	bx	lr

340020f4 <LL_ADC_Disable>:
  * @rmtoll CR       ADDIS          LL_ADC_Disable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
{
340020f4:	b480      	push	{r7}
340020f6:	b083      	sub	sp, #12
340020f8:	af00      	add	r7, sp, #0
340020fa:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
340020fc:	687b      	ldr	r3, [r7, #4]
340020fe:	689b      	ldr	r3, [r3, #8]
34002100:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002104:	f043 0202 	orr.w	r2, r3, #2
34002108:	687b      	ldr	r3, [r7, #4]
3400210a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADDIS);
}
3400210c:	bf00      	nop
3400210e:	370c      	adds	r7, #12
34002110:	46bd      	mov	sp, r7
34002112:	f85d 7b04 	ldr.w	r7, [sp], #4
34002116:	4770      	bx	lr

34002118 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
34002118:	b480      	push	{r7}
3400211a:	b083      	sub	sp, #12
3400211c:	af00      	add	r7, sp, #0
3400211e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34002120:	687b      	ldr	r3, [r7, #4]
34002122:	689b      	ldr	r3, [r3, #8]
34002124:	f003 0301 	and.w	r3, r3, #1
34002128:	2b01      	cmp	r3, #1
3400212a:	d101      	bne.n	34002130 <LL_ADC_IsEnabled+0x18>
3400212c:	2301      	movs	r3, #1
3400212e:	e000      	b.n	34002132 <LL_ADC_IsEnabled+0x1a>
34002130:	2300      	movs	r3, #0
}
34002132:	4618      	mov	r0, r3
34002134:	370c      	adds	r7, #12
34002136:	46bd      	mov	sp, r7
34002138:	f85d 7b04 	ldr.w	r7, [sp], #4
3400213c:	4770      	bx	lr

3400213e <LL_ADC_IsDisableOngoing>:
  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
  * @param  ADCx ADC instance
  * @retval 0: no ADC disable command on going.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(const ADC_TypeDef *ADCx)
{
3400213e:	b480      	push	{r7}
34002140:	b083      	sub	sp, #12
34002142:	af00      	add	r7, sp, #0
34002144:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
34002146:	687b      	ldr	r3, [r7, #4]
34002148:	689b      	ldr	r3, [r3, #8]
3400214a:	f003 0302 	and.w	r3, r3, #2
3400214e:	2b02      	cmp	r3, #2
34002150:	d101      	bne.n	34002156 <LL_ADC_IsDisableOngoing+0x18>
34002152:	2301      	movs	r3, #1
34002154:	e000      	b.n	34002158 <LL_ADC_IsDisableOngoing+0x1a>
34002156:	2300      	movs	r3, #0
}
34002158:	4618      	mov	r0, r3
3400215a:	370c      	adds	r7, #12
3400215c:	46bd      	mov	sp, r7
3400215e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002162:	4770      	bx	lr

34002164 <LL_ADC_REG_StartConversion>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
{
34002164:	b480      	push	{r7}
34002166:	b083      	sub	sp, #12
34002168:	af00      	add	r7, sp, #0
3400216a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
3400216c:	687b      	ldr	r3, [r7, #4]
3400216e:	689b      	ldr	r3, [r3, #8]
34002170:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002174:	f043 0204 	orr.w	r2, r3, #4
34002178:	687b      	ldr	r3, [r7, #4]
3400217a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTART);
}
3400217c:	bf00      	nop
3400217e:	370c      	adds	r7, #12
34002180:	46bd      	mov	sp, r7
34002182:	f85d 7b04 	ldr.w	r7, [sp], #4
34002186:	4770      	bx	lr

34002188 <LL_ADC_REG_StopConversion>:
  * @rmtoll CR       ADSTP          LL_ADC_REG_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
{
34002188:	b480      	push	{r7}
3400218a:	b083      	sub	sp, #12
3400218c:	af00      	add	r7, sp, #0
3400218e:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002190:	687b      	ldr	r3, [r7, #4]
34002192:	689b      	ldr	r3, [r3, #8]
34002194:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002198:	f043 0210 	orr.w	r2, r3, #16
3400219c:	687b      	ldr	r3, [r7, #4]
3400219e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTP);
}
340021a0:	bf00      	nop
340021a2:	370c      	adds	r7, #12
340021a4:	46bd      	mov	sp, r7
340021a6:	f85d 7b04 	ldr.w	r7, [sp], #4
340021aa:	4770      	bx	lr

340021ac <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
340021ac:	b480      	push	{r7}
340021ae:	b083      	sub	sp, #12
340021b0:	af00      	add	r7, sp, #0
340021b2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
340021b4:	687b      	ldr	r3, [r7, #4]
340021b6:	689b      	ldr	r3, [r3, #8]
340021b8:	f003 0304 	and.w	r3, r3, #4
340021bc:	2b04      	cmp	r3, #4
340021be:	d101      	bne.n	340021c4 <LL_ADC_REG_IsConversionOngoing+0x18>
340021c0:	2301      	movs	r3, #1
340021c2:	e000      	b.n	340021c6 <LL_ADC_REG_IsConversionOngoing+0x1a>
340021c4:	2300      	movs	r3, #0
}
340021c6:	4618      	mov	r0, r3
340021c8:	370c      	adds	r7, #12
340021ca:	46bd      	mov	sp, r7
340021cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340021d0:	4770      	bx	lr

340021d2 <LL_ADC_INJ_StopConversion>:
  * @rmtoll CR       JADSTP         LL_ADC_INJ_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_StopConversion(ADC_TypeDef *ADCx)
{
340021d2:	b480      	push	{r7}
340021d4:	b083      	sub	sp, #12
340021d6:	af00      	add	r7, sp, #0
340021d8:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
340021da:	687b      	ldr	r3, [r7, #4]
340021dc:	689b      	ldr	r3, [r3, #8]
340021de:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
340021e2:	f043 0220 	orr.w	r2, r3, #32
340021e6:	687b      	ldr	r3, [r7, #4]
340021e8:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_JADSTP);
}
340021ea:	bf00      	nop
340021ec:	370c      	adds	r7, #12
340021ee:	46bd      	mov	sp, r7
340021f0:	f85d 7b04 	ldr.w	r7, [sp], #4
340021f4:	4770      	bx	lr

340021f6 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
340021f6:	b480      	push	{r7}
340021f8:	b083      	sub	sp, #12
340021fa:	af00      	add	r7, sp, #0
340021fc:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
340021fe:	687b      	ldr	r3, [r7, #4]
34002200:	689b      	ldr	r3, [r3, #8]
34002202:	f003 0308 	and.w	r3, r3, #8
34002206:	2b08      	cmp	r3, #8
34002208:	d101      	bne.n	3400220e <LL_ADC_INJ_IsConversionOngoing+0x18>
3400220a:	2301      	movs	r3, #1
3400220c:	e000      	b.n	34002210 <LL_ADC_INJ_IsConversionOngoing+0x1a>
3400220e:	2300      	movs	r3, #0
}
34002210:	4618      	mov	r0, r3
34002212:	370c      	adds	r7, #12
34002214:	46bd      	mov	sp, r7
34002216:	f85d 7b04 	ldr.w	r7, [sp], #4
3400221a:	4770      	bx	lr

3400221c <LL_ADC_ClearFlag_AWD1>:
  * @rmtoll ISR      AWD1           LL_ADC_ClearFlag_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx)
{
3400221c:	b480      	push	{r7}
3400221e:	b083      	sub	sp, #12
34002220:	af00      	add	r7, sp, #0
34002222:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD1);
34002224:	687b      	ldr	r3, [r7, #4]
34002226:	2280      	movs	r2, #128	@ 0x80
34002228:	601a      	str	r2, [r3, #0]
}
3400222a:	bf00      	nop
3400222c:	370c      	adds	r7, #12
3400222e:	46bd      	mov	sp, r7
34002230:	f85d 7b04 	ldr.w	r7, [sp], #4
34002234:	4770      	bx	lr

34002236 <LL_ADC_ClearFlag_AWD2>:
  * @rmtoll ISR      AWD2           LL_ADC_ClearFlag_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD2(ADC_TypeDef *ADCx)
{
34002236:	b480      	push	{r7}
34002238:	b083      	sub	sp, #12
3400223a:	af00      	add	r7, sp, #0
3400223c:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD2);
3400223e:	687b      	ldr	r3, [r7, #4]
34002240:	f44f 7280 	mov.w	r2, #256	@ 0x100
34002244:	601a      	str	r2, [r3, #0]
}
34002246:	bf00      	nop
34002248:	370c      	adds	r7, #12
3400224a:	46bd      	mov	sp, r7
3400224c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002250:	4770      	bx	lr

34002252 <LL_ADC_ClearFlag_AWD3>:
  * @rmtoll ISR      AWD3           LL_ADC_ClearFlag_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD3(ADC_TypeDef *ADCx)
{
34002252:	b480      	push	{r7}
34002254:	b083      	sub	sp, #12
34002256:	af00      	add	r7, sp, #0
34002258:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD3);
3400225a:	687b      	ldr	r3, [r7, #4]
3400225c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002260:	601a      	str	r2, [r3, #0]
}
34002262:	bf00      	nop
34002264:	370c      	adds	r7, #12
34002266:	46bd      	mov	sp, r7
34002268:	f85d 7b04 	ldr.w	r7, [sp], #4
3400226c:	4770      	bx	lr

3400226e <LL_ADC_EnableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_EnableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
{
3400226e:	b480      	push	{r7}
34002270:	b083      	sub	sp, #12
34002272:	af00      	add	r7, sp, #0
34002274:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
34002276:	687b      	ldr	r3, [r7, #4]
34002278:	685b      	ldr	r3, [r3, #4]
3400227a:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
3400227e:	687b      	ldr	r3, [r7, #4]
34002280:	605a      	str	r2, [r3, #4]
}
34002282:	bf00      	nop
34002284:	370c      	adds	r7, #12
34002286:	46bd      	mov	sp, r7
34002288:	f85d 7b04 	ldr.w	r7, [sp], #4
3400228c:	4770      	bx	lr

3400228e <LL_ADC_EnableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_EnableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
{
3400228e:	b480      	push	{r7}
34002290:	b083      	sub	sp, #12
34002292:	af00      	add	r7, sp, #0
34002294:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
34002296:	687b      	ldr	r3, [r7, #4]
34002298:	685b      	ldr	r3, [r3, #4]
3400229a:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
3400229e:	687b      	ldr	r3, [r7, #4]
340022a0:	605a      	str	r2, [r3, #4]
}
340022a2:	bf00      	nop
340022a4:	370c      	adds	r7, #12
340022a6:	46bd      	mov	sp, r7
340022a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340022ac:	4770      	bx	lr

340022ae <LL_ADC_EnableIT_AWD3>:
  * @rmtoll IER      AWD3IE         LL_ADC_EnableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD3(ADC_TypeDef *ADCx)
{
340022ae:	b480      	push	{r7}
340022b0:	b083      	sub	sp, #12
340022b2:	af00      	add	r7, sp, #0
340022b4:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD3);
340022b6:	687b      	ldr	r3, [r7, #4]
340022b8:	685b      	ldr	r3, [r3, #4]
340022ba:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
340022be:	687b      	ldr	r3, [r7, #4]
340022c0:	605a      	str	r2, [r3, #4]
}
340022c2:	bf00      	nop
340022c4:	370c      	adds	r7, #12
340022c6:	46bd      	mov	sp, r7
340022c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340022cc:	4770      	bx	lr

340022ce <LL_ADC_DisableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_DisableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
{
340022ce:	b480      	push	{r7}
340022d0:	b083      	sub	sp, #12
340022d2:	af00      	add	r7, sp, #0
340022d4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
340022d6:	687b      	ldr	r3, [r7, #4]
340022d8:	685b      	ldr	r3, [r3, #4]
340022da:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
340022de:	687b      	ldr	r3, [r7, #4]
340022e0:	605a      	str	r2, [r3, #4]
}
340022e2:	bf00      	nop
340022e4:	370c      	adds	r7, #12
340022e6:	46bd      	mov	sp, r7
340022e8:	f85d 7b04 	ldr.w	r7, [sp], #4
340022ec:	4770      	bx	lr

340022ee <LL_ADC_DisableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_DisableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
{
340022ee:	b480      	push	{r7}
340022f0:	b083      	sub	sp, #12
340022f2:	af00      	add	r7, sp, #0
340022f4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
340022f6:	687b      	ldr	r3, [r7, #4]
340022f8:	685b      	ldr	r3, [r3, #4]
340022fa:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
340022fe:	687b      	ldr	r3, [r7, #4]
34002300:	605a      	str	r2, [r3, #4]
}
34002302:	bf00      	nop
34002304:	370c      	adds	r7, #12
34002306:	46bd      	mov	sp, r7
34002308:	f85d 7b04 	ldr.w	r7, [sp], #4
3400230c:	4770      	bx	lr

3400230e <LL_ADC_DisableIT_AWD3>:
  * @rmtoll IER      AWD3IE         LL_ADC_DisableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
{
3400230e:	b480      	push	{r7}
34002310:	b083      	sub	sp, #12
34002312:	af00      	add	r7, sp, #0
34002314:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD3);
34002316:	687b      	ldr	r3, [r7, #4]
34002318:	685b      	ldr	r3, [r3, #4]
3400231a:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400231e:	687b      	ldr	r3, [r7, #4]
34002320:	605a      	str	r2, [r3, #4]
}
34002322:	bf00      	nop
34002324:	370c      	adds	r7, #12
34002326:	46bd      	mov	sp, r7
34002328:	f85d 7b04 	ldr.w	r7, [sp], #4
3400232c:	4770      	bx	lr
	...

34002330 <HAL_ADC_Init>:
  *         without disabling the other ADCs sharing the same ADC common instance.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
34002330:	b580      	push	{r7, lr}
34002332:	b088      	sub	sp, #32
34002334:	af00      	add	r7, sp, #0
34002336:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34002338:	2300      	movs	r3, #0
3400233a:	77fb      	strb	r3, [r7, #31]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
3400233c:	687b      	ldr	r3, [r7, #4]
3400233e:	2b00      	cmp	r3, #0
34002340:	d101      	bne.n	34002346 <HAL_ADC_Init+0x16>
  {
    return HAL_ERROR;
34002342:	2301      	movs	r3, #1
34002344:	e108      	b.n	34002558 <HAL_ADC_Init+0x228>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
34002346:	687b      	ldr	r3, [r7, #4]
34002348:	68db      	ldr	r3, [r3, #12]
3400234a:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
3400234c:	687b      	ldr	r3, [r7, #4]
3400234e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002350:	2b00      	cmp	r3, #0
34002352:	d109      	bne.n	34002368 <HAL_ADC_Init+0x38>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
34002354:	6878      	ldr	r0, [r7, #4]
34002356:	f7fe fe5b 	bl	34001010 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
3400235a:	687b      	ldr	r3, [r7, #4]
3400235c:	2200      	movs	r2, #0
3400235e:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
34002360:	687b      	ldr	r3, [r7, #4]
34002362:	2200      	movs	r2, #0
34002364:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  }

  /* ADC must be disabled to set configuration bits                            */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34002368:	687b      	ldr	r3, [r7, #4]
3400236a:	681b      	ldr	r3, [r3, #0]
3400236c:	4618      	mov	r0, r3
3400236e:	f7ff fed3 	bl	34002118 <LL_ADC_IsEnabled>
34002372:	4603      	mov	r3, r0
34002374:	2b00      	cmp	r3, #0
34002376:	d001      	beq.n	3400237c <HAL_ADC_Init+0x4c>
  {
    return HAL_ERROR;
34002378:	2301      	movs	r3, #1
3400237a:	e0ed      	b.n	34002558 <HAL_ADC_Init+0x228>
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
3400237c:	687b      	ldr	r3, [r7, #4]
3400237e:	681b      	ldr	r3, [r3, #0]
34002380:	4618      	mov	r0, r3
34002382:	f7ff fe91 	bl	340020a8 <LL_ADC_IsDeepPowerDownEnabled>
34002386:	4603      	mov	r3, r0
34002388:	2b00      	cmp	r3, #0
3400238a:	d004      	beq.n	34002396 <HAL_ADC_Init+0x66>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
3400238c:	687b      	ldr	r3, [r7, #4]
3400238e:	681b      	ldr	r3, [r3, #0]
34002390:	4618      	mov	r0, r3
34002392:	f7ff fe77 	bl	34002084 <LL_ADC_DisableDeepPowerDown>
  }
  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34002396:	687b      	ldr	r3, [r7, #4]
34002398:	681b      	ldr	r3, [r3, #0]
3400239a:	4618      	mov	r0, r3
3400239c:	f7ff ff06 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
340023a0:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
340023a2:	687b      	ldr	r3, [r7, #4]
340023a4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340023a6:	f003 0310 	and.w	r3, r3, #16
340023aa:	2b00      	cmp	r3, #0
340023ac:	f040 80cb 	bne.w	34002546 <HAL_ADC_Init+0x216>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
340023b0:	697b      	ldr	r3, [r7, #20]
340023b2:	2b00      	cmp	r3, #0
340023b4:	f040 80c7 	bne.w	34002546 <HAL_ADC_Init+0x216>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
340023b8:	687b      	ldr	r3, [r7, #4]
340023ba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340023bc:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
340023c0:	f043 0202 	orr.w	r2, r3, #2
340023c4:	687b      	ldr	r3, [r7, #4]
340023c6:	659a      	str	r2, [r3, #88]	@ 0x58
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */

    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
340023c8:	687b      	ldr	r3, [r7, #4]
340023ca:	7d5b      	ldrb	r3, [r3, #21]
340023cc:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                    |
340023ce:	687b      	ldr	r3, [r7, #4]
340023d0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
340023d2:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                 |
340023d4:	687b      	ldr	r3, [r7, #4]
340023d6:	685b      	ldr	r3, [r3, #4]
                hadc->Init.Overrun                                                    |
340023d8:	431a      	orrs	r2, r3
                ADC_CFGR1_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
340023da:	687b      	ldr	r3, [r7, #4]
340023dc:	7f1b      	ldrb	r3, [r3, #28]
340023de:	041b      	lsls	r3, r3, #16
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
340023e0:	4313      	orrs	r3, r2
340023e2:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
340023e4:	687b      	ldr	r3, [r7, #4]
340023e6:	7f1b      	ldrb	r3, [r3, #28]
340023e8:	2b01      	cmp	r3, #1
340023ea:	d106      	bne.n	340023fa <HAL_ADC_Init+0xca>
    {
      tmpCFGR1 |= ADC_CFGR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
340023ec:	687b      	ldr	r3, [r7, #4]
340023ee:	6a1b      	ldr	r3, [r3, #32]
340023f0:	3b01      	subs	r3, #1
340023f2:	045b      	lsls	r3, r3, #17
340023f4:	69ba      	ldr	r2, [r7, #24]
340023f6:	4313      	orrs	r3, r2
340023f8:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
340023fa:	687b      	ldr	r3, [r7, #4]
340023fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340023fe:	2b00      	cmp	r3, #0
34002400:	d009      	beq.n	34002416 <HAL_ADC_Init+0xe6>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34002402:	687b      	ldr	r3, [r7, #4]
34002404:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34002406:	f403 7278 	and.w	r2, r3, #992	@ 0x3e0
                   | hadc->Init.ExternalTrigConvEdge
3400240a:	687b      	ldr	r3, [r7, #4]
3400240c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400240e:	4313      	orrs	r3, r2
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34002410:	69ba      	ldr	r2, [r7, #24]
34002412:	4313      	orrs	r3, r2
34002414:	61bb      	str	r3, [r7, #24]
                  );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_1, tmpCFGR1);
34002416:	687b      	ldr	r3, [r7, #4]
34002418:	681b      	ldr	r3, [r3, #0]
3400241a:	68da      	ldr	r2, [r3, #12]
3400241c:	4b50      	ldr	r3, [pc, #320]	@ (34002560 <HAL_ADC_Init+0x230>)
3400241e:	4013      	ands	r3, r2
34002420:	687a      	ldr	r2, [r7, #4]
34002422:	6812      	ldr	r2, [r2, #0]
34002424:	69b9      	ldr	r1, [r7, #24]
34002426:	430b      	orrs	r3, r1
34002428:	60d3      	str	r3, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
3400242a:	687b      	ldr	r3, [r7, #4]
3400242c:	681b      	ldr	r3, [r3, #0]
3400242e:	691b      	ldr	r3, [r3, #16]
34002430:	f423 4120 	bic.w	r1, r3, #40960	@ 0xa000
34002434:	687b      	ldr	r3, [r7, #4]
34002436:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002438:	687b      	ldr	r3, [r7, #4]
3400243a:	681b      	ldr	r3, [r3, #0]
3400243c:	430a      	orrs	r2, r1
3400243e:	611a      	str	r2, [r3, #16]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34002440:	687b      	ldr	r3, [r7, #4]
34002442:	681b      	ldr	r3, [r3, #0]
34002444:	4618      	mov	r0, r3
34002446:	f7ff feb1 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
3400244a:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
3400244c:	687b      	ldr	r3, [r7, #4]
3400244e:	681b      	ldr	r3, [r3, #0]
34002450:	4618      	mov	r0, r3
34002452:	f7ff fed0 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
34002456:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34002458:	693b      	ldr	r3, [r7, #16]
3400245a:	2b00      	cmp	r3, #0
3400245c:	d151      	bne.n	34002502 <HAL_ADC_Init+0x1d2>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
3400245e:	68fb      	ldr	r3, [r7, #12]
34002460:	2b00      	cmp	r3, #0
34002462:	d14e      	bne.n	34002502 <HAL_ADC_Init+0x1d2>
       )
    {
      tmpCFGR1 = (
                   ADC_CFGR1_AUTODELAY((uint32_t)hadc->Init.LowPowerAutoWait)        |
34002464:	687b      	ldr	r3, [r7, #4]
34002466:	7d1b      	ldrb	r3, [r3, #20]
34002468:	039a      	lsls	r2, r3, #14
                   ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
3400246a:	687b      	ldr	r3, [r7, #4]
3400246c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      tmpCFGR1 = (
3400246e:	4313      	orrs	r3, r2
34002470:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_2, tmpCFGR1);
34002472:	687b      	ldr	r3, [r7, #4]
34002474:	681b      	ldr	r3, [r3, #0]
34002476:	68db      	ldr	r3, [r3, #12]
34002478:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
3400247c:	f023 0303 	bic.w	r3, r3, #3
34002480:	687a      	ldr	r2, [r7, #4]
34002482:	6812      	ldr	r2, [r2, #0]
34002484:	69b9      	ldr	r1, [r7, #24]
34002486:	430b      	orrs	r3, r1
34002488:	60d3      	str	r3, [r2, #12]

      LL_ADC_SetGainCompensation(hadc->Instance, hadc->Init.GainCompensation);
3400248a:	687b      	ldr	r3, [r7, #4]
3400248c:	681a      	ldr	r2, [r3, #0]
3400248e:	687b      	ldr	r3, [r7, #4]
34002490:	689b      	ldr	r3, [r3, #8]
34002492:	4619      	mov	r1, r3
34002494:	4610      	mov	r0, r2
34002496:	f7ff fb57 	bl	34001b48 <LL_ADC_SetGainCompensation>

      if (hadc->Init.OversamplingMode == ENABLE)
3400249a:	687b      	ldr	r3, [r7, #4]
3400249c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
340024a0:	2b01      	cmp	r3, #1
340024a2:	d11b      	bne.n	340024dc <HAL_ADC_Init+0x1ac>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
340024a4:	687b      	ldr	r3, [r7, #4]
340024a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340024a8:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
340024aa:	687b      	ldr	r3, [r7, #4]
340024ac:	681b      	ldr	r3, [r3, #0]
340024ae:	691a      	ldr	r2, [r3, #16]
340024b0:	4b2c      	ldr	r3, [pc, #176]	@ (34002564 <HAL_ADC_Init+0x234>)
340024b2:	4013      	ands	r3, r2
340024b4:	687a      	ldr	r2, [r7, #4]
340024b6:	6c12      	ldr	r2, [r2, #64]	@ 0x40
340024b8:	3a01      	subs	r2, #1
340024ba:	0411      	lsls	r1, r2, #16
340024bc:	687a      	ldr	r2, [r7, #4]
340024be:	6c52      	ldr	r2, [r2, #68]	@ 0x44
340024c0:	4311      	orrs	r1, r2
340024c2:	687a      	ldr	r2, [r7, #4]
340024c4:	6c92      	ldr	r2, [r2, #72]	@ 0x48
340024c6:	4311      	orrs	r1, r2
340024c8:	687a      	ldr	r2, [r7, #4]
340024ca:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
340024cc:	430a      	orrs	r2, r1
340024ce:	431a      	orrs	r2, r3
340024d0:	687b      	ldr	r3, [r7, #4]
340024d2:	681b      	ldr	r3, [r3, #0]
340024d4:	f042 0201 	orr.w	r2, r2, #1
340024d8:	611a      	str	r2, [r3, #16]
340024da:	e007      	b.n	340024ec <HAL_ADC_Init+0x1bc>

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
340024dc:	687b      	ldr	r3, [r7, #4]
340024de:	681b      	ldr	r3, [r3, #0]
340024e0:	691a      	ldr	r2, [r3, #16]
340024e2:	687b      	ldr	r3, [r7, #4]
340024e4:	681b      	ldr	r3, [r3, #0]
340024e6:	f022 0201 	bic.w	r2, r2, #1
340024ea:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
340024ec:	687b      	ldr	r3, [r7, #4]
340024ee:	681b      	ldr	r3, [r3, #0]
340024f0:	691b      	ldr	r3, [r3, #16]
340024f2:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
340024f6:	687b      	ldr	r3, [r7, #4]
340024f8:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340024fa:	687b      	ldr	r3, [r7, #4]
340024fc:	681b      	ldr	r3, [r3, #0]
340024fe:	430a      	orrs	r2, r1
34002500:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
34002502:	687b      	ldr	r3, [r7, #4]
34002504:	68db      	ldr	r3, [r3, #12]
34002506:	2b01      	cmp	r3, #1
34002508:	d10c      	bne.n	34002524 <HAL_ADC_Init+0x1f4>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
3400250a:	687b      	ldr	r3, [r7, #4]
3400250c:	681b      	ldr	r3, [r3, #0]
3400250e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34002510:	f023 010f 	bic.w	r1, r3, #15
34002514:	687b      	ldr	r3, [r7, #4]
34002516:	699b      	ldr	r3, [r3, #24]
34002518:	1e5a      	subs	r2, r3, #1
3400251a:	687b      	ldr	r3, [r7, #4]
3400251c:	681b      	ldr	r3, [r3, #0]
3400251e:	430a      	orrs	r2, r1
34002520:	631a      	str	r2, [r3, #48]	@ 0x30
34002522:	e007      	b.n	34002534 <HAL_ADC_Init+0x204>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
34002524:	687b      	ldr	r3, [r7, #4]
34002526:	681b      	ldr	r3, [r3, #0]
34002528:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400252a:	687b      	ldr	r3, [r7, #4]
3400252c:	681b      	ldr	r3, [r3, #0]
3400252e:	f022 020f 	bic.w	r2, r2, #15
34002532:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
34002534:	687b      	ldr	r3, [r7, #4]
34002536:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002538:	f023 0303 	bic.w	r3, r3, #3
3400253c:	f043 0201 	orr.w	r2, r3, #1
34002540:	687b      	ldr	r3, [r7, #4]
34002542:	659a      	str	r2, [r3, #88]	@ 0x58
34002544:	e007      	b.n	34002556 <HAL_ADC_Init+0x226>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34002546:	687b      	ldr	r3, [r7, #4]
34002548:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400254a:	f043 0210 	orr.w	r2, r3, #16
3400254e:	687b      	ldr	r3, [r7, #4]
34002550:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34002552:	2301      	movs	r3, #1
34002554:	77fb      	strb	r3, [r7, #31]
  }

  return tmp_hal_status;
34002556:	7ffb      	ldrb	r3, [r7, #31]
}
34002558:	4618      	mov	r0, r3
3400255a:	3720      	adds	r7, #32
3400255c:	46bd      	mov	sp, r7
3400255e:	bd80      	pop	{r7, pc}
34002560:	fff0c013 	.word	0xfff0c013
34002564:	fc00f81e 	.word	0xfc00f81e

34002568 <HAL_ADC_Start_IT>:
  *          before calling HAL_ADC_Start_IT().
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef *hadc)
{
34002568:	b580      	push	{r7, lr}
3400256a:	b086      	sub	sp, #24
3400256c:	af00      	add	r7, sp, #0
3400256e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34002570:	4891      	ldr	r0, [pc, #580]	@ (340027b8 <HAL_ADC_Start_IT+0x250>)
34002572:	f7ff fd6b 	bl	3400204c <LL_ADC_GetMultimode>
34002576:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
34002578:	687b      	ldr	r3, [r7, #4]
3400257a:	681b      	ldr	r3, [r3, #0]
3400257c:	4618      	mov	r0, r3
3400257e:	f7ff fe15 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
34002582:	4603      	mov	r3, r0
34002584:	2b00      	cmp	r3, #0
34002586:	f040 8110 	bne.w	340027aa <HAL_ADC_Start_IT+0x242>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
3400258a:	687b      	ldr	r3, [r7, #4]
3400258c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34002590:	2b01      	cmp	r3, #1
34002592:	d101      	bne.n	34002598 <HAL_ADC_Start_IT+0x30>
34002594:	2302      	movs	r3, #2
34002596:	e10b      	b.n	340027b0 <HAL_ADC_Start_IT+0x248>
34002598:	687b      	ldr	r3, [r7, #4]
3400259a:	2201      	movs	r2, #1
3400259c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Enable the ADC peripheral */
    tmp_hal_status = ADC_Enable(hadc);
340025a0:	6878      	ldr	r0, [r7, #4]
340025a2:	f001 f82b 	bl	340035fc <ADC_Enable>
340025a6:	4603      	mov	r3, r0
340025a8:	75fb      	strb	r3, [r7, #23]

    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
340025aa:	7dfb      	ldrb	r3, [r7, #23]
340025ac:	2b00      	cmp	r3, #0
340025ae:	f040 80f7 	bne.w	340027a0 <HAL_ADC_Start_IT+0x238>
    {
      /* Set ADC state                                                        */
      /* - Clear state bitfield related to regular group conversion results   */
      /* - Set state bitfield related to regular operation                    */
      ADC_STATE_CLR_SET(hadc->State,
340025b2:	687b      	ldr	r3, [r7, #4]
340025b4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340025b6:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
340025ba:	f023 0301 	bic.w	r3, r3, #1
340025be:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
340025c2:	687b      	ldr	r3, [r7, #4]
340025c4:	659a      	str	r2, [r3, #88]	@ 0x58

#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
340025c6:	687b      	ldr	r3, [r7, #4]
340025c8:	681b      	ldr	r3, [r3, #0]
340025ca:	4a7c      	ldr	r2, [pc, #496]	@ (340027bc <HAL_ADC_Start_IT+0x254>)
340025cc:	4293      	cmp	r3, r2
340025ce:	d002      	beq.n	340025d6 <HAL_ADC_Start_IT+0x6e>
340025d0:	687b      	ldr	r3, [r7, #4]
340025d2:	681b      	ldr	r3, [r3, #0]
340025d4:	e000      	b.n	340025d8 <HAL_ADC_Start_IT+0x70>
340025d6:	4b7a      	ldr	r3, [pc, #488]	@ (340027c0 <HAL_ADC_Start_IT+0x258>)
340025d8:	687a      	ldr	r2, [r7, #4]
340025da:	6812      	ldr	r2, [r2, #0]
340025dc:	4293      	cmp	r3, r2
340025de:	d002      	beq.n	340025e6 <HAL_ADC_Start_IT+0x7e>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
340025e0:	693b      	ldr	r3, [r7, #16]
340025e2:	2b00      	cmp	r3, #0
340025e4:	d105      	bne.n	340025f2 <HAL_ADC_Start_IT+0x8a>
         )
      {
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
340025e6:	687b      	ldr	r3, [r7, #4]
340025e8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340025ea:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
340025ee:	687b      	ldr	r3, [r7, #4]
340025f0:	659a      	str	r2, [r3, #88]	@ 0x58
      }
#endif /* ADC_MULTIMODE_SUPPORT */

      /* Set ADC error code */
      /* Check if a conversion is on going on ADC group injected */
      if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
340025f2:	687b      	ldr	r3, [r7, #4]
340025f4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340025f6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340025fa:	2b00      	cmp	r3, #0
340025fc:	d006      	beq.n	3400260c <HAL_ADC_Start_IT+0xa4>
      {
        /* Reset ADC error code fields related to regular conversions only */
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
340025fe:	687b      	ldr	r3, [r7, #4]
34002600:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34002602:	f023 0206 	bic.w	r2, r3, #6
34002606:	687b      	ldr	r3, [r7, #4]
34002608:	65da      	str	r2, [r3, #92]	@ 0x5c
3400260a:	e002      	b.n	34002612 <HAL_ADC_Start_IT+0xaa>
      }
      else
      {
        /* Reset all ADC error code fields */
        ADC_CLEAR_ERRORCODE(hadc);
3400260c:	687b      	ldr	r3, [r7, #4]
3400260e:	2200      	movs	r2, #0
34002610:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Clear ADC group regular conversion flag and overrun flag               */
      /* (To ensure of no unknown state from potential previous ADC operations) */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
34002612:	687b      	ldr	r3, [r7, #4]
34002614:	681b      	ldr	r3, [r3, #0]
34002616:	221c      	movs	r2, #28
34002618:	601a      	str	r2, [r3, #0]

      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
3400261a:	687b      	ldr	r3, [r7, #4]
3400261c:	2200      	movs	r2, #0
3400261e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

      /* Disable all interruptions before enabling the desired ones */
      __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
34002622:	687b      	ldr	r3, [r7, #4]
34002624:	681b      	ldr	r3, [r3, #0]
34002626:	685a      	ldr	r2, [r3, #4]
34002628:	687b      	ldr	r3, [r7, #4]
3400262a:	681b      	ldr	r3, [r3, #0]
3400262c:	f022 021c 	bic.w	r2, r2, #28
34002630:	605a      	str	r2, [r3, #4]

      /* Enable ADC end of conversion interrupt */
      switch (hadc->Init.EOCSelection)
34002632:	687b      	ldr	r3, [r7, #4]
34002634:	691b      	ldr	r3, [r3, #16]
34002636:	2b08      	cmp	r3, #8
34002638:	d108      	bne.n	3400264c <HAL_ADC_Start_IT+0xe4>
      {
        case ADC_EOC_SEQ_CONV:
          __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOS);
3400263a:	687b      	ldr	r3, [r7, #4]
3400263c:	681b      	ldr	r3, [r3, #0]
3400263e:	685a      	ldr	r2, [r3, #4]
34002640:	687b      	ldr	r3, [r7, #4]
34002642:	681b      	ldr	r3, [r3, #0]
34002644:	f042 0208 	orr.w	r2, r2, #8
34002648:	605a      	str	r2, [r3, #4]
          break;
3400264a:	e008      	b.n	3400265e <HAL_ADC_Start_IT+0xf6>
        /* case ADC_EOC_SINGLE_CONV */
        default:
          __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
3400264c:	687b      	ldr	r3, [r7, #4]
3400264e:	681b      	ldr	r3, [r3, #0]
34002650:	685a      	ldr	r2, [r3, #4]
34002652:	687b      	ldr	r3, [r7, #4]
34002654:	681b      	ldr	r3, [r3, #0]
34002656:	f042 0204 	orr.w	r2, r2, #4
3400265a:	605a      	str	r2, [r3, #4]
          break;
3400265c:	bf00      	nop

      /* Enable ADC overrun interrupt */
      /* If hadc->Init.Overrun is set to ADC_OVR_DATA_PRESERVED, only then is
         ADC_IT_OVR enabled; otherwise data overwrite is considered as normal
         behavior and no CPU time is lost for a non-processed interruption */
      if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
3400265e:	687b      	ldr	r3, [r7, #4]
34002660:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34002662:	2b00      	cmp	r3, #0
34002664:	d107      	bne.n	34002676 <HAL_ADC_Start_IT+0x10e>
      {
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
34002666:	687b      	ldr	r3, [r7, #4]
34002668:	681b      	ldr	r3, [r3, #0]
3400266a:	685a      	ldr	r2, [r3, #4]
3400266c:	687b      	ldr	r3, [r7, #4]
3400266e:	681b      	ldr	r3, [r3, #0]
34002670:	f042 0210 	orr.w	r2, r2, #16
34002674:	605a      	str	r2, [r3, #4]
      /* Case of multimode enabled (when multimode feature is available):     */
      /*  - if ADC is slave and dual regular conversions are enabled, ADC is  */
      /*    enabled only (conversion is not started),                         */
      /*  - if ADC is master, ADC is enabled and conversion is started.       */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34002676:	687b      	ldr	r3, [r7, #4]
34002678:	681b      	ldr	r3, [r3, #0]
3400267a:	4a50      	ldr	r2, [pc, #320]	@ (340027bc <HAL_ADC_Start_IT+0x254>)
3400267c:	4293      	cmp	r3, r2
3400267e:	d002      	beq.n	34002686 <HAL_ADC_Start_IT+0x11e>
34002680:	687b      	ldr	r3, [r7, #4]
34002682:	681b      	ldr	r3, [r3, #0]
34002684:	e000      	b.n	34002688 <HAL_ADC_Start_IT+0x120>
34002686:	4b4e      	ldr	r3, [pc, #312]	@ (340027c0 <HAL_ADC_Start_IT+0x258>)
34002688:	687a      	ldr	r2, [r7, #4]
3400268a:	6812      	ldr	r2, [r2, #0]
3400268c:	4293      	cmp	r3, r2
3400268e:	d008      	beq.n	340026a2 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
34002690:	693b      	ldr	r3, [r7, #16]
34002692:	2b00      	cmp	r3, #0
34002694:	d005      	beq.n	340026a2 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
34002696:	693b      	ldr	r3, [r7, #16]
34002698:	2b05      	cmp	r3, #5
3400269a:	d002      	beq.n	340026a2 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
3400269c:	693b      	ldr	r3, [r7, #16]
3400269e:	2b09      	cmp	r3, #9
340026a0:	d13a      	bne.n	34002718 <HAL_ADC_Start_IT+0x1b0>
         )
      {
        /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
        if (READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
340026a2:	687b      	ldr	r3, [r7, #4]
340026a4:	681b      	ldr	r3, [r3, #0]
340026a6:	68db      	ldr	r3, [r3, #12]
340026a8:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
340026ac:	2b00      	cmp	r3, #0
340026ae:	d02d      	beq.n	3400270c <HAL_ADC_Start_IT+0x1a4>
        {
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
340026b0:	687b      	ldr	r3, [r7, #4]
340026b2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340026b4:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
340026b8:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
340026bc:	687b      	ldr	r3, [r7, #4]
340026be:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Enable as well injected interruptions in case
           HAL_ADCEx_InjectedStart_IT() has not been called beforehand. This
           allows to start regular and injected conversions when JAUTO is
           set with a single call to HAL_ADC_Start_IT() */
          switch (hadc->Init.EOCSelection)
340026c0:	687b      	ldr	r3, [r7, #4]
340026c2:	691b      	ldr	r3, [r3, #16]
340026c4:	2b08      	cmp	r3, #8
340026c6:	d110      	bne.n	340026ea <HAL_ADC_Start_IT+0x182>
          {
            case ADC_EOC_SEQ_CONV:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
340026c8:	687b      	ldr	r3, [r7, #4]
340026ca:	681b      	ldr	r3, [r3, #0]
340026cc:	685a      	ldr	r2, [r3, #4]
340026ce:	687b      	ldr	r3, [r7, #4]
340026d0:	681b      	ldr	r3, [r3, #0]
340026d2:	f022 0220 	bic.w	r2, r2, #32
340026d6:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
340026d8:	687b      	ldr	r3, [r7, #4]
340026da:	681b      	ldr	r3, [r3, #0]
340026dc:	685a      	ldr	r2, [r3, #4]
340026de:	687b      	ldr	r3, [r7, #4]
340026e0:	681b      	ldr	r3, [r3, #0]
340026e2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
340026e6:	605a      	str	r2, [r3, #4]
              break;
340026e8:	e010      	b.n	3400270c <HAL_ADC_Start_IT+0x1a4>
            /* case ADC_EOC_SINGLE_CONV */
            default:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
340026ea:	687b      	ldr	r3, [r7, #4]
340026ec:	681b      	ldr	r3, [r3, #0]
340026ee:	685a      	ldr	r2, [r3, #4]
340026f0:	687b      	ldr	r3, [r7, #4]
340026f2:	681b      	ldr	r3, [r3, #0]
340026f4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
340026f8:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
340026fa:	687b      	ldr	r3, [r7, #4]
340026fc:	681b      	ldr	r3, [r3, #0]
340026fe:	685a      	ldr	r2, [r3, #4]
34002700:	687b      	ldr	r3, [r7, #4]
34002702:	681b      	ldr	r3, [r3, #0]
34002704:	f042 0220 	orr.w	r2, r2, #32
34002708:	605a      	str	r2, [r3, #4]
              break;
3400270a:	bf00      	nop
          }
        }

        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
3400270c:	687b      	ldr	r3, [r7, #4]
3400270e:	681b      	ldr	r3, [r3, #0]
34002710:	4618      	mov	r0, r3
34002712:	f7ff fd27 	bl	34002164 <LL_ADC_REG_StartConversion>
34002716:	e04a      	b.n	340027ae <HAL_ADC_Start_IT+0x246>
      }
      else
      {
        /* ADC instance is a multimode slave instance with multimode regular conversions enabled */
        SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
34002718:	687b      	ldr	r3, [r7, #4]
3400271a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400271c:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
34002720:	687b      	ldr	r3, [r7, #4]
34002722:	659a      	str	r2, [r3, #88]	@ 0x58
        /* if Master ADC JAUTO bit is set, Slave injected interruptions
           are enabled nevertheless (for same reason as above) */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
34002724:	687b      	ldr	r3, [r7, #4]
34002726:	681b      	ldr	r3, [r3, #0]
34002728:	4a24      	ldr	r2, [pc, #144]	@ (340027bc <HAL_ADC_Start_IT+0x254>)
3400272a:	4293      	cmp	r3, r2
3400272c:	d002      	beq.n	34002734 <HAL_ADC_Start_IT+0x1cc>
3400272e:	687b      	ldr	r3, [r7, #4]
34002730:	681b      	ldr	r3, [r3, #0]
34002732:	e000      	b.n	34002736 <HAL_ADC_Start_IT+0x1ce>
34002734:	4b22      	ldr	r3, [pc, #136]	@ (340027c0 <HAL_ADC_Start_IT+0x258>)
34002736:	60fb      	str	r3, [r7, #12]
        if (READ_BIT(tmpADC_Master->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
34002738:	68fb      	ldr	r3, [r7, #12]
3400273a:	68db      	ldr	r3, [r3, #12]
3400273c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34002740:	2b00      	cmp	r3, #0
34002742:	d034      	beq.n	340027ae <HAL_ADC_Start_IT+0x246>
        {
          /* First, update Slave State in setting HAL_ADC_STATE_INJ_BUSY bit
             and in resetting HAL_ADC_STATE_INJ_EOC bit */
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
34002744:	687b      	ldr	r3, [r7, #4]
34002746:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002748:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3400274c:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34002750:	687b      	ldr	r3, [r7, #4]
34002752:	659a      	str	r2, [r3, #88]	@ 0x58
          /* Next, set Slave injected interruptions */
          switch (hadc->Init.EOCSelection)
34002754:	687b      	ldr	r3, [r7, #4]
34002756:	691b      	ldr	r3, [r3, #16]
34002758:	2b08      	cmp	r3, #8
3400275a:	d110      	bne.n	3400277e <HAL_ADC_Start_IT+0x216>
          {
            case ADC_EOC_SEQ_CONV:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
3400275c:	687b      	ldr	r3, [r7, #4]
3400275e:	681b      	ldr	r3, [r3, #0]
34002760:	685a      	ldr	r2, [r3, #4]
34002762:	687b      	ldr	r3, [r7, #4]
34002764:	681b      	ldr	r3, [r3, #0]
34002766:	f022 0220 	bic.w	r2, r2, #32
3400276a:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
3400276c:	687b      	ldr	r3, [r7, #4]
3400276e:	681b      	ldr	r3, [r3, #0]
34002770:	685a      	ldr	r2, [r3, #4]
34002772:	687b      	ldr	r3, [r7, #4]
34002774:	681b      	ldr	r3, [r3, #0]
34002776:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
3400277a:	605a      	str	r2, [r3, #4]
              break;
3400277c:	e017      	b.n	340027ae <HAL_ADC_Start_IT+0x246>
            /* case ADC_EOC_SINGLE_CONV */
            default:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
3400277e:	687b      	ldr	r3, [r7, #4]
34002780:	681b      	ldr	r3, [r3, #0]
34002782:	685a      	ldr	r2, [r3, #4]
34002784:	687b      	ldr	r3, [r7, #4]
34002786:	681b      	ldr	r3, [r3, #0]
34002788:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
3400278c:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
3400278e:	687b      	ldr	r3, [r7, #4]
34002790:	681b      	ldr	r3, [r3, #0]
34002792:	685a      	ldr	r2, [r3, #4]
34002794:	687b      	ldr	r3, [r7, #4]
34002796:	681b      	ldr	r3, [r3, #0]
34002798:	f042 0220 	orr.w	r2, r2, #32
3400279c:	605a      	str	r2, [r3, #4]
              break;
3400279e:	e006      	b.n	340027ae <HAL_ADC_Start_IT+0x246>
      LL_ADC_REG_StartConversion(hadc->Instance);
#endif /* ADC_MULTIMODE_SUPPORT */
    }
    else
    {
      __HAL_UNLOCK(hadc);
340027a0:	687b      	ldr	r3, [r7, #4]
340027a2:	2200      	movs	r2, #0
340027a4:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
340027a8:	e001      	b.n	340027ae <HAL_ADC_Start_IT+0x246>
    }

  }
  else
  {
    tmp_hal_status = HAL_BUSY;
340027aa:	2302      	movs	r3, #2
340027ac:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
340027ae:	7dfb      	ldrb	r3, [r7, #23]
}
340027b0:	4618      	mov	r0, r3
340027b2:	3718      	adds	r7, #24
340027b4:	46bd      	mov	sp, r7
340027b6:	bd80      	pop	{r7, pc}
340027b8:	50022300 	.word	0x50022300
340027bc:	50022100 	.word	0x50022100
340027c0:	50022000 	.word	0x50022000

340027c4 <HAL_ADC_Stop_IT>:
  *         end-of-conversion, disable ADC peripheral.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef *hadc)
{
340027c4:	b580      	push	{r7, lr}
340027c6:	b084      	sub	sp, #16
340027c8:	af00      	add	r7, sp, #0
340027ca:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
340027cc:	687b      	ldr	r3, [r7, #4]
340027ce:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
340027d2:	2b01      	cmp	r3, #1
340027d4:	d101      	bne.n	340027da <HAL_ADC_Stop_IT+0x16>
340027d6:	2302      	movs	r3, #2
340027d8:	e02b      	b.n	34002832 <HAL_ADC_Stop_IT+0x6e>
340027da:	687b      	ldr	r3, [r7, #4]
340027dc:	2201      	movs	r2, #1
340027de:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* 1. Stop potential conversion on going, on ADC groups regular and injected */
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
340027e2:	2103      	movs	r1, #3
340027e4:	6878      	ldr	r0, [r7, #4]
340027e6:	f000 fe4d 	bl	34003484 <ADC_ConversionStop>
340027ea:	4603      	mov	r3, r0
340027ec:	73fb      	strb	r3, [r7, #15]

  /* Disable ADC peripheral if conversions are effectively stopped */
  if (tmp_hal_status == HAL_OK)
340027ee:	7bfb      	ldrb	r3, [r7, #15]
340027f0:	2b00      	cmp	r3, #0
340027f2:	d119      	bne.n	34002828 <HAL_ADC_Stop_IT+0x64>
  {
    /* Disable ADC end of conversion interrupt for regular group */
    /* Disable ADC overrun interrupt */
    __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
340027f4:	687b      	ldr	r3, [r7, #4]
340027f6:	681b      	ldr	r3, [r3, #0]
340027f8:	685a      	ldr	r2, [r3, #4]
340027fa:	687b      	ldr	r3, [r7, #4]
340027fc:	681b      	ldr	r3, [r3, #0]
340027fe:	f022 021c 	bic.w	r2, r2, #28
34002802:	605a      	str	r2, [r3, #4]

    /* 2. Disable the ADC peripheral */
    tmp_hal_status = ADC_Disable(hadc);
34002804:	6878      	ldr	r0, [r7, #4]
34002806:	f000 ff5b 	bl	340036c0 <ADC_Disable>
3400280a:	4603      	mov	r3, r0
3400280c:	73fb      	strb	r3, [r7, #15]

    /* Check if ADC is effectively disabled */
    if (tmp_hal_status == HAL_OK)
3400280e:	7bfb      	ldrb	r3, [r7, #15]
34002810:	2b00      	cmp	r3, #0
34002812:	d109      	bne.n	34002828 <HAL_ADC_Stop_IT+0x64>
    {
      /* Set ADC state */
      ADC_STATE_CLR_SET(hadc->State,
34002814:	687b      	ldr	r3, [r7, #4]
34002816:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002818:	f423 5388 	bic.w	r3, r3, #4352	@ 0x1100
3400281c:	f023 0301 	bic.w	r3, r3, #1
34002820:	f043 0201 	orr.w	r2, r3, #1
34002824:	687b      	ldr	r3, [r7, #4]
34002826:	659a      	str	r2, [r3, #88]	@ 0x58
                        HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                        HAL_ADC_STATE_READY);
    }
  }

  __HAL_UNLOCK(hadc);
34002828:	687b      	ldr	r3, [r7, #4]
3400282a:	2200      	movs	r2, #0
3400282c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34002830:	7bfb      	ldrb	r3, [r7, #15]
}
34002832:	4618      	mov	r0, r3
34002834:	3710      	adds	r7, #16
34002836:	46bd      	mov	sp, r7
34002838:	bd80      	pop	{r7, pc}

3400283a <HAL_ADC_GetValue>:
  *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
  * @param hadc ADC handle
  * @retval ADC group regular conversion data
  */
uint32_t HAL_ADC_GetValue(const ADC_HandleTypeDef *hadc)
{
3400283a:	b480      	push	{r7}
3400283c:	b083      	sub	sp, #12
3400283e:	af00      	add	r7, sp, #0
34002840:	6078      	str	r0, [r7, #4]

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
34002842:	687b      	ldr	r3, [r7, #4]
34002844:	681b      	ldr	r3, [r3, #0]
34002846:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
34002848:	4618      	mov	r0, r3
3400284a:	370c      	adds	r7, #12
3400284c:	46bd      	mov	sp, r7
3400284e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002852:	4770      	bx	lr

34002854 <HAL_ADC_IRQHandler>:
  * @brief  Handle ADC interrupt request.
  * @param hadc ADC handle
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc)
{
34002854:	b580      	push	{r7, lr}
34002856:	b08a      	sub	sp, #40	@ 0x28
34002858:	af00      	add	r7, sp, #0
3400285a:	6078      	str	r0, [r7, #4]
  uint32_t overrun_error = 0UL; /* flag set if overrun occurrence has to be considered as an error */
3400285c:	2300      	movs	r3, #0
3400285e:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t tmp_isr = hadc->Instance->ISR;
34002860:	687b      	ldr	r3, [r7, #4]
34002862:	681b      	ldr	r3, [r3, #0]
34002864:	681b      	ldr	r3, [r3, #0]
34002866:	61fb      	str	r3, [r7, #28]
  uint32_t tmp_ier = hadc->Instance->IER;
34002868:	687b      	ldr	r3, [r7, #4]
3400286a:	681b      	ldr	r3, [r3, #0]
3400286c:	685b      	ldr	r3, [r3, #4]
3400286e:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_inj_is_trigger_source_sw_start;
  uint32_t tmp_adc_reg_is_trigger_source_sw_start;
  uint32_t tmp_cfgr;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34002870:	4882      	ldr	r0, [pc, #520]	@ (34002a7c <HAL_ADC_IRQHandler+0x228>)
34002872:	f7ff fbeb 	bl	3400204c <LL_ADC_GetMultimode>
34002876:	6178      	str	r0, [r7, #20]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));

  /* ========== Check End of Sampling flag for ADC group regular ========== */
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
34002878:	69fb      	ldr	r3, [r7, #28]
3400287a:	f003 0302 	and.w	r3, r3, #2
3400287e:	2b00      	cmp	r3, #0
34002880:	d017      	beq.n	340028b2 <HAL_ADC_IRQHandler+0x5e>
34002882:	69bb      	ldr	r3, [r7, #24]
34002884:	f003 0302 	and.w	r3, r3, #2
34002888:	2b00      	cmp	r3, #0
3400288a:	d012      	beq.n	340028b2 <HAL_ADC_IRQHandler+0x5e>
  {
    /* Update state machine on end of sampling status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
3400288c:	687b      	ldr	r3, [r7, #4]
3400288e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002890:	f003 0310 	and.w	r3, r3, #16
34002894:	2b00      	cmp	r3, #0
34002896:	d105      	bne.n	340028a4 <HAL_ADC_IRQHandler+0x50>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
34002898:	687b      	ldr	r3, [r7, #4]
3400289a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400289c:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
340028a0:	687b      	ldr	r3, [r7, #4]
340028a2:	659a      	str	r2, [r3, #88]	@ 0x58

    /* End Of Sampling callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->EndOfSamplingCallback(hadc);
#else
    HAL_ADCEx_EndOfSamplingCallback(hadc);
340028a4:	6878      	ldr	r0, [r7, #4]
340028a6:	f000 ffae 	bl	34003806 <HAL_ADCEx_EndOfSamplingCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
340028aa:	687b      	ldr	r3, [r7, #4]
340028ac:	681b      	ldr	r3, [r3, #0]
340028ae:	2202      	movs	r2, #2
340028b0:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
340028b2:	69fb      	ldr	r3, [r7, #28]
340028b4:	f003 0304 	and.w	r3, r3, #4
340028b8:	2b00      	cmp	r3, #0
340028ba:	d004      	beq.n	340028c6 <HAL_ADC_IRQHandler+0x72>
340028bc:	69bb      	ldr	r3, [r7, #24]
340028be:	f003 0304 	and.w	r3, r3, #4
340028c2:	2b00      	cmp	r3, #0
340028c4:	d10a      	bne.n	340028dc <HAL_ADC_IRQHandler+0x88>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
340028c6:	69fb      	ldr	r3, [r7, #28]
340028c8:	f003 0308 	and.w	r3, r3, #8
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
340028cc:	2b00      	cmp	r3, #0
340028ce:	f000 8083 	beq.w	340029d8 <HAL_ADC_IRQHandler+0x184>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
340028d2:	69bb      	ldr	r3, [r7, #24]
340028d4:	f003 0308 	and.w	r3, r3, #8
340028d8:	2b00      	cmp	r3, #0
340028da:	d07d      	beq.n	340029d8 <HAL_ADC_IRQHandler+0x184>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
340028dc:	687b      	ldr	r3, [r7, #4]
340028de:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340028e0:	f003 0310 	and.w	r3, r3, #16
340028e4:	2b00      	cmp	r3, #0
340028e6:	d105      	bne.n	340028f4 <HAL_ADC_IRQHandler+0xa0>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
340028e8:	687b      	ldr	r3, [r7, #4]
340028ea:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340028ec:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
340028f0:	687b      	ldr	r3, [r7, #4]
340028f2:	659a      	str	r2, [r3, #88]	@ 0x58
    }

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
340028f4:	687b      	ldr	r3, [r7, #4]
340028f6:	681b      	ldr	r3, [r3, #0]
340028f8:	4618      	mov	r0, r3
340028fa:	f7ff f948 	bl	34001b8e <LL_ADC_REG_IsTriggerSourceSWStart>
340028fe:	4603      	mov	r3, r0
34002900:	2b00      	cmp	r3, #0
34002902:	d062      	beq.n	340029ca <HAL_ADC_IRQHandler+0x176>
    {
      /* Get relevant register CFGR in ADC instance of ADC master or slave    */
      /* in function of multimode state (for devices with multimode           */
      /* available).                                                          */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34002904:	687b      	ldr	r3, [r7, #4]
34002906:	681b      	ldr	r3, [r3, #0]
34002908:	4a5d      	ldr	r2, [pc, #372]	@ (34002a80 <HAL_ADC_IRQHandler+0x22c>)
3400290a:	4293      	cmp	r3, r2
3400290c:	d002      	beq.n	34002914 <HAL_ADC_IRQHandler+0xc0>
3400290e:	687b      	ldr	r3, [r7, #4]
34002910:	681b      	ldr	r3, [r3, #0]
34002912:	e000      	b.n	34002916 <HAL_ADC_IRQHandler+0xc2>
34002914:	4b5b      	ldr	r3, [pc, #364]	@ (34002a84 <HAL_ADC_IRQHandler+0x230>)
34002916:	687a      	ldr	r2, [r7, #4]
34002918:	6812      	ldr	r2, [r2, #0]
3400291a:	4293      	cmp	r3, r2
3400291c:	d008      	beq.n	34002930 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
3400291e:	697b      	ldr	r3, [r7, #20]
34002920:	2b00      	cmp	r3, #0
34002922:	d005      	beq.n	34002930 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
34002924:	697b      	ldr	r3, [r7, #20]
34002926:	2b05      	cmp	r3, #5
34002928:	d002      	beq.n	34002930 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
3400292a:	697b      	ldr	r3, [r7, #20]
3400292c:	2b09      	cmp	r3, #9
3400292e:	d104      	bne.n	3400293a <HAL_ADC_IRQHandler+0xe6>
         )
      {
        /* check CONT bit directly in handle ADC CFGR register */
        tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
34002930:	687b      	ldr	r3, [r7, #4]
34002932:	681b      	ldr	r3, [r3, #0]
34002934:	68db      	ldr	r3, [r3, #12]
34002936:	623b      	str	r3, [r7, #32]
34002938:	e00c      	b.n	34002954 <HAL_ADC_IRQHandler+0x100>
      }
      else
      {
        /* else need to check Master ADC CONT bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
3400293a:	687b      	ldr	r3, [r7, #4]
3400293c:	681b      	ldr	r3, [r3, #0]
3400293e:	4a50      	ldr	r2, [pc, #320]	@ (34002a80 <HAL_ADC_IRQHandler+0x22c>)
34002940:	4293      	cmp	r3, r2
34002942:	d002      	beq.n	3400294a <HAL_ADC_IRQHandler+0xf6>
34002944:	687b      	ldr	r3, [r7, #4]
34002946:	681b      	ldr	r3, [r3, #0]
34002948:	e000      	b.n	3400294c <HAL_ADC_IRQHandler+0xf8>
3400294a:	4b4e      	ldr	r3, [pc, #312]	@ (34002a84 <HAL_ADC_IRQHandler+0x230>)
3400294c:	613b      	str	r3, [r7, #16]
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR1);
3400294e:	693b      	ldr	r3, [r7, #16]
34002950:	68db      	ldr	r3, [r3, #12]
34002952:	623b      	str	r3, [r7, #32]
#else
      tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
#endif /* ADC_MULTIMODE_SUPPORT */

      /* Carry on if continuous mode is disabled */
      if (READ_BIT(tmp_cfgr, ADC_CFGR1_CONT) != ADC_CFGR1_CONT)
34002954:	6a3b      	ldr	r3, [r7, #32]
34002956:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400295a:	2b00      	cmp	r3, #0
3400295c:	d135      	bne.n	340029ca <HAL_ADC_IRQHandler+0x176>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
3400295e:	687b      	ldr	r3, [r7, #4]
34002960:	681b      	ldr	r3, [r3, #0]
34002962:	681b      	ldr	r3, [r3, #0]
34002964:	f003 0308 	and.w	r3, r3, #8
34002968:	2b08      	cmp	r3, #8
3400296a:	d12e      	bne.n	340029ca <HAL_ADC_IRQHandler+0x176>
        {
          /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit         */
          /* ADSTART==0 (no conversion on going)                              */
          if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
3400296c:	687b      	ldr	r3, [r7, #4]
3400296e:	681b      	ldr	r3, [r3, #0]
34002970:	4618      	mov	r0, r3
34002972:	f7ff fc1b 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
34002976:	4603      	mov	r3, r0
34002978:	2b00      	cmp	r3, #0
3400297a:	d11a      	bne.n	340029b2 <HAL_ADC_IRQHandler+0x15e>
          {
            /* Disable ADC end of sequence conversion interrupt */
            /* Note: Overrun interrupt was enabled with EOC interrupt in      */
            /* HAL_Start_IT(), but is not disabled here because can be used   */
            /* by overrun IRQ process below.                                  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
3400297c:	687b      	ldr	r3, [r7, #4]
3400297e:	681b      	ldr	r3, [r3, #0]
34002980:	685a      	ldr	r2, [r3, #4]
34002982:	687b      	ldr	r3, [r7, #4]
34002984:	681b      	ldr	r3, [r3, #0]
34002986:	f022 020c 	bic.w	r2, r2, #12
3400298a:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
3400298c:	687b      	ldr	r3, [r7, #4]
3400298e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002990:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34002994:	687b      	ldr	r3, [r7, #4]
34002996:	659a      	str	r2, [r3, #88]	@ 0x58

            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
34002998:	687b      	ldr	r3, [r7, #4]
3400299a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400299c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340029a0:	2b00      	cmp	r3, #0
340029a2:	d112      	bne.n	340029ca <HAL_ADC_IRQHandler+0x176>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
340029a4:	687b      	ldr	r3, [r7, #4]
340029a6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340029a8:	f043 0201 	orr.w	r2, r3, #1
340029ac:	687b      	ldr	r3, [r7, #4]
340029ae:	659a      	str	r2, [r3, #88]	@ 0x58
340029b0:	e00b      	b.n	340029ca <HAL_ADC_IRQHandler+0x176>
            }
          }
          else
          {
            /* Change ADC state to error state */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340029b2:	687b      	ldr	r3, [r7, #4]
340029b4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340029b6:	f043 0210 	orr.w	r2, r3, #16
340029ba:	687b      	ldr	r3, [r7, #4]
340029bc:	659a      	str	r2, [r3, #88]	@ 0x58

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340029be:	687b      	ldr	r3, [r7, #4]
340029c0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340029c2:	f043 0201 	orr.w	r2, r3, #1
340029c6:	687b      	ldr	r3, [r7, #4]
340029c8:	65da      	str	r2, [r3, #92]	@ 0x5c
    /*       possibility to use:                                              */
    /*        " if ( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "               */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
340029ca:	6878      	ldr	r0, [r7, #4]
340029cc:	f00a fa4e 	bl	3400ce6c <HAL_ADC_ConvCpltCallback>
    /* Clear regular group conversion flag */
    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
    /*       conversion flags clear induces the release of the preserved data.*/
    /*       Therefore, if the preserved data value is needed, it must be     */
    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
340029d0:	687b      	ldr	r3, [r7, #4]
340029d2:	681b      	ldr	r3, [r3, #0]
340029d4:	220c      	movs	r2, #12
340029d6:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
340029d8:	69fb      	ldr	r3, [r7, #28]
340029da:	f003 0320 	and.w	r3, r3, #32
340029de:	2b00      	cmp	r3, #0
340029e0:	d004      	beq.n	340029ec <HAL_ADC_IRQHandler+0x198>
340029e2:	69bb      	ldr	r3, [r7, #24]
340029e4:	f003 0320 	and.w	r3, r3, #32
340029e8:	2b00      	cmp	r3, #0
340029ea:	d10b      	bne.n	34002a04 <HAL_ADC_IRQHandler+0x1b0>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
340029ec:	69fb      	ldr	r3, [r7, #28]
340029ee:	f003 0340 	and.w	r3, r3, #64	@ 0x40
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
340029f2:	2b00      	cmp	r3, #0
340029f4:	f000 808d 	beq.w	34002b12 <HAL_ADC_IRQHandler+0x2be>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
340029f8:	69bb      	ldr	r3, [r7, #24]
340029fa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340029fe:	2b00      	cmp	r3, #0
34002a00:	f000 8087 	beq.w	34002b12 <HAL_ADC_IRQHandler+0x2be>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
34002a04:	687b      	ldr	r3, [r7, #4]
34002a06:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002a08:	f003 0310 	and.w	r3, r3, #16
34002a0c:	2b00      	cmp	r3, #0
34002a0e:	d105      	bne.n	34002a1c <HAL_ADC_IRQHandler+0x1c8>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
34002a10:	687b      	ldr	r3, [r7, #4]
34002a12:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002a14:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
34002a18:	687b      	ldr	r3, [r7, #4]
34002a1a:	659a      	str	r2, [r3, #88]	@ 0x58
    }

    /* Retrieve ADC configuration */
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
34002a1c:	687b      	ldr	r3, [r7, #4]
34002a1e:	681b      	ldr	r3, [r3, #0]
34002a20:	4618      	mov	r0, r3
34002a22:	f7ff f909 	bl	34001c38 <LL_ADC_INJ_IsTriggerSourceSWStart>
34002a26:	60f8      	str	r0, [r7, #12]
    tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
34002a28:	687b      	ldr	r3, [r7, #4]
34002a2a:	681b      	ldr	r3, [r3, #0]
34002a2c:	4618      	mov	r0, r3
34002a2e:	f7ff f8ae 	bl	34001b8e <LL_ADC_REG_IsTriggerSourceSWStart>
34002a32:	60b8      	str	r0, [r7, #8]
    /* Get relevant register CFGR in ADC instance of ADC master or slave  */
    /* in function of multimode state (for devices with multimode         */
    /* available).                                                        */
#if defined(ADC_MULTIMODE_SUPPORT)
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34002a34:	687b      	ldr	r3, [r7, #4]
34002a36:	681b      	ldr	r3, [r3, #0]
34002a38:	4a11      	ldr	r2, [pc, #68]	@ (34002a80 <HAL_ADC_IRQHandler+0x22c>)
34002a3a:	4293      	cmp	r3, r2
34002a3c:	d002      	beq.n	34002a44 <HAL_ADC_IRQHandler+0x1f0>
34002a3e:	687b      	ldr	r3, [r7, #4]
34002a40:	681b      	ldr	r3, [r3, #0]
34002a42:	e000      	b.n	34002a46 <HAL_ADC_IRQHandler+0x1f2>
34002a44:	4b0f      	ldr	r3, [pc, #60]	@ (34002a84 <HAL_ADC_IRQHandler+0x230>)
34002a46:	687a      	ldr	r2, [r7, #4]
34002a48:	6812      	ldr	r2, [r2, #0]
34002a4a:	4293      	cmp	r3, r2
34002a4c:	d008      	beq.n	34002a60 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
34002a4e:	697b      	ldr	r3, [r7, #20]
34002a50:	2b00      	cmp	r3, #0
34002a52:	d005      	beq.n	34002a60 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
34002a54:	697b      	ldr	r3, [r7, #20]
34002a56:	2b06      	cmp	r3, #6
34002a58:	d002      	beq.n	34002a60 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
34002a5a:	697b      	ldr	r3, [r7, #20]
34002a5c:	2b07      	cmp	r3, #7
34002a5e:	d104      	bne.n	34002a6a <HAL_ADC_IRQHandler+0x216>
       )
    {
      tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
34002a60:	687b      	ldr	r3, [r7, #4]
34002a62:	681b      	ldr	r3, [r3, #0]
34002a64:	68db      	ldr	r3, [r3, #12]
34002a66:	623b      	str	r3, [r7, #32]
34002a68:	e013      	b.n	34002a92 <HAL_ADC_IRQHandler+0x23e>
    }
    else
    {
      tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
34002a6a:	687b      	ldr	r3, [r7, #4]
34002a6c:	681b      	ldr	r3, [r3, #0]
34002a6e:	4a04      	ldr	r2, [pc, #16]	@ (34002a80 <HAL_ADC_IRQHandler+0x22c>)
34002a70:	4293      	cmp	r3, r2
34002a72:	d009      	beq.n	34002a88 <HAL_ADC_IRQHandler+0x234>
34002a74:	687b      	ldr	r3, [r7, #4]
34002a76:	681b      	ldr	r3, [r3, #0]
34002a78:	e007      	b.n	34002a8a <HAL_ADC_IRQHandler+0x236>
34002a7a:	bf00      	nop
34002a7c:	50022300 	.word	0x50022300
34002a80:	50022100 	.word	0x50022100
34002a84:	50022000 	.word	0x50022000
34002a88:	4b66      	ldr	r3, [pc, #408]	@ (34002c24 <HAL_ADC_IRQHandler+0x3d0>)
34002a8a:	613b      	str	r3, [r7, #16]
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR1);
34002a8c:	693b      	ldr	r3, [r7, #16]
34002a8e:	68db      	ldr	r3, [r3, #12]
34002a90:	623b      	str	r3, [r7, #32]
    /* Disable interruption if no further conversion upcoming by injected     */
    /* external trigger or by automatic injected conversion with regular      */
    /* group having no further conversion upcoming (same conditions as        */
    /* regular group interruption disabling above),                           */
    /* and if injected scan sequence is completed.                            */
    if (tmp_adc_inj_is_trigger_source_sw_start != 0UL)
34002a92:	68fb      	ldr	r3, [r7, #12]
34002a94:	2b00      	cmp	r3, #0
34002a96:	d035      	beq.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
    {
      if (((READ_BIT(tmp_cfgr, ADC_CFGR1_JAUTO) == 0UL) ||
34002a98:	6a3b      	ldr	r3, [r7, #32]
34002a9a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34002a9e:	2b00      	cmp	r3, #0
34002aa0:	d007      	beq.n	34002ab2 <HAL_ADC_IRQHandler+0x25e>
34002aa2:	68bb      	ldr	r3, [r7, #8]
34002aa4:	2b00      	cmp	r3, #0
34002aa6:	d02d      	beq.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
           ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
            (READ_BIT(tmp_cfgr, ADC_CFGR1_CONT) == 0UL))))
34002aa8:	6a3b      	ldr	r3, [r7, #32]
34002aaa:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
           ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
34002aae:	2b00      	cmp	r3, #0
34002ab0:	d128      	bne.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
34002ab2:	687b      	ldr	r3, [r7, #4]
34002ab4:	681b      	ldr	r3, [r3, #0]
34002ab6:	681b      	ldr	r3, [r3, #0]
34002ab8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34002abc:	2b40      	cmp	r3, #64	@ 0x40
34002abe:	d121      	bne.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
        {
          if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
34002ac0:	687b      	ldr	r3, [r7, #4]
34002ac2:	681b      	ldr	r3, [r3, #0]
34002ac4:	4618      	mov	r0, r3
34002ac6:	f7ff fb96 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
34002aca:	4603      	mov	r3, r0
34002acc:	2b00      	cmp	r3, #0
34002ace:	d119      	bne.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
          {
            /* Disable ADC end of sequence conversion interrupt  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
34002ad0:	687b      	ldr	r3, [r7, #4]
34002ad2:	681b      	ldr	r3, [r3, #0]
34002ad4:	685a      	ldr	r2, [r3, #4]
34002ad6:	687b      	ldr	r3, [r7, #4]
34002ad8:	681b      	ldr	r3, [r3, #0]
34002ada:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
34002ade:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
34002ae0:	687b      	ldr	r3, [r7, #4]
34002ae2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002ae4:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34002ae8:	687b      	ldr	r3, [r7, #4]
34002aea:	659a      	str	r2, [r3, #88]	@ 0x58

            if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
34002aec:	687b      	ldr	r3, [r7, #4]
34002aee:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002af0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002af4:	2b00      	cmp	r3, #0
34002af6:	d105      	bne.n	34002b04 <HAL_ADC_IRQHandler+0x2b0>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
34002af8:	687b      	ldr	r3, [r7, #4]
34002afa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002afc:	f043 0201 	orr.w	r2, r3, #1
34002b00:	687b      	ldr	r3, [r7, #4]
34002b02:	659a      	str	r2, [r3, #88]	@ 0x58
              interruption has been triggered by end of conversion or end of
              sequence.    */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedConvCpltCallback(hadc);
#else
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
34002b04:	6878      	ldr	r0, [r7, #4]
34002b06:	f000 fe60 	bl	340037ca <HAL_ADCEx_InjectedConvCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear injected group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
34002b0a:	687b      	ldr	r3, [r7, #4]
34002b0c:	681b      	ldr	r3, [r3, #0]
34002b0e:	2260      	movs	r2, #96	@ 0x60
34002b10:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Analog watchdog 1 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
34002b12:	69fb      	ldr	r3, [r7, #28]
34002b14:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34002b18:	2b00      	cmp	r3, #0
34002b1a:	d011      	beq.n	34002b40 <HAL_ADC_IRQHandler+0x2ec>
34002b1c:	69bb      	ldr	r3, [r7, #24]
34002b1e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34002b22:	2b00      	cmp	r3, #0
34002b24:	d00c      	beq.n	34002b40 <HAL_ADC_IRQHandler+0x2ec>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
34002b26:	687b      	ldr	r3, [r7, #4]
34002b28:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002b2a:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34002b2e:	687b      	ldr	r3, [r7, #4]
34002b30:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 1 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindowCallback(hadc);
#else
    HAL_ADC_LevelOutOfWindowCallback(hadc);
34002b32:	6878      	ldr	r0, [r7, #4]
34002b34:	f000 f87a 	bl	34002c2c <HAL_ADC_LevelOutOfWindowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
34002b38:	687b      	ldr	r3, [r7, #4]
34002b3a:	681b      	ldr	r3, [r3, #0]
34002b3c:	2280      	movs	r2, #128	@ 0x80
34002b3e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 2 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
34002b40:	69fb      	ldr	r3, [r7, #28]
34002b42:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002b46:	2b00      	cmp	r3, #0
34002b48:	d012      	beq.n	34002b70 <HAL_ADC_IRQHandler+0x31c>
34002b4a:	69bb      	ldr	r3, [r7, #24]
34002b4c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002b50:	2b00      	cmp	r3, #0
34002b52:	d00d      	beq.n	34002b70 <HAL_ADC_IRQHandler+0x31c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
34002b54:	687b      	ldr	r3, [r7, #4]
34002b56:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002b58:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34002b5c:	687b      	ldr	r3, [r7, #4]
34002b5e:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 2 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow2Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
34002b60:	6878      	ldr	r0, [r7, #4]
34002b62:	f000 fe3c 	bl	340037de <HAL_ADCEx_LevelOutOfWindow2Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
34002b66:	687b      	ldr	r3, [r7, #4]
34002b68:	681b      	ldr	r3, [r3, #0]
34002b6a:	f44f 7280 	mov.w	r2, #256	@ 0x100
34002b6e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 3 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
34002b70:	69fb      	ldr	r3, [r7, #28]
34002b72:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002b76:	2b00      	cmp	r3, #0
34002b78:	d012      	beq.n	34002ba0 <HAL_ADC_IRQHandler+0x34c>
34002b7a:	69bb      	ldr	r3, [r7, #24]
34002b7c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002b80:	2b00      	cmp	r3, #0
34002b82:	d00d      	beq.n	34002ba0 <HAL_ADC_IRQHandler+0x34c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
34002b84:	687b      	ldr	r3, [r7, #4]
34002b86:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002b88:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34002b8c:	687b      	ldr	r3, [r7, #4]
34002b8e:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 3 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow3Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
34002b90:	6878      	ldr	r0, [r7, #4]
34002b92:	f000 fe2e 	bl	340037f2 <HAL_ADCEx_LevelOutOfWindow3Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
34002b96:	687b      	ldr	r3, [r7, #4]
34002b98:	681b      	ldr	r3, [r3, #0]
34002b9a:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002b9e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Overrun flag ========== */
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
34002ba0:	69fb      	ldr	r3, [r7, #28]
34002ba2:	f003 0310 	and.w	r3, r3, #16
34002ba6:	2b00      	cmp	r3, #0
34002ba8:	d038      	beq.n	34002c1c <HAL_ADC_IRQHandler+0x3c8>
34002baa:	69bb      	ldr	r3, [r7, #24]
34002bac:	f003 0310 	and.w	r3, r3, #16
34002bb0:	2b00      	cmp	r3, #0
34002bb2:	d033      	beq.n	34002c1c <HAL_ADC_IRQHandler+0x3c8>
    /* overrun event is not considered as an error.                           */
    /* (cf ref manual "Managing conversions without using the DMA and without */
    /* overrun ")                                                             */
    /* Exception for usage with DMA overrun event always considered as an     */
    /* error.                                                                 */
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
34002bb4:	687b      	ldr	r3, [r7, #4]
34002bb6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34002bb8:	2b00      	cmp	r3, #0
34002bba:	d102      	bne.n	34002bc2 <HAL_ADC_IRQHandler+0x36e>
    {
      overrun_error = 1UL;
34002bbc:	2301      	movs	r3, #1
34002bbe:	627b      	str	r3, [r7, #36]	@ 0x24
34002bc0:	e016      	b.n	34002bf0 <HAL_ADC_IRQHandler+0x39c>
    }
    else
    {
      /* Check DMA configuration */
#if defined(ADC_MULTIMODE_SUPPORT)
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
34002bc2:	697b      	ldr	r3, [r7, #20]
34002bc4:	2b00      	cmp	r3, #0
34002bc6:	d00a      	beq.n	34002bde <HAL_ADC_IRQHandler+0x38a>
      {
        overrun_error = 1UL;
34002bc8:	2301      	movs	r3, #1
34002bca:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Multimode (when feature is available) is enabled,
           Common Control Register MDMA bits must be checked. */
        if (LL_ADC_GetMultiDataFormat(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DATA_EACH_ADC)
34002bcc:	4816      	ldr	r0, [pc, #88]	@ (34002c28 <HAL_ADC_IRQHandler+0x3d4>)
34002bce:	f7ff fa4b 	bl	34002068 <LL_ADC_GetMultiDataFormat>
34002bd2:	4603      	mov	r3, r0
34002bd4:	2b00      	cmp	r3, #0
34002bd6:	d00b      	beq.n	34002bf0 <HAL_ADC_IRQHandler+0x39c>
        {
          overrun_error = 1UL;
34002bd8:	2301      	movs	r3, #1
34002bda:	627b      	str	r3, [r7, #36]	@ 0x24
34002bdc:	e008      	b.n	34002bf0 <HAL_ADC_IRQHandler+0x39c>
      }
      else
#endif /* ADC_MULTIMODE_SUPPORT */
      {
        /* Multimode not set or feature not available or ADC independent */
        if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMNGT) != 0UL)
34002bde:	687b      	ldr	r3, [r7, #4]
34002be0:	681b      	ldr	r3, [r3, #0]
34002be2:	68db      	ldr	r3, [r3, #12]
34002be4:	f003 0303 	and.w	r3, r3, #3
34002be8:	2b00      	cmp	r3, #0
34002bea:	d001      	beq.n	34002bf0 <HAL_ADC_IRQHandler+0x39c>
        {
          overrun_error = 1UL;
34002bec:	2301      	movs	r3, #1
34002bee:	627b      	str	r3, [r7, #36]	@ 0x24
        }
      }
    }

    if (overrun_error == 1UL)
34002bf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002bf2:	2b01      	cmp	r3, #1
34002bf4:	d10e      	bne.n	34002c14 <HAL_ADC_IRQHandler+0x3c0>
    {
      /* Change ADC state to error state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
34002bf6:	687b      	ldr	r3, [r7, #4]
34002bf8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002bfa:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34002bfe:	687b      	ldr	r3, [r7, #4]
34002c00:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Set ADC error code to overrun */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
34002c02:	687b      	ldr	r3, [r7, #4]
34002c04:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34002c06:	f043 0202 	orr.w	r2, r3, #2
34002c0a:	687b      	ldr	r3, [r7, #4]
34002c0c:	65da      	str	r2, [r3, #92]	@ 0x5c
      /*       Therefore, old ADC conversion data can be retrieved in         */
      /*       function "HAL_ADC_ErrorCallback()".                            */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ErrorCallback(hadc);
#else
      HAL_ADC_ErrorCallback(hadc);
34002c0e:	6878      	ldr	r0, [r7, #4]
34002c10:	f000 f816 	bl	34002c40 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    }

    /* Clear ADC overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
34002c14:	687b      	ldr	r3, [r7, #4]
34002c16:	681b      	ldr	r3, [r3, #0]
34002c18:	2210      	movs	r2, #16
34002c1a:	601a      	str	r2, [r3, #0]
  }

}
34002c1c:	bf00      	nop
34002c1e:	3728      	adds	r7, #40	@ 0x28
34002c20:	46bd      	mov	sp, r7
34002c22:	bd80      	pop	{r7, pc}
34002c24:	50022000 	.word	0x50022000
34002c28:	50022300 	.word	0x50022300

34002c2c <HAL_ADC_LevelOutOfWindowCallback>:
  * @brief  Analog watchdog 1 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc)
{
34002c2c:	b480      	push	{r7}
34002c2e:	b083      	sub	sp, #12
34002c30:	af00      	add	r7, sp, #0
34002c32:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
  */
}
34002c34:	bf00      	nop
34002c36:	370c      	adds	r7, #12
34002c38:	46bd      	mov	sp, r7
34002c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c3e:	4770      	bx	lr

34002c40 <HAL_ADC_ErrorCallback>:
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
34002c40:	b480      	push	{r7}
34002c42:	b083      	sub	sp, #12
34002c44:	af00      	add	r7, sp, #0
34002c46:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */
}
34002c48:	bf00      	nop
34002c4a:	370c      	adds	r7, #12
34002c4c:	46bd      	mov	sp, r7
34002c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c52:	4770      	bx	lr

34002c54 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig)
{
34002c54:	b590      	push	{r4, r7, lr}
34002c56:	b089      	sub	sp, #36	@ 0x24
34002c58:	af00      	add	r7, sp, #0
34002c5a:	6078      	str	r0, [r7, #4]
34002c5c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34002c5e:	2300      	movs	r3, #0
34002c60:	77fb      	strb	r3, [r7, #31]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfig->Channel));
  }

  /* ADC must be disabled to set configuration bits                           */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34002c62:	687b      	ldr	r3, [r7, #4]
34002c64:	681b      	ldr	r3, [r3, #0]
34002c66:	4618      	mov	r0, r3
34002c68:	f7ff fa56 	bl	34002118 <LL_ADC_IsEnabled>
34002c6c:	4603      	mov	r3, r0
34002c6e:	2b00      	cmp	r3, #0
34002c70:	d001      	beq.n	34002c76 <HAL_ADC_ConfigChannel+0x22>
  {
    return HAL_ERROR;
34002c72:	2301      	movs	r3, #1
34002c74:	e1db      	b.n	3400302e <HAL_ADC_ConfigChannel+0x3da>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
34002c76:	687b      	ldr	r3, [r7, #4]
34002c78:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34002c7c:	2b01      	cmp	r3, #1
34002c7e:	d101      	bne.n	34002c84 <HAL_ADC_ConfigChannel+0x30>
34002c80:	2302      	movs	r3, #2
34002c82:	e1d4      	b.n	3400302e <HAL_ADC_ConfigChannel+0x3da>
34002c84:	687b      	ldr	r3, [r7, #4]
34002c86:	2201      	movs	r2, #1
34002c88:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
34002c8c:	687b      	ldr	r3, [r7, #4]
34002c8e:	681b      	ldr	r3, [r3, #0]
34002c90:	4618      	mov	r0, r3
34002c92:	f7ff fa8b 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
34002c96:	4603      	mov	r3, r0
34002c98:	2b00      	cmp	r3, #0
34002c9a:	f040 81bb 	bne.w	34003014 <HAL_ADC_ConfigChannel+0x3c0>
  {
    /* ADC channels preselection */
    LL_ADC_SetChannelPreselection(hadc->Instance, pConfig->Channel);
34002c9e:	687b      	ldr	r3, [r7, #4]
34002ca0:	681a      	ldr	r2, [r3, #0]
34002ca2:	683b      	ldr	r3, [r7, #0]
34002ca4:	681b      	ldr	r3, [r3, #0]
34002ca6:	4619      	mov	r1, r3
34002ca8:	4610      	mov	r0, r2
34002caa:	f7fe ffae 	bl	34001c0a <LL_ADC_SetChannelPreselection>

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, pConfig->Rank, pConfig->Channel);
34002cae:	687b      	ldr	r3, [r7, #4]
34002cb0:	6818      	ldr	r0, [r3, #0]
34002cb2:	683b      	ldr	r3, [r7, #0]
34002cb4:	6859      	ldr	r1, [r3, #4]
34002cb6:	683b      	ldr	r3, [r7, #0]
34002cb8:	681b      	ldr	r3, [r3, #0]
34002cba:	461a      	mov	r2, r3
34002cbc:	f7fe ff7a 	bl	34001bb4 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34002cc0:	687b      	ldr	r3, [r7, #4]
34002cc2:	681b      	ldr	r3, [r3, #0]
34002cc4:	4618      	mov	r0, r3
34002cc6:	f7ff fa71 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
34002cca:	61b8      	str	r0, [r7, #24]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
34002ccc:	687b      	ldr	r3, [r7, #4]
34002cce:	681b      	ldr	r3, [r3, #0]
34002cd0:	4618      	mov	r0, r3
34002cd2:	f7ff fa90 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
34002cd6:	6178      	str	r0, [r7, #20]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34002cd8:	69bb      	ldr	r3, [r7, #24]
34002cda:	2b00      	cmp	r3, #0
34002cdc:	f040 80aa 	bne.w	34002e34 <HAL_ADC_ConfigChannel+0x1e0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
34002ce0:	697b      	ldr	r3, [r7, #20]
34002ce2:	2b00      	cmp	r3, #0
34002ce4:	f040 80a6 	bne.w	34002e34 <HAL_ADC_ConfigChannel+0x1e0>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, pConfig->SamplingTime);
34002ce8:	687b      	ldr	r3, [r7, #4]
34002cea:	6818      	ldr	r0, [r3, #0]
34002cec:	683b      	ldr	r3, [r7, #0]
34002cee:	6819      	ldr	r1, [r3, #0]
34002cf0:	683b      	ldr	r3, [r7, #0]
34002cf2:	689b      	ldr	r3, [r3, #8]
34002cf4:	461a      	mov	r2, r3
34002cf6:	f7fe ffb3 	bl	34001c60 <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
34002cfa:	683b      	ldr	r3, [r7, #0]
34002cfc:	695a      	ldr	r2, [r3, #20]
34002cfe:	687b      	ldr	r3, [r7, #4]
34002d00:	681b      	ldr	r3, [r3, #0]
34002d02:	68db      	ldr	r3, [r3, #12]
34002d04:	089b      	lsrs	r3, r3, #2
34002d06:	f003 0303 	and.w	r3, r3, #3
34002d0a:	005b      	lsls	r3, r3, #1
34002d0c:	fa02 f303 	lsl.w	r3, r2, r3
34002d10:	613b      	str	r3, [r7, #16]

      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
34002d12:	683b      	ldr	r3, [r7, #0]
34002d14:	691b      	ldr	r3, [r3, #16]
34002d16:	2b04      	cmp	r3, #4
34002d18:	d038      	beq.n	34002d8c <HAL_ADC_ConfigChannel+0x138>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffsetChannel(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel);
34002d1a:	687b      	ldr	r3, [r7, #4]
34002d1c:	6818      	ldr	r0, [r3, #0]
34002d1e:	683b      	ldr	r3, [r7, #0]
34002d20:	6919      	ldr	r1, [r3, #16]
34002d22:	683b      	ldr	r3, [r7, #0]
34002d24:	681b      	ldr	r3, [r3, #0]
34002d26:	461a      	mov	r2, r3
34002d28:	f7fe fe6f 	bl	34001a0a <LL_ADC_SetOffsetChannel>
        LL_ADC_SetOffsetLevel(hadc->Instance, pConfig->OffsetNumber, tmpOffsetShifted);
34002d2c:	687b      	ldr	r3, [r7, #4]
34002d2e:	6818      	ldr	r0, [r3, #0]
34002d30:	683b      	ldr	r3, [r7, #0]
34002d32:	691b      	ldr	r3, [r3, #16]
34002d34:	693a      	ldr	r2, [r7, #16]
34002d36:	4619      	mov	r1, r3
34002d38:	f7fe fe9a 	bl	34001a70 <LL_ADC_SetOffsetLevel>
        /* Signed and unsigned saturation cannot be set at the same time */
        assert_param(!((pConfig->OffsetSignedSaturation == ENABLE) && (pConfig->OffsetSaturation == ENABLE)));


        /* Set ADC offset sign */
        LL_ADC_SetOffsetSign(hadc->Instance, pConfig->OffsetNumber, pConfig->OffsetSign);
34002d3c:	687b      	ldr	r3, [r7, #4]
34002d3e:	6818      	ldr	r0, [r3, #0]
34002d40:	683b      	ldr	r3, [r7, #0]
34002d42:	6919      	ldr	r1, [r3, #16]
34002d44:	683b      	ldr	r3, [r7, #0]
34002d46:	69db      	ldr	r3, [r3, #28]
34002d48:	461a      	mov	r2, r3
34002d4a:	f7fe feac 	bl	34001aa6 <LL_ADC_SetOffsetSign>
        /* Set ADC offset signed saturation */
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
34002d4e:	687b      	ldr	r3, [r7, #4]
34002d50:	6818      	ldr	r0, [r3, #0]
34002d52:	683b      	ldr	r3, [r7, #0]
34002d54:	6919      	ldr	r1, [r3, #16]
                                         (pConfig->OffsetSignedSaturation == ENABLE) \
34002d56:	683b      	ldr	r3, [r7, #0]
34002d58:	7e1b      	ldrb	r3, [r3, #24]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
34002d5a:	2b01      	cmp	r3, #1
34002d5c:	d102      	bne.n	34002d64 <HAL_ADC_ConfigChannel+0x110>
34002d5e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34002d62:	e000      	b.n	34002d66 <HAL_ADC_ConfigChannel+0x112>
34002d64:	2300      	movs	r3, #0
34002d66:	461a      	mov	r2, r3
34002d68:	f7fe feb8 	bl	34001adc <LL_ADC_SetOffsetSignedSaturation>
                                         ? LL_ADC_OFFSET_SIGNED_SAT_ENABLE           \
                                         : LL_ADC_OFFSET_SIGNED_SAT_DISABLE);
        /* Set ADC offset unsigned saturation */
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
34002d6c:	687b      	ldr	r3, [r7, #4]
34002d6e:	6818      	ldr	r0, [r3, #0]
34002d70:	683b      	ldr	r3, [r7, #0]
34002d72:	6919      	ldr	r1, [r3, #16]
                                           (pConfig->OffsetSaturation == ENABLE)     \
34002d74:	683b      	ldr	r3, [r7, #0]
34002d76:	7e5b      	ldrb	r3, [r3, #25]
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
34002d78:	2b01      	cmp	r3, #1
34002d7a:	d102      	bne.n	34002d82 <HAL_ADC_ConfigChannel+0x12e>
34002d7c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34002d80:	e000      	b.n	34002d84 <HAL_ADC_ConfigChannel+0x130>
34002d82:	2300      	movs	r3, #0
34002d84:	461a      	mov	r2, r3
34002d86:	f7fe fec4 	bl	34001b12 <LL_ADC_SetOffsetUnsignedSaturation>
34002d8a:	e053      	b.n	34002e34 <HAL_ADC_ConfigChannel+0x1e0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted.
           If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
34002d8c:	687b      	ldr	r3, [r7, #4]
34002d8e:	681b      	ldr	r3, [r3, #0]
34002d90:	2100      	movs	r1, #0
34002d92:	4618      	mov	r0, r3
34002d94:	f7fe fe55 	bl	34001a42 <LL_ADC_GetOffsetChannel>
34002d98:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34002d9a:	683b      	ldr	r3, [r7, #0]
34002d9c:	681b      	ldr	r3, [r3, #0]
34002d9e:	4053      	eors	r3, r2
34002da0:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
34002da4:	2b00      	cmp	r3, #0
34002da6:	d106      	bne.n	34002db6 <HAL_ADC_ConfigChannel+0x162>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1, 0UL);
34002da8:	687b      	ldr	r3, [r7, #4]
34002daa:	681b      	ldr	r3, [r3, #0]
34002dac:	2200      	movs	r2, #0
34002dae:	2100      	movs	r1, #0
34002db0:	4618      	mov	r0, r3
34002db2:	f7fe fe5d 	bl	34001a70 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
34002db6:	687b      	ldr	r3, [r7, #4]
34002db8:	681b      	ldr	r3, [r3, #0]
34002dba:	2101      	movs	r1, #1
34002dbc:	4618      	mov	r0, r3
34002dbe:	f7fe fe40 	bl	34001a42 <LL_ADC_GetOffsetChannel>
34002dc2:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34002dc4:	683b      	ldr	r3, [r7, #0]
34002dc6:	681b      	ldr	r3, [r3, #0]
34002dc8:	4053      	eors	r3, r2
34002dca:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
34002dce:	2b00      	cmp	r3, #0
34002dd0:	d106      	bne.n	34002de0 <HAL_ADC_ConfigChannel+0x18c>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2, 0UL);
34002dd2:	687b      	ldr	r3, [r7, #4]
34002dd4:	681b      	ldr	r3, [r3, #0]
34002dd6:	2200      	movs	r2, #0
34002dd8:	2101      	movs	r1, #1
34002dda:	4618      	mov	r0, r3
34002ddc:	f7fe fe48 	bl	34001a70 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
34002de0:	687b      	ldr	r3, [r7, #4]
34002de2:	681b      	ldr	r3, [r3, #0]
34002de4:	2102      	movs	r1, #2
34002de6:	4618      	mov	r0, r3
34002de8:	f7fe fe2b 	bl	34001a42 <LL_ADC_GetOffsetChannel>
34002dec:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34002dee:	683b      	ldr	r3, [r7, #0]
34002df0:	681b      	ldr	r3, [r3, #0]
34002df2:	4053      	eors	r3, r2
34002df4:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
34002df8:	2b00      	cmp	r3, #0
34002dfa:	d106      	bne.n	34002e0a <HAL_ADC_ConfigChannel+0x1b6>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3, 0UL);
34002dfc:	687b      	ldr	r3, [r7, #4]
34002dfe:	681b      	ldr	r3, [r3, #0]
34002e00:	2200      	movs	r2, #0
34002e02:	2102      	movs	r1, #2
34002e04:	4618      	mov	r0, r3
34002e06:	f7fe fe33 	bl	34001a70 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
34002e0a:	687b      	ldr	r3, [r7, #4]
34002e0c:	681b      	ldr	r3, [r3, #0]
34002e0e:	2103      	movs	r1, #3
34002e10:	4618      	mov	r0, r3
34002e12:	f7fe fe16 	bl	34001a42 <LL_ADC_GetOffsetChannel>
34002e16:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34002e18:	683b      	ldr	r3, [r7, #0]
34002e1a:	681b      	ldr	r3, [r3, #0]
34002e1c:	4053      	eors	r3, r2
34002e1e:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
34002e22:	2b00      	cmp	r3, #0
34002e24:	d106      	bne.n	34002e34 <HAL_ADC_ConfigChannel+0x1e0>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4, 0UL);
34002e26:	687b      	ldr	r3, [r7, #4]
34002e28:	681b      	ldr	r3, [r3, #0]
34002e2a:	2200      	movs	r2, #0
34002e2c:	2103      	movs	r1, #3
34002e2e:	4618      	mov	r0, r3
34002e30:	f7fe fe1e 	bl	34001a70 <LL_ADC_SetOffsetLevel>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
34002e34:	687b      	ldr	r3, [r7, #4]
34002e36:	681b      	ldr	r3, [r3, #0]
34002e38:	4618      	mov	r0, r3
34002e3a:	f7ff f96d 	bl	34002118 <LL_ADC_IsEnabled>
34002e3e:	4603      	mov	r3, r0
34002e40:	2b00      	cmp	r3, #0
34002e42:	f040 8090 	bne.w	34002f66 <HAL_ADC_ConfigChannel+0x312>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
34002e46:	687b      	ldr	r3, [r7, #4]
34002e48:	6818      	ldr	r0, [r3, #0]
34002e4a:	683b      	ldr	r3, [r7, #0]
34002e4c:	6819      	ldr	r1, [r3, #0]
34002e4e:	683b      	ldr	r3, [r7, #0]
34002e50:	68db      	ldr	r3, [r3, #12]
34002e52:	461a      	mov	r2, r3
34002e54:	f7fe ffca 	bl	34001dec <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (pConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
34002e58:	683b      	ldr	r3, [r7, #0]
34002e5a:	68db      	ldr	r3, [r3, #12]
34002e5c:	4a76      	ldr	r2, [pc, #472]	@ (34003038 <HAL_ADC_ConfigChannel+0x3e4>)
34002e5e:	4293      	cmp	r3, r2
34002e60:	f040 8081 	bne.w	34002f66 <HAL_ADC_ConfigChannel+0x312>
      {
        /* Set ADC channel preselection of corresponding negative channel */
        LL_ADC_SetChannelPreselection(hadc->Instance,
34002e64:	687b      	ldr	r3, [r7, #4]
34002e66:	681a      	ldr	r2, [r3, #0]
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
34002e68:	683b      	ldr	r3, [r7, #0]
34002e6a:	681b      	ldr	r3, [r3, #0]
34002e6c:	2b00      	cmp	r3, #0
34002e6e:	d05a      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e70:	683b      	ldr	r3, [r7, #0]
34002e72:	681b      	ldr	r3, [r3, #0]
34002e74:	2b01      	cmp	r3, #1
34002e76:	d056      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e78:	683b      	ldr	r3, [r7, #0]
34002e7a:	681b      	ldr	r3, [r3, #0]
34002e7c:	2b02      	cmp	r3, #2
34002e7e:	d052      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e80:	683b      	ldr	r3, [r7, #0]
34002e82:	681b      	ldr	r3, [r3, #0]
34002e84:	2b03      	cmp	r3, #3
34002e86:	d04e      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e88:	683b      	ldr	r3, [r7, #0]
34002e8a:	681b      	ldr	r3, [r3, #0]
34002e8c:	2b04      	cmp	r3, #4
34002e8e:	d04a      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e90:	683b      	ldr	r3, [r7, #0]
34002e92:	681b      	ldr	r3, [r3, #0]
34002e94:	2b05      	cmp	r3, #5
34002e96:	d046      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002e98:	683b      	ldr	r3, [r7, #0]
34002e9a:	681b      	ldr	r3, [r3, #0]
34002e9c:	2b06      	cmp	r3, #6
34002e9e:	d042      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ea0:	683b      	ldr	r3, [r7, #0]
34002ea2:	681b      	ldr	r3, [r3, #0]
34002ea4:	2b07      	cmp	r3, #7
34002ea6:	d03e      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ea8:	683b      	ldr	r3, [r7, #0]
34002eaa:	681b      	ldr	r3, [r3, #0]
34002eac:	2b08      	cmp	r3, #8
34002eae:	d03a      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002eb0:	683b      	ldr	r3, [r7, #0]
34002eb2:	681b      	ldr	r3, [r3, #0]
34002eb4:	2b09      	cmp	r3, #9
34002eb6:	d036      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002eb8:	683b      	ldr	r3, [r7, #0]
34002eba:	681b      	ldr	r3, [r3, #0]
34002ebc:	2b0a      	cmp	r3, #10
34002ebe:	d032      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ec0:	683b      	ldr	r3, [r7, #0]
34002ec2:	681b      	ldr	r3, [r3, #0]
34002ec4:	2b0b      	cmp	r3, #11
34002ec6:	d02e      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ec8:	683b      	ldr	r3, [r7, #0]
34002eca:	681b      	ldr	r3, [r3, #0]
34002ecc:	2b0c      	cmp	r3, #12
34002ece:	d02a      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ed0:	683b      	ldr	r3, [r7, #0]
34002ed2:	681b      	ldr	r3, [r3, #0]
34002ed4:	2b0d      	cmp	r3, #13
34002ed6:	d026      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ed8:	683b      	ldr	r3, [r7, #0]
34002eda:	681b      	ldr	r3, [r3, #0]
34002edc:	2b0e      	cmp	r3, #14
34002ede:	d022      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ee0:	683b      	ldr	r3, [r7, #0]
34002ee2:	681b      	ldr	r3, [r3, #0]
34002ee4:	2b0f      	cmp	r3, #15
34002ee6:	d01e      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ee8:	683b      	ldr	r3, [r7, #0]
34002eea:	681b      	ldr	r3, [r3, #0]
34002eec:	2b10      	cmp	r3, #16
34002eee:	d01a      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ef0:	683b      	ldr	r3, [r7, #0]
34002ef2:	681b      	ldr	r3, [r3, #0]
34002ef4:	2b11      	cmp	r3, #17
34002ef6:	d016      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002ef8:	683b      	ldr	r3, [r7, #0]
34002efa:	681b      	ldr	r3, [r3, #0]
34002efc:	2b12      	cmp	r3, #18
34002efe:	d012      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002f00:	683b      	ldr	r3, [r7, #0]
34002f02:	681b      	ldr	r3, [r3, #0]
34002f04:	2b13      	cmp	r3, #19
34002f06:	d00e      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002f08:	683b      	ldr	r3, [r7, #0]
34002f0a:	681b      	ldr	r3, [r3, #0]
34002f0c:	494b      	ldr	r1, [pc, #300]	@ (3400303c <HAL_ADC_ConfigChannel+0x3e8>)
34002f0e:	428b      	cmp	r3, r1
34002f10:	d009      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002f12:	683b      	ldr	r3, [r7, #0]
34002f14:	681b      	ldr	r3, [r3, #0]
34002f16:	494a      	ldr	r1, [pc, #296]	@ (34003040 <HAL_ADC_ConfigChannel+0x3ec>)
34002f18:	428b      	cmp	r3, r1
34002f1a:	d004      	beq.n	34002f26 <HAL_ADC_ConfigChannel+0x2d2>
34002f1c:	683b      	ldr	r3, [r7, #0]
34002f1e:	681b      	ldr	r3, [r3, #0]
34002f20:	4948      	ldr	r1, [pc, #288]	@ (34003044 <HAL_ADC_ConfigChannel+0x3f0>)
34002f22:	428b      	cmp	r3, r1
34002f24:	d101      	bne.n	34002f2a <HAL_ADC_ConfigChannel+0x2d6>
34002f26:	2301      	movs	r3, #1
34002f28:	e000      	b.n	34002f2c <HAL_ADC_ConfigChannel+0x2d8>
34002f2a:	2300      	movs	r3, #0
        LL_ADC_SetChannelPreselection(hadc->Instance,
34002f2c:	2b00      	cmp	r3, #0
34002f2e:	d015      	beq.n	34002f5c <HAL_ADC_ConfigChannel+0x308>
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
34002f30:	687b      	ldr	r3, [r7, #4]
34002f32:	681b      	ldr	r3, [r3, #0]
34002f34:	4944      	ldr	r1, [pc, #272]	@ (34003048 <HAL_ADC_ConfigChannel+0x3f4>)
34002f36:	428b      	cmp	r3, r1
34002f38:	bf14      	ite	ne
34002f3a:	2301      	movne	r3, #1
34002f3c:	2300      	moveq	r3, #0
34002f3e:	b2db      	uxtb	r3, r3
34002f40:	4618      	mov	r0, r3
34002f42:	683b      	ldr	r3, [r7, #0]
34002f44:	681b      	ldr	r3, [r3, #0]
34002f46:	b2db      	uxtb	r3, r3
34002f48:	461c      	mov	r4, r3
34002f4a:	4940      	ldr	r1, [pc, #256]	@ (3400304c <HAL_ADC_ConfigChannel+0x3f8>)
34002f4c:	4603      	mov	r3, r0
34002f4e:	009b      	lsls	r3, r3, #2
34002f50:	4403      	add	r3, r0
34002f52:	009b      	lsls	r3, r3, #2
34002f54:	440b      	add	r3, r1
34002f56:	4423      	add	r3, r4
34002f58:	781b      	ldrb	r3, [r3, #0]
34002f5a:	e000      	b.n	34002f5e <HAL_ADC_ConfigChannel+0x30a>
        LL_ADC_SetChannelPreselection(hadc->Instance,
34002f5c:	23ff      	movs	r3, #255	@ 0xff
34002f5e:	4619      	mov	r1, r3
34002f60:	4610      	mov	r0, r2
34002f62:	f7fe fe52 	bl	34001c0a <LL_ADC_SetChannelPreselection>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
34002f66:	683b      	ldr	r3, [r7, #0]
34002f68:	681b      	ldr	r3, [r3, #0]
34002f6a:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
34002f6e:	2b00      	cmp	r3, #0
34002f70:	d058      	beq.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
    {
      tmp_config_common_path_internal_channel =
        LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34002f72:	4837      	ldr	r0, [pc, #220]	@ (34003050 <HAL_ADC_ConfigChannel+0x3fc>)
34002f74:	f7fe fd07 	bl	34001986 <LL_ADC_GetCommonPathInternalCh>
34002f78:	60f8      	str	r0, [r7, #12]
      tmp_config_path_internal_channel = LL_ADC_GetPathInternalCh(hadc->Instance);
34002f7a:	687b      	ldr	r3, [r7, #4]
34002f7c:	681b      	ldr	r3, [r3, #0]
34002f7e:	4618      	mov	r0, r3
34002f80:	f7fe fd25 	bl	340019ce <LL_ADC_GetPathInternalCh>
34002f84:	60b8      	str	r0, [r7, #8]
      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if ((pConfig->Channel == ADC_CHANNEL_VREFINT)
34002f86:	683b      	ldr	r3, [r7, #0]
34002f88:	681b      	ldr	r3, [r3, #0]
34002f8a:	4a2e      	ldr	r2, [pc, #184]	@ (34003044 <HAL_ADC_ConfigChannel+0x3f0>)
34002f8c:	4293      	cmp	r3, r2
34002f8e:	d111      	bne.n	34002fb4 <HAL_ADC_ConfigChannel+0x360>
          && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
34002f90:	68fb      	ldr	r3, [r7, #12]
34002f92:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
34002f96:	2b00      	cmp	r3, #0
34002f98:	d10c      	bne.n	34002fb4 <HAL_ADC_ConfigChannel+0x360>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
34002f9a:	687b      	ldr	r3, [r7, #4]
34002f9c:	681b      	ldr	r3, [r3, #0]
34002f9e:	4a2a      	ldr	r2, [pc, #168]	@ (34003048 <HAL_ADC_ConfigChannel+0x3f4>)
34002fa0:	4293      	cmp	r3, r2
34002fa2:	d13f      	bne.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
34002fa4:	68fb      	ldr	r3, [r7, #12]
34002fa6:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
34002faa:	4619      	mov	r1, r3
34002fac:	4828      	ldr	r0, [pc, #160]	@ (34003050 <HAL_ADC_ConfigChannel+0x3fc>)
34002fae:	f7fe fcd7 	bl	34001960 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_VREFINT_INSTANCE(hadc))
34002fb2:	e037      	b.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_common_path_internal_channel);
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
34002fb4:	683b      	ldr	r3, [r7, #0]
34002fb6:	681b      	ldr	r3, [r3, #0]
34002fb8:	4a20      	ldr	r2, [pc, #128]	@ (3400303c <HAL_ADC_ConfigChannel+0x3e8>)
34002fba:	4293      	cmp	r3, r2
34002fbc:	d111      	bne.n	34002fe2 <HAL_ADC_ConfigChannel+0x38e>
               && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
34002fbe:	68fb      	ldr	r3, [r7, #12]
34002fc0:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34002fc4:	2b00      	cmp	r3, #0
34002fc6:	d10c      	bne.n	34002fe2 <HAL_ADC_ConfigChannel+0x38e>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
34002fc8:	687b      	ldr	r3, [r7, #4]
34002fca:	681b      	ldr	r3, [r3, #0]
34002fcc:	4a21      	ldr	r2, [pc, #132]	@ (34003054 <HAL_ADC_ConfigChannel+0x400>)
34002fce:	4293      	cmp	r3, r2
34002fd0:	d128      	bne.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
34002fd2:	68fb      	ldr	r3, [r7, #12]
34002fd4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
34002fd8:	4619      	mov	r1, r3
34002fda:	481d      	ldr	r0, [pc, #116]	@ (34003050 <HAL_ADC_ConfigChannel+0x3fc>)
34002fdc:	f7fe fcc0 	bl	34001960 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
34002fe0:	e020      	b.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_common_path_internal_channel);
        }
      }
      else if (((pConfig->Channel == ADC_CHANNEL_VDDCORE)
34002fe2:	683b      	ldr	r3, [r7, #0]
34002fe4:	681b      	ldr	r3, [r3, #0]
34002fe6:	4a16      	ldr	r2, [pc, #88]	@ (34003040 <HAL_ADC_ConfigChannel+0x3ec>)
34002fe8:	4293      	cmp	r3, r2
34002fea:	d11b      	bne.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
                && ((tmp_config_path_internal_channel & LL_ADC_PATH_INTERNAL_VDDCORE) == 0UL)))
34002fec:	68bb      	ldr	r3, [r7, #8]
34002fee:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34002ff2:	2b00      	cmp	r3, #0
34002ff4:	d116      	bne.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
      {
        if (ADC_VDDCORE_INSTANCE(hadc))
34002ff6:	687b      	ldr	r3, [r7, #4]
34002ff8:	681b      	ldr	r3, [r3, #0]
34002ffa:	4a16      	ldr	r2, [pc, #88]	@ (34003054 <HAL_ADC_ConfigChannel+0x400>)
34002ffc:	4293      	cmp	r3, r2
34002ffe:	d111      	bne.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetPathInternalCh(hadc->Instance, LL_ADC_PATH_INTERNAL_VDDCORE | tmp_config_path_internal_channel);
34003000:	687b      	ldr	r3, [r7, #4]
34003002:	681a      	ldr	r2, [r3, #0]
34003004:	68bb      	ldr	r3, [r7, #8]
34003006:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
3400300a:	4619      	mov	r1, r3
3400300c:	4610      	mov	r0, r2
3400300e:	f7fe fcc8 	bl	340019a2 <LL_ADC_SetPathInternalCh>
34003012:	e007      	b.n	34003024 <HAL_ADC_ConfigChannel+0x3d0>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34003014:	687b      	ldr	r3, [r7, #4]
34003016:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003018:	f043 0220 	orr.w	r2, r3, #32
3400301c:	687b      	ldr	r3, [r7, #4]
3400301e:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34003020:	2301      	movs	r3, #1
34003022:	77fb      	strb	r3, [r7, #31]
  }

  __HAL_UNLOCK(hadc);
34003024:	687b      	ldr	r3, [r7, #4]
34003026:	2200      	movs	r2, #0
34003028:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
3400302c:	7ffb      	ldrb	r3, [r7, #31]
}
3400302e:	4618      	mov	r0, r3
34003030:	3724      	adds	r7, #36	@ 0x24
34003032:	46bd      	mov	sp, r7
34003034:	bd90      	pop	{r4, r7, pc}
34003036:	bf00      	nop
34003038:	43ff0000 	.word	0x43ff0000
3400303c:	01000810 	.word	0x01000810
34003040:	00040811 	.word	0x00040811
34003044:	00400411 	.word	0x00400411
34003048:	50022000 	.word	0x50022000
3400304c:	3400dfe4 	.word	0x3400dfe4
34003050:	50022300 	.word	0x50022300
34003054:	50022100 	.word	0x50022100

34003058 <HAL_ADC_AnalogWDGConfig>:
  * @param hadc ADC handle
  * @param pAnalogWDGConfig Structure of ADC analog watchdog configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef *hadc, const ADC_AnalogWDGConfTypeDef *pAnalogWDGConfig)
{
34003058:	b580      	push	{r7, lr}
3400305a:	b088      	sub	sp, #32
3400305c:	af00      	add	r7, sp, #0
3400305e:	6078      	str	r0, [r7, #4]
34003060:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34003062:	2300      	movs	r3, #0
34003064:	77fb      	strb	r3, [r7, #31]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_ANALOG_WATCHDOG_NUMBER(pAnalogWDGConfig->WatchdogNumber));
  assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(pAnalogWDGConfig->WatchdogMode));
  assert_param(IS_FUNCTIONAL_STATE(pAnalogWDGConfig->ITMode));

  if ((pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
34003066:	683b      	ldr	r3, [r7, #0]
34003068:	685b      	ldr	r3, [r3, #4]
3400306a:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
3400306e:	d003      	beq.n	34003078 <HAL_ADC_AnalogWDGConfig+0x20>
      (pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
34003070:	683b      	ldr	r3, [r7, #0]
34003072:	685b      	ldr	r3, [r3, #4]
  if ((pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
34003074:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), pAnalogWDGConfig->HighThreshold));
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), pAnalogWDGConfig->LowThreshold));
  }

  /* ADC must be disabled to set configuration bits                           */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34003078:	687b      	ldr	r3, [r7, #4]
3400307a:	681b      	ldr	r3, [r3, #0]
3400307c:	4618      	mov	r0, r3
3400307e:	f7ff f84b 	bl	34002118 <LL_ADC_IsEnabled>
34003082:	4603      	mov	r3, r0
34003084:	2b00      	cmp	r3, #0
34003086:	d001      	beq.n	3400308c <HAL_ADC_AnalogWDGConfig+0x34>
  {
    return HAL_ERROR;
34003088:	2301      	movs	r3, #1
3400308a:	e1f4      	b.n	34003476 <HAL_ADC_AnalogWDGConfig+0x41e>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
3400308c:	687b      	ldr	r3, [r7, #4]
3400308e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003092:	2b01      	cmp	r3, #1
34003094:	d101      	bne.n	3400309a <HAL_ADC_AnalogWDGConfig+0x42>
34003096:	2302      	movs	r3, #2
34003098:	e1ed      	b.n	34003476 <HAL_ADC_AnalogWDGConfig+0x41e>
3400309a:	687b      	ldr	r3, [r7, #4]
3400309c:	2201      	movs	r2, #1
3400309e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on ADC groups regular and injected:                  */
  /*  - Analog watchdog channels                                              */
  /*  - Analog watchdog thresholds                                            */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
340030a2:	687b      	ldr	r3, [r7, #4]
340030a4:	681b      	ldr	r3, [r3, #0]
340030a6:	4618      	mov	r0, r3
340030a8:	f7ff f880 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
340030ac:	61b8      	str	r0, [r7, #24]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
340030ae:	687b      	ldr	r3, [r7, #4]
340030b0:	681b      	ldr	r3, [r3, #0]
340030b2:	4618      	mov	r0, r3
340030b4:	f7ff f89f 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
340030b8:	6178      	str	r0, [r7, #20]

  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
340030ba:	69bb      	ldr	r3, [r7, #24]
340030bc:	2b00      	cmp	r3, #0
340030be:	f040 81cd 	bne.w	3400345c <HAL_ADC_AnalogWDGConfig+0x404>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
340030c2:	697b      	ldr	r3, [r7, #20]
340030c4:	2b00      	cmp	r3, #0
340030c6:	f040 81c9 	bne.w	3400345c <HAL_ADC_AnalogWDGConfig+0x404>
     )
  {
    /* Format analog watchdog thresholds data in function of the selected ADC resolution */
    tmp_adc_resolution = LL_ADC_GetResolution(hadc->Instance);
340030ca:	687b      	ldr	r3, [r7, #4]
340030cc:	681b      	ldr	r3, [r3, #0]
340030ce:	4618      	mov	r0, r3
340030d0:	f7fe fc8d 	bl	340019ee <LL_ADC_GetResolution>
340030d4:	6138      	str	r0, [r7, #16]
    tmp_awd_high_threshold_shifted = __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(tmp_adc_resolution,
340030d6:	683b      	ldr	r3, [r7, #0]
340030d8:	691a      	ldr	r2, [r3, #16]
340030da:	693b      	ldr	r3, [r7, #16]
340030dc:	085b      	lsrs	r3, r3, #1
340030de:	fa02 f303 	lsl.w	r3, r2, r3
340030e2:	60fb      	str	r3, [r7, #12]
                                                                                pAnalogWDGConfig->HighThreshold);
    tmp_awd_low_threshold_shifted = __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(tmp_adc_resolution,
340030e4:	683b      	ldr	r3, [r7, #0]
340030e6:	695a      	ldr	r2, [r3, #20]
340030e8:	693b      	ldr	r3, [r7, #16]
340030ea:	085b      	lsrs	r3, r3, #1
340030ec:	fa02 f303 	lsl.w	r3, r2, r3
340030f0:	60bb      	str	r3, [r7, #8]
                                                                               pAnalogWDGConfig->LowThreshold);

    /* Analog watchdog configuration */
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
340030f2:	683b      	ldr	r3, [r7, #0]
340030f4:	681b      	ldr	r3, [r3, #0]
340030f6:	4a96      	ldr	r2, [pc, #600]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
340030f8:	4293      	cmp	r3, r2
340030fa:	f040 80be 	bne.w	3400327a <HAL_ADC_AnalogWDGConfig+0x222>
    {
      /* Configuration of analog watchdog:                                    */
      /*  - Set the analog watchdog enable mode: one or overall group of      */
      /*    channels, on groups regular and-or injected.                      */
      switch (pAnalogWDGConfig->WatchdogMode)
340030fe:	683b      	ldr	r3, [r7, #0]
34003100:	685b      	ldr	r3, [r3, #4]
34003102:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003106:	d04a      	beq.n	3400319e <HAL_ADC_AnalogWDGConfig+0x146>
34003108:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
3400310c:	d877      	bhi.n	340031fe <HAL_ADC_AnalogWDGConfig+0x1a6>
3400310e:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003112:	d06c      	beq.n	340031ee <HAL_ADC_AnalogWDGConfig+0x196>
34003114:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003118:	d871      	bhi.n	340031fe <HAL_ADC_AnalogWDGConfig+0x1a6>
3400311a:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
3400311e:	d026      	beq.n	3400316e <HAL_ADC_AnalogWDGConfig+0x116>
34003120:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
34003124:	d86b      	bhi.n	340031fe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003126:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400312a:	d058      	beq.n	340031de <HAL_ADC_AnalogWDGConfig+0x186>
3400312c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003130:	d865      	bhi.n	340031fe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003132:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
34003136:	d04a      	beq.n	340031ce <HAL_ADC_AnalogWDGConfig+0x176>
34003138:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
3400313c:	d15f      	bne.n	340031fe <HAL_ADC_AnalogWDGConfig+0x1a6>
      {
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
3400313e:	687b      	ldr	r3, [r7, #4]
34003140:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
34003142:	683b      	ldr	r3, [r7, #0]
34003144:	689b      	ldr	r3, [r3, #8]
34003146:	069b      	lsls	r3, r3, #26
34003148:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
3400314c:	683b      	ldr	r3, [r7, #0]
3400314e:	689b      	ldr	r3, [r3, #8]
34003150:	b2db      	uxtb	r3, r3
34003152:	4619      	mov	r1, r3
34003154:	4b7f      	ldr	r3, [pc, #508]	@ (34003354 <HAL_ADC_AnalogWDGConfig+0x2fc>)
34003156:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
3400315a:	f3c3 0313 	ubfx	r3, r3, #0, #20
3400315e:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003160:	f443 0340 	orr.w	r3, r3, #12582912	@ 0xc00000
34003164:	461a      	mov	r2, r3
34003166:	497a      	ldr	r1, [pc, #488]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003168:	f7fe fefc 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_REGULAR));
          break;
3400316c:	e04f      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
3400316e:	687b      	ldr	r3, [r7, #4]
34003170:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
34003172:	683b      	ldr	r3, [r7, #0]
34003174:	689b      	ldr	r3, [r3, #8]
34003176:	069b      	lsls	r3, r3, #26
34003178:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
3400317c:	683b      	ldr	r3, [r7, #0]
3400317e:	689b      	ldr	r3, [r3, #8]
34003180:	b2db      	uxtb	r3, r3
34003182:	4619      	mov	r1, r3
34003184:	4b73      	ldr	r3, [pc, #460]	@ (34003354 <HAL_ADC_AnalogWDGConfig+0x2fc>)
34003186:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
3400318a:	f3c3 0313 	ubfx	r3, r3, #0, #20
3400318e:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003190:	f043 73a0 	orr.w	r3, r3, #20971520	@ 0x1400000
34003194:	461a      	mov	r2, r3
34003196:	496e      	ldr	r1, [pc, #440]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003198:	f7fe fee4 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_INJECTED));
          break;
3400319c:	e037      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
3400319e:	687b      	ldr	r3, [r7, #4]
340031a0:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
340031a2:	683b      	ldr	r3, [r7, #0]
340031a4:	689b      	ldr	r3, [r3, #8]
340031a6:	069b      	lsls	r3, r3, #26
340031a8:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
340031ac:	683b      	ldr	r3, [r7, #0]
340031ae:	689b      	ldr	r3, [r3, #8]
340031b0:	b2db      	uxtb	r3, r3
340031b2:	4619      	mov	r1, r3
340031b4:	4b67      	ldr	r3, [pc, #412]	@ (34003354 <HAL_ADC_AnalogWDGConfig+0x2fc>)
340031b6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
340031ba:	f3c3 0313 	ubfx	r3, r3, #0, #20
340031be:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
340031c0:	f043 73e0 	orr.w	r3, r3, #29360128	@ 0x1c00000
340031c4:	461a      	mov	r2, r3
340031c6:	4962      	ldr	r1, [pc, #392]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
340031c8:	f7fe fecc 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_REGULAR_INJECTED));
          break;
340031cc:	e01f      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG);
340031ce:	687b      	ldr	r3, [r7, #4]
340031d0:	681b      	ldr	r3, [r3, #0]
340031d2:	4a61      	ldr	r2, [pc, #388]	@ (34003358 <HAL_ADC_AnalogWDGConfig+0x300>)
340031d4:	495e      	ldr	r1, [pc, #376]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
340031d6:	4618      	mov	r0, r3
340031d8:	f7fe fec4 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
          break;
340031dc:	e017      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_INJ);
340031de:	687b      	ldr	r3, [r7, #4]
340031e0:	681b      	ldr	r3, [r3, #0]
340031e2:	4a5e      	ldr	r2, [pc, #376]	@ (3400335c <HAL_ADC_AnalogWDGConfig+0x304>)
340031e4:	495a      	ldr	r1, [pc, #360]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
340031e6:	4618      	mov	r0, r3
340031e8:	f7fe febc 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
          break;
340031ec:	e00f      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
340031ee:	687b      	ldr	r3, [r7, #4]
340031f0:	681b      	ldr	r3, [r3, #0]
340031f2:	4a5b      	ldr	r2, [pc, #364]	@ (34003360 <HAL_ADC_AnalogWDGConfig+0x308>)
340031f4:	4956      	ldr	r1, [pc, #344]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
340031f6:	4618      	mov	r0, r3
340031f8:	f7fe feb4 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
          break;
340031fc:	e007      	b.n	3400320e <HAL_ADC_AnalogWDGConfig+0x1b6>

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_DISABLE);
340031fe:	687b      	ldr	r3, [r7, #4]
34003200:	681b      	ldr	r3, [r3, #0]
34003202:	2200      	movs	r2, #0
34003204:	4952      	ldr	r1, [pc, #328]	@ (34003350 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003206:	4618      	mov	r0, r3
34003208:	f7fe feac 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
          break;
3400320c:	bf00      	nop
      }

      /* Set the filtering configuration */
      assert_param(IS_ADC_ANALOG_WATCHDOG_FILTERING_MODE(pAnalogWDGConfig->FilteringConfig));
      LL_ADC_SetAWDFilteringConfiguration(hadc->Instance, hadc->Instance->AWD1HTR, pAnalogWDGConfig->FilteringConfig);
3400320e:	687b      	ldr	r3, [r7, #4]
34003210:	6818      	ldr	r0, [r3, #0]
34003212:	687b      	ldr	r3, [r7, #4]
34003214:	681b      	ldr	r3, [r3, #0]
34003216:	f8d3 10ac 	ldr.w	r1, [r3, #172]	@ 0xac
3400321a:	683b      	ldr	r3, [r7, #0]
3400321c:	699b      	ldr	r3, [r3, #24]
3400321e:	461a      	mov	r2, r3
34003220:	f7fe fefe 	bl	34002020 <LL_ADC_SetAWDFilteringConfiguration>

      /* Set ADC analog watchdog thresholds value of both thresholds high and low */
      LL_ADC_SetAnalogWDThresholds(hadc->Instance, pAnalogWDGConfig->WatchdogNumber,
34003224:	687b      	ldr	r3, [r7, #4]
34003226:	6818      	ldr	r0, [r3, #0]
34003228:	683b      	ldr	r3, [r7, #0]
3400322a:	6819      	ldr	r1, [r3, #0]
3400322c:	68fb      	ldr	r3, [r7, #12]
3400322e:	2201      	movs	r2, #1
34003230:	f7fe fec6 	bl	34001fc0 <LL_ADC_SetAnalogWDThresholds>
                                   LL_ADC_AWD_THRESHOLD_HIGH, tmp_awd_high_threshold_shifted);
      LL_ADC_SetAnalogWDThresholds(hadc->Instance, pAnalogWDGConfig->WatchdogNumber,
34003234:	687b      	ldr	r3, [r7, #4]
34003236:	6818      	ldr	r0, [r3, #0]
34003238:	683b      	ldr	r3, [r7, #0]
3400323a:	6819      	ldr	r1, [r3, #0]
3400323c:	68bb      	ldr	r3, [r7, #8]
3400323e:	2200      	movs	r2, #0
34003240:	f7fe febe 	bl	34001fc0 <LL_ADC_SetAnalogWDThresholds>
                                   LL_ADC_AWD_THRESHOLD_LOW, tmp_awd_low_threshold_shifted);

      /* Update state, clear previous result related to AWD1 */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD1);
34003244:	687b      	ldr	r3, [r7, #4]
34003246:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003248:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
3400324c:	687b      	ldr	r3, [r7, #4]
3400324e:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Clear flag ADC analog watchdog */
      /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
      /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
      /* (in case left enabled by previous ADC operations).                 */
      LL_ADC_ClearFlag_AWD1(hadc->Instance);
34003250:	687b      	ldr	r3, [r7, #4]
34003252:	681b      	ldr	r3, [r3, #0]
34003254:	4618      	mov	r0, r3
34003256:	f7fe ffe1 	bl	3400221c <LL_ADC_ClearFlag_AWD1>

      /* Configure ADC analog watchdog interrupt */
      if (pAnalogWDGConfig->ITMode == ENABLE)
3400325a:	683b      	ldr	r3, [r7, #0]
3400325c:	7b1b      	ldrb	r3, [r3, #12]
3400325e:	2b01      	cmp	r3, #1
34003260:	d105      	bne.n	3400326e <HAL_ADC_AnalogWDGConfig+0x216>
      {
        LL_ADC_EnableIT_AWD1(hadc->Instance);
34003262:	687b      	ldr	r3, [r7, #4]
34003264:	681b      	ldr	r3, [r3, #0]
34003266:	4618      	mov	r0, r3
34003268:	f7ff f801 	bl	3400226e <LL_ADC_EnableIT_AWD1>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
3400326c:	e0fe      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
      }
      else
      {
        LL_ADC_DisableIT_AWD1(hadc->Instance);
3400326e:	687b      	ldr	r3, [r7, #4]
34003270:	681b      	ldr	r3, [r3, #0]
34003272:	4618      	mov	r0, r3
34003274:	f7ff f82b 	bl	340022ce <LL_ADC_DisableIT_AWD1>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003278:	e0f8      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
      }
    }
    /* Case of ADC_ANALOGWATCHDOG_2 or ADC_ANALOGWATCHDOG_3 */
    else
    {
      switch (pAnalogWDGConfig->WatchdogMode)
3400327a:	683b      	ldr	r3, [r7, #0]
3400327c:	685b      	ldr	r3, [r3, #4]
3400327e:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003282:	d01a      	beq.n	340032ba <HAL_ADC_AnalogWDGConfig+0x262>
34003284:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003288:	d86e      	bhi.n	34003368 <HAL_ADC_AnalogWDGConfig+0x310>
3400328a:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
3400328e:	d039      	beq.n	34003304 <HAL_ADC_AnalogWDGConfig+0x2ac>
34003290:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003294:	d868      	bhi.n	34003368 <HAL_ADC_AnalogWDGConfig+0x310>
34003296:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
3400329a:	d00e      	beq.n	340032ba <HAL_ADC_AnalogWDGConfig+0x262>
3400329c:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
340032a0:	d862      	bhi.n	34003368 <HAL_ADC_AnalogWDGConfig+0x310>
340032a2:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340032a6:	d02d      	beq.n	34003304 <HAL_ADC_AnalogWDGConfig+0x2ac>
340032a8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340032ac:	d85c      	bhi.n	34003368 <HAL_ADC_AnalogWDGConfig+0x310>
340032ae:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
340032b2:	d027      	beq.n	34003304 <HAL_ADC_AnalogWDGConfig+0x2ac>
340032b4:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
340032b8:	d156      	bne.n	34003368 <HAL_ADC_AnalogWDGConfig+0x310>
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          /* Update AWD by bitfield to keep the possibility to monitor        */
          /* several channels by successive calls of this function.           */
          if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
340032ba:	683b      	ldr	r3, [r7, #0]
340032bc:	681b      	ldr	r3, [r3, #0]
340032be:	4a29      	ldr	r2, [pc, #164]	@ (34003364 <HAL_ADC_AnalogWDGConfig+0x30c>)
340032c0:	4293      	cmp	r3, r2
340032c2:	d10f      	bne.n	340032e4 <HAL_ADC_AnalogWDGConfig+0x28c>
          {
            SET_BIT(hadc->Instance->AWD2CR, (1UL                                                       \
340032c4:	687b      	ldr	r3, [r7, #4]
340032c6:	681b      	ldr	r3, [r3, #0]
340032c8:	f8d3 10a0 	ldr.w	r1, [r3, #160]	@ 0xa0
340032cc:	683b      	ldr	r3, [r7, #0]
340032ce:	689b      	ldr	r3, [r3, #8]
340032d0:	f003 031f 	and.w	r3, r3, #31
340032d4:	2201      	movs	r2, #1
340032d6:	409a      	lsls	r2, r3
340032d8:	687b      	ldr	r3, [r7, #4]
340032da:	681b      	ldr	r3, [r3, #0]
340032dc:	430a      	orrs	r2, r1
340032de:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
          else
          {
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                      \
                                             << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(pAnalogWDGConfig->Channel) & 0x1FUL)));
          }
          break;
340032e2:	e04a      	b.n	3400337a <HAL_ADC_AnalogWDGConfig+0x322>
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                      \
340032e4:	687b      	ldr	r3, [r7, #4]
340032e6:	681b      	ldr	r3, [r3, #0]
340032e8:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
340032ec:	683b      	ldr	r3, [r7, #0]
340032ee:	689b      	ldr	r3, [r3, #8]
340032f0:	f003 031f 	and.w	r3, r3, #31
340032f4:	2201      	movs	r2, #1
340032f6:	409a      	lsls	r2, r3
340032f8:	687b      	ldr	r3, [r7, #4]
340032fa:	681b      	ldr	r3, [r3, #0]
340032fc:	430a      	orrs	r2, r1
340032fe:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
          break;
34003302:	e03a      	b.n	3400337a <HAL_ADC_AnalogWDGConfig+0x322>
        case ADC_ANALOGWATCHDOG_ALL_REG:
        case ADC_ANALOGWATCHDOG_ALL_INJEC:
        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          /* Update AWD by bitfield to keep the possibility to monitor        */
          /* several channels by successive calls of this function.           */
          if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
34003304:	683b      	ldr	r3, [r7, #0]
34003306:	681b      	ldr	r3, [r3, #0]
34003308:	4a16      	ldr	r2, [pc, #88]	@ (34003364 <HAL_ADC_AnalogWDGConfig+0x30c>)
3400330a:	4293      	cmp	r3, r2
3400330c:	d10f      	bne.n	3400332e <HAL_ADC_AnalogWDGConfig+0x2d6>
          {
            SET_BIT(hadc->Instance->AWD2CR, (1UL                                                           \
3400330e:	687b      	ldr	r3, [r7, #4]
34003310:	681b      	ldr	r3, [r3, #0]
34003312:	f8d3 10a0 	ldr.w	r1, [r3, #160]	@ 0xa0
34003316:	683b      	ldr	r3, [r7, #0]
34003318:	689b      	ldr	r3, [r3, #8]
3400331a:	f003 031f 	and.w	r3, r3, #31
3400331e:	2201      	movs	r2, #1
34003320:	409a      	lsls	r2, r3
34003322:	687b      	ldr	r3, [r7, #4]
34003324:	681b      	ldr	r3, [r3, #0]
34003326:	430a      	orrs	r2, r1
34003328:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
          else
          {
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                        \
                                             << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(pAnalogWDGConfig->Channel) & 0x1FUL)));
          }
          break;
3400332c:	e025      	b.n	3400337a <HAL_ADC_AnalogWDGConfig+0x322>
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                        \
3400332e:	687b      	ldr	r3, [r7, #4]
34003330:	681b      	ldr	r3, [r3, #0]
34003332:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
34003336:	683b      	ldr	r3, [r7, #0]
34003338:	689b      	ldr	r3, [r3, #8]
3400333a:	f003 031f 	and.w	r3, r3, #31
3400333e:	2201      	movs	r2, #1
34003340:	409a      	lsls	r2, r3
34003342:	687b      	ldr	r3, [r7, #4]
34003344:	681b      	ldr	r3, [r3, #0]
34003346:	430a      	orrs	r2, r1
34003348:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
          break;
3400334c:	e015      	b.n	3400337a <HAL_ADC_AnalogWDGConfig+0x322>
3400334e:	bf00      	nop
34003350:	7dc00000 	.word	0x7dc00000
34003354:	3400df94 	.word	0x3400df94
34003358:	008fffff 	.word	0x008fffff
3400335c:	010fffff 	.word	0x010fffff
34003360:	018fffff 	.word	0x018fffff
34003364:	001fffff 	.word	0x001fffff

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, pAnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_DISABLE);
34003368:	687b      	ldr	r3, [r7, #4]
3400336a:	6818      	ldr	r0, [r3, #0]
3400336c:	683b      	ldr	r3, [r7, #0]
3400336e:	681b      	ldr	r3, [r3, #0]
34003370:	2200      	movs	r2, #0
34003372:	4619      	mov	r1, r3
34003374:	f7fe fdf6 	bl	34001f64 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003378:	bf00      	nop
      }

      if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
3400337a:	683b      	ldr	r3, [r7, #0]
3400337c:	681b      	ldr	r3, [r3, #0]
3400337e:	4a40      	ldr	r2, [pc, #256]	@ (34003480 <HAL_ADC_AnalogWDGConfig+0x428>)
34003380:	4293      	cmp	r3, r2
34003382:	d118      	bne.n	340033b6 <HAL_ADC_AnalogWDGConfig+0x35e>
      {
        /* Set ADC analog watchdog thresholds value of both thresholds high and low */
        MODIFY_REG(hadc->Instance->AWD2LTR, ADC_AWD2LTR_LTR, tmp_awd_low_threshold_shifted);
34003384:	687b      	ldr	r3, [r7, #4]
34003386:	681b      	ldr	r3, [r3, #0]
34003388:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400338c:	0ddb      	lsrs	r3, r3, #23
3400338e:	05db      	lsls	r3, r3, #23
34003390:	687a      	ldr	r2, [r7, #4]
34003392:	6812      	ldr	r2, [r2, #0]
34003394:	68b9      	ldr	r1, [r7, #8]
34003396:	430b      	orrs	r3, r1
34003398:	f8c2 30b0 	str.w	r3, [r2, #176]	@ 0xb0
        MODIFY_REG(hadc->Instance->AWD2HTR, ADC_AWD2HTR_HTR, tmp_awd_high_threshold_shifted);
3400339c:	687b      	ldr	r3, [r7, #4]
3400339e:	681b      	ldr	r3, [r3, #0]
340033a0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
340033a4:	0ddb      	lsrs	r3, r3, #23
340033a6:	05db      	lsls	r3, r3, #23
340033a8:	687a      	ldr	r2, [r7, #4]
340033aa:	6812      	ldr	r2, [r2, #0]
340033ac:	68f9      	ldr	r1, [r7, #12]
340033ae:	430b      	orrs	r3, r1
340033b0:	f8c2 30b4 	str.w	r3, [r2, #180]	@ 0xb4
340033b4:	e017      	b.n	340033e6 <HAL_ADC_AnalogWDGConfig+0x38e>
      }
      else
      {
        /* Set ADC analog watchdog thresholds value of both thresholds high and low */
        MODIFY_REG(hadc->Instance->AWD3LTR, ADC_AWD3LTR_LTR, tmp_awd_low_threshold_shifted);
340033b6:	687b      	ldr	r3, [r7, #4]
340033b8:	681b      	ldr	r3, [r3, #0]
340033ba:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340033be:	0ddb      	lsrs	r3, r3, #23
340033c0:	05db      	lsls	r3, r3, #23
340033c2:	687a      	ldr	r2, [r7, #4]
340033c4:	6812      	ldr	r2, [r2, #0]
340033c6:	68b9      	ldr	r1, [r7, #8]
340033c8:	430b      	orrs	r3, r1
340033ca:	f8c2 30b8 	str.w	r3, [r2, #184]	@ 0xb8
        MODIFY_REG(hadc->Instance->AWD3HTR, ADC_AWD3HTR_HTR, tmp_awd_high_threshold_shifted);
340033ce:	687b      	ldr	r3, [r7, #4]
340033d0:	681b      	ldr	r3, [r3, #0]
340033d2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340033d6:	0ddb      	lsrs	r3, r3, #23
340033d8:	05db      	lsls	r3, r3, #23
340033da:	687a      	ldr	r2, [r7, #4]
340033dc:	6812      	ldr	r2, [r2, #0]
340033de:	68f9      	ldr	r1, [r7, #12]
340033e0:	430b      	orrs	r3, r1
340033e2:	f8c2 30bc 	str.w	r3, [r2, #188]	@ 0xbc
      }

      if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
340033e6:	683b      	ldr	r3, [r7, #0]
340033e8:	681b      	ldr	r3, [r3, #0]
340033ea:	4a25      	ldr	r2, [pc, #148]	@ (34003480 <HAL_ADC_AnalogWDGConfig+0x428>)
340033ec:	4293      	cmp	r3, r2
340033ee:	d11a      	bne.n	34003426 <HAL_ADC_AnalogWDGConfig+0x3ce>
      {
        /* Update state, clear previous result related to AWD2 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD2);
340033f0:	687b      	ldr	r3, [r7, #4]
340033f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340033f4:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
340033f8:	687b      	ldr	r3, [r7, #4]
340033fa:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD2(hadc->Instance);
340033fc:	687b      	ldr	r3, [r7, #4]
340033fe:	681b      	ldr	r3, [r3, #0]
34003400:	4618      	mov	r0, r3
34003402:	f7fe ff18 	bl	34002236 <LL_ADC_ClearFlag_AWD2>

        /* Configure ADC analog watchdog interrupt */
        if (pAnalogWDGConfig->ITMode == ENABLE)
34003406:	683b      	ldr	r3, [r7, #0]
34003408:	7b1b      	ldrb	r3, [r3, #12]
3400340a:	2b01      	cmp	r3, #1
3400340c:	d105      	bne.n	3400341a <HAL_ADC_AnalogWDGConfig+0x3c2>
        {
          LL_ADC_EnableIT_AWD2(hadc->Instance);
3400340e:	687b      	ldr	r3, [r7, #4]
34003410:	681b      	ldr	r3, [r3, #0]
34003412:	4618      	mov	r0, r3
34003414:	f7fe ff3b 	bl	3400228e <LL_ADC_EnableIT_AWD2>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003418:	e028      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
        }
        else
        {
          LL_ADC_DisableIT_AWD2(hadc->Instance);
3400341a:	687b      	ldr	r3, [r7, #4]
3400341c:	681b      	ldr	r3, [r3, #0]
3400341e:	4618      	mov	r0, r3
34003420:	f7fe ff65 	bl	340022ee <LL_ADC_DisableIT_AWD2>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003424:	e022      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
      }
      /* (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_3) */
      else
      {
        /* Update state, clear previous result related to AWD3 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD3);
34003426:	687b      	ldr	r3, [r7, #4]
34003428:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400342a:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
3400342e:	687b      	ldr	r3, [r7, #4]
34003430:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD3(hadc->Instance);
34003432:	687b      	ldr	r3, [r7, #4]
34003434:	681b      	ldr	r3, [r3, #0]
34003436:	4618      	mov	r0, r3
34003438:	f7fe ff0b 	bl	34002252 <LL_ADC_ClearFlag_AWD3>

        /* Configure ADC analog watchdog interrupt */
        if (pAnalogWDGConfig->ITMode == ENABLE)
3400343c:	683b      	ldr	r3, [r7, #0]
3400343e:	7b1b      	ldrb	r3, [r3, #12]
34003440:	2b01      	cmp	r3, #1
34003442:	d105      	bne.n	34003450 <HAL_ADC_AnalogWDGConfig+0x3f8>
        {
          LL_ADC_EnableIT_AWD3(hadc->Instance);
34003444:	687b      	ldr	r3, [r7, #4]
34003446:	681b      	ldr	r3, [r3, #0]
34003448:	4618      	mov	r0, r3
3400344a:	f7fe ff30 	bl	340022ae <LL_ADC_EnableIT_AWD3>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
3400344e:	e00d      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
        }
        else
        {
          LL_ADC_DisableIT_AWD3(hadc->Instance);
34003450:	687b      	ldr	r3, [r7, #4]
34003452:	681b      	ldr	r3, [r3, #0]
34003454:	4618      	mov	r0, r3
34003456:	f7fe ff5a 	bl	3400230e <LL_ADC_DisableIT_AWD3>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
3400345a:	e007      	b.n	3400346c <HAL_ADC_AnalogWDGConfig+0x414>
  /* If a conversion is on going on ADC group regular or injected, no update  */
  /* could be done on neither of the AWD configuration structure parameters.  */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
3400345c:	687b      	ldr	r3, [r7, #4]
3400345e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003460:	f043 0220 	orr.w	r2, r3, #32
34003464:	687b      	ldr	r3, [r7, #4]
34003466:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34003468:	2301      	movs	r3, #1
3400346a:	77fb      	strb	r3, [r7, #31]
  }

  __HAL_UNLOCK(hadc);
3400346c:	687b      	ldr	r3, [r7, #4]
3400346e:	2200      	movs	r2, #0
34003470:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34003474:	7ffb      	ldrb	r3, [r7, #31]
}
34003476:	4618      	mov	r0, r3
34003478:	3720      	adds	r7, #32
3400347a:	46bd      	mov	sp, r7
3400347c:	bd80      	pop	{r7, pc}
3400347e:	bf00      	nop
34003480:	001fffff 	.word	0x001fffff

34003484 <ADC_ConversionStop>:
  *            @arg @ref ADC_INJECTED_GROUP          ADC injected conversion type.
  *            @arg @ref ADC_REGULAR_INJECTED_GROUP  ADC regular and injected conversion type.
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc, uint32_t ConversionGroup)
{
34003484:	b580      	push	{r7, lr}
34003486:	b088      	sub	sp, #32
34003488:	af00      	add	r7, sp, #0
3400348a:	6078      	str	r0, [r7, #4]
3400348c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t conversion_timeout_cpu_cycles = 0UL;
3400348e:	2300      	movs	r3, #0
34003490:	61fb      	str	r3, [r7, #28]
  uint32_t conversion_group_reassigned = ConversionGroup;
34003492:	683b      	ldr	r3, [r7, #0]
34003494:	61bb      	str	r3, [r7, #24]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));

  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34003496:	687b      	ldr	r3, [r7, #4]
34003498:	681b      	ldr	r3, [r3, #0]
3400349a:	4618      	mov	r0, r3
3400349c:	f7fe fe86 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
340034a0:	6138      	str	r0, [r7, #16]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
340034a2:	687b      	ldr	r3, [r7, #4]
340034a4:	681b      	ldr	r3, [r3, #0]
340034a6:	4618      	mov	r0, r3
340034a8:	f7fe fea5 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
340034ac:	60f8      	str	r0, [r7, #12]
  if ((tmp_adc_is_conversion_on_going_regular != 0UL)
340034ae:	693b      	ldr	r3, [r7, #16]
340034b0:	2b00      	cmp	r3, #0
340034b2:	d103      	bne.n	340034bc <ADC_ConversionStop+0x38>
      || (tmp_adc_is_conversion_on_going_injected != 0UL)
340034b4:	68fb      	ldr	r3, [r7, #12]
340034b6:	2b00      	cmp	r3, #0
340034b8:	f000 8098 	beq.w	340035ec <ADC_ConversionStop+0x168>
    /* auto-delay mode.                                                       */
    /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
    /* injected group stop ADC_CR_JADSTP).                                    */
    /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
    /* (see reference manual).                                                */
    if (((hadc->Instance->CFGR1 & ADC_CFGR1_JAUTO) != 0UL)
340034bc:	687b      	ldr	r3, [r7, #4]
340034be:	681b      	ldr	r3, [r3, #0]
340034c0:	68db      	ldr	r3, [r3, #12]
340034c2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
340034c6:	2b00      	cmp	r3, #0
340034c8:	d02a      	beq.n	34003520 <ADC_ConversionStop+0x9c>
        && (hadc->Init.ContinuousConvMode == ENABLE)
340034ca:	687b      	ldr	r3, [r7, #4]
340034cc:	7d5b      	ldrb	r3, [r3, #21]
340034ce:	2b01      	cmp	r3, #1
340034d0:	d126      	bne.n	34003520 <ADC_ConversionStop+0x9c>
        && (hadc->Init.LowPowerAutoWait == ENABLE)
340034d2:	687b      	ldr	r3, [r7, #4]
340034d4:	7d1b      	ldrb	r3, [r3, #20]
340034d6:	2b01      	cmp	r3, #1
340034d8:	d122      	bne.n	34003520 <ADC_ConversionStop+0x9c>
       )
    {
      /* Use stop of regular group */
      conversion_group_reassigned = ADC_REGULAR_GROUP;
340034da:	2301      	movs	r3, #1
340034dc:	61bb      	str	r3, [r7, #24]

      /* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
340034de:	e014      	b.n	3400350a <ADC_ConversionStop+0x86>
      {
        if (conversion_timeout_cpu_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
340034e0:	69fb      	ldr	r3, [r7, #28]
340034e2:	4a45      	ldr	r2, [pc, #276]	@ (340035f8 <ADC_ConversionStop+0x174>)
340034e4:	4293      	cmp	r3, r2
340034e6:	d90d      	bls.n	34003504 <ADC_ConversionStop+0x80>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340034e8:	687b      	ldr	r3, [r7, #4]
340034ea:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340034ec:	f043 0210 	orr.w	r2, r3, #16
340034f0:	687b      	ldr	r3, [r7, #4]
340034f2:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340034f4:	687b      	ldr	r3, [r7, #4]
340034f6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340034f8:	f043 0201 	orr.w	r2, r3, #1
340034fc:	687b      	ldr	r3, [r7, #4]
340034fe:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
34003500:	2301      	movs	r3, #1
34003502:	e074      	b.n	340035ee <ADC_ConversionStop+0x16a>
        }
        conversion_timeout_cpu_cycles ++;
34003504:	69fb      	ldr	r3, [r7, #28]
34003506:	3301      	adds	r3, #1
34003508:	61fb      	str	r3, [r7, #28]
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
3400350a:	687b      	ldr	r3, [r7, #4]
3400350c:	681b      	ldr	r3, [r3, #0]
3400350e:	681b      	ldr	r3, [r3, #0]
34003510:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34003514:	2b40      	cmp	r3, #64	@ 0x40
34003516:	d1e3      	bne.n	340034e0 <ADC_ConversionStop+0x5c>
      }

      /* Clear JEOS */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
34003518:	687b      	ldr	r3, [r7, #4]
3400351a:	681b      	ldr	r3, [r3, #0]
3400351c:	2240      	movs	r2, #64	@ 0x40
3400351e:	601a      	str	r2, [r3, #0]
    }

    /* Stop potential conversion on going on ADC group regular */
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
34003520:	69bb      	ldr	r3, [r7, #24]
34003522:	2b02      	cmp	r3, #2
34003524:	d014      	beq.n	34003550 <ADC_ConversionStop+0xcc>
    {
      /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
34003526:	687b      	ldr	r3, [r7, #4]
34003528:	681b      	ldr	r3, [r3, #0]
3400352a:	4618      	mov	r0, r3
3400352c:	f7fe fe3e 	bl	340021ac <LL_ADC_REG_IsConversionOngoing>
34003530:	4603      	mov	r3, r0
34003532:	2b00      	cmp	r3, #0
34003534:	d00c      	beq.n	34003550 <ADC_ConversionStop+0xcc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
34003536:	687b      	ldr	r3, [r7, #4]
34003538:	681b      	ldr	r3, [r3, #0]
3400353a:	4618      	mov	r0, r3
3400353c:	f7fe fdff 	bl	3400213e <LL_ADC_IsDisableOngoing>
34003540:	4603      	mov	r3, r0
34003542:	2b00      	cmp	r3, #0
34003544:	d104      	bne.n	34003550 <ADC_ConversionStop+0xcc>
        {
          /* Stop ADC group regular conversion */
          LL_ADC_REG_StopConversion(hadc->Instance);
34003546:	687b      	ldr	r3, [r7, #4]
34003548:	681b      	ldr	r3, [r3, #0]
3400354a:	4618      	mov	r0, r3
3400354c:	f7fe fe1c 	bl	34002188 <LL_ADC_REG_StopConversion>
        }
      }
    }

    /* Stop potential conversion on going on ADC group injected */
    if (conversion_group_reassigned != ADC_REGULAR_GROUP)
34003550:	69bb      	ldr	r3, [r7, #24]
34003552:	2b01      	cmp	r3, #1
34003554:	d014      	beq.n	34003580 <ADC_ConversionStop+0xfc>
    {
      /* Software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 */
      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
34003556:	687b      	ldr	r3, [r7, #4]
34003558:	681b      	ldr	r3, [r3, #0]
3400355a:	4618      	mov	r0, r3
3400355c:	f7fe fe4b 	bl	340021f6 <LL_ADC_INJ_IsConversionOngoing>
34003560:	4603      	mov	r3, r0
34003562:	2b00      	cmp	r3, #0
34003564:	d00c      	beq.n	34003580 <ADC_ConversionStop+0xfc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
34003566:	687b      	ldr	r3, [r7, #4]
34003568:	681b      	ldr	r3, [r3, #0]
3400356a:	4618      	mov	r0, r3
3400356c:	f7fe fde7 	bl	3400213e <LL_ADC_IsDisableOngoing>
34003570:	4603      	mov	r3, r0
34003572:	2b00      	cmp	r3, #0
34003574:	d104      	bne.n	34003580 <ADC_ConversionStop+0xfc>
        {
          /* Stop ADC group injected conversion */
          LL_ADC_INJ_StopConversion(hadc->Instance);
34003576:	687b      	ldr	r3, [r7, #4]
34003578:	681b      	ldr	r3, [r3, #0]
3400357a:	4618      	mov	r0, r3
3400357c:	f7fe fe29 	bl	340021d2 <LL_ADC_INJ_StopConversion>
        }
      }
    }

    /* Selection of start and stop bits with respect to the regular or injected group */
    switch (conversion_group_reassigned)
34003580:	69bb      	ldr	r3, [r7, #24]
34003582:	2b02      	cmp	r3, #2
34003584:	d005      	beq.n	34003592 <ADC_ConversionStop+0x10e>
34003586:	69bb      	ldr	r3, [r7, #24]
34003588:	2b03      	cmp	r3, #3
3400358a:	d105      	bne.n	34003598 <ADC_ConversionStop+0x114>
    {
      case ADC_REGULAR_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
3400358c:	230c      	movs	r3, #12
3400358e:	617b      	str	r3, [r7, #20]
        break;
34003590:	e005      	b.n	3400359e <ADC_ConversionStop+0x11a>
      case ADC_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
34003592:	2308      	movs	r3, #8
34003594:	617b      	str	r3, [r7, #20]
        break;
34003596:	e002      	b.n	3400359e <ADC_ConversionStop+0x11a>
      /* Case ADC_REGULAR_GROUP only*/
      default:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
34003598:	2304      	movs	r3, #4
3400359a:	617b      	str	r3, [r7, #20]
        break;
3400359c:	bf00      	nop
    }

    /* Wait for conversion effectively stopped */
    tickstart = HAL_GetTick();
3400359e:	f7fe f9d3 	bl	34001948 <HAL_GetTick>
340035a2:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
340035a4:	e01b      	b.n	340035de <ADC_ConversionStop+0x15a>
    {
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
340035a6:	f7fe f9cf 	bl	34001948 <HAL_GetTick>
340035aa:	4602      	mov	r2, r0
340035ac:	68bb      	ldr	r3, [r7, #8]
340035ae:	1ad3      	subs	r3, r2, r3
340035b0:	2b05      	cmp	r3, #5
340035b2:	d914      	bls.n	340035de <ADC_ConversionStop+0x15a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
340035b4:	687b      	ldr	r3, [r7, #4]
340035b6:	681b      	ldr	r3, [r3, #0]
340035b8:	689a      	ldr	r2, [r3, #8]
340035ba:	697b      	ldr	r3, [r7, #20]
340035bc:	4013      	ands	r3, r2
340035be:	2b00      	cmp	r3, #0
340035c0:	d00d      	beq.n	340035de <ADC_ConversionStop+0x15a>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340035c2:	687b      	ldr	r3, [r7, #4]
340035c4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340035c6:	f043 0210 	orr.w	r2, r3, #16
340035ca:	687b      	ldr	r3, [r7, #4]
340035cc:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340035ce:	687b      	ldr	r3, [r7, #4]
340035d0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340035d2:	f043 0201 	orr.w	r2, r3, #1
340035d6:	687b      	ldr	r3, [r7, #4]
340035d8:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
340035da:	2301      	movs	r3, #1
340035dc:	e007      	b.n	340035ee <ADC_ConversionStop+0x16a>
    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
340035de:	687b      	ldr	r3, [r7, #4]
340035e0:	681b      	ldr	r3, [r3, #0]
340035e2:	689a      	ldr	r2, [r3, #8]
340035e4:	697b      	ldr	r3, [r7, #20]
340035e6:	4013      	ands	r3, r2
340035e8:	2b00      	cmp	r3, #0
340035ea:	d1dc      	bne.n	340035a6 <ADC_ConversionStop+0x122>
    }

  }

  /* Return HAL status */
  return HAL_OK;
340035ec:	2300      	movs	r3, #0
}
340035ee:	4618      	mov	r0, r3
340035f0:	3720      	adds	r7, #32
340035f2:	46bd      	mov	sp, r7
340035f4:	bd80      	pop	{r7, pc}
340035f6:	bf00      	nop
340035f8:	a33fffff 	.word	0xa33fffff

340035fc <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
340035fc:	b580      	push	{r7, lr}
340035fe:	b084      	sub	sp, #16
34003600:	af00      	add	r7, sp, #0
34003602:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
34003604:	687b      	ldr	r3, [r7, #4]
34003606:	681b      	ldr	r3, [r3, #0]
34003608:	4618      	mov	r0, r3
3400360a:	f7fe fd85 	bl	34002118 <LL_ADC_IsEnabled>
3400360e:	4603      	mov	r3, r0
34003610:	2b00      	cmp	r3, #0
34003612:	d14d      	bne.n	340036b0 <ADC_Enable+0xb4>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
34003614:	687b      	ldr	r3, [r7, #4]
34003616:	681b      	ldr	r3, [r3, #0]
34003618:	689a      	ldr	r2, [r3, #8]
3400361a:	4b28      	ldr	r3, [pc, #160]	@ (340036bc <ADC_Enable+0xc0>)
3400361c:	4013      	ands	r3, r2
3400361e:	2b00      	cmp	r3, #0
34003620:	d00d      	beq.n	3400363e <ADC_Enable+0x42>
                               | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34003622:	687b      	ldr	r3, [r7, #4]
34003624:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003626:	f043 0210 	orr.w	r2, r3, #16
3400362a:	687b      	ldr	r3, [r7, #4]
3400362c:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
3400362e:	687b      	ldr	r3, [r7, #4]
34003630:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34003632:	f043 0201 	orr.w	r2, r3, #1
34003636:	687b      	ldr	r3, [r7, #4]
34003638:	65da      	str	r2, [r3, #92]	@ 0x5c

      return HAL_ERROR;
3400363a:	2301      	movs	r3, #1
3400363c:	e039      	b.n	340036b2 <ADC_Enable+0xb6>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
3400363e:	687b      	ldr	r3, [r7, #4]
34003640:	681b      	ldr	r3, [r3, #0]
34003642:	4618      	mov	r0, r3
34003644:	f7fe fd44 	bl	340020d0 <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
34003648:	f7fe f97e 	bl	34001948 <HAL_GetTick>
3400364c:	60f8      	str	r0, [r7, #12]

    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
3400364e:	e028      	b.n	340036a2 <ADC_Enable+0xa6>
          The workaround is to continue setting ADEN until ADRDY is becomes 1.
          Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
          4 ADC clock cycle duration */
      /* Note: Test of ADC enabled required due to hardware constraint to     */
      /*       not enable ADC if already enabled.                             */
      if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
34003650:	687b      	ldr	r3, [r7, #4]
34003652:	681b      	ldr	r3, [r3, #0]
34003654:	4618      	mov	r0, r3
34003656:	f7fe fd5f 	bl	34002118 <LL_ADC_IsEnabled>
3400365a:	4603      	mov	r3, r0
3400365c:	2b00      	cmp	r3, #0
3400365e:	d104      	bne.n	3400366a <ADC_Enable+0x6e>
      {
        LL_ADC_Enable(hadc->Instance);
34003660:	687b      	ldr	r3, [r7, #4]
34003662:	681b      	ldr	r3, [r3, #0]
34003664:	4618      	mov	r0, r3
34003666:	f7fe fd33 	bl	340020d0 <LL_ADC_Enable>
      }

      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
3400366a:	f7fe f96d 	bl	34001948 <HAL_GetTick>
3400366e:	4602      	mov	r2, r0
34003670:	68fb      	ldr	r3, [r7, #12]
34003672:	1ad3      	subs	r3, r2, r3
34003674:	2b02      	cmp	r3, #2
34003676:	d914      	bls.n	340036a2 <ADC_Enable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
34003678:	687b      	ldr	r3, [r7, #4]
3400367a:	681b      	ldr	r3, [r3, #0]
3400367c:	681b      	ldr	r3, [r3, #0]
3400367e:	f003 0301 	and.w	r3, r3, #1
34003682:	2b01      	cmp	r3, #1
34003684:	d00d      	beq.n	340036a2 <ADC_Enable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34003686:	687b      	ldr	r3, [r7, #4]
34003688:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400368a:	f043 0210 	orr.w	r2, r3, #16
3400368e:	687b      	ldr	r3, [r7, #4]
34003690:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34003692:	687b      	ldr	r3, [r7, #4]
34003694:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34003696:	f043 0201 	orr.w	r2, r3, #1
3400369a:	687b      	ldr	r3, [r7, #4]
3400369c:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
3400369e:	2301      	movs	r3, #1
340036a0:	e007      	b.n	340036b2 <ADC_Enable+0xb6>
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
340036a2:	687b      	ldr	r3, [r7, #4]
340036a4:	681b      	ldr	r3, [r3, #0]
340036a6:	681b      	ldr	r3, [r3, #0]
340036a8:	f003 0301 	and.w	r3, r3, #1
340036ac:	2b01      	cmp	r3, #1
340036ae:	d1cf      	bne.n	34003650 <ADC_Enable+0x54>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
340036b0:	2300      	movs	r3, #0
}
340036b2:	4618      	mov	r0, r3
340036b4:	3710      	adds	r7, #16
340036b6:	46bd      	mov	sp, r7
340036b8:	bd80      	pop	{r7, pc}
340036ba:	bf00      	nop
340036bc:	8000003f 	.word	0x8000003f

340036c0 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
340036c0:	b580      	push	{r7, lr}
340036c2:	b084      	sub	sp, #16
340036c4:	af00      	add	r7, sp, #0
340036c6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
340036c8:	687b      	ldr	r3, [r7, #4]
340036ca:	681b      	ldr	r3, [r3, #0]
340036cc:	4618      	mov	r0, r3
340036ce:	f7fe fd36 	bl	3400213e <LL_ADC_IsDisableOngoing>
340036d2:	60f8      	str	r0, [r7, #12]

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
340036d4:	687b      	ldr	r3, [r7, #4]
340036d6:	681b      	ldr	r3, [r3, #0]
340036d8:	4618      	mov	r0, r3
340036da:	f7fe fd1d 	bl	34002118 <LL_ADC_IsEnabled>
340036de:	4603      	mov	r3, r0
340036e0:	2b00      	cmp	r3, #0
340036e2:	d047      	beq.n	34003774 <ADC_Disable+0xb4>
      && (tmp_adc_is_disable_on_going == 0UL)
340036e4:	68fb      	ldr	r3, [r7, #12]
340036e6:	2b00      	cmp	r3, #0
340036e8:	d144      	bne.n	34003774 <ADC_Disable+0xb4>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
340036ea:	687b      	ldr	r3, [r7, #4]
340036ec:	681b      	ldr	r3, [r3, #0]
340036ee:	689b      	ldr	r3, [r3, #8]
340036f0:	f003 030d 	and.w	r3, r3, #13
340036f4:	2b01      	cmp	r3, #1
340036f6:	d10c      	bne.n	34003712 <ADC_Disable+0x52>
    {
      /* Disable the ADC peripheral */
      LL_ADC_Disable(hadc->Instance);
340036f8:	687b      	ldr	r3, [r7, #4]
340036fa:	681b      	ldr	r3, [r3, #0]
340036fc:	4618      	mov	r0, r3
340036fe:	f7fe fcf9 	bl	340020f4 <LL_ADC_Disable>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
34003702:	687b      	ldr	r3, [r7, #4]
34003704:	681b      	ldr	r3, [r3, #0]
34003706:	2203      	movs	r2, #3
34003708:	601a      	str	r2, [r3, #0]
      return HAL_ERROR;
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
3400370a:	f7fe f91d 	bl	34001948 <HAL_GetTick>
3400370e:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
34003710:	e029      	b.n	34003766 <ADC_Disable+0xa6>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34003712:	687b      	ldr	r3, [r7, #4]
34003714:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003716:	f043 0210 	orr.w	r2, r3, #16
3400371a:	687b      	ldr	r3, [r7, #4]
3400371c:	659a      	str	r2, [r3, #88]	@ 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
3400371e:	687b      	ldr	r3, [r7, #4]
34003720:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34003722:	f043 0201 	orr.w	r2, r3, #1
34003726:	687b      	ldr	r3, [r7, #4]
34003728:	65da      	str	r2, [r3, #92]	@ 0x5c
      return HAL_ERROR;
3400372a:	2301      	movs	r3, #1
3400372c:	e023      	b.n	34003776 <ADC_Disable+0xb6>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
3400372e:	f7fe f90b 	bl	34001948 <HAL_GetTick>
34003732:	4602      	mov	r2, r0
34003734:	68bb      	ldr	r3, [r7, #8]
34003736:	1ad3      	subs	r3, r2, r3
34003738:	2b02      	cmp	r3, #2
3400373a:	d914      	bls.n	34003766 <ADC_Disable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
3400373c:	687b      	ldr	r3, [r7, #4]
3400373e:	681b      	ldr	r3, [r3, #0]
34003740:	689b      	ldr	r3, [r3, #8]
34003742:	f003 0301 	and.w	r3, r3, #1
34003746:	2b00      	cmp	r3, #0
34003748:	d00d      	beq.n	34003766 <ADC_Disable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
3400374a:	687b      	ldr	r3, [r7, #4]
3400374c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400374e:	f043 0210 	orr.w	r2, r3, #16
34003752:	687b      	ldr	r3, [r7, #4]
34003754:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34003756:	687b      	ldr	r3, [r7, #4]
34003758:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3400375a:	f043 0201 	orr.w	r2, r3, #1
3400375e:	687b      	ldr	r3, [r7, #4]
34003760:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
34003762:	2301      	movs	r3, #1
34003764:	e007      	b.n	34003776 <ADC_Disable+0xb6>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
34003766:	687b      	ldr	r3, [r7, #4]
34003768:	681b      	ldr	r3, [r3, #0]
3400376a:	689b      	ldr	r3, [r3, #8]
3400376c:	f003 0301 	and.w	r3, r3, #1
34003770:	2b00      	cmp	r3, #0
34003772:	d1dc      	bne.n	3400372e <ADC_Disable+0x6e>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
34003774:	2300      	movs	r3, #0
}
34003776:	4618      	mov	r0, r3
34003778:	3710      	adds	r7, #16
3400377a:	46bd      	mov	sp, r7
3400377c:	bd80      	pop	{r7, pc}

3400377e <LL_ADC_IsEnabled>:
{
3400377e:	b480      	push	{r7}
34003780:	b083      	sub	sp, #12
34003782:	af00      	add	r7, sp, #0
34003784:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34003786:	687b      	ldr	r3, [r7, #4]
34003788:	689b      	ldr	r3, [r3, #8]
3400378a:	f003 0301 	and.w	r3, r3, #1
3400378e:	2b01      	cmp	r3, #1
34003790:	d101      	bne.n	34003796 <LL_ADC_IsEnabled+0x18>
34003792:	2301      	movs	r3, #1
34003794:	e000      	b.n	34003798 <LL_ADC_IsEnabled+0x1a>
34003796:	2300      	movs	r3, #0
}
34003798:	4618      	mov	r0, r3
3400379a:	370c      	adds	r7, #12
3400379c:	46bd      	mov	sp, r7
3400379e:	f85d 7b04 	ldr.w	r7, [sp], #4
340037a2:	4770      	bx	lr

340037a4 <LL_ADC_REG_IsConversionOngoing>:
{
340037a4:	b480      	push	{r7}
340037a6:	b083      	sub	sp, #12
340037a8:	af00      	add	r7, sp, #0
340037aa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
340037ac:	687b      	ldr	r3, [r7, #4]
340037ae:	689b      	ldr	r3, [r3, #8]
340037b0:	f003 0304 	and.w	r3, r3, #4
340037b4:	2b04      	cmp	r3, #4
340037b6:	d101      	bne.n	340037bc <LL_ADC_REG_IsConversionOngoing+0x18>
340037b8:	2301      	movs	r3, #1
340037ba:	e000      	b.n	340037be <LL_ADC_REG_IsConversionOngoing+0x1a>
340037bc:	2300      	movs	r3, #0
}
340037be:	4618      	mov	r0, r3
340037c0:	370c      	adds	r7, #12
340037c2:	46bd      	mov	sp, r7
340037c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340037c8:	4770      	bx	lr

340037ca <HAL_ADCEx_InjectedConvCpltCallback>:
  * @brief  Injected conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
{
340037ca:	b480      	push	{r7}
340037cc:	b083      	sub	sp, #12
340037ce:	af00      	add	r7, sp, #0
340037d0:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
340037d2:	bf00      	nop
340037d4:	370c      	adds	r7, #12
340037d6:	46bd      	mov	sp, r7
340037d8:	f85d 7b04 	ldr.w	r7, [sp], #4
340037dc:	4770      	bx	lr

340037de <HAL_ADCEx_LevelOutOfWindow2Callback>:
  * @brief  Analog watchdog 2 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow2Callback(ADC_HandleTypeDef *hadc)
{
340037de:	b480      	push	{r7}
340037e0:	b083      	sub	sp, #12
340037e2:	af00      	add	r7, sp, #0
340037e4:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow2Callback must be implemented in the user file.
  */
}
340037e6:	bf00      	nop
340037e8:	370c      	adds	r7, #12
340037ea:	46bd      	mov	sp, r7
340037ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340037f0:	4770      	bx	lr

340037f2 <HAL_ADCEx_LevelOutOfWindow3Callback>:
  * @brief  Analog watchdog 3 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
{
340037f2:	b480      	push	{r7}
340037f4:	b083      	sub	sp, #12
340037f6:	af00      	add	r7, sp, #0
340037f8:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow3Callback must be implemented in the user file.
  */
}
340037fa:	bf00      	nop
340037fc:	370c      	adds	r7, #12
340037fe:	46bd      	mov	sp, r7
34003800:	f85d 7b04 	ldr.w	r7, [sp], #4
34003804:	4770      	bx	lr

34003806 <HAL_ADCEx_EndOfSamplingCallback>:
  * @brief  End Of Sampling callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
{
34003806:	b480      	push	{r7}
34003808:	b083      	sub	sp, #12
3400380a:	af00      	add	r7, sp, #0
3400380c:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_EndOfSamplingCallback must be implemented in the user file.
  */
}
3400380e:	bf00      	nop
34003810:	370c      	adds	r7, #12
34003812:	46bd      	mov	sp, r7
34003814:	f85d 7b04 	ldr.w	r7, [sp], #4
34003818:	4770      	bx	lr
	...

3400381c <HAL_ADCEx_MultiModeConfigChannel>:
  * @param pMultimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc,
                                                   const ADC_MultiModeTypeDef *pMultimode)
{
3400381c:	b590      	push	{r4, r7, lr}
3400381e:	b09f      	sub	sp, #124	@ 0x7c
34003820:	af00      	add	r7, sp, #0
34003822:	6078      	str	r0, [r7, #4]
34003824:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34003826:	2300      	movs	r3, #0
34003828:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    assert_param(IS_ADC_DUAL_DATA_MODE(pMultimode->DualModeData));
    assert_param(IS_ADC_SAMPLING_DELAY(pMultimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
3400382c:	687b      	ldr	r3, [r7, #4]
3400382e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003832:	2b01      	cmp	r3, #1
34003834:	d101      	bne.n	3400383a <HAL_ADCEx_MultiModeConfigChannel+0x1e>
34003836:	2302      	movs	r3, #2
34003838:	e095      	b.n	34003966 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
3400383a:	687b      	ldr	r3, [r7, #4]
3400383c:	2201      	movs	r2, #1
3400383e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
34003842:	2300      	movs	r3, #0
34003844:	667b      	str	r3, [r7, #100]	@ 0x64
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);
34003846:	2300      	movs	r3, #0
34003848:	66bb      	str	r3, [r7, #104]	@ 0x68

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
3400384a:	687b      	ldr	r3, [r7, #4]
3400384c:	681b      	ldr	r3, [r3, #0]
3400384e:	4a48      	ldr	r2, [pc, #288]	@ (34003970 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
34003850:	4293      	cmp	r3, r2
34003852:	d102      	bne.n	3400385a <HAL_ADCEx_MultiModeConfigChannel+0x3e>
34003854:	4b47      	ldr	r3, [pc, #284]	@ (34003974 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
34003856:	60fb      	str	r3, [r7, #12]
34003858:	e001      	b.n	3400385e <HAL_ADCEx_MultiModeConfigChannel+0x42>
3400385a:	2300      	movs	r3, #0
3400385c:	60fb      	str	r3, [r7, #12]

  if (tmphadcSlave.Instance == NULL)
3400385e:	68fb      	ldr	r3, [r7, #12]
34003860:	2b00      	cmp	r3, #0
34003862:	d10b      	bne.n	3400387c <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34003864:	687b      	ldr	r3, [r7, #4]
34003866:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003868:	f043 0220 	orr.w	r2, r3, #32
3400386c:	687b      	ldr	r3, [r7, #4]
3400386e:	659a      	str	r2, [r3, #88]	@ 0x58

    __HAL_UNLOCK(hadc);
34003870:	687b      	ldr	r3, [r7, #4]
34003872:	2200      	movs	r2, #0
34003874:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    return HAL_ERROR;
34003878:	2301      	movs	r3, #1
3400387a:	e074      	b.n	34003966 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
  }

  /* ADC must be disabled to set configuration bits */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
3400387c:	687b      	ldr	r3, [r7, #4]
3400387e:	681b      	ldr	r3, [r3, #0]
34003880:	4618      	mov	r0, r3
34003882:	f7ff ff7c 	bl	3400377e <LL_ADC_IsEnabled>
34003886:	4603      	mov	r3, r0
34003888:	2b00      	cmp	r3, #0
3400388a:	d008      	beq.n	3400389e <HAL_ADCEx_MultiModeConfigChannel+0x82>
  {
    if (LL_ADC_IsEnabled(tmphadcSlave.Instance) != 0UL)
3400388c:	68fb      	ldr	r3, [r7, #12]
3400388e:	4618      	mov	r0, r3
34003890:	f7ff ff75 	bl	3400377e <LL_ADC_IsEnabled>
34003894:	4603      	mov	r3, r0
34003896:	2b00      	cmp	r3, #0
34003898:	d001      	beq.n	3400389e <HAL_ADCEx_MultiModeConfigChannel+0x82>
    {
      return HAL_ERROR;
3400389a:	2301      	movs	r3, #1
3400389c:	e063      	b.n	34003966 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DMA configuration                                           */
  /*  - Multimode DMA mode                                                    */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
3400389e:	68fb      	ldr	r3, [r7, #12]
340038a0:	4618      	mov	r0, r3
340038a2:	f7ff ff7f 	bl	340037a4 <LL_ADC_REG_IsConversionOngoing>
340038a6:	6738      	str	r0, [r7, #112]	@ 0x70
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
340038a8:	687b      	ldr	r3, [r7, #4]
340038aa:	681b      	ldr	r3, [r3, #0]
340038ac:	4618      	mov	r0, r3
340038ae:	f7ff ff79 	bl	340037a4 <LL_ADC_REG_IsConversionOngoing>
340038b2:	4603      	mov	r3, r0
340038b4:	2b00      	cmp	r3, #0
340038b6:	d145      	bne.n	34003944 <HAL_ADCEx_MultiModeConfigChannel+0x128>
      && (tmphadcSlave_conversion_on_going == 0UL))
340038b8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
340038ba:	2b00      	cmp	r3, #0
340038bc:	d142      	bne.n	34003944 <HAL_ADCEx_MultiModeConfigChannel+0x128>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
340038be:	4b2e      	ldr	r3, [pc, #184]	@ (34003978 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
340038c0:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
340038c2:	683b      	ldr	r3, [r7, #0]
340038c4:	681b      	ldr	r3, [r3, #0]
340038c6:	2b00      	cmp	r3, #0
340038c8:	d022      	beq.n	34003910 <HAL_ADCEx_MultiModeConfigChannel+0xf4>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, pMultimode->DualModeData);
340038ca:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340038cc:	689b      	ldr	r3, [r3, #8]
340038ce:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
340038d2:	683b      	ldr	r3, [r7, #0]
340038d4:	685b      	ldr	r3, [r3, #4]
340038d6:	431a      	orrs	r2, r3
340038d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340038da:	609a      	str	r2, [r3, #8]
      /*      from 1 to 10 clock cycles for 10 bits,                              */
      /*      from 1 to 8 clock cycles for 8 bits                                 */
      /*      from 1 to 6 clock cycles for 6 bits                                 */
      /*    If a higher delay is selected, it will be clipped to maximum delay    */
      /*    range                                                                 */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
340038dc:	4824      	ldr	r0, [pc, #144]	@ (34003970 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
340038de:	f7ff ff4e 	bl	3400377e <LL_ADC_IsEnabled>
340038e2:	4604      	mov	r4, r0
340038e4:	4823      	ldr	r0, [pc, #140]	@ (34003974 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
340038e6:	f7ff ff4a 	bl	3400377e <LL_ADC_IsEnabled>
340038ea:	4603      	mov	r3, r0
340038ec:	4323      	orrs	r3, r4
340038ee:	2b00      	cmp	r3, #0
340038f0:	d132      	bne.n	34003958 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
      {
        MODIFY_REG(tmpADC_Common->CCR,
340038f2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340038f4:	689b      	ldr	r3, [r3, #8]
340038f6:	f423 6371 	bic.w	r3, r3, #3856	@ 0xf10
340038fa:	f023 030f 	bic.w	r3, r3, #15
340038fe:	683a      	ldr	r2, [r7, #0]
34003900:	6811      	ldr	r1, [r2, #0]
34003902:	683a      	ldr	r2, [r7, #0]
34003904:	6892      	ldr	r2, [r2, #8]
34003906:	430a      	orrs	r2, r1
34003908:	431a      	orrs	r2, r3
3400390a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400390c:	609a      	str	r2, [r3, #8]
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
3400390e:	e023      	b.n	34003958 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
34003910:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34003912:	689b      	ldr	r3, [r3, #8]
34003914:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
34003918:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400391a:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
3400391c:	4814      	ldr	r0, [pc, #80]	@ (34003970 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
3400391e:	f7ff ff2e 	bl	3400377e <LL_ADC_IsEnabled>
34003922:	4604      	mov	r4, r0
34003924:	4813      	ldr	r0, [pc, #76]	@ (34003974 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
34003926:	f7ff ff2a 	bl	3400377e <LL_ADC_IsEnabled>
3400392a:	4603      	mov	r3, r0
3400392c:	4323      	orrs	r3, r4
3400392e:	2b00      	cmp	r3, #0
34003930:	d112      	bne.n	34003958 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
34003932:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34003934:	689b      	ldr	r3, [r3, #8]
34003936:	f423 6371 	bic.w	r3, r3, #3856	@ 0xf10
3400393a:	f023 030f 	bic.w	r3, r3, #15
3400393e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34003940:	6093      	str	r3, [r2, #8]
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
34003942:	e009      	b.n	34003958 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34003944:	687b      	ldr	r3, [r7, #4]
34003946:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003948:	f043 0220 	orr.w	r2, r3, #32
3400394c:	687b      	ldr	r3, [r7, #4]
3400394e:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34003950:	2301      	movs	r3, #1
34003952:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
34003956:	e000      	b.n	3400395a <HAL_ADCEx_MultiModeConfigChannel+0x13e>
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
34003958:	bf00      	nop
  }

  __HAL_UNLOCK(hadc);
3400395a:	687b      	ldr	r3, [r7, #4]
3400395c:	2200      	movs	r2, #0
3400395e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34003962:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
34003966:	4618      	mov	r0, r3
34003968:	377c      	adds	r7, #124	@ 0x7c
3400396a:	46bd      	mov	sp, r7
3400396c:	bd90      	pop	{r4, r7, pc}
3400396e:	bf00      	nop
34003970:	50022000 	.word	0x50022000
34003974:	50022100 	.word	0x50022100
34003978:	50022300 	.word	0x50022300

3400397c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3400397c:	b480      	push	{r7}
3400397e:	b085      	sub	sp, #20
34003980:	af00      	add	r7, sp, #0
34003982:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34003984:	687b      	ldr	r3, [r7, #4]
34003986:	f003 0307 	and.w	r3, r3, #7
3400398a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
3400398c:	4b0c      	ldr	r3, [pc, #48]	@ (340039c0 <__NVIC_SetPriorityGrouping+0x44>)
3400398e:	68db      	ldr	r3, [r3, #12]
34003990:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34003992:	68ba      	ldr	r2, [r7, #8]
34003994:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34003998:	4013      	ands	r3, r2
3400399a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3400399c:	68fb      	ldr	r3, [r7, #12]
3400399e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
340039a0:	68bb      	ldr	r3, [r7, #8]
340039a2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
340039a4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
340039a8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
340039ac:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
340039ae:	4a04      	ldr	r2, [pc, #16]	@ (340039c0 <__NVIC_SetPriorityGrouping+0x44>)
340039b0:	68bb      	ldr	r3, [r7, #8]
340039b2:	60d3      	str	r3, [r2, #12]
}
340039b4:	bf00      	nop
340039b6:	3714      	adds	r7, #20
340039b8:	46bd      	mov	sp, r7
340039ba:	f85d 7b04 	ldr.w	r7, [sp], #4
340039be:	4770      	bx	lr
340039c0:	e000ed00 	.word	0xe000ed00

340039c4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
340039c4:	b480      	push	{r7}
340039c6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
340039c8:	4b04      	ldr	r3, [pc, #16]	@ (340039dc <__NVIC_GetPriorityGrouping+0x18>)
340039ca:	68db      	ldr	r3, [r3, #12]
340039cc:	0a1b      	lsrs	r3, r3, #8
340039ce:	f003 0307 	and.w	r3, r3, #7
}
340039d2:	4618      	mov	r0, r3
340039d4:	46bd      	mov	sp, r7
340039d6:	f85d 7b04 	ldr.w	r7, [sp], #4
340039da:	4770      	bx	lr
340039dc:	e000ed00 	.word	0xe000ed00

340039e0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
340039e0:	b480      	push	{r7}
340039e2:	b083      	sub	sp, #12
340039e4:	af00      	add	r7, sp, #0
340039e6:	4603      	mov	r3, r0
340039e8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
340039ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340039ee:	2b00      	cmp	r3, #0
340039f0:	db0b      	blt.n	34003a0a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340039f2:	88fb      	ldrh	r3, [r7, #6]
340039f4:	f003 021f 	and.w	r2, r3, #31
340039f8:	4907      	ldr	r1, [pc, #28]	@ (34003a18 <__NVIC_EnableIRQ+0x38>)
340039fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340039fe:	095b      	lsrs	r3, r3, #5
34003a00:	2001      	movs	r0, #1
34003a02:	fa00 f202 	lsl.w	r2, r0, r2
34003a06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
34003a0a:	bf00      	nop
34003a0c:	370c      	adds	r7, #12
34003a0e:	46bd      	mov	sp, r7
34003a10:	f85d 7b04 	ldr.w	r7, [sp], #4
34003a14:	4770      	bx	lr
34003a16:	bf00      	nop
34003a18:	e000e100 	.word	0xe000e100

34003a1c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34003a1c:	b480      	push	{r7}
34003a1e:	b083      	sub	sp, #12
34003a20:	af00      	add	r7, sp, #0
34003a22:	4603      	mov	r3, r0
34003a24:	6039      	str	r1, [r7, #0]
34003a26:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34003a28:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34003a2c:	2b00      	cmp	r3, #0
34003a2e:	db0a      	blt.n	34003a46 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34003a30:	683b      	ldr	r3, [r7, #0]
34003a32:	b2da      	uxtb	r2, r3
34003a34:	490c      	ldr	r1, [pc, #48]	@ (34003a68 <__NVIC_SetPriority+0x4c>)
34003a36:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34003a3a:	0112      	lsls	r2, r2, #4
34003a3c:	b2d2      	uxtb	r2, r2
34003a3e:	440b      	add	r3, r1
34003a40:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34003a44:	e00a      	b.n	34003a5c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34003a46:	683b      	ldr	r3, [r7, #0]
34003a48:	b2da      	uxtb	r2, r3
34003a4a:	4908      	ldr	r1, [pc, #32]	@ (34003a6c <__NVIC_SetPriority+0x50>)
34003a4c:	88fb      	ldrh	r3, [r7, #6]
34003a4e:	f003 030f 	and.w	r3, r3, #15
34003a52:	3b04      	subs	r3, #4
34003a54:	0112      	lsls	r2, r2, #4
34003a56:	b2d2      	uxtb	r2, r2
34003a58:	440b      	add	r3, r1
34003a5a:	761a      	strb	r2, [r3, #24]
}
34003a5c:	bf00      	nop
34003a5e:	370c      	adds	r7, #12
34003a60:	46bd      	mov	sp, r7
34003a62:	f85d 7b04 	ldr.w	r7, [sp], #4
34003a66:	4770      	bx	lr
34003a68:	e000e100 	.word	0xe000e100
34003a6c:	e000ed00 	.word	0xe000ed00

34003a70 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34003a70:	b480      	push	{r7}
34003a72:	b089      	sub	sp, #36	@ 0x24
34003a74:	af00      	add	r7, sp, #0
34003a76:	60f8      	str	r0, [r7, #12]
34003a78:	60b9      	str	r1, [r7, #8]
34003a7a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34003a7c:	68fb      	ldr	r3, [r7, #12]
34003a7e:	f003 0307 	and.w	r3, r3, #7
34003a82:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34003a84:	69fb      	ldr	r3, [r7, #28]
34003a86:	f1c3 0307 	rsb	r3, r3, #7
34003a8a:	2b04      	cmp	r3, #4
34003a8c:	bf28      	it	cs
34003a8e:	2304      	movcs	r3, #4
34003a90:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34003a92:	69fb      	ldr	r3, [r7, #28]
34003a94:	3304      	adds	r3, #4
34003a96:	2b06      	cmp	r3, #6
34003a98:	d902      	bls.n	34003aa0 <NVIC_EncodePriority+0x30>
34003a9a:	69fb      	ldr	r3, [r7, #28]
34003a9c:	3b03      	subs	r3, #3
34003a9e:	e000      	b.n	34003aa2 <NVIC_EncodePriority+0x32>
34003aa0:	2300      	movs	r3, #0
34003aa2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34003aa4:	f04f 32ff 	mov.w	r2, #4294967295
34003aa8:	69bb      	ldr	r3, [r7, #24]
34003aaa:	fa02 f303 	lsl.w	r3, r2, r3
34003aae:	43da      	mvns	r2, r3
34003ab0:	68bb      	ldr	r3, [r7, #8]
34003ab2:	401a      	ands	r2, r3
34003ab4:	697b      	ldr	r3, [r7, #20]
34003ab6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34003ab8:	f04f 31ff 	mov.w	r1, #4294967295
34003abc:	697b      	ldr	r3, [r7, #20]
34003abe:	fa01 f303 	lsl.w	r3, r1, r3
34003ac2:	43d9      	mvns	r1, r3
34003ac4:	687b      	ldr	r3, [r7, #4]
34003ac6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34003ac8:	4313      	orrs	r3, r2
         );
}
34003aca:	4618      	mov	r0, r3
34003acc:	3724      	adds	r7, #36	@ 0x24
34003ace:	46bd      	mov	sp, r7
34003ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ad4:	4770      	bx	lr
	...

34003ad8 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34003ad8:	b580      	push	{r7, lr}
34003ada:	b082      	sub	sp, #8
34003adc:	af00      	add	r7, sp, #0
34003ade:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34003ae0:	687b      	ldr	r3, [r7, #4]
34003ae2:	3b01      	subs	r3, #1
34003ae4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003ae8:	d301      	bcc.n	34003aee <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34003aea:	2301      	movs	r3, #1
34003aec:	e00f      	b.n	34003b0e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34003aee:	4a0a      	ldr	r2, [pc, #40]	@ (34003b18 <SysTick_Config+0x40>)
34003af0:	687b      	ldr	r3, [r7, #4]
34003af2:	3b01      	subs	r3, #1
34003af4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
34003af6:	210f      	movs	r1, #15
34003af8:	f04f 30ff 	mov.w	r0, #4294967295
34003afc:	f7ff ff8e 	bl	34003a1c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34003b00:	4b05      	ldr	r3, [pc, #20]	@ (34003b18 <SysTick_Config+0x40>)
34003b02:	2200      	movs	r2, #0
34003b04:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34003b06:	4b04      	ldr	r3, [pc, #16]	@ (34003b18 <SysTick_Config+0x40>)
34003b08:	2207      	movs	r2, #7
34003b0a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34003b0c:	2300      	movs	r3, #0
}
34003b0e:	4618      	mov	r0, r3
34003b10:	3708      	adds	r7, #8
34003b12:	46bd      	mov	sp, r7
34003b14:	bd80      	pop	{r7, pc}
34003b16:	bf00      	nop
34003b18:	e000e010 	.word	0xe000e010

34003b1c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34003b1c:	b580      	push	{r7, lr}
34003b1e:	b082      	sub	sp, #8
34003b20:	af00      	add	r7, sp, #0
34003b22:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34003b24:	6878      	ldr	r0, [r7, #4]
34003b26:	f7ff ff29 	bl	3400397c <__NVIC_SetPriorityGrouping>
}
34003b2a:	bf00      	nop
34003b2c:	3708      	adds	r7, #8
34003b2e:	46bd      	mov	sp, r7
34003b30:	bd80      	pop	{r7, pc}

34003b32 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34003b32:	b580      	push	{r7, lr}
34003b34:	b086      	sub	sp, #24
34003b36:	af00      	add	r7, sp, #0
34003b38:	4603      	mov	r3, r0
34003b3a:	60b9      	str	r1, [r7, #8]
34003b3c:	607a      	str	r2, [r7, #4]
34003b3e:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34003b40:	f7ff ff40 	bl	340039c4 <__NVIC_GetPriorityGrouping>
34003b44:	4603      	mov	r3, r0
34003b46:	f003 0307 	and.w	r3, r3, #7
34003b4a:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
34003b4c:	687a      	ldr	r2, [r7, #4]
34003b4e:	68b9      	ldr	r1, [r7, #8]
34003b50:	6978      	ldr	r0, [r7, #20]
34003b52:	f7ff ff8d 	bl	34003a70 <NVIC_EncodePriority>
34003b56:	4602      	mov	r2, r0
34003b58:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34003b5c:	4611      	mov	r1, r2
34003b5e:	4618      	mov	r0, r3
34003b60:	f7ff ff5c 	bl	34003a1c <__NVIC_SetPriority>
}
34003b64:	bf00      	nop
34003b66:	3718      	adds	r7, #24
34003b68:	46bd      	mov	sp, r7
34003b6a:	bd80      	pop	{r7, pc}

34003b6c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
34003b6c:	b580      	push	{r7, lr}
34003b6e:	b082      	sub	sp, #8
34003b70:	af00      	add	r7, sp, #0
34003b72:	4603      	mov	r3, r0
34003b74:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34003b76:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34003b7a:	4618      	mov	r0, r3
34003b7c:	f7ff ff30 	bl	340039e0 <__NVIC_EnableIRQ>
}
34003b80:	bf00      	nop
34003b82:	3708      	adds	r7, #8
34003b84:	46bd      	mov	sp, r7
34003b86:	bd80      	pop	{r7, pc}

34003b88 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34003b88:	b580      	push	{r7, lr}
34003b8a:	b082      	sub	sp, #8
34003b8c:	af00      	add	r7, sp, #0
34003b8e:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34003b90:	6878      	ldr	r0, [r7, #4]
34003b92:	f7ff ffa1 	bl	34003ad8 <SysTick_Config>
34003b96:	4603      	mov	r3, r0
}
34003b98:	4618      	mov	r0, r3
34003b9a:	3708      	adds	r7, #8
34003b9c:	46bd      	mov	sp, r7
34003b9e:	bd80      	pop	{r7, pc}

34003ba0 <HAL_DMA_Abort_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *const hdma)
{
34003ba0:	b480      	push	{r7}
34003ba2:	b083      	sub	sp, #12
34003ba4:	af00      	add	r7, sp, #0
34003ba6:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
34003ba8:	687b      	ldr	r3, [r7, #4]
34003baa:	2b00      	cmp	r3, #0
34003bac:	d101      	bne.n	34003bb2 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
34003bae:	2301      	movs	r3, #1
34003bb0:	e019      	b.n	34003be6 <HAL_DMA_Abort_IT+0x46>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
34003bb2:	687b      	ldr	r3, [r7, #4]
34003bb4:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003bb8:	b2db      	uxtb	r3, r3
34003bba:	2b02      	cmp	r3, #2
34003bbc:	d004      	beq.n	34003bc8 <HAL_DMA_Abort_IT+0x28>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
34003bbe:	687b      	ldr	r3, [r7, #4]
34003bc0:	2220      	movs	r2, #32
34003bc2:	659a      	str	r2, [r3, #88]	@ 0x58

    return HAL_ERROR;
34003bc4:	2301      	movs	r3, #1
34003bc6:	e00e      	b.n	34003be6 <HAL_DMA_Abort_IT+0x46>
  }
  else
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
34003bc8:	687b      	ldr	r3, [r7, #4]
34003bca:	2204      	movs	r2, #4
34003bcc:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Suspend the channel and activate suspend interrupt */
    hdma->Instance->CCR |= (DMA_CCR_SUSP | DMA_CCR_SUSPIE);
34003bd0:	687b      	ldr	r3, [r7, #4]
34003bd2:	681b      	ldr	r3, [r3, #0]
34003bd4:	695b      	ldr	r3, [r3, #20]
34003bd6:	687a      	ldr	r2, [r7, #4]
34003bd8:	6812      	ldr	r2, [r2, #0]
34003bda:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34003bde:	f043 0304 	orr.w	r3, r3, #4
34003be2:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
34003be4:	2300      	movs	r3, #0
}
34003be6:	4618      	mov	r0, r3
34003be8:	370c      	adds	r7, #12
34003bea:	46bd      	mov	sp, r7
34003bec:	f85d 7b04 	ldr.w	r7, [sp], #4
34003bf0:	4770      	bx	lr

34003bf2 <HAL_DMA_GetState>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval DMA state.
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef const *const hdma)
{
34003bf2:	b480      	push	{r7}
34003bf4:	b083      	sub	sp, #12
34003bf6:	af00      	add	r7, sp, #0
34003bf8:	6078      	str	r0, [r7, #4]
  /* Return the DMA channel state */
  return hdma->State;
34003bfa:	687b      	ldr	r3, [r7, #4]
34003bfc:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003c00:	b2db      	uxtb	r3, r3
}
34003c02:	4618      	mov	r0, r3
34003c04:	370c      	adds	r7, #12
34003c06:	46bd      	mov	sp, r7
34003c08:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c0c:	4770      	bx	lr

34003c0e <HAL_DMAEx_GetFifoLevel>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval Returns the number of available beats in FIFO.
  */
uint32_t HAL_DMAEx_GetFifoLevel(DMA_HandleTypeDef const *const hdma)
{
34003c0e:	b480      	push	{r7}
34003c10:	b083      	sub	sp, #12
34003c12:	af00      	add	r7, sp, #0
34003c14:	6078      	str	r0, [r7, #4]
  return ((hdma->Instance->CSR & DMA_CSR_FIFOL) >> DMA_CSR_FIFOL_Pos);
34003c16:	687b      	ldr	r3, [r7, #4]
34003c18:	681b      	ldr	r3, [r3, #0]
34003c1a:	691b      	ldr	r3, [r3, #16]
34003c1c:	0c1b      	lsrs	r3, r3, #16
34003c1e:	b2db      	uxtb	r3, r3
}
34003c20:	4618      	mov	r0, r3
34003c22:	370c      	adds	r7, #12
34003c24:	46bd      	mov	sp, r7
34003c26:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c2a:	4770      	bx	lr

34003c2c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34003c2c:	b480      	push	{r7}
34003c2e:	b087      	sub	sp, #28
34003c30:	af00      	add	r7, sp, #0
34003c32:	6078      	str	r0, [r7, #4]
34003c34:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34003c36:	2300      	movs	r3, #0
34003c38:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34003c3a:	e180      	b.n	34003f3e <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34003c3c:	683b      	ldr	r3, [r7, #0]
34003c3e:	681a      	ldr	r2, [r3, #0]
34003c40:	2101      	movs	r1, #1
34003c42:	697b      	ldr	r3, [r7, #20]
34003c44:	fa01 f303 	lsl.w	r3, r1, r3
34003c48:	4013      	ands	r3, r2
34003c4a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
34003c4c:	68fb      	ldr	r3, [r7, #12]
34003c4e:	2b00      	cmp	r3, #0
34003c50:	f000 8172 	beq.w	34003f38 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34003c54:	683b      	ldr	r3, [r7, #0]
34003c56:	685b      	ldr	r3, [r3, #4]
34003c58:	f003 0303 	and.w	r3, r3, #3
34003c5c:	2b01      	cmp	r3, #1
34003c5e:	d005      	beq.n	34003c6c <HAL_GPIO_Init+0x40>
34003c60:	683b      	ldr	r3, [r7, #0]
34003c62:	685b      	ldr	r3, [r3, #4]
34003c64:	f003 0303 	and.w	r3, r3, #3
34003c68:	2b02      	cmp	r3, #2
34003c6a:	d130      	bne.n	34003cce <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34003c6c:	687b      	ldr	r3, [r7, #4]
34003c6e:	689b      	ldr	r3, [r3, #8]
34003c70:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34003c72:	697b      	ldr	r3, [r7, #20]
34003c74:	005b      	lsls	r3, r3, #1
34003c76:	2203      	movs	r2, #3
34003c78:	fa02 f303 	lsl.w	r3, r2, r3
34003c7c:	43db      	mvns	r3, r3
34003c7e:	693a      	ldr	r2, [r7, #16]
34003c80:	4013      	ands	r3, r2
34003c82:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34003c84:	683b      	ldr	r3, [r7, #0]
34003c86:	68da      	ldr	r2, [r3, #12]
34003c88:	697b      	ldr	r3, [r7, #20]
34003c8a:	005b      	lsls	r3, r3, #1
34003c8c:	fa02 f303 	lsl.w	r3, r2, r3
34003c90:	693a      	ldr	r2, [r7, #16]
34003c92:	4313      	orrs	r3, r2
34003c94:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34003c96:	687b      	ldr	r3, [r7, #4]
34003c98:	693a      	ldr	r2, [r7, #16]
34003c9a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34003c9c:	687b      	ldr	r3, [r7, #4]
34003c9e:	685b      	ldr	r3, [r3, #4]
34003ca0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34003ca2:	2201      	movs	r2, #1
34003ca4:	697b      	ldr	r3, [r7, #20]
34003ca6:	fa02 f303 	lsl.w	r3, r2, r3
34003caa:	43db      	mvns	r3, r3
34003cac:	693a      	ldr	r2, [r7, #16]
34003cae:	4013      	ands	r3, r2
34003cb0:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34003cb2:	683b      	ldr	r3, [r7, #0]
34003cb4:	685b      	ldr	r3, [r3, #4]
34003cb6:	091b      	lsrs	r3, r3, #4
34003cb8:	f003 0201 	and.w	r2, r3, #1
34003cbc:	697b      	ldr	r3, [r7, #20]
34003cbe:	fa02 f303 	lsl.w	r3, r2, r3
34003cc2:	693a      	ldr	r2, [r7, #16]
34003cc4:	4313      	orrs	r3, r2
34003cc6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34003cc8:	687b      	ldr	r3, [r7, #4]
34003cca:	693a      	ldr	r2, [r7, #16]
34003ccc:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34003cce:	683b      	ldr	r3, [r7, #0]
34003cd0:	685b      	ldr	r3, [r3, #4]
34003cd2:	f003 0303 	and.w	r3, r3, #3
34003cd6:	2b03      	cmp	r3, #3
34003cd8:	d109      	bne.n	34003cee <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34003cda:	683b      	ldr	r3, [r7, #0]
34003cdc:	685b      	ldr	r3, [r3, #4]
34003cde:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34003ce2:	2b03      	cmp	r3, #3
34003ce4:	d11b      	bne.n	34003d1e <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34003ce6:	683b      	ldr	r3, [r7, #0]
34003ce8:	689b      	ldr	r3, [r3, #8]
34003cea:	2b01      	cmp	r3, #1
34003cec:	d017      	beq.n	34003d1e <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
34003cee:	687b      	ldr	r3, [r7, #4]
34003cf0:	68db      	ldr	r3, [r3, #12]
34003cf2:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34003cf4:	697b      	ldr	r3, [r7, #20]
34003cf6:	005b      	lsls	r3, r3, #1
34003cf8:	2203      	movs	r2, #3
34003cfa:	fa02 f303 	lsl.w	r3, r2, r3
34003cfe:	43db      	mvns	r3, r3
34003d00:	693a      	ldr	r2, [r7, #16]
34003d02:	4013      	ands	r3, r2
34003d04:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34003d06:	683b      	ldr	r3, [r7, #0]
34003d08:	689a      	ldr	r2, [r3, #8]
34003d0a:	697b      	ldr	r3, [r7, #20]
34003d0c:	005b      	lsls	r3, r3, #1
34003d0e:	fa02 f303 	lsl.w	r3, r2, r3
34003d12:	693a      	ldr	r2, [r7, #16]
34003d14:	4313      	orrs	r3, r2
34003d16:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34003d18:	687b      	ldr	r3, [r7, #4]
34003d1a:	693a      	ldr	r2, [r7, #16]
34003d1c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34003d1e:	683b      	ldr	r3, [r7, #0]
34003d20:	685b      	ldr	r3, [r3, #4]
34003d22:	f003 0303 	and.w	r3, r3, #3
34003d26:	2b02      	cmp	r3, #2
34003d28:	d123      	bne.n	34003d72 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
34003d2a:	697b      	ldr	r3, [r7, #20]
34003d2c:	08da      	lsrs	r2, r3, #3
34003d2e:	687b      	ldr	r3, [r7, #4]
34003d30:	3208      	adds	r2, #8
34003d32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34003d36:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34003d38:	697b      	ldr	r3, [r7, #20]
34003d3a:	f003 0307 	and.w	r3, r3, #7
34003d3e:	009b      	lsls	r3, r3, #2
34003d40:	220f      	movs	r2, #15
34003d42:	fa02 f303 	lsl.w	r3, r2, r3
34003d46:	43db      	mvns	r3, r3
34003d48:	693a      	ldr	r2, [r7, #16]
34003d4a:	4013      	ands	r3, r2
34003d4c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34003d4e:	683b      	ldr	r3, [r7, #0]
34003d50:	691a      	ldr	r2, [r3, #16]
34003d52:	697b      	ldr	r3, [r7, #20]
34003d54:	f003 0307 	and.w	r3, r3, #7
34003d58:	009b      	lsls	r3, r3, #2
34003d5a:	fa02 f303 	lsl.w	r3, r2, r3
34003d5e:	693a      	ldr	r2, [r7, #16]
34003d60:	4313      	orrs	r3, r2
34003d62:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34003d64:	697b      	ldr	r3, [r7, #20]
34003d66:	08da      	lsrs	r2, r3, #3
34003d68:	687b      	ldr	r3, [r7, #4]
34003d6a:	3208      	adds	r2, #8
34003d6c:	6939      	ldr	r1, [r7, #16]
34003d6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34003d72:	687b      	ldr	r3, [r7, #4]
34003d74:	681b      	ldr	r3, [r3, #0]
34003d76:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34003d78:	697b      	ldr	r3, [r7, #20]
34003d7a:	005b      	lsls	r3, r3, #1
34003d7c:	2203      	movs	r2, #3
34003d7e:	fa02 f303 	lsl.w	r3, r2, r3
34003d82:	43db      	mvns	r3, r3
34003d84:	693a      	ldr	r2, [r7, #16]
34003d86:	4013      	ands	r3, r2
34003d88:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34003d8a:	683b      	ldr	r3, [r7, #0]
34003d8c:	685b      	ldr	r3, [r3, #4]
34003d8e:	f003 0203 	and.w	r2, r3, #3
34003d92:	697b      	ldr	r3, [r7, #20]
34003d94:	005b      	lsls	r3, r3, #1
34003d96:	fa02 f303 	lsl.w	r3, r2, r3
34003d9a:	693a      	ldr	r2, [r7, #16]
34003d9c:	4313      	orrs	r3, r2
34003d9e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34003da0:	687b      	ldr	r3, [r7, #4]
34003da2:	693a      	ldr	r2, [r7, #16]
34003da4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34003da6:	683b      	ldr	r3, [r7, #0]
34003da8:	685b      	ldr	r3, [r3, #4]
34003daa:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34003dae:	2b00      	cmp	r3, #0
34003db0:	f000 80c2 	beq.w	34003f38 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34003db4:	4a69      	ldr	r2, [pc, #420]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003db6:	697b      	ldr	r3, [r7, #20]
34003db8:	089b      	lsrs	r3, r3, #2
34003dba:	3318      	adds	r3, #24
34003dbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34003dc0:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34003dc2:	697b      	ldr	r3, [r7, #20]
34003dc4:	f003 0303 	and.w	r3, r3, #3
34003dc8:	00db      	lsls	r3, r3, #3
34003dca:	220f      	movs	r2, #15
34003dcc:	fa02 f303 	lsl.w	r3, r2, r3
34003dd0:	43db      	mvns	r3, r3
34003dd2:	693a      	ldr	r2, [r7, #16]
34003dd4:	4013      	ands	r3, r2
34003dd6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34003dd8:	687b      	ldr	r3, [r7, #4]
34003dda:	4a61      	ldr	r2, [pc, #388]	@ (34003f60 <HAL_GPIO_Init+0x334>)
34003ddc:	4293      	cmp	r3, r2
34003dde:	d043      	beq.n	34003e68 <HAL_GPIO_Init+0x23c>
34003de0:	687b      	ldr	r3, [r7, #4]
34003de2:	4a60      	ldr	r2, [pc, #384]	@ (34003f64 <HAL_GPIO_Init+0x338>)
34003de4:	4293      	cmp	r3, r2
34003de6:	d03d      	beq.n	34003e64 <HAL_GPIO_Init+0x238>
34003de8:	687b      	ldr	r3, [r7, #4]
34003dea:	4a5f      	ldr	r2, [pc, #380]	@ (34003f68 <HAL_GPIO_Init+0x33c>)
34003dec:	4293      	cmp	r3, r2
34003dee:	d037      	beq.n	34003e60 <HAL_GPIO_Init+0x234>
34003df0:	687b      	ldr	r3, [r7, #4]
34003df2:	4a5e      	ldr	r2, [pc, #376]	@ (34003f6c <HAL_GPIO_Init+0x340>)
34003df4:	4293      	cmp	r3, r2
34003df6:	d031      	beq.n	34003e5c <HAL_GPIO_Init+0x230>
34003df8:	687b      	ldr	r3, [r7, #4]
34003dfa:	4a5d      	ldr	r2, [pc, #372]	@ (34003f70 <HAL_GPIO_Init+0x344>)
34003dfc:	4293      	cmp	r3, r2
34003dfe:	d02b      	beq.n	34003e58 <HAL_GPIO_Init+0x22c>
34003e00:	687b      	ldr	r3, [r7, #4]
34003e02:	4a5c      	ldr	r2, [pc, #368]	@ (34003f74 <HAL_GPIO_Init+0x348>)
34003e04:	4293      	cmp	r3, r2
34003e06:	d025      	beq.n	34003e54 <HAL_GPIO_Init+0x228>
34003e08:	687b      	ldr	r3, [r7, #4]
34003e0a:	4a5b      	ldr	r2, [pc, #364]	@ (34003f78 <HAL_GPIO_Init+0x34c>)
34003e0c:	4293      	cmp	r3, r2
34003e0e:	d01f      	beq.n	34003e50 <HAL_GPIO_Init+0x224>
34003e10:	687b      	ldr	r3, [r7, #4]
34003e12:	4a5a      	ldr	r2, [pc, #360]	@ (34003f7c <HAL_GPIO_Init+0x350>)
34003e14:	4293      	cmp	r3, r2
34003e16:	d019      	beq.n	34003e4c <HAL_GPIO_Init+0x220>
34003e18:	687b      	ldr	r3, [r7, #4]
34003e1a:	4a59      	ldr	r2, [pc, #356]	@ (34003f80 <HAL_GPIO_Init+0x354>)
34003e1c:	4293      	cmp	r3, r2
34003e1e:	d013      	beq.n	34003e48 <HAL_GPIO_Init+0x21c>
34003e20:	687b      	ldr	r3, [r7, #4]
34003e22:	4a58      	ldr	r2, [pc, #352]	@ (34003f84 <HAL_GPIO_Init+0x358>)
34003e24:	4293      	cmp	r3, r2
34003e26:	d00d      	beq.n	34003e44 <HAL_GPIO_Init+0x218>
34003e28:	687b      	ldr	r3, [r7, #4]
34003e2a:	4a57      	ldr	r2, [pc, #348]	@ (34003f88 <HAL_GPIO_Init+0x35c>)
34003e2c:	4293      	cmp	r3, r2
34003e2e:	d007      	beq.n	34003e40 <HAL_GPIO_Init+0x214>
34003e30:	687b      	ldr	r3, [r7, #4]
34003e32:	4a56      	ldr	r2, [pc, #344]	@ (34003f8c <HAL_GPIO_Init+0x360>)
34003e34:	4293      	cmp	r3, r2
34003e36:	d101      	bne.n	34003e3c <HAL_GPIO_Init+0x210>
34003e38:	230b      	movs	r3, #11
34003e3a:	e016      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e3c:	2310      	movs	r3, #16
34003e3e:	e014      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e40:	230a      	movs	r3, #10
34003e42:	e012      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e44:	2309      	movs	r3, #9
34003e46:	e010      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e48:	2308      	movs	r3, #8
34003e4a:	e00e      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e4c:	2307      	movs	r3, #7
34003e4e:	e00c      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e50:	2306      	movs	r3, #6
34003e52:	e00a      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e54:	2305      	movs	r3, #5
34003e56:	e008      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e58:	2304      	movs	r3, #4
34003e5a:	e006      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e5c:	2303      	movs	r3, #3
34003e5e:	e004      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e60:	2302      	movs	r3, #2
34003e62:	e002      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e64:	2301      	movs	r3, #1
34003e66:	e000      	b.n	34003e6a <HAL_GPIO_Init+0x23e>
34003e68:	2300      	movs	r3, #0
34003e6a:	697a      	ldr	r2, [r7, #20]
34003e6c:	f002 0203 	and.w	r2, r2, #3
34003e70:	00d2      	lsls	r2, r2, #3
34003e72:	4093      	lsls	r3, r2
34003e74:	693a      	ldr	r2, [r7, #16]
34003e76:	4313      	orrs	r3, r2
34003e78:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34003e7a:	4938      	ldr	r1, [pc, #224]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003e7c:	697b      	ldr	r3, [r7, #20]
34003e7e:	089b      	lsrs	r3, r3, #2
34003e80:	3318      	adds	r3, #24
34003e82:	693a      	ldr	r2, [r7, #16]
34003e84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34003e88:	4b34      	ldr	r3, [pc, #208]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003e8a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34003e8e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34003e90:	68fb      	ldr	r3, [r7, #12]
34003e92:	43db      	mvns	r3, r3
34003e94:	693a      	ldr	r2, [r7, #16]
34003e96:	4013      	ands	r3, r2
34003e98:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
34003e9a:	683b      	ldr	r3, [r7, #0]
34003e9c:	685b      	ldr	r3, [r3, #4]
34003e9e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34003ea2:	2b00      	cmp	r3, #0
34003ea4:	d003      	beq.n	34003eae <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
34003ea6:	693a      	ldr	r2, [r7, #16]
34003ea8:	68fb      	ldr	r3, [r7, #12]
34003eaa:	4313      	orrs	r3, r2
34003eac:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34003eae:	4a2b      	ldr	r2, [pc, #172]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003eb0:	693b      	ldr	r3, [r7, #16]
34003eb2:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34003eb6:	4b29      	ldr	r3, [pc, #164]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003eb8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34003ebc:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34003ebe:	68fb      	ldr	r3, [r7, #12]
34003ec0:	43db      	mvns	r3, r3
34003ec2:	693a      	ldr	r2, [r7, #16]
34003ec4:	4013      	ands	r3, r2
34003ec6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34003ec8:	683b      	ldr	r3, [r7, #0]
34003eca:	685b      	ldr	r3, [r3, #4]
34003ecc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34003ed0:	2b00      	cmp	r3, #0
34003ed2:	d003      	beq.n	34003edc <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
34003ed4:	693a      	ldr	r2, [r7, #16]
34003ed6:	68fb      	ldr	r3, [r7, #12]
34003ed8:	4313      	orrs	r3, r2
34003eda:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
34003edc:	4a1f      	ldr	r2, [pc, #124]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003ede:	693b      	ldr	r3, [r7, #16]
34003ee0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34003ee4:	4b1d      	ldr	r3, [pc, #116]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003ee6:	681b      	ldr	r3, [r3, #0]
34003ee8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34003eea:	68fb      	ldr	r3, [r7, #12]
34003eec:	43db      	mvns	r3, r3
34003eee:	693a      	ldr	r2, [r7, #16]
34003ef0:	4013      	ands	r3, r2
34003ef2:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34003ef4:	683b      	ldr	r3, [r7, #0]
34003ef6:	685b      	ldr	r3, [r3, #4]
34003ef8:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34003efc:	2b00      	cmp	r3, #0
34003efe:	d003      	beq.n	34003f08 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34003f00:	693a      	ldr	r2, [r7, #16]
34003f02:	68fb      	ldr	r3, [r7, #12]
34003f04:	4313      	orrs	r3, r2
34003f06:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34003f08:	4a14      	ldr	r2, [pc, #80]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003f0a:	693b      	ldr	r3, [r7, #16]
34003f0c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34003f0e:	4b13      	ldr	r3, [pc, #76]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003f10:	685b      	ldr	r3, [r3, #4]
34003f12:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34003f14:	68fb      	ldr	r3, [r7, #12]
34003f16:	43db      	mvns	r3, r3
34003f18:	693a      	ldr	r2, [r7, #16]
34003f1a:	4013      	ands	r3, r2
34003f1c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34003f1e:	683b      	ldr	r3, [r7, #0]
34003f20:	685b      	ldr	r3, [r3, #4]
34003f22:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34003f26:	2b00      	cmp	r3, #0
34003f28:	d003      	beq.n	34003f32 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
34003f2a:	693a      	ldr	r2, [r7, #16]
34003f2c:	68fb      	ldr	r3, [r7, #12]
34003f2e:	4313      	orrs	r3, r2
34003f30:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34003f32:	4a0a      	ldr	r2, [pc, #40]	@ (34003f5c <HAL_GPIO_Init+0x330>)
34003f34:	693b      	ldr	r3, [r7, #16]
34003f36:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34003f38:	697b      	ldr	r3, [r7, #20]
34003f3a:	3301      	adds	r3, #1
34003f3c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34003f3e:	683b      	ldr	r3, [r7, #0]
34003f40:	681a      	ldr	r2, [r3, #0]
34003f42:	697b      	ldr	r3, [r7, #20]
34003f44:	fa22 f303 	lsr.w	r3, r2, r3
34003f48:	2b00      	cmp	r3, #0
34003f4a:	f47f ae77 	bne.w	34003c3c <HAL_GPIO_Init+0x10>
  }
}
34003f4e:	bf00      	nop
34003f50:	bf00      	nop
34003f52:	371c      	adds	r7, #28
34003f54:	46bd      	mov	sp, r7
34003f56:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f5a:	4770      	bx	lr
34003f5c:	56025000 	.word	0x56025000
34003f60:	56020000 	.word	0x56020000
34003f64:	56020400 	.word	0x56020400
34003f68:	56020800 	.word	0x56020800
34003f6c:	56020c00 	.word	0x56020c00
34003f70:	56021000 	.word	0x56021000
34003f74:	56021400 	.word	0x56021400
34003f78:	56021800 	.word	0x56021800
34003f7c:	56021c00 	.word	0x56021c00
34003f80:	56023400 	.word	0x56023400
34003f84:	56023800 	.word	0x56023800
34003f88:	56023c00 	.word	0x56023c00
34003f8c:	56024000 	.word	0x56024000

34003f90 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34003f90:	b480      	push	{r7}
34003f92:	b083      	sub	sp, #12
34003f94:	af00      	add	r7, sp, #0
34003f96:	6078      	str	r0, [r7, #4]
34003f98:	460b      	mov	r3, r1
34003f9a:	807b      	strh	r3, [r7, #2]
34003f9c:	4613      	mov	r3, r2
34003f9e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34003fa0:	787b      	ldrb	r3, [r7, #1]
34003fa2:	2b00      	cmp	r3, #0
34003fa4:	d003      	beq.n	34003fae <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34003fa6:	887a      	ldrh	r2, [r7, #2]
34003fa8:	687b      	ldr	r3, [r7, #4]
34003faa:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34003fac:	e002      	b.n	34003fb4 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34003fae:	887a      	ldrh	r2, [r7, #2]
34003fb0:	687b      	ldr	r3, [r7, #4]
34003fb2:	629a      	str	r2, [r3, #40]	@ 0x28
}
34003fb4:	bf00      	nop
34003fb6:	370c      	adds	r7, #12
34003fb8:	46bd      	mov	sp, r7
34003fba:	f85d 7b04 	ldr.w	r7, [sp], #4
34003fbe:	4770      	bx	lr

34003fc0 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
34003fc0:	b480      	push	{r7}
34003fc2:	b085      	sub	sp, #20
34003fc4:	af00      	add	r7, sp, #0
34003fc6:	6078      	str	r0, [r7, #4]
34003fc8:	460b      	mov	r3, r1
34003fca:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
34003fcc:	687b      	ldr	r3, [r7, #4]
34003fce:	695b      	ldr	r3, [r3, #20]
34003fd0:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
34003fd2:	887a      	ldrh	r2, [r7, #2]
34003fd4:	68fb      	ldr	r3, [r7, #12]
34003fd6:	4013      	ands	r3, r2
34003fd8:	041a      	lsls	r2, r3, #16
34003fda:	68fb      	ldr	r3, [r7, #12]
34003fdc:	43d9      	mvns	r1, r3
34003fde:	887b      	ldrh	r3, [r7, #2]
34003fe0:	400b      	ands	r3, r1
34003fe2:	431a      	orrs	r2, r3
34003fe4:	687b      	ldr	r3, [r7, #4]
34003fe6:	619a      	str	r2, [r3, #24]
}
34003fe8:	bf00      	nop
34003fea:	3714      	adds	r7, #20
34003fec:	46bd      	mov	sp, r7
34003fee:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ff2:	4770      	bx	lr

34003ff4 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
34003ff4:	b580      	push	{r7, lr}
34003ff6:	b082      	sub	sp, #8
34003ff8:	af00      	add	r7, sp, #0
34003ffa:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
34003ffc:	687b      	ldr	r3, [r7, #4]
34003ffe:	2b00      	cmp	r3, #0
34004000:	d101      	bne.n	34004006 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
34004002:	2301      	movs	r3, #1
34004004:	e08d      	b.n	34004122 <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
34004006:	687b      	ldr	r3, [r7, #4]
34004008:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400400c:	b2db      	uxtb	r3, r3
3400400e:	2b00      	cmp	r3, #0
34004010:	d106      	bne.n	34004020 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
34004012:	687b      	ldr	r3, [r7, #4]
34004014:	2200      	movs	r2, #0
34004016:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
3400401a:	6878      	ldr	r0, [r7, #4]
3400401c:	f7fd f8ee 	bl	340011fc <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
34004020:	687b      	ldr	r3, [r7, #4]
34004022:	2224      	movs	r2, #36	@ 0x24
34004024:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
34004028:	687b      	ldr	r3, [r7, #4]
3400402a:	681b      	ldr	r3, [r3, #0]
3400402c:	681a      	ldr	r2, [r3, #0]
3400402e:	687b      	ldr	r3, [r7, #4]
34004030:	681b      	ldr	r3, [r3, #0]
34004032:	f022 0201 	bic.w	r2, r2, #1
34004036:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34004038:	687b      	ldr	r3, [r7, #4]
3400403a:	685a      	ldr	r2, [r3, #4]
3400403c:	687b      	ldr	r3, [r7, #4]
3400403e:	681b      	ldr	r3, [r3, #0]
34004040:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
34004044:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
34004046:	687b      	ldr	r3, [r7, #4]
34004048:	681b      	ldr	r3, [r3, #0]
3400404a:	689a      	ldr	r2, [r3, #8]
3400404c:	687b      	ldr	r3, [r7, #4]
3400404e:	681b      	ldr	r3, [r3, #0]
34004050:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34004054:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
34004056:	687b      	ldr	r3, [r7, #4]
34004058:	68db      	ldr	r3, [r3, #12]
3400405a:	2b01      	cmp	r3, #1
3400405c:	d107      	bne.n	3400406e <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3400405e:	687b      	ldr	r3, [r7, #4]
34004060:	689a      	ldr	r2, [r3, #8]
34004062:	687b      	ldr	r3, [r7, #4]
34004064:	681b      	ldr	r3, [r3, #0]
34004066:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3400406a:	609a      	str	r2, [r3, #8]
3400406c:	e006      	b.n	3400407c <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3400406e:	687b      	ldr	r3, [r7, #4]
34004070:	689a      	ldr	r2, [r3, #8]
34004072:	687b      	ldr	r3, [r7, #4]
34004074:	681b      	ldr	r3, [r3, #0]
34004076:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
3400407a:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400407c:	687b      	ldr	r3, [r7, #4]
3400407e:	68db      	ldr	r3, [r3, #12]
34004080:	2b02      	cmp	r3, #2
34004082:	d108      	bne.n	34004096 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34004084:	687b      	ldr	r3, [r7, #4]
34004086:	681b      	ldr	r3, [r3, #0]
34004088:	685a      	ldr	r2, [r3, #4]
3400408a:	687b      	ldr	r3, [r7, #4]
3400408c:	681b      	ldr	r3, [r3, #0]
3400408e:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
34004092:	605a      	str	r2, [r3, #4]
34004094:	e007      	b.n	340040a6 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
34004096:	687b      	ldr	r3, [r7, #4]
34004098:	681b      	ldr	r3, [r3, #0]
3400409a:	685a      	ldr	r2, [r3, #4]
3400409c:	687b      	ldr	r3, [r7, #4]
3400409e:	681b      	ldr	r3, [r3, #0]
340040a0:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
340040a4:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
340040a6:	687b      	ldr	r3, [r7, #4]
340040a8:	681b      	ldr	r3, [r3, #0]
340040aa:	685b      	ldr	r3, [r3, #4]
340040ac:	687a      	ldr	r2, [r7, #4]
340040ae:	6812      	ldr	r2, [r2, #0]
340040b0:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
340040b4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
340040b8:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
340040ba:	687b      	ldr	r3, [r7, #4]
340040bc:	681b      	ldr	r3, [r3, #0]
340040be:	68da      	ldr	r2, [r3, #12]
340040c0:	687b      	ldr	r3, [r7, #4]
340040c2:	681b      	ldr	r3, [r3, #0]
340040c4:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340040c8:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340040ca:	687b      	ldr	r3, [r7, #4]
340040cc:	691a      	ldr	r2, [r3, #16]
340040ce:	687b      	ldr	r3, [r7, #4]
340040d0:	695b      	ldr	r3, [r3, #20]
340040d2:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
340040d6:	687b      	ldr	r3, [r7, #4]
340040d8:	699b      	ldr	r3, [r3, #24]
340040da:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340040dc:	687b      	ldr	r3, [r7, #4]
340040de:	681b      	ldr	r3, [r3, #0]
340040e0:	430a      	orrs	r2, r1
340040e2:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
340040e4:	687b      	ldr	r3, [r7, #4]
340040e6:	69d9      	ldr	r1, [r3, #28]
340040e8:	687b      	ldr	r3, [r7, #4]
340040ea:	6a1a      	ldr	r2, [r3, #32]
340040ec:	687b      	ldr	r3, [r7, #4]
340040ee:	681b      	ldr	r3, [r3, #0]
340040f0:	430a      	orrs	r2, r1
340040f2:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
340040f4:	687b      	ldr	r3, [r7, #4]
340040f6:	681b      	ldr	r3, [r3, #0]
340040f8:	681a      	ldr	r2, [r3, #0]
340040fa:	687b      	ldr	r3, [r7, #4]
340040fc:	681b      	ldr	r3, [r3, #0]
340040fe:	f042 0201 	orr.w	r2, r2, #1
34004102:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
34004104:	687b      	ldr	r3, [r7, #4]
34004106:	2200      	movs	r2, #0
34004108:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
3400410a:	687b      	ldr	r3, [r7, #4]
3400410c:	2220      	movs	r2, #32
3400410e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
34004112:	687b      	ldr	r3, [r7, #4]
34004114:	2200      	movs	r2, #0
34004116:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
34004118:	687b      	ldr	r3, [r7, #4]
3400411a:	2200      	movs	r2, #0
3400411c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
34004120:	2300      	movs	r3, #0
}
34004122:	4618      	mov	r0, r3
34004124:	3708      	adds	r7, #8
34004126:	46bd      	mov	sp, r7
34004128:	bd80      	pop	{r7, pc}
	...

3400412c <HAL_I2C_Master_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
3400412c:	b580      	push	{r7, lr}
3400412e:	b088      	sub	sp, #32
34004130:	af02      	add	r7, sp, #8
34004132:	60f8      	str	r0, [r7, #12]
34004134:	607a      	str	r2, [r7, #4]
34004136:	461a      	mov	r2, r3
34004138:	460b      	mov	r3, r1
3400413a:	817b      	strh	r3, [r7, #10]
3400413c:	4613      	mov	r3, r2
3400413e:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
34004140:	68fb      	ldr	r3, [r7, #12]
34004142:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004146:	b2db      	uxtb	r3, r3
34004148:	2b20      	cmp	r3, #32
3400414a:	d153      	bne.n	340041f4 <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
3400414c:	68fb      	ldr	r3, [r7, #12]
3400414e:	681b      	ldr	r3, [r3, #0]
34004150:	699b      	ldr	r3, [r3, #24]
34004152:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004156:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400415a:	d101      	bne.n	34004160 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
3400415c:	2302      	movs	r3, #2
3400415e:	e04a      	b.n	340041f6 <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34004160:	68fb      	ldr	r3, [r7, #12]
34004162:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34004166:	2b01      	cmp	r3, #1
34004168:	d101      	bne.n	3400416e <HAL_I2C_Master_Transmit_IT+0x42>
3400416a:	2302      	movs	r3, #2
3400416c:	e043      	b.n	340041f6 <HAL_I2C_Master_Transmit_IT+0xca>
3400416e:	68fb      	ldr	r3, [r7, #12]
34004170:	2201      	movs	r2, #1
34004172:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
34004176:	68fb      	ldr	r3, [r7, #12]
34004178:	2221      	movs	r2, #33	@ 0x21
3400417a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
3400417e:	68fb      	ldr	r3, [r7, #12]
34004180:	2210      	movs	r2, #16
34004182:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
34004186:	68fb      	ldr	r3, [r7, #12]
34004188:	2200      	movs	r2, #0
3400418a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
3400418c:	68fb      	ldr	r3, [r7, #12]
3400418e:	687a      	ldr	r2, [r7, #4]
34004190:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
34004192:	68fb      	ldr	r3, [r7, #12]
34004194:	893a      	ldrh	r2, [r7, #8]
34004196:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34004198:	68fb      	ldr	r3, [r7, #12]
3400419a:	4a19      	ldr	r2, [pc, #100]	@ (34004200 <HAL_I2C_Master_Transmit_IT+0xd4>)
3400419c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
3400419e:	68fb      	ldr	r3, [r7, #12]
340041a0:	4a18      	ldr	r2, [pc, #96]	@ (34004204 <HAL_I2C_Master_Transmit_IT+0xd8>)
340041a2:	635a      	str	r2, [r3, #52]	@ 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
340041a4:	68fb      	ldr	r3, [r7, #12]
340041a6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340041a8:	b29b      	uxth	r3, r3
340041aa:	2bff      	cmp	r3, #255	@ 0xff
340041ac:	d906      	bls.n	340041bc <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
340041ae:	68fb      	ldr	r3, [r7, #12]
340041b0:	22ff      	movs	r2, #255	@ 0xff
340041b2:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_RELOAD_MODE;
340041b4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340041b8:	617b      	str	r3, [r7, #20]
340041ba:	e007      	b.n	340041cc <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
340041bc:	68fb      	ldr	r3, [r7, #12]
340041be:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340041c0:	b29a      	uxth	r2, r3
340041c2:	68fb      	ldr	r3, [r7, #12]
340041c4:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_AUTOEND_MODE;
340041c6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
340041ca:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
340041cc:	68fb      	ldr	r3, [r7, #12]
340041ce:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340041d0:	b2da      	uxtb	r2, r3
340041d2:	8979      	ldrh	r1, [r7, #10]
340041d4:	4b0c      	ldr	r3, [pc, #48]	@ (34004208 <HAL_I2C_Master_Transmit_IT+0xdc>)
340041d6:	9300      	str	r3, [sp, #0]
340041d8:	697b      	ldr	r3, [r7, #20]
340041da:	68f8      	ldr	r0, [r7, #12]
340041dc:	f001 fc2e 	bl	34005a3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340041e0:	68fb      	ldr	r3, [r7, #12]
340041e2:	2200      	movs	r2, #0
340041e4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
340041e8:	2101      	movs	r1, #1
340041ea:	68f8      	ldr	r0, [r7, #12]
340041ec:	f001 fc58 	bl	34005aa0 <I2C_Enable_IRQ>

    return HAL_OK;
340041f0:	2300      	movs	r3, #0
340041f2:	e000      	b.n	340041f6 <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
340041f4:	2302      	movs	r3, #2
  }
}
340041f6:	4618      	mov	r0, r3
340041f8:	3718      	adds	r7, #24
340041fa:	46bd      	mov	sp, r7
340041fc:	bd80      	pop	{r7, pc}
340041fe:	bf00      	nop
34004200:	ffff0000 	.word	0xffff0000
34004204:	3400458f 	.word	0x3400458f
34004208:	80002000 	.word	0x80002000

3400420c <HAL_I2C_Master_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                            uint16_t Size)
{
3400420c:	b580      	push	{r7, lr}
3400420e:	b088      	sub	sp, #32
34004210:	af02      	add	r7, sp, #8
34004212:	60f8      	str	r0, [r7, #12]
34004214:	607a      	str	r2, [r7, #4]
34004216:	461a      	mov	r2, r3
34004218:	460b      	mov	r3, r1
3400421a:	817b      	strh	r3, [r7, #10]
3400421c:	4613      	mov	r3, r2
3400421e:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
34004220:	68fb      	ldr	r3, [r7, #12]
34004222:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004226:	b2db      	uxtb	r3, r3
34004228:	2b20      	cmp	r3, #32
3400422a:	d153      	bne.n	340042d4 <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
3400422c:	68fb      	ldr	r3, [r7, #12]
3400422e:	681b      	ldr	r3, [r3, #0]
34004230:	699b      	ldr	r3, [r3, #24]
34004232:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004236:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400423a:	d101      	bne.n	34004240 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
3400423c:	2302      	movs	r3, #2
3400423e:	e04a      	b.n	340042d6 <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34004240:	68fb      	ldr	r3, [r7, #12]
34004242:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34004246:	2b01      	cmp	r3, #1
34004248:	d101      	bne.n	3400424e <HAL_I2C_Master_Receive_IT+0x42>
3400424a:	2302      	movs	r3, #2
3400424c:	e043      	b.n	340042d6 <HAL_I2C_Master_Receive_IT+0xca>
3400424e:	68fb      	ldr	r3, [r7, #12]
34004250:	2201      	movs	r2, #1
34004252:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
34004256:	68fb      	ldr	r3, [r7, #12]
34004258:	2222      	movs	r2, #34	@ 0x22
3400425a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
3400425e:	68fb      	ldr	r3, [r7, #12]
34004260:	2210      	movs	r2, #16
34004262:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
34004266:	68fb      	ldr	r3, [r7, #12]
34004268:	2200      	movs	r2, #0
3400426a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
3400426c:	68fb      	ldr	r3, [r7, #12]
3400426e:	687a      	ldr	r2, [r7, #4]
34004270:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
34004272:	68fb      	ldr	r3, [r7, #12]
34004274:	893a      	ldrh	r2, [r7, #8]
34004276:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34004278:	68fb      	ldr	r3, [r7, #12]
3400427a:	4a19      	ldr	r2, [pc, #100]	@ (340042e0 <HAL_I2C_Master_Receive_IT+0xd4>)
3400427c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
3400427e:	68fb      	ldr	r3, [r7, #12]
34004280:	4a18      	ldr	r2, [pc, #96]	@ (340042e4 <HAL_I2C_Master_Receive_IT+0xd8>)
34004282:	635a      	str	r2, [r3, #52]	@ 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004284:	68fb      	ldr	r3, [r7, #12]
34004286:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004288:	b29b      	uxth	r3, r3
3400428a:	2bff      	cmp	r3, #255	@ 0xff
3400428c:	d906      	bls.n	3400429c <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3400428e:	68fb      	ldr	r3, [r7, #12]
34004290:	22ff      	movs	r2, #255	@ 0xff
34004292:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_RELOAD_MODE;
34004294:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34004298:	617b      	str	r3, [r7, #20]
3400429a:	e007      	b.n	340042ac <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
3400429c:	68fb      	ldr	r3, [r7, #12]
3400429e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340042a0:	b29a      	uxth	r2, r3
340042a2:	68fb      	ldr	r3, [r7, #12]
340042a4:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_AUTOEND_MODE;
340042a6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
340042aa:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
340042ac:	68fb      	ldr	r3, [r7, #12]
340042ae:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340042b0:	b2da      	uxtb	r2, r3
340042b2:	8979      	ldrh	r1, [r7, #10]
340042b4:	4b0c      	ldr	r3, [pc, #48]	@ (340042e8 <HAL_I2C_Master_Receive_IT+0xdc>)
340042b6:	9300      	str	r3, [sp, #0]
340042b8:	697b      	ldr	r3, [r7, #20]
340042ba:	68f8      	ldr	r0, [r7, #12]
340042bc:	f001 fbbe 	bl	34005a3c <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340042c0:	68fb      	ldr	r3, [r7, #12]
340042c2:	2200      	movs	r2, #0
340042c4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
340042c8:	2102      	movs	r1, #2
340042ca:	68f8      	ldr	r0, [r7, #12]
340042cc:	f001 fbe8 	bl	34005aa0 <I2C_Enable_IRQ>

    return HAL_OK;
340042d0:	2300      	movs	r3, #0
340042d2:	e000      	b.n	340042d6 <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
340042d4:	2302      	movs	r3, #2
  }
}
340042d6:	4618      	mov	r0, r3
340042d8:	3718      	adds	r7, #24
340042da:	46bd      	mov	sp, r7
340042dc:	bd80      	pop	{r7, pc}
340042de:	bf00      	nop
340042e0:	ffff0000 	.word	0xffff0000
340042e4:	3400458f 	.word	0x3400458f
340042e8:	80002400 	.word	0x80002400

340042ec <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
340042ec:	b580      	push	{r7, lr}
340042ee:	b084      	sub	sp, #16
340042f0:	af00      	add	r7, sp, #0
340042f2:	60f8      	str	r0, [r7, #12]
340042f4:	60b9      	str	r1, [r7, #8]
340042f6:	4613      	mov	r3, r2
340042f8:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
340042fa:	68fb      	ldr	r3, [r7, #12]
340042fc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004300:	b2db      	uxtb	r3, r3
34004302:	2b20      	cmp	r3, #32
34004304:	d156      	bne.n	340043b4 <HAL_I2C_Slave_Transmit_IT+0xc8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34004306:	68fb      	ldr	r3, [r7, #12]
34004308:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400430c:	2b01      	cmp	r3, #1
3400430e:	d101      	bne.n	34004314 <HAL_I2C_Slave_Transmit_IT+0x28>
34004310:	2302      	movs	r3, #2
34004312:	e050      	b.n	340043b6 <HAL_I2C_Slave_Transmit_IT+0xca>
34004314:	68fb      	ldr	r3, [r7, #12]
34004316:	2201      	movs	r2, #1
34004318:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
3400431c:	68fb      	ldr	r3, [r7, #12]
3400431e:	2221      	movs	r2, #33	@ 0x21
34004320:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
34004324:	68fb      	ldr	r3, [r7, #12]
34004326:	2220      	movs	r2, #32
34004328:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
3400432c:	68fb      	ldr	r3, [r7, #12]
3400432e:	2200      	movs	r2, #0
34004330:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
34004332:	68fb      	ldr	r3, [r7, #12]
34004334:	681b      	ldr	r3, [r3, #0]
34004336:	685a      	ldr	r2, [r3, #4]
34004338:	68fb      	ldr	r3, [r7, #12]
3400433a:	681b      	ldr	r3, [r3, #0]
3400433c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34004340:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
34004342:	68fb      	ldr	r3, [r7, #12]
34004344:	68ba      	ldr	r2, [r7, #8]
34004346:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
34004348:	68fb      	ldr	r3, [r7, #12]
3400434a:	88fa      	ldrh	r2, [r7, #6]
3400434c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
3400434e:	68fb      	ldr	r3, [r7, #12]
34004350:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004352:	b29a      	uxth	r2, r3
34004354:	68fb      	ldr	r3, [r7, #12]
34004356:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34004358:	68fb      	ldr	r3, [r7, #12]
3400435a:	4a19      	ldr	r2, [pc, #100]	@ (340043c0 <HAL_I2C_Slave_Transmit_IT+0xd4>)
3400435c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
3400435e:	68fb      	ldr	r3, [r7, #12]
34004360:	4a18      	ldr	r2, [pc, #96]	@ (340043c4 <HAL_I2C_Slave_Transmit_IT+0xd8>)
34004362:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Preload TX data if no stretch enable */
    if (hi2c->Init.NoStretchMode == I2C_NOSTRETCH_ENABLE)
34004364:	68fb      	ldr	r3, [r7, #12]
34004366:	6a1b      	ldr	r3, [r3, #32]
34004368:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400436c:	d117      	bne.n	3400439e <HAL_I2C_Slave_Transmit_IT+0xb2>
    {
      /* Preload TX register */
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
3400436e:	68fb      	ldr	r3, [r7, #12]
34004370:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004372:	781a      	ldrb	r2, [r3, #0]
34004374:	68fb      	ldr	r3, [r7, #12]
34004376:	681b      	ldr	r3, [r3, #0]
34004378:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3400437a:	68fb      	ldr	r3, [r7, #12]
3400437c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400437e:	1c5a      	adds	r2, r3, #1
34004380:	68fb      	ldr	r3, [r7, #12]
34004382:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
34004384:	68fb      	ldr	r3, [r7, #12]
34004386:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004388:	b29b      	uxth	r3, r3
3400438a:	3b01      	subs	r3, #1
3400438c:	b29a      	uxth	r2, r3
3400438e:	68fb      	ldr	r3, [r7, #12]
34004390:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
34004392:	68fb      	ldr	r3, [r7, #12]
34004394:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004396:	3b01      	subs	r3, #1
34004398:	b29a      	uxth	r2, r3
3400439a:	68fb      	ldr	r3, [r7, #12]
3400439c:	851a      	strh	r2, [r3, #40]	@ 0x28
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400439e:	68fb      	ldr	r3, [r7, #12]
340043a0:	2200      	movs	r2, #0
340043a2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
340043a6:	f248 0101 	movw	r1, #32769	@ 0x8001
340043aa:	68f8      	ldr	r0, [r7, #12]
340043ac:	f001 fb78 	bl	34005aa0 <I2C_Enable_IRQ>

    return HAL_OK;
340043b0:	2300      	movs	r3, #0
340043b2:	e000      	b.n	340043b6 <HAL_I2C_Slave_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
340043b4:	2302      	movs	r3, #2
  }
}
340043b6:	4618      	mov	r0, r3
340043b8:	3710      	adds	r7, #16
340043ba:	46bd      	mov	sp, r7
340043bc:	bd80      	pop	{r7, pc}
340043be:	bf00      	nop
340043c0:	ffff0000 	.word	0xffff0000
340043c4:	340047df 	.word	0x340047df

340043c8 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
340043c8:	b580      	push	{r7, lr}
340043ca:	b084      	sub	sp, #16
340043cc:	af00      	add	r7, sp, #0
340043ce:	60f8      	str	r0, [r7, #12]
340043d0:	60b9      	str	r1, [r7, #8]
340043d2:	4613      	mov	r3, r2
340043d4:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
340043d6:	68fb      	ldr	r3, [r7, #12]
340043d8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340043dc:	b2db      	uxtb	r3, r3
340043de:	2b20      	cmp	r3, #32
340043e0:	d139      	bne.n	34004456 <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340043e2:	68fb      	ldr	r3, [r7, #12]
340043e4:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340043e8:	2b01      	cmp	r3, #1
340043ea:	d101      	bne.n	340043f0 <HAL_I2C_Slave_Receive_IT+0x28>
340043ec:	2302      	movs	r3, #2
340043ee:	e033      	b.n	34004458 <HAL_I2C_Slave_Receive_IT+0x90>
340043f0:	68fb      	ldr	r3, [r7, #12]
340043f2:	2201      	movs	r2, #1
340043f4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
340043f8:	68fb      	ldr	r3, [r7, #12]
340043fa:	2222      	movs	r2, #34	@ 0x22
340043fc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
34004400:	68fb      	ldr	r3, [r7, #12]
34004402:	2220      	movs	r2, #32
34004404:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
34004408:	68fb      	ldr	r3, [r7, #12]
3400440a:	2200      	movs	r2, #0
3400440c:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
3400440e:	68fb      	ldr	r3, [r7, #12]
34004410:	681b      	ldr	r3, [r3, #0]
34004412:	685a      	ldr	r2, [r3, #4]
34004414:	68fb      	ldr	r3, [r7, #12]
34004416:	681b      	ldr	r3, [r3, #0]
34004418:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400441c:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
3400441e:	68fb      	ldr	r3, [r7, #12]
34004420:	68ba      	ldr	r2, [r7, #8]
34004422:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
34004424:	68fb      	ldr	r3, [r7, #12]
34004426:	88fa      	ldrh	r2, [r7, #6]
34004428:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
3400442a:	68fb      	ldr	r3, [r7, #12]
3400442c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400442e:	b29a      	uxth	r2, r3
34004430:	68fb      	ldr	r3, [r7, #12]
34004432:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34004434:	68fb      	ldr	r3, [r7, #12]
34004436:	4a0a      	ldr	r2, [pc, #40]	@ (34004460 <HAL_I2C_Slave_Receive_IT+0x98>)
34004438:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
3400443a:	68fb      	ldr	r3, [r7, #12]
3400443c:	4a09      	ldr	r2, [pc, #36]	@ (34004464 <HAL_I2C_Slave_Receive_IT+0x9c>)
3400443e:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34004440:	68fb      	ldr	r3, [r7, #12]
34004442:	2200      	movs	r2, #0
34004444:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
34004448:	f248 0102 	movw	r1, #32770	@ 0x8002
3400444c:	68f8      	ldr	r0, [r7, #12]
3400444e:	f001 fb27 	bl	34005aa0 <I2C_Enable_IRQ>

    return HAL_OK;
34004452:	2300      	movs	r3, #0
34004454:	e000      	b.n	34004458 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
34004456:	2302      	movs	r3, #2
  }
}
34004458:	4618      	mov	r0, r3
3400445a:	3710      	adds	r7, #16
3400445c:	46bd      	mov	sp, r7
3400445e:	bd80      	pop	{r7, pc}
34004460:	ffff0000 	.word	0xffff0000
34004464:	340047df 	.word	0x340047df

34004468 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c) /* Derogation MISRAC2012-Rule-8.13 */
{
34004468:	b580      	push	{r7, lr}
3400446a:	b084      	sub	sp, #16
3400446c:	af00      	add	r7, sp, #0
3400446e:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
34004470:	687b      	ldr	r3, [r7, #4]
34004472:	681b      	ldr	r3, [r3, #0]
34004474:	699b      	ldr	r3, [r3, #24]
34004476:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
34004478:	687b      	ldr	r3, [r7, #4]
3400447a:	681b      	ldr	r3, [r3, #0]
3400447c:	681b      	ldr	r3, [r3, #0]
3400447e:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
34004480:	687b      	ldr	r3, [r7, #4]
34004482:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34004484:	2b00      	cmp	r3, #0
34004486:	d005      	beq.n	34004494 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
34004488:	687b      	ldr	r3, [r7, #4]
3400448a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400448c:	68ba      	ldr	r2, [r7, #8]
3400448e:	68f9      	ldr	r1, [r7, #12]
34004490:	6878      	ldr	r0, [r7, #4]
34004492:	4798      	blx	r3
  }
}
34004494:	bf00      	nop
34004496:	3710      	adds	r7, #16
34004498:	46bd      	mov	sp, r7
3400449a:	bd80      	pop	{r7, pc}

3400449c <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
3400449c:	b580      	push	{r7, lr}
3400449e:	b086      	sub	sp, #24
340044a0:	af00      	add	r7, sp, #0
340044a2:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
340044a4:	687b      	ldr	r3, [r7, #4]
340044a6:	681b      	ldr	r3, [r3, #0]
340044a8:	699b      	ldr	r3, [r3, #24]
340044aa:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
340044ac:	687b      	ldr	r3, [r7, #4]
340044ae:	681b      	ldr	r3, [r3, #0]
340044b0:	681b      	ldr	r3, [r3, #0]
340044b2:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
340044b4:	697b      	ldr	r3, [r7, #20]
340044b6:	0a1b      	lsrs	r3, r3, #8
340044b8:	f003 0301 	and.w	r3, r3, #1
340044bc:	2b00      	cmp	r3, #0
340044be:	d010      	beq.n	340044e2 <HAL_I2C_ER_IRQHandler+0x46>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
340044c0:	693b      	ldr	r3, [r7, #16]
340044c2:	09db      	lsrs	r3, r3, #7
340044c4:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
340044c8:	2b00      	cmp	r3, #0
340044ca:	d00a      	beq.n	340044e2 <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
340044cc:	687b      	ldr	r3, [r7, #4]
340044ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340044d0:	f043 0201 	orr.w	r2, r3, #1
340044d4:	687b      	ldr	r3, [r7, #4]
340044d6:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
340044d8:	687b      	ldr	r3, [r7, #4]
340044da:	681b      	ldr	r3, [r3, #0]
340044dc:	f44f 7280 	mov.w	r2, #256	@ 0x100
340044e0:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
340044e2:	697b      	ldr	r3, [r7, #20]
340044e4:	0a9b      	lsrs	r3, r3, #10
340044e6:	f003 0301 	and.w	r3, r3, #1
340044ea:	2b00      	cmp	r3, #0
340044ec:	d010      	beq.n	34004510 <HAL_I2C_ER_IRQHandler+0x74>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
340044ee:	693b      	ldr	r3, [r7, #16]
340044f0:	09db      	lsrs	r3, r3, #7
340044f2:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
340044f6:	2b00      	cmp	r3, #0
340044f8:	d00a      	beq.n	34004510 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
340044fa:	687b      	ldr	r3, [r7, #4]
340044fc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340044fe:	f043 0208 	orr.w	r2, r3, #8
34004502:	687b      	ldr	r3, [r7, #4]
34004504:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
34004506:	687b      	ldr	r3, [r7, #4]
34004508:	681b      	ldr	r3, [r3, #0]
3400450a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400450e:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
34004510:	697b      	ldr	r3, [r7, #20]
34004512:	0a5b      	lsrs	r3, r3, #9
34004514:	f003 0301 	and.w	r3, r3, #1
34004518:	2b00      	cmp	r3, #0
3400451a:	d010      	beq.n	3400453e <HAL_I2C_ER_IRQHandler+0xa2>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
3400451c:	693b      	ldr	r3, [r7, #16]
3400451e:	09db      	lsrs	r3, r3, #7
34004520:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
34004524:	2b00      	cmp	r3, #0
34004526:	d00a      	beq.n	3400453e <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
34004528:	687b      	ldr	r3, [r7, #4]
3400452a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400452c:	f043 0202 	orr.w	r2, r3, #2
34004530:	687b      	ldr	r3, [r7, #4]
34004532:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
34004534:	687b      	ldr	r3, [r7, #4]
34004536:	681b      	ldr	r3, [r3, #0]
34004538:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400453c:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
3400453e:	687b      	ldr	r3, [r7, #4]
34004540:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004542:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
34004544:	68fb      	ldr	r3, [r7, #12]
34004546:	f003 030b 	and.w	r3, r3, #11
3400454a:	2b00      	cmp	r3, #0
3400454c:	d003      	beq.n	34004556 <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
3400454e:	68f9      	ldr	r1, [r7, #12]
34004550:	6878      	ldr	r0, [r7, #4]
34004552:	f001 f919 	bl	34005788 <I2C_ITError>
  }
}
34004556:	bf00      	nop
34004558:	3718      	adds	r7, #24
3400455a:	46bd      	mov	sp, r7
3400455c:	bd80      	pop	{r7, pc}

3400455e <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
3400455e:	b480      	push	{r7}
34004560:	b083      	sub	sp, #12
34004562:	af00      	add	r7, sp, #0
34004564:	6078      	str	r0, [r7, #4]
34004566:	460b      	mov	r3, r1
34004568:	70fb      	strb	r3, [r7, #3]
3400456a:	4613      	mov	r3, r2
3400456c:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
3400456e:	bf00      	nop
34004570:	370c      	adds	r7, #12
34004572:	46bd      	mov	sp, r7
34004574:	f85d 7b04 	ldr.w	r7, [sp], #4
34004578:	4770      	bx	lr

3400457a <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400457a:	b480      	push	{r7}
3400457c:	b083      	sub	sp, #12
3400457e:	af00      	add	r7, sp, #0
34004580:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
34004582:	bf00      	nop
34004584:	370c      	adds	r7, #12
34004586:	46bd      	mov	sp, r7
34004588:	f85d 7b04 	ldr.w	r7, [sp], #4
3400458c:	4770      	bx	lr

3400458e <I2C_Master_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
3400458e:	b580      	push	{r7, lr}
34004590:	b088      	sub	sp, #32
34004592:	af02      	add	r7, sp, #8
34004594:	60f8      	str	r0, [r7, #12]
34004596:	60b9      	str	r1, [r7, #8]
34004598:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
3400459a:	68bb      	ldr	r3, [r7, #8]
3400459c:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
3400459e:	68fb      	ldr	r3, [r7, #12]
340045a0:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340045a4:	2b01      	cmp	r3, #1
340045a6:	d101      	bne.n	340045ac <I2C_Master_ISR_IT+0x1e>
340045a8:	2302      	movs	r3, #2
340045aa:	e114      	b.n	340047d6 <I2C_Master_ISR_IT+0x248>
340045ac:	68fb      	ldr	r3, [r7, #12]
340045ae:	2201      	movs	r2, #1
340045b0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
340045b4:	697b      	ldr	r3, [r7, #20]
340045b6:	091b      	lsrs	r3, r3, #4
340045b8:	f003 0301 	and.w	r3, r3, #1
340045bc:	2b00      	cmp	r3, #0
340045be:	d013      	beq.n	340045e8 <I2C_Master_ISR_IT+0x5a>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
340045c0:	687b      	ldr	r3, [r7, #4]
340045c2:	091b      	lsrs	r3, r3, #4
340045c4:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
340045c8:	2b00      	cmp	r3, #0
340045ca:	d00d      	beq.n	340045e8 <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340045cc:	68fb      	ldr	r3, [r7, #12]
340045ce:	681b      	ldr	r3, [r3, #0]
340045d0:	2210      	movs	r2, #16
340045d2:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340045d4:	68fb      	ldr	r3, [r7, #12]
340045d6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340045d8:	f043 0204 	orr.w	r2, r3, #4
340045dc:	68fb      	ldr	r3, [r7, #12]
340045de:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
340045e0:	68f8      	ldr	r0, [r7, #12]
340045e2:	f001 f9e8 	bl	340059b6 <I2C_Flush_TXDR>
340045e6:	e0e1      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340045e8:	697b      	ldr	r3, [r7, #20]
340045ea:	089b      	lsrs	r3, r3, #2
340045ec:	f003 0301 	and.w	r3, r3, #1
340045f0:	2b00      	cmp	r3, #0
340045f2:	d023      	beq.n	3400463c <I2C_Master_ISR_IT+0xae>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
340045f4:	687b      	ldr	r3, [r7, #4]
340045f6:	089b      	lsrs	r3, r3, #2
340045f8:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340045fc:	2b00      	cmp	r3, #0
340045fe:	d01d      	beq.n	3400463c <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
34004600:	697b      	ldr	r3, [r7, #20]
34004602:	f023 0304 	bic.w	r3, r3, #4
34004606:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34004608:	68fb      	ldr	r3, [r7, #12]
3400460a:	681b      	ldr	r3, [r3, #0]
3400460c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400460e:	68fb      	ldr	r3, [r7, #12]
34004610:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004612:	b2d2      	uxtb	r2, r2
34004614:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
34004616:	68fb      	ldr	r3, [r7, #12]
34004618:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400461a:	1c5a      	adds	r2, r3, #1
3400461c:	68fb      	ldr	r3, [r7, #12]
3400461e:	625a      	str	r2, [r3, #36]	@ 0x24

    hi2c->XferSize--;
34004620:	68fb      	ldr	r3, [r7, #12]
34004622:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004624:	3b01      	subs	r3, #1
34004626:	b29a      	uxth	r2, r3
34004628:	68fb      	ldr	r3, [r7, #12]
3400462a:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferCount--;
3400462c:	68fb      	ldr	r3, [r7, #12]
3400462e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004630:	b29b      	uxth	r3, r3
34004632:	3b01      	subs	r3, #1
34004634:	b29a      	uxth	r2, r3
34004636:	68fb      	ldr	r3, [r7, #12]
34004638:	855a      	strh	r2, [r3, #42]	@ 0x2a
3400463a:	e0b7      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
3400463c:	697b      	ldr	r3, [r7, #20]
3400463e:	085b      	lsrs	r3, r3, #1
34004640:	f003 0301 	and.w	r3, r3, #1
34004644:	2b00      	cmp	r3, #0
34004646:	d01e      	beq.n	34004686 <I2C_Master_ISR_IT+0xf8>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34004648:	687b      	ldr	r3, [r7, #4]
3400464a:	085b      	lsrs	r3, r3, #1
3400464c:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34004650:	2b00      	cmp	r3, #0
34004652:	d018      	beq.n	34004686 <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34004654:	68fb      	ldr	r3, [r7, #12]
34004656:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004658:	781a      	ldrb	r2, [r3, #0]
3400465a:	68fb      	ldr	r3, [r7, #12]
3400465c:	681b      	ldr	r3, [r3, #0]
3400465e:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
34004660:	68fb      	ldr	r3, [r7, #12]
34004662:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004664:	1c5a      	adds	r2, r3, #1
34004666:	68fb      	ldr	r3, [r7, #12]
34004668:	625a      	str	r2, [r3, #36]	@ 0x24

    hi2c->XferSize--;
3400466a:	68fb      	ldr	r3, [r7, #12]
3400466c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400466e:	3b01      	subs	r3, #1
34004670:	b29a      	uxth	r2, r3
34004672:	68fb      	ldr	r3, [r7, #12]
34004674:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferCount--;
34004676:	68fb      	ldr	r3, [r7, #12]
34004678:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400467a:	b29b      	uxth	r3, r3
3400467c:	3b01      	subs	r3, #1
3400467e:	b29a      	uxth	r2, r3
34004680:	68fb      	ldr	r3, [r7, #12]
34004682:	855a      	strh	r2, [r3, #42]	@ 0x2a
34004684:	e092      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
34004686:	697b      	ldr	r3, [r7, #20]
34004688:	09db      	lsrs	r3, r3, #7
3400468a:	f003 0301 	and.w	r3, r3, #1
3400468e:	2b00      	cmp	r3, #0
34004690:	d05d      	beq.n	3400474e <I2C_Master_ISR_IT+0x1c0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34004692:	687b      	ldr	r3, [r7, #4]
34004694:	099b      	lsrs	r3, r3, #6
34004696:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
3400469a:	2b00      	cmp	r3, #0
3400469c:	d057      	beq.n	3400474e <I2C_Master_ISR_IT+0x1c0>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400469e:	68fb      	ldr	r3, [r7, #12]
340046a0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340046a2:	b29b      	uxth	r3, r3
340046a4:	2b00      	cmp	r3, #0
340046a6:	d040      	beq.n	3400472a <I2C_Master_ISR_IT+0x19c>
340046a8:	68fb      	ldr	r3, [r7, #12]
340046aa:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340046ac:	2b00      	cmp	r3, #0
340046ae:	d13c      	bne.n	3400472a <I2C_Master_ISR_IT+0x19c>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
340046b0:	68fb      	ldr	r3, [r7, #12]
340046b2:	681b      	ldr	r3, [r3, #0]
340046b4:	685b      	ldr	r3, [r3, #4]
340046b6:	b29b      	uxth	r3, r3
340046b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
340046bc:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
340046be:	68fb      	ldr	r3, [r7, #12]
340046c0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340046c2:	b29b      	uxth	r3, r3
340046c4:	2bff      	cmp	r3, #255	@ 0xff
340046c6:	d90e      	bls.n	340046e6 <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
340046c8:	68fb      	ldr	r3, [r7, #12]
340046ca:	22ff      	movs	r2, #255	@ 0xff
340046cc:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340046ce:	68fb      	ldr	r3, [r7, #12]
340046d0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340046d2:	b2da      	uxtb	r2, r3
340046d4:	8a79      	ldrh	r1, [r7, #18]
340046d6:	2300      	movs	r3, #0
340046d8:	9300      	str	r3, [sp, #0]
340046da:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340046de:	68f8      	ldr	r0, [r7, #12]
340046e0:	f001 f9ac 	bl	34005a3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
340046e4:	e032      	b.n	3400474c <I2C_Master_ISR_IT+0x1be>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
340046e6:	68fb      	ldr	r3, [r7, #12]
340046e8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340046ea:	b29a      	uxth	r2, r3
340046ec:	68fb      	ldr	r3, [r7, #12]
340046ee:	851a      	strh	r2, [r3, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
340046f0:	68fb      	ldr	r3, [r7, #12]
340046f2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340046f4:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
340046f8:	d00b      	beq.n	34004712 <I2C_Master_ISR_IT+0x184>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
340046fa:	68fb      	ldr	r3, [r7, #12]
340046fc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340046fe:	b2da      	uxtb	r2, r3
                             hi2c->XferOptions, I2C_NO_STARTSTOP);
34004700:	68fb      	ldr	r3, [r7, #12]
34004702:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
34004704:	8a79      	ldrh	r1, [r7, #18]
34004706:	2000      	movs	r0, #0
34004708:	9000      	str	r0, [sp, #0]
3400470a:	68f8      	ldr	r0, [r7, #12]
3400470c:	f001 f996 	bl	34005a3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004710:	e01c      	b.n	3400474c <I2C_Master_ISR_IT+0x1be>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
34004712:	68fb      	ldr	r3, [r7, #12]
34004714:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004716:	b2da      	uxtb	r2, r3
34004718:	8a79      	ldrh	r1, [r7, #18]
3400471a:	2300      	movs	r3, #0
3400471c:	9300      	str	r3, [sp, #0]
3400471e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34004722:	68f8      	ldr	r0, [r7, #12]
34004724:	f001 f98a 	bl	34005a3c <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004728:	e010      	b.n	3400474c <I2C_Master_ISR_IT+0x1be>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
3400472a:	68fb      	ldr	r3, [r7, #12]
3400472c:	681b      	ldr	r3, [r3, #0]
3400472e:	685b      	ldr	r3, [r3, #4]
34004730:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34004734:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34004738:	d003      	beq.n	34004742 <I2C_Master_ISR_IT+0x1b4>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
3400473a:	68f8      	ldr	r0, [r7, #12]
3400473c:	f000 fcec 	bl	34005118 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34004740:	e034      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34004742:	2140      	movs	r1, #64	@ 0x40
34004744:	68f8      	ldr	r0, [r7, #12]
34004746:	f001 f81f 	bl	34005788 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400474a:	e02f      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
3400474c:	e02e      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
3400474e:	697b      	ldr	r3, [r7, #20]
34004750:	099b      	lsrs	r3, r3, #6
34004752:	f003 0301 	and.w	r3, r3, #1
34004756:	2b00      	cmp	r3, #0
34004758:	d028      	beq.n	340047ac <I2C_Master_ISR_IT+0x21e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
3400475a:	687b      	ldr	r3, [r7, #4]
3400475c:	099b      	lsrs	r3, r3, #6
3400475e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
34004762:	2b00      	cmp	r3, #0
34004764:	d022      	beq.n	340047ac <I2C_Master_ISR_IT+0x21e>
  {
    if (hi2c->XferCount == 0U)
34004766:	68fb      	ldr	r3, [r7, #12]
34004768:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400476a:	b29b      	uxth	r3, r3
3400476c:	2b00      	cmp	r3, #0
3400476e:	d119      	bne.n	340047a4 <I2C_Master_ISR_IT+0x216>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34004770:	68fb      	ldr	r3, [r7, #12]
34004772:	681b      	ldr	r3, [r3, #0]
34004774:	685b      	ldr	r3, [r3, #4]
34004776:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400477a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400477e:	d015      	beq.n	340047ac <I2C_Master_ISR_IT+0x21e>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
34004780:	68fb      	ldr	r3, [r7, #12]
34004782:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004784:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34004788:	d108      	bne.n	3400479c <I2C_Master_ISR_IT+0x20e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
3400478a:	68fb      	ldr	r3, [r7, #12]
3400478c:	681b      	ldr	r3, [r3, #0]
3400478e:	685a      	ldr	r2, [r3, #4]
34004790:	68fb      	ldr	r3, [r7, #12]
34004792:	681b      	ldr	r3, [r3, #0]
34004794:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004798:	605a      	str	r2, [r3, #4]
3400479a:	e007      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
3400479c:	68f8      	ldr	r0, [r7, #12]
3400479e:	f000 fcbb 	bl	34005118 <I2C_ITMasterSeqCplt>
340047a2:	e003      	b.n	340047ac <I2C_Master_ISR_IT+0x21e>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
340047a4:	2140      	movs	r1, #64	@ 0x40
340047a6:	68f8      	ldr	r0, [r7, #12]
340047a8:	f000 ffee 	bl	34005788 <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
340047ac:	697b      	ldr	r3, [r7, #20]
340047ae:	095b      	lsrs	r3, r3, #5
340047b0:	f003 0301 	and.w	r3, r3, #1
340047b4:	2b00      	cmp	r3, #0
340047b6:	d009      	beq.n	340047cc <I2C_Master_ISR_IT+0x23e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
340047b8:	687b      	ldr	r3, [r7, #4]
340047ba:	095b      	lsrs	r3, r3, #5
340047bc:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
340047c0:	2b00      	cmp	r3, #0
340047c2:	d003      	beq.n	340047cc <I2C_Master_ISR_IT+0x23e>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
340047c4:	6979      	ldr	r1, [r7, #20]
340047c6:	68f8      	ldr	r0, [r7, #12]
340047c8:	f000 fd42 	bl	34005250 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
340047cc:	68fb      	ldr	r3, [r7, #12]
340047ce:	2200      	movs	r2, #0
340047d0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
340047d4:	2300      	movs	r3, #0
}
340047d6:	4618      	mov	r0, r3
340047d8:	3718      	adds	r7, #24
340047da:	46bd      	mov	sp, r7
340047dc:	bd80      	pop	{r7, pc}

340047de <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
340047de:	b580      	push	{r7, lr}
340047e0:	b086      	sub	sp, #24
340047e2:	af00      	add	r7, sp, #0
340047e4:	60f8      	str	r0, [r7, #12]
340047e6:	60b9      	str	r1, [r7, #8]
340047e8:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
340047ea:	68fb      	ldr	r3, [r7, #12]
340047ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340047ee:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
340047f0:	68bb      	ldr	r3, [r7, #8]
340047f2:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
340047f4:	68fb      	ldr	r3, [r7, #12]
340047f6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340047fa:	2b01      	cmp	r3, #1
340047fc:	d101      	bne.n	34004802 <I2C_Slave_ISR_IT+0x24>
340047fe:	2302      	movs	r3, #2
34004800:	e0ed      	b.n	340049de <I2C_Slave_ISR_IT+0x200>
34004802:	68fb      	ldr	r3, [r7, #12]
34004804:	2201      	movs	r2, #1
34004806:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
3400480a:	693b      	ldr	r3, [r7, #16]
3400480c:	095b      	lsrs	r3, r3, #5
3400480e:	f003 0301 	and.w	r3, r3, #1
34004812:	2b00      	cmp	r3, #0
34004814:	d00a      	beq.n	3400482c <I2C_Slave_ISR_IT+0x4e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34004816:	687b      	ldr	r3, [r7, #4]
34004818:	095b      	lsrs	r3, r3, #5
3400481a:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
3400481e:	2b00      	cmp	r3, #0
34004820:	d004      	beq.n	3400482c <I2C_Slave_ISR_IT+0x4e>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
34004822:	6939      	ldr	r1, [r7, #16]
34004824:	68f8      	ldr	r0, [r7, #12]
34004826:	f000 fddd 	bl	340053e4 <I2C_ITSlaveCplt>
3400482a:	e0d3      	b.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
3400482c:	693b      	ldr	r3, [r7, #16]
3400482e:	091b      	lsrs	r3, r3, #4
34004830:	f003 0301 	and.w	r3, r3, #1
34004834:	2b00      	cmp	r3, #0
34004836:	d04d      	beq.n	340048d4 <I2C_Slave_ISR_IT+0xf6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34004838:	687b      	ldr	r3, [r7, #4]
3400483a:	091b      	lsrs	r3, r3, #4
3400483c:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
34004840:	2b00      	cmp	r3, #0
34004842:	d047      	beq.n	340048d4 <I2C_Slave_ISR_IT+0xf6>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
34004844:	68fb      	ldr	r3, [r7, #12]
34004846:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004848:	b29b      	uxth	r3, r3
3400484a:	2b00      	cmp	r3, #0
3400484c:	d128      	bne.n	340048a0 <I2C_Slave_ISR_IT+0xc2>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
3400484e:	68fb      	ldr	r3, [r7, #12]
34004850:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004854:	b2db      	uxtb	r3, r3
34004856:	2b28      	cmp	r3, #40	@ 0x28
34004858:	d108      	bne.n	3400486c <I2C_Slave_ISR_IT+0x8e>
3400485a:	697b      	ldr	r3, [r7, #20]
3400485c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34004860:	d104      	bne.n	3400486c <I2C_Slave_ISR_IT+0x8e>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
34004862:	6939      	ldr	r1, [r7, #16]
34004864:	68f8      	ldr	r0, [r7, #12]
34004866:	f000 ff39 	bl	340056dc <I2C_ITListenCplt>
3400486a:	e032      	b.n	340048d2 <I2C_Slave_ISR_IT+0xf4>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
3400486c:	68fb      	ldr	r3, [r7, #12]
3400486e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004872:	b2db      	uxtb	r3, r3
34004874:	2b29      	cmp	r3, #41	@ 0x29
34004876:	d10e      	bne.n	34004896 <I2C_Slave_ISR_IT+0xb8>
34004878:	697b      	ldr	r3, [r7, #20]
3400487a:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
3400487e:	d00a      	beq.n	34004896 <I2C_Slave_ISR_IT+0xb8>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004880:	68fb      	ldr	r3, [r7, #12]
34004882:	681b      	ldr	r3, [r3, #0]
34004884:	2210      	movs	r2, #16
34004886:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
34004888:	68f8      	ldr	r0, [r7, #12]
3400488a:	f001 f894 	bl	340059b6 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
3400488e:	68f8      	ldr	r0, [r7, #12]
34004890:	f000 fc7f 	bl	34005192 <I2C_ITSlaveSeqCplt>
34004894:	e01d      	b.n	340048d2 <I2C_Slave_ISR_IT+0xf4>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004896:	68fb      	ldr	r3, [r7, #12]
34004898:	681b      	ldr	r3, [r3, #0]
3400489a:	2210      	movs	r2, #16
3400489c:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
3400489e:	e096      	b.n	340049ce <I2C_Slave_ISR_IT+0x1f0>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340048a0:	68fb      	ldr	r3, [r7, #12]
340048a2:	681b      	ldr	r3, [r3, #0]
340048a4:	2210      	movs	r2, #16
340048a6:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340048a8:	68fb      	ldr	r3, [r7, #12]
340048aa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340048ac:	f043 0204 	orr.w	r2, r3, #4
340048b0:	68fb      	ldr	r3, [r7, #12]
340048b2:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
340048b4:	697b      	ldr	r3, [r7, #20]
340048b6:	2b00      	cmp	r3, #0
340048b8:	d004      	beq.n	340048c4 <I2C_Slave_ISR_IT+0xe6>
340048ba:	697b      	ldr	r3, [r7, #20]
340048bc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340048c0:	f040 8085 	bne.w	340049ce <I2C_Slave_ISR_IT+0x1f0>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
340048c4:	68fb      	ldr	r3, [r7, #12]
340048c6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340048c8:	4619      	mov	r1, r3
340048ca:	68f8      	ldr	r0, [r7, #12]
340048cc:	f000 ff5c 	bl	34005788 <I2C_ITError>
    if (hi2c->XferCount == 0U)
340048d0:	e07d      	b.n	340049ce <I2C_Slave_ISR_IT+0x1f0>
340048d2:	e07c      	b.n	340049ce <I2C_Slave_ISR_IT+0x1f0>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340048d4:	693b      	ldr	r3, [r7, #16]
340048d6:	089b      	lsrs	r3, r3, #2
340048d8:	f003 0301 	and.w	r3, r3, #1
340048dc:	2b00      	cmp	r3, #0
340048de:	d030      	beq.n	34004942 <I2C_Slave_ISR_IT+0x164>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
340048e0:	687b      	ldr	r3, [r7, #4]
340048e2:	089b      	lsrs	r3, r3, #2
340048e4:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340048e8:	2b00      	cmp	r3, #0
340048ea:	d02a      	beq.n	34004942 <I2C_Slave_ISR_IT+0x164>
  {
    if (hi2c->XferCount > 0U)
340048ec:	68fb      	ldr	r3, [r7, #12]
340048ee:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340048f0:	b29b      	uxth	r3, r3
340048f2:	2b00      	cmp	r3, #0
340048f4:	d018      	beq.n	34004928 <I2C_Slave_ISR_IT+0x14a>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340048f6:	68fb      	ldr	r3, [r7, #12]
340048f8:	681b      	ldr	r3, [r3, #0]
340048fa:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340048fc:	68fb      	ldr	r3, [r7, #12]
340048fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004900:	b2d2      	uxtb	r2, r2
34004902:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34004904:	68fb      	ldr	r3, [r7, #12]
34004906:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004908:	1c5a      	adds	r2, r3, #1
3400490a:	68fb      	ldr	r3, [r7, #12]
3400490c:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
3400490e:	68fb      	ldr	r3, [r7, #12]
34004910:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004912:	3b01      	subs	r3, #1
34004914:	b29a      	uxth	r2, r3
34004916:	68fb      	ldr	r3, [r7, #12]
34004918:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
3400491a:	68fb      	ldr	r3, [r7, #12]
3400491c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400491e:	b29b      	uxth	r3, r3
34004920:	3b01      	subs	r3, #1
34004922:	b29a      	uxth	r2, r3
34004924:	68fb      	ldr	r3, [r7, #12]
34004926:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
34004928:	68fb      	ldr	r3, [r7, #12]
3400492a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400492c:	b29b      	uxth	r3, r3
3400492e:	2b00      	cmp	r3, #0
34004930:	d14f      	bne.n	340049d2 <I2C_Slave_ISR_IT+0x1f4>
34004932:	697b      	ldr	r3, [r7, #20]
34004934:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34004938:	d04b      	beq.n	340049d2 <I2C_Slave_ISR_IT+0x1f4>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
3400493a:	68f8      	ldr	r0, [r7, #12]
3400493c:	f000 fc29 	bl	34005192 <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
34004940:	e047      	b.n	340049d2 <I2C_Slave_ISR_IT+0x1f4>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
34004942:	693b      	ldr	r3, [r7, #16]
34004944:	08db      	lsrs	r3, r3, #3
34004946:	f003 0301 	and.w	r3, r3, #1
3400494a:	2b00      	cmp	r3, #0
3400494c:	d00a      	beq.n	34004964 <I2C_Slave_ISR_IT+0x186>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
3400494e:	687b      	ldr	r3, [r7, #4]
34004950:	08db      	lsrs	r3, r3, #3
34004952:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
34004956:	2b00      	cmp	r3, #0
34004958:	d004      	beq.n	34004964 <I2C_Slave_ISR_IT+0x186>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
3400495a:	6939      	ldr	r1, [r7, #16]
3400495c:	68f8      	ldr	r0, [r7, #12]
3400495e:	f000 fb57 	bl	34005010 <I2C_ITAddrCplt>
34004962:	e037      	b.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34004964:	693b      	ldr	r3, [r7, #16]
34004966:	085b      	lsrs	r3, r3, #1
34004968:	f003 0301 	and.w	r3, r3, #1
3400496c:	2b00      	cmp	r3, #0
3400496e:	d031      	beq.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34004970:	687b      	ldr	r3, [r7, #4]
34004972:	085b      	lsrs	r3, r3, #1
34004974:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34004978:	2b00      	cmp	r3, #0
3400497a:	d02b      	beq.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
3400497c:	68fb      	ldr	r3, [r7, #12]
3400497e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004980:	b29b      	uxth	r3, r3
34004982:	2b00      	cmp	r3, #0
34004984:	d018      	beq.n	340049b8 <I2C_Slave_ISR_IT+0x1da>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34004986:	68fb      	ldr	r3, [r7, #12]
34004988:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400498a:	781a      	ldrb	r2, [r3, #0]
3400498c:	68fb      	ldr	r3, [r7, #12]
3400498e:	681b      	ldr	r3, [r3, #0]
34004990:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34004992:	68fb      	ldr	r3, [r7, #12]
34004994:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34004996:	1c5a      	adds	r2, r3, #1
34004998:	68fb      	ldr	r3, [r7, #12]
3400499a:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
3400499c:	68fb      	ldr	r3, [r7, #12]
3400499e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340049a0:	b29b      	uxth	r3, r3
340049a2:	3b01      	subs	r3, #1
340049a4:	b29a      	uxth	r2, r3
340049a6:	68fb      	ldr	r3, [r7, #12]
340049a8:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
340049aa:	68fb      	ldr	r3, [r7, #12]
340049ac:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340049ae:	3b01      	subs	r3, #1
340049b0:	b29a      	uxth	r2, r3
340049b2:	68fb      	ldr	r3, [r7, #12]
340049b4:	851a      	strh	r2, [r3, #40]	@ 0x28
340049b6:	e00d      	b.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
340049b8:	697b      	ldr	r3, [r7, #20]
340049ba:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340049be:	d002      	beq.n	340049c6 <I2C_Slave_ISR_IT+0x1e8>
340049c0:	697b      	ldr	r3, [r7, #20]
340049c2:	2b00      	cmp	r3, #0
340049c4:	d106      	bne.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
340049c6:	68f8      	ldr	r0, [r7, #12]
340049c8:	f000 fbe3 	bl	34005192 <I2C_ITSlaveSeqCplt>
340049cc:	e002      	b.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
    if (hi2c->XferCount == 0U)
340049ce:	bf00      	nop
340049d0:	e000      	b.n	340049d4 <I2C_Slave_ISR_IT+0x1f6>
    if ((hi2c->XferCount == 0U) && \
340049d2:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
340049d4:	68fb      	ldr	r3, [r7, #12]
340049d6:	2200      	movs	r2, #0
340049d8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
340049dc:	2300      	movs	r3, #0
}
340049de:	4618      	mov	r0, r3
340049e0:	3718      	adds	r7, #24
340049e2:	46bd      	mov	sp, r7
340049e4:	bd80      	pop	{r7, pc}

340049e6 <I2C_Master_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                            uint32_t ITSources)
{
340049e6:	b580      	push	{r7, lr}
340049e8:	b088      	sub	sp, #32
340049ea:	af02      	add	r7, sp, #8
340049ec:	60f8      	str	r0, [r7, #12]
340049ee:	60b9      	str	r1, [r7, #8]
340049f0:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
340049f2:	68fb      	ldr	r3, [r7, #12]
340049f4:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340049f8:	2b01      	cmp	r3, #1
340049fa:	d101      	bne.n	34004a00 <I2C_Master_ISR_DMA+0x1a>
340049fc:	2302      	movs	r3, #2
340049fe:	e0e1      	b.n	34004bc4 <I2C_Master_ISR_DMA+0x1de>
34004a00:	68fb      	ldr	r3, [r7, #12]
34004a02:	2201      	movs	r2, #1
34004a04:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004a08:	68bb      	ldr	r3, [r7, #8]
34004a0a:	091b      	lsrs	r3, r3, #4
34004a0c:	f003 0301 	and.w	r3, r3, #1
34004a10:	2b00      	cmp	r3, #0
34004a12:	d017      	beq.n	34004a44 <I2C_Master_ISR_DMA+0x5e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34004a14:	687b      	ldr	r3, [r7, #4]
34004a16:	091b      	lsrs	r3, r3, #4
34004a18:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004a1c:	2b00      	cmp	r3, #0
34004a1e:	d011      	beq.n	34004a44 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004a20:	68fb      	ldr	r3, [r7, #12]
34004a22:	681b      	ldr	r3, [r3, #0]
34004a24:	2210      	movs	r2, #16
34004a26:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34004a28:	68fb      	ldr	r3, [r7, #12]
34004a2a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004a2c:	f043 0204 	orr.w	r2, r3, #4
34004a30:	68fb      	ldr	r3, [r7, #12]
34004a32:	645a      	str	r2, [r3, #68]	@ 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
34004a34:	2120      	movs	r1, #32
34004a36:	68f8      	ldr	r0, [r7, #12]
34004a38:	f001 f832 	bl	34005aa0 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34004a3c:	68f8      	ldr	r0, [r7, #12]
34004a3e:	f000 ffba 	bl	340059b6 <I2C_Flush_TXDR>
34004a42:	e0ba      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34004a44:	68bb      	ldr	r3, [r7, #8]
34004a46:	09db      	lsrs	r3, r3, #7
34004a48:	f003 0301 	and.w	r3, r3, #1
34004a4c:	2b00      	cmp	r3, #0
34004a4e:	d072      	beq.n	34004b36 <I2C_Master_ISR_DMA+0x150>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34004a50:	687b      	ldr	r3, [r7, #4]
34004a52:	099b      	lsrs	r3, r3, #6
34004a54:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34004a58:	2b00      	cmp	r3, #0
34004a5a:	d06c      	beq.n	34004b36 <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
34004a5c:	68fb      	ldr	r3, [r7, #12]
34004a5e:	681b      	ldr	r3, [r3, #0]
34004a60:	681a      	ldr	r2, [r3, #0]
34004a62:	68fb      	ldr	r3, [r7, #12]
34004a64:	681b      	ldr	r3, [r3, #0]
34004a66:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34004a6a:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
34004a6c:	68fb      	ldr	r3, [r7, #12]
34004a6e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004a70:	b29b      	uxth	r3, r3
34004a72:	2b00      	cmp	r3, #0
34004a74:	d04e      	beq.n	34004b14 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
34004a76:	68fb      	ldr	r3, [r7, #12]
34004a78:	681b      	ldr	r3, [r3, #0]
34004a7a:	685b      	ldr	r3, [r3, #4]
34004a7c:	b29b      	uxth	r3, r3
34004a7e:	f3c3 0309 	ubfx	r3, r3, #0, #10
34004a82:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004a84:	68fb      	ldr	r3, [r7, #12]
34004a86:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004a88:	b29b      	uxth	r3, r3
34004a8a:	2bff      	cmp	r3, #255	@ 0xff
34004a8c:	d906      	bls.n	34004a9c <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
34004a8e:	68fb      	ldr	r3, [r7, #12]
34004a90:	22ff      	movs	r2, #255	@ 0xff
34004a92:	851a      	strh	r2, [r3, #40]	@ 0x28
        xfermode = I2C_RELOAD_MODE;
34004a94:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34004a98:	617b      	str	r3, [r7, #20]
34004a9a:	e010      	b.n	34004abe <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
34004a9c:	68fb      	ldr	r3, [r7, #12]
34004a9e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004aa0:	b29a      	uxth	r2, r3
34004aa2:	68fb      	ldr	r3, [r7, #12]
34004aa4:	851a      	strh	r2, [r3, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
34004aa6:	68fb      	ldr	r3, [r7, #12]
34004aa8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004aaa:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34004aae:	d003      	beq.n	34004ab8 <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
34004ab0:	68fb      	ldr	r3, [r7, #12]
34004ab2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004ab4:	617b      	str	r3, [r7, #20]
34004ab6:	e002      	b.n	34004abe <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
34004ab8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34004abc:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
34004abe:	68fb      	ldr	r3, [r7, #12]
34004ac0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004ac2:	b2da      	uxtb	r2, r3
34004ac4:	8a79      	ldrh	r1, [r7, #18]
34004ac6:	2300      	movs	r3, #0
34004ac8:	9300      	str	r3, [sp, #0]
34004aca:	697b      	ldr	r3, [r7, #20]
34004acc:	68f8      	ldr	r0, [r7, #12]
34004ace:	f000 ffb5 	bl	34005a3c <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
34004ad2:	68fb      	ldr	r3, [r7, #12]
34004ad4:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004ad6:	b29a      	uxth	r2, r3
34004ad8:	68fb      	ldr	r3, [r7, #12]
34004ada:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004adc:	1ad3      	subs	r3, r2, r3
34004ade:	b29a      	uxth	r2, r3
34004ae0:	68fb      	ldr	r3, [r7, #12]
34004ae2:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004ae4:	68fb      	ldr	r3, [r7, #12]
34004ae6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004aea:	b2db      	uxtb	r3, r3
34004aec:	2b22      	cmp	r3, #34	@ 0x22
34004aee:	d108      	bne.n	34004b02 <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34004af0:	68fb      	ldr	r3, [r7, #12]
34004af2:	681b      	ldr	r3, [r3, #0]
34004af4:	681a      	ldr	r2, [r3, #0]
34004af6:	68fb      	ldr	r3, [r7, #12]
34004af8:	681b      	ldr	r3, [r3, #0]
34004afa:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34004afe:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34004b00:	e05b      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34004b02:	68fb      	ldr	r3, [r7, #12]
34004b04:	681b      	ldr	r3, [r3, #0]
34004b06:	681a      	ldr	r2, [r3, #0]
34004b08:	68fb      	ldr	r3, [r7, #12]
34004b0a:	681b      	ldr	r3, [r3, #0]
34004b0c:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004b10:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34004b12:	e052      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34004b14:	68fb      	ldr	r3, [r7, #12]
34004b16:	681b      	ldr	r3, [r3, #0]
34004b18:	685b      	ldr	r3, [r3, #4]
34004b1a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34004b1e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34004b22:	d003      	beq.n	34004b2c <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
34004b24:	68f8      	ldr	r0, [r7, #12]
34004b26:	f000 faf7 	bl	34005118 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
34004b2a:	e046      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34004b2c:	2140      	movs	r1, #64	@ 0x40
34004b2e:	68f8      	ldr	r0, [r7, #12]
34004b30:	f000 fe2a 	bl	34005788 <I2C_ITError>
    if (hi2c->XferCount != 0U)
34004b34:	e041      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34004b36:	68bb      	ldr	r3, [r7, #8]
34004b38:	099b      	lsrs	r3, r3, #6
34004b3a:	f003 0301 	and.w	r3, r3, #1
34004b3e:	2b00      	cmp	r3, #0
34004b40:	d029      	beq.n	34004b96 <I2C_Master_ISR_DMA+0x1b0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34004b42:	687b      	ldr	r3, [r7, #4]
34004b44:	099b      	lsrs	r3, r3, #6
34004b46:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34004b4a:	2b00      	cmp	r3, #0
34004b4c:	d023      	beq.n	34004b96 <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
34004b4e:	68fb      	ldr	r3, [r7, #12]
34004b50:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004b52:	b29b      	uxth	r3, r3
34004b54:	2b00      	cmp	r3, #0
34004b56:	d119      	bne.n	34004b8c <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34004b58:	68fb      	ldr	r3, [r7, #12]
34004b5a:	681b      	ldr	r3, [r3, #0]
34004b5c:	685b      	ldr	r3, [r3, #4]
34004b5e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34004b62:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34004b66:	d027      	beq.n	34004bb8 <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
34004b68:	68fb      	ldr	r3, [r7, #12]
34004b6a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004b6c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34004b70:	d108      	bne.n	34004b84 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
34004b72:	68fb      	ldr	r3, [r7, #12]
34004b74:	681b      	ldr	r3, [r3, #0]
34004b76:	685a      	ldr	r2, [r3, #4]
34004b78:	68fb      	ldr	r3, [r7, #12]
34004b7a:	681b      	ldr	r3, [r3, #0]
34004b7c:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004b80:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
34004b82:	e019      	b.n	34004bb8 <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
34004b84:	68f8      	ldr	r0, [r7, #12]
34004b86:	f000 fac7 	bl	34005118 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
34004b8a:	e015      	b.n	34004bb8 <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34004b8c:	2140      	movs	r1, #64	@ 0x40
34004b8e:	68f8      	ldr	r0, [r7, #12]
34004b90:	f000 fdfa 	bl	34005788 <I2C_ITError>
    if (hi2c->XferCount == 0U)
34004b94:	e010      	b.n	34004bb8 <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004b96:	68bb      	ldr	r3, [r7, #8]
34004b98:	095b      	lsrs	r3, r3, #5
34004b9a:	f003 0301 	and.w	r3, r3, #1
34004b9e:	2b00      	cmp	r3, #0
34004ba0:	d00b      	beq.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34004ba2:	687b      	ldr	r3, [r7, #4]
34004ba4:	095b      	lsrs	r3, r3, #5
34004ba6:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004baa:	2b00      	cmp	r3, #0
34004bac:	d005      	beq.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
34004bae:	68b9      	ldr	r1, [r7, #8]
34004bb0:	68f8      	ldr	r0, [r7, #12]
34004bb2:	f000 fb4d 	bl	34005250 <I2C_ITMasterCplt>
34004bb6:	e000      	b.n	34004bba <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
34004bb8:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34004bba:	68fb      	ldr	r3, [r7, #12]
34004bbc:	2200      	movs	r2, #0
34004bbe:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34004bc2:	2300      	movs	r3, #0
}
34004bc4:	4618      	mov	r0, r3
34004bc6:	3718      	adds	r7, #24
34004bc8:	46bd      	mov	sp, r7
34004bca:	bd80      	pop	{r7, pc}

34004bcc <I2C_Mem_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Mem_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                         uint32_t ITSources)
{
34004bcc:	b580      	push	{r7, lr}
34004bce:	b088      	sub	sp, #32
34004bd0:	af02      	add	r7, sp, #8
34004bd2:	60f8      	str	r0, [r7, #12]
34004bd4:	60b9      	str	r1, [r7, #8]
34004bd6:	607a      	str	r2, [r7, #4]
  uint32_t direction = I2C_GENERATE_START_WRITE;
34004bd8:	4b92      	ldr	r3, [pc, #584]	@ (34004e24 <I2C_Mem_ISR_DMA+0x258>)
34004bda:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
34004bdc:	68fb      	ldr	r3, [r7, #12]
34004bde:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34004be2:	2b01      	cmp	r3, #1
34004be4:	d101      	bne.n	34004bea <I2C_Mem_ISR_DMA+0x1e>
34004be6:	2302      	movs	r3, #2
34004be8:	e118      	b.n	34004e1c <I2C_Mem_ISR_DMA+0x250>
34004bea:	68fb      	ldr	r3, [r7, #12]
34004bec:	2201      	movs	r2, #1
34004bee:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004bf2:	68bb      	ldr	r3, [r7, #8]
34004bf4:	091b      	lsrs	r3, r3, #4
34004bf6:	f003 0301 	and.w	r3, r3, #1
34004bfa:	2b00      	cmp	r3, #0
34004bfc:	d017      	beq.n	34004c2e <I2C_Mem_ISR_DMA+0x62>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34004bfe:	687b      	ldr	r3, [r7, #4]
34004c00:	091b      	lsrs	r3, r3, #4
34004c02:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004c06:	2b00      	cmp	r3, #0
34004c08:	d011      	beq.n	34004c2e <I2C_Mem_ISR_DMA+0x62>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004c0a:	68fb      	ldr	r3, [r7, #12]
34004c0c:	681b      	ldr	r3, [r3, #0]
34004c0e:	2210      	movs	r2, #16
34004c10:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34004c12:	68fb      	ldr	r3, [r7, #12]
34004c14:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004c16:	f043 0204 	orr.w	r2, r3, #4
34004c1a:	68fb      	ldr	r3, [r7, #12]
34004c1c:	645a      	str	r2, [r3, #68]	@ 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
34004c1e:	2120      	movs	r1, #32
34004c20:	68f8      	ldr	r0, [r7, #12]
34004c22:	f000 ff3d 	bl	34005aa0 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34004c26:	68f8      	ldr	r0, [r7, #12]
34004c28:	f000 fec5 	bl	340059b6 <I2C_Flush_TXDR>
34004c2c:	e0f1      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
34004c2e:	68bb      	ldr	r3, [r7, #8]
34004c30:	085b      	lsrs	r3, r3, #1
34004c32:	f003 0301 	and.w	r3, r3, #1
34004c36:	2b00      	cmp	r3, #0
34004c38:	d00f      	beq.n	34004c5a <I2C_Mem_ISR_DMA+0x8e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34004c3a:	687b      	ldr	r3, [r7, #4]
34004c3c:	085b      	lsrs	r3, r3, #1
34004c3e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
34004c42:	2b00      	cmp	r3, #0
34004c44:	d009      	beq.n	34004c5a <I2C_Mem_ISR_DMA+0x8e>
  {
    /* Write LSB part of Memory Address */
    hi2c->Instance->TXDR = hi2c->Memaddress;
34004c46:	68fb      	ldr	r3, [r7, #12]
34004c48:	681b      	ldr	r3, [r3, #0]
34004c4a:	68fa      	ldr	r2, [r7, #12]
34004c4c:	6d12      	ldr	r2, [r2, #80]	@ 0x50
34004c4e:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Reset Memaddress content */
    hi2c->Memaddress = 0xFFFFFFFFU;
34004c50:	68fb      	ldr	r3, [r7, #12]
34004c52:	f04f 32ff 	mov.w	r2, #4294967295
34004c56:	651a      	str	r2, [r3, #80]	@ 0x50
34004c58:	e0db      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34004c5a:	68bb      	ldr	r3, [r7, #8]
34004c5c:	09db      	lsrs	r3, r3, #7
34004c5e:	f003 0301 	and.w	r3, r3, #1
34004c62:	2b00      	cmp	r3, #0
34004c64:	d060      	beq.n	34004d28 <I2C_Mem_ISR_DMA+0x15c>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34004c66:	687b      	ldr	r3, [r7, #4]
34004c68:	099b      	lsrs	r3, r3, #6
34004c6a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34004c6e:	2b00      	cmp	r3, #0
34004c70:	d05a      	beq.n	34004d28 <I2C_Mem_ISR_DMA+0x15c>
  {
    /* Disable Interrupt related to address step */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34004c72:	2101      	movs	r1, #1
34004c74:	68f8      	ldr	r0, [r7, #12]
34004c76:	f000 ff97 	bl	34005ba8 <I2C_Disable_IRQ>

    /* Enable only Error interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
34004c7a:	2110      	movs	r1, #16
34004c7c:	68f8      	ldr	r0, [r7, #12]
34004c7e:	f000 ff0f 	bl	34005aa0 <I2C_Enable_IRQ>

    if (hi2c->XferCount != 0U)
34004c82:	68fb      	ldr	r3, [r7, #12]
34004c84:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004c86:	b29b      	uxth	r3, r3
34004c88:	2b00      	cmp	r3, #0
34004c8a:	d048      	beq.n	34004d1e <I2C_Mem_ISR_DMA+0x152>
    {
      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004c8c:	68fb      	ldr	r3, [r7, #12]
34004c8e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004c90:	b29b      	uxth	r3, r3
34004c92:	2bff      	cmp	r3, #255	@ 0xff
34004c94:	d910      	bls.n	34004cb8 <I2C_Mem_ISR_DMA+0xec>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
34004c96:	68fb      	ldr	r3, [r7, #12]
34004c98:	22ff      	movs	r2, #255	@ 0xff
34004c9a:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34004c9c:	68fb      	ldr	r3, [r7, #12]
34004c9e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34004ca0:	b299      	uxth	r1, r3
34004ca2:	68fb      	ldr	r3, [r7, #12]
34004ca4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004ca6:	b2da      	uxtb	r2, r3
34004ca8:	2300      	movs	r3, #0
34004caa:	9300      	str	r3, [sp, #0]
34004cac:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34004cb0:	68f8      	ldr	r0, [r7, #12]
34004cb2:	f000 fec3 	bl	34005a3c <I2C_TransferConfig>
34004cb6:	e011      	b.n	34004cdc <I2C_Mem_ISR_DMA+0x110>
                           I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
34004cb8:	68fb      	ldr	r3, [r7, #12]
34004cba:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004cbc:	b29a      	uxth	r2, r3
34004cbe:	68fb      	ldr	r3, [r7, #12]
34004cc0:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34004cc2:	68fb      	ldr	r3, [r7, #12]
34004cc4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34004cc6:	b299      	uxth	r1, r3
34004cc8:	68fb      	ldr	r3, [r7, #12]
34004cca:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004ccc:	b2da      	uxtb	r2, r3
34004cce:	2300      	movs	r3, #0
34004cd0:	9300      	str	r3, [sp, #0]
34004cd2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34004cd6:	68f8      	ldr	r0, [r7, #12]
34004cd8:	f000 feb0 	bl	34005a3c <I2C_TransferConfig>
                           I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
34004cdc:	68fb      	ldr	r3, [r7, #12]
34004cde:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004ce0:	b29a      	uxth	r2, r3
34004ce2:	68fb      	ldr	r3, [r7, #12]
34004ce4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004ce6:	1ad3      	subs	r3, r2, r3
34004ce8:	b29a      	uxth	r2, r3
34004cea:	68fb      	ldr	r3, [r7, #12]
34004cec:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004cee:	68fb      	ldr	r3, [r7, #12]
34004cf0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004cf4:	b2db      	uxtb	r3, r3
34004cf6:	2b22      	cmp	r3, #34	@ 0x22
34004cf8:	d108      	bne.n	34004d0c <I2C_Mem_ISR_DMA+0x140>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34004cfa:	68fb      	ldr	r3, [r7, #12]
34004cfc:	681b      	ldr	r3, [r3, #0]
34004cfe:	681a      	ldr	r2, [r3, #0]
34004d00:	68fb      	ldr	r3, [r7, #12]
34004d02:	681b      	ldr	r3, [r3, #0]
34004d04:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34004d08:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34004d0a:	e082      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34004d0c:	68fb      	ldr	r3, [r7, #12]
34004d0e:	681b      	ldr	r3, [r3, #0]
34004d10:	681a      	ldr	r2, [r3, #0]
34004d12:	68fb      	ldr	r3, [r7, #12]
34004d14:	681b      	ldr	r3, [r3, #0]
34004d16:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004d1a:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34004d1c:	e079      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
    }
    else
    {
      /* Wrong size Status regarding TCR flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34004d1e:	2140      	movs	r1, #64	@ 0x40
34004d20:	68f8      	ldr	r0, [r7, #12]
34004d22:	f000 fd31 	bl	34005788 <I2C_ITError>
    if (hi2c->XferCount != 0U)
34004d26:	e074      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34004d28:	68bb      	ldr	r3, [r7, #8]
34004d2a:	099b      	lsrs	r3, r3, #6
34004d2c:	f003 0301 	and.w	r3, r3, #1
34004d30:	2b00      	cmp	r3, #0
34004d32:	d05e      	beq.n	34004df2 <I2C_Mem_ISR_DMA+0x226>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34004d34:	687b      	ldr	r3, [r7, #4]
34004d36:	099b      	lsrs	r3, r3, #6
34004d38:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34004d3c:	2b00      	cmp	r3, #0
34004d3e:	d058      	beq.n	34004df2 <I2C_Mem_ISR_DMA+0x226>
  {
    /* Disable Interrupt related to address step */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34004d40:	2101      	movs	r1, #1
34004d42:	68f8      	ldr	r0, [r7, #12]
34004d44:	f000 ff30 	bl	34005ba8 <I2C_Disable_IRQ>

    /* Enable only Error and NACK interrupt for data transfer */
    I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
34004d48:	2110      	movs	r1, #16
34004d4a:	68f8      	ldr	r0, [r7, #12]
34004d4c:	f000 fea8 	bl	34005aa0 <I2C_Enable_IRQ>

    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004d50:	68fb      	ldr	r3, [r7, #12]
34004d52:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004d56:	b2db      	uxtb	r3, r3
34004d58:	2b22      	cmp	r3, #34	@ 0x22
34004d5a:	d101      	bne.n	34004d60 <I2C_Mem_ISR_DMA+0x194>
    {
      direction = I2C_GENERATE_START_READ;
34004d5c:	4b32      	ldr	r3, [pc, #200]	@ (34004e28 <I2C_Mem_ISR_DMA+0x25c>)
34004d5e:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34004d60:	68fb      	ldr	r3, [r7, #12]
34004d62:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004d64:	b29b      	uxth	r3, r3
34004d66:	2bff      	cmp	r3, #255	@ 0xff
34004d68:	d910      	bls.n	34004d8c <I2C_Mem_ISR_DMA+0x1c0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
34004d6a:	68fb      	ldr	r3, [r7, #12]
34004d6c:	22ff      	movs	r2, #255	@ 0xff
34004d6e:	851a      	strh	r2, [r3, #40]	@ 0x28

      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34004d70:	68fb      	ldr	r3, [r7, #12]
34004d72:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34004d74:	b299      	uxth	r1, r3
34004d76:	68fb      	ldr	r3, [r7, #12]
34004d78:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004d7a:	b2da      	uxtb	r2, r3
34004d7c:	697b      	ldr	r3, [r7, #20]
34004d7e:	9300      	str	r3, [sp, #0]
34004d80:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34004d84:	68f8      	ldr	r0, [r7, #12]
34004d86:	f000 fe59 	bl	34005a3c <I2C_TransferConfig>
34004d8a:	e011      	b.n	34004db0 <I2C_Mem_ISR_DMA+0x1e4>
                         I2C_RELOAD_MODE, direction);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
34004d8c:	68fb      	ldr	r3, [r7, #12]
34004d8e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004d90:	b29a      	uxth	r2, r3
34004d92:	68fb      	ldr	r3, [r7, #12]
34004d94:	851a      	strh	r2, [r3, #40]	@ 0x28

      /* Set NBYTES to write and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34004d96:	68fb      	ldr	r3, [r7, #12]
34004d98:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34004d9a:	b299      	uxth	r1, r3
34004d9c:	68fb      	ldr	r3, [r7, #12]
34004d9e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004da0:	b2da      	uxtb	r2, r3
34004da2:	697b      	ldr	r3, [r7, #20]
34004da4:	9300      	str	r3, [sp, #0]
34004da6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34004daa:	68f8      	ldr	r0, [r7, #12]
34004dac:	f000 fe46 	bl	34005a3c <I2C_TransferConfig>
                         I2C_AUTOEND_MODE, direction);
    }

    /* Update XferCount value */
    hi2c->XferCount -= hi2c->XferSize;
34004db0:	68fb      	ldr	r3, [r7, #12]
34004db2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34004db4:	b29a      	uxth	r2, r3
34004db6:	68fb      	ldr	r3, [r7, #12]
34004db8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34004dba:	1ad3      	subs	r3, r2, r3
34004dbc:	b29a      	uxth	r2, r3
34004dbe:	68fb      	ldr	r3, [r7, #12]
34004dc0:	855a      	strh	r2, [r3, #42]	@ 0x2a

    /* Enable DMA Request */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004dc2:	68fb      	ldr	r3, [r7, #12]
34004dc4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004dc8:	b2db      	uxtb	r3, r3
34004dca:	2b22      	cmp	r3, #34	@ 0x22
34004dcc:	d108      	bne.n	34004de0 <I2C_Mem_ISR_DMA+0x214>
    {
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34004dce:	68fb      	ldr	r3, [r7, #12]
34004dd0:	681b      	ldr	r3, [r3, #0]
34004dd2:	681a      	ldr	r2, [r3, #0]
34004dd4:	68fb      	ldr	r3, [r7, #12]
34004dd6:	681b      	ldr	r3, [r3, #0]
34004dd8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34004ddc:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004dde:	e018      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
    }
    else
    {
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34004de0:	68fb      	ldr	r3, [r7, #12]
34004de2:	681b      	ldr	r3, [r3, #0]
34004de4:	681a      	ldr	r2, [r3, #0]
34004de6:	68fb      	ldr	r3, [r7, #12]
34004de8:	681b      	ldr	r3, [r3, #0]
34004dea:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34004dee:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34004df0:	e00f      	b.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004df2:	68bb      	ldr	r3, [r7, #8]
34004df4:	095b      	lsrs	r3, r3, #5
34004df6:	f003 0301 	and.w	r3, r3, #1
34004dfa:	2b00      	cmp	r3, #0
34004dfc:	d009      	beq.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34004dfe:	687b      	ldr	r3, [r7, #4]
34004e00:	095b      	lsrs	r3, r3, #5
34004e02:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004e06:	2b00      	cmp	r3, #0
34004e08:	d003      	beq.n	34004e12 <I2C_Mem_ISR_DMA+0x246>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
34004e0a:	68b9      	ldr	r1, [r7, #8]
34004e0c:	68f8      	ldr	r0, [r7, #12]
34004e0e:	f000 fa1f 	bl	34005250 <I2C_ITMasterCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34004e12:	68fb      	ldr	r3, [r7, #12]
34004e14:	2200      	movs	r2, #0
34004e16:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34004e1a:	2300      	movs	r3, #0
}
34004e1c:	4618      	mov	r0, r3
34004e1e:	3718      	adds	r7, #24
34004e20:	46bd      	mov	sp, r7
34004e22:	bd80      	pop	{r7, pc}
34004e24:	80002000 	.word	0x80002000
34004e28:	80002400 	.word	0x80002400

34004e2c <I2C_Slave_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
34004e2c:	b590      	push	{r4, r7, lr}
34004e2e:	b089      	sub	sp, #36	@ 0x24
34004e30:	af00      	add	r7, sp, #0
34004e32:	60f8      	str	r0, [r7, #12]
34004e34:	60b9      	str	r1, [r7, #8]
34004e36:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
34004e38:	68fb      	ldr	r3, [r7, #12]
34004e3a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004e3c:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
34004e3e:	2300      	movs	r3, #0
34004e40:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
34004e42:	68fb      	ldr	r3, [r7, #12]
34004e44:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34004e48:	2b01      	cmp	r3, #1
34004e4a:	d101      	bne.n	34004e50 <I2C_Slave_ISR_DMA+0x24>
34004e4c:	2302      	movs	r3, #2
34004e4e:	e0db      	b.n	34005008 <I2C_Slave_ISR_DMA+0x1dc>
34004e50:	68fb      	ldr	r3, [r7, #12]
34004e52:	2201      	movs	r2, #1
34004e54:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004e58:	68bb      	ldr	r3, [r7, #8]
34004e5a:	095b      	lsrs	r3, r3, #5
34004e5c:	f003 0301 	and.w	r3, r3, #1
34004e60:	2b00      	cmp	r3, #0
34004e62:	d00a      	beq.n	34004e7a <I2C_Slave_ISR_DMA+0x4e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34004e64:	687b      	ldr	r3, [r7, #4]
34004e66:	095b      	lsrs	r3, r3, #5
34004e68:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34004e6c:	2b00      	cmp	r3, #0
34004e6e:	d004      	beq.n	34004e7a <I2C_Slave_ISR_DMA+0x4e>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
34004e70:	68b9      	ldr	r1, [r7, #8]
34004e72:	68f8      	ldr	r0, [r7, #12]
34004e74:	f000 fab6 	bl	340053e4 <I2C_ITSlaveCplt>
34004e78:	e0c1      	b.n	34004ffe <I2C_Slave_ISR_DMA+0x1d2>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004e7a:	68bb      	ldr	r3, [r7, #8]
34004e7c:	091b      	lsrs	r3, r3, #4
34004e7e:	f003 0301 	and.w	r3, r3, #1
34004e82:	2b00      	cmp	r3, #0
34004e84:	f000 80ab 	beq.w	34004fde <I2C_Slave_ISR_DMA+0x1b2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34004e88:	687b      	ldr	r3, [r7, #4]
34004e8a:	091b      	lsrs	r3, r3, #4
34004e8c:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34004e90:	2b00      	cmp	r3, #0
34004e92:	f000 80a4 	beq.w	34004fde <I2C_Slave_ISR_DMA+0x1b2>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34004e96:	687b      	ldr	r3, [r7, #4]
34004e98:	0b9b      	lsrs	r3, r3, #14
34004e9a:	f003 0301 	and.w	r3, r3, #1
34004e9e:	2b00      	cmp	r3, #0
34004ea0:	d106      	bne.n	34004eb0 <I2C_Slave_ISR_DMA+0x84>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
34004ea2:	687b      	ldr	r3, [r7, #4]
34004ea4:	0bdb      	lsrs	r3, r3, #15
34004ea6:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34004eaa:	2b00      	cmp	r3, #0
34004eac:	f000 8090 	beq.w	34004fd0 <I2C_Slave_ISR_DMA+0x1a4>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
34004eb0:	68fb      	ldr	r3, [r7, #12]
34004eb2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34004eb4:	2b00      	cmp	r3, #0
34004eb6:	d015      	beq.n	34004ee4 <I2C_Slave_ISR_DMA+0xb8>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
34004eb8:	687b      	ldr	r3, [r7, #4]
34004eba:	0bdb      	lsrs	r3, r3, #15
34004ebc:	f003 0301 	and.w	r3, r3, #1
34004ec0:	2b00      	cmp	r3, #0
34004ec2:	d00f      	beq.n	34004ee4 <I2C_Slave_ISR_DMA+0xb8>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
34004ec4:	68fb      	ldr	r3, [r7, #12]
34004ec6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34004ec8:	681b      	ldr	r3, [r3, #0]
34004eca:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34004ecc:	b29c      	uxth	r4, r3
34004ece:	68fb      	ldr	r3, [r7, #12]
34004ed0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34004ed2:	4618      	mov	r0, r3
34004ed4:	f7fe fe9b 	bl	34003c0e <HAL_DMAEx_GetFifoLevel>
34004ed8:	4603      	mov	r3, r0
34004eda:	4423      	add	r3, r4
34004edc:	2b00      	cmp	r3, #0
34004ede:	d101      	bne.n	34004ee4 <I2C_Slave_ISR_DMA+0xb8>
          {
            treatdmanack = 1U;
34004ee0:	2301      	movs	r3, #1
34004ee2:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
34004ee4:	68fb      	ldr	r3, [r7, #12]
34004ee6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34004ee8:	2b00      	cmp	r3, #0
34004eea:	d015      	beq.n	34004f18 <I2C_Slave_ISR_DMA+0xec>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
34004eec:	687b      	ldr	r3, [r7, #4]
34004eee:	0b9b      	lsrs	r3, r3, #14
34004ef0:	f003 0301 	and.w	r3, r3, #1
34004ef4:	2b00      	cmp	r3, #0
34004ef6:	d00f      	beq.n	34004f18 <I2C_Slave_ISR_DMA+0xec>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
34004ef8:	68fb      	ldr	r3, [r7, #12]
34004efa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34004efc:	681b      	ldr	r3, [r3, #0]
34004efe:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34004f00:	b29c      	uxth	r4, r3
34004f02:	68fb      	ldr	r3, [r7, #12]
34004f04:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34004f06:	4618      	mov	r0, r3
34004f08:	f7fe fe81 	bl	34003c0e <HAL_DMAEx_GetFifoLevel>
34004f0c:	4603      	mov	r3, r0
34004f0e:	4423      	add	r3, r4
34004f10:	2b00      	cmp	r3, #0
34004f12:	d101      	bne.n	34004f18 <I2C_Slave_ISR_DMA+0xec>
          {
            treatdmanack = 1U;
34004f14:	2301      	movs	r3, #1
34004f16:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
34004f18:	69fb      	ldr	r3, [r7, #28]
34004f1a:	2b01      	cmp	r3, #1
34004f1c:	d128      	bne.n	34004f70 <I2C_Slave_ISR_DMA+0x144>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
34004f1e:	68fb      	ldr	r3, [r7, #12]
34004f20:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004f24:	b2db      	uxtb	r3, r3
34004f26:	2b28      	cmp	r3, #40	@ 0x28
34004f28:	d108      	bne.n	34004f3c <I2C_Slave_ISR_DMA+0x110>
34004f2a:	69bb      	ldr	r3, [r7, #24]
34004f2c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34004f30:	d104      	bne.n	34004f3c <I2C_Slave_ISR_DMA+0x110>
          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
             Warning[Pa134]: left and right operands are identical */
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
34004f32:	68b9      	ldr	r1, [r7, #8]
34004f34:	68f8      	ldr	r0, [r7, #12]
34004f36:	f000 fbd1 	bl	340056dc <I2C_ITListenCplt>
34004f3a:	e048      	b.n	34004fce <I2C_Slave_ISR_DMA+0x1a2>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
34004f3c:	68fb      	ldr	r3, [r7, #12]
34004f3e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004f42:	b2db      	uxtb	r3, r3
34004f44:	2b29      	cmp	r3, #41	@ 0x29
34004f46:	d10e      	bne.n	34004f66 <I2C_Slave_ISR_DMA+0x13a>
34004f48:	69bb      	ldr	r3, [r7, #24]
34004f4a:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34004f4e:	d00a      	beq.n	34004f66 <I2C_Slave_ISR_DMA+0x13a>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004f50:	68fb      	ldr	r3, [r7, #12]
34004f52:	681b      	ldr	r3, [r3, #0]
34004f54:	2210      	movs	r2, #16
34004f56:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
34004f58:	68f8      	ldr	r0, [r7, #12]
34004f5a:	f000 fd2c 	bl	340059b6 <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
34004f5e:	68f8      	ldr	r0, [r7, #12]
34004f60:	f000 f917 	bl	34005192 <I2C_ITSlaveSeqCplt>
34004f64:	e033      	b.n	34004fce <I2C_Slave_ISR_DMA+0x1a2>
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004f66:	68fb      	ldr	r3, [r7, #12]
34004f68:	681b      	ldr	r3, [r3, #0]
34004f6a:	2210      	movs	r2, #16
34004f6c:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
34004f6e:	e034      	b.n	34004fda <I2C_Slave_ISR_DMA+0x1ae>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004f70:	68fb      	ldr	r3, [r7, #12]
34004f72:	681b      	ldr	r3, [r3, #0]
34004f74:	2210      	movs	r2, #16
34004f76:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34004f78:	68fb      	ldr	r3, [r7, #12]
34004f7a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004f7c:	f043 0204 	orr.w	r2, r3, #4
34004f80:	68fb      	ldr	r3, [r7, #12]
34004f82:	645a      	str	r2, [r3, #68]	@ 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
34004f84:	68fb      	ldr	r3, [r7, #12]
34004f86:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004f8a:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
34004f8c:	69bb      	ldr	r3, [r7, #24]
34004f8e:	2b00      	cmp	r3, #0
34004f90:	d003      	beq.n	34004f9a <I2C_Slave_ISR_DMA+0x16e>
34004f92:	69bb      	ldr	r3, [r7, #24]
34004f94:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34004f98:	d11f      	bne.n	34004fda <I2C_Slave_ISR_DMA+0x1ae>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
34004f9a:	7dfb      	ldrb	r3, [r7, #23]
34004f9c:	2b21      	cmp	r3, #33	@ 0x21
34004f9e:	d002      	beq.n	34004fa6 <I2C_Slave_ISR_DMA+0x17a>
34004fa0:	7dfb      	ldrb	r3, [r7, #23]
34004fa2:	2b29      	cmp	r3, #41	@ 0x29
34004fa4:	d103      	bne.n	34004fae <I2C_Slave_ISR_DMA+0x182>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
34004fa6:	68fb      	ldr	r3, [r7, #12]
34004fa8:	2221      	movs	r2, #33	@ 0x21
34004faa:	631a      	str	r2, [r3, #48]	@ 0x30
34004fac:	e008      	b.n	34004fc0 <I2C_Slave_ISR_DMA+0x194>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
34004fae:	7dfb      	ldrb	r3, [r7, #23]
34004fb0:	2b22      	cmp	r3, #34	@ 0x22
34004fb2:	d002      	beq.n	34004fba <I2C_Slave_ISR_DMA+0x18e>
34004fb4:	7dfb      	ldrb	r3, [r7, #23]
34004fb6:	2b2a      	cmp	r3, #42	@ 0x2a
34004fb8:	d102      	bne.n	34004fc0 <I2C_Slave_ISR_DMA+0x194>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
34004fba:	68fb      	ldr	r3, [r7, #12]
34004fbc:	2222      	movs	r2, #34	@ 0x22
34004fbe:	631a      	str	r2, [r3, #48]	@ 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
34004fc0:	68fb      	ldr	r3, [r7, #12]
34004fc2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004fc4:	4619      	mov	r1, r3
34004fc6:	68f8      	ldr	r0, [r7, #12]
34004fc8:	f000 fbde 	bl	34005788 <I2C_ITError>
      if (treatdmanack == 1U)
34004fcc:	e005      	b.n	34004fda <I2C_Slave_ISR_DMA+0x1ae>
34004fce:	e004      	b.n	34004fda <I2C_Slave_ISR_DMA+0x1ae>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34004fd0:	68fb      	ldr	r3, [r7, #12]
34004fd2:	681b      	ldr	r3, [r3, #0]
34004fd4:	2210      	movs	r2, #16
34004fd6:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34004fd8:	e011      	b.n	34004ffe <I2C_Slave_ISR_DMA+0x1d2>
      if (treatdmanack == 1U)
34004fda:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34004fdc:	e00f      	b.n	34004ffe <I2C_Slave_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
34004fde:	68bb      	ldr	r3, [r7, #8]
34004fe0:	08db      	lsrs	r3, r3, #3
34004fe2:	f003 0301 	and.w	r3, r3, #1
34004fe6:	2b00      	cmp	r3, #0
34004fe8:	d009      	beq.n	34004ffe <I2C_Slave_ISR_DMA+0x1d2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
34004fea:	687b      	ldr	r3, [r7, #4]
34004fec:	08db      	lsrs	r3, r3, #3
34004fee:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
34004ff2:	2b00      	cmp	r3, #0
34004ff4:	d003      	beq.n	34004ffe <I2C_Slave_ISR_DMA+0x1d2>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
34004ff6:	68b9      	ldr	r1, [r7, #8]
34004ff8:	68f8      	ldr	r0, [r7, #12]
34004ffa:	f000 f809 	bl	34005010 <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34004ffe:	68fb      	ldr	r3, [r7, #12]
34005000:	2200      	movs	r2, #0
34005002:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34005006:	2300      	movs	r3, #0
}
34005008:	4618      	mov	r0, r3
3400500a:	3724      	adds	r7, #36	@ 0x24
3400500c:	46bd      	mov	sp, r7
3400500e:	bd90      	pop	{r4, r7, pc}

34005010 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
34005010:	b580      	push	{r7, lr}
34005012:	b084      	sub	sp, #16
34005014:	af00      	add	r7, sp, #0
34005016:	6078      	str	r0, [r7, #4]
34005018:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
3400501a:	687b      	ldr	r3, [r7, #4]
3400501c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005020:	b2db      	uxtb	r3, r3
34005022:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34005026:	2b28      	cmp	r3, #40	@ 0x28
34005028:	d16a      	bne.n	34005100 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
3400502a:	687b      	ldr	r3, [r7, #4]
3400502c:	681b      	ldr	r3, [r3, #0]
3400502e:	699b      	ldr	r3, [r3, #24]
34005030:	0c1b      	lsrs	r3, r3, #16
34005032:	b2db      	uxtb	r3, r3
34005034:	f003 0301 	and.w	r3, r3, #1
34005038:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
3400503a:	687b      	ldr	r3, [r7, #4]
3400503c:	681b      	ldr	r3, [r3, #0]
3400503e:	699b      	ldr	r3, [r3, #24]
34005040:	0c1b      	lsrs	r3, r3, #16
34005042:	b29b      	uxth	r3, r3
34005044:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
34005048:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
3400504a:	687b      	ldr	r3, [r7, #4]
3400504c:	681b      	ldr	r3, [r3, #0]
3400504e:	689b      	ldr	r3, [r3, #8]
34005050:	b29b      	uxth	r3, r3
34005052:	f3c3 0309 	ubfx	r3, r3, #0, #10
34005056:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
34005058:	687b      	ldr	r3, [r7, #4]
3400505a:	681b      	ldr	r3, [r3, #0]
3400505c:	68db      	ldr	r3, [r3, #12]
3400505e:	b29b      	uxth	r3, r3
34005060:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
34005064:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34005066:	687b      	ldr	r3, [r7, #4]
34005068:	68db      	ldr	r3, [r3, #12]
3400506a:	2b02      	cmp	r3, #2
3400506c:	d138      	bne.n	340050e0 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
3400506e:	897b      	ldrh	r3, [r7, #10]
34005070:	09db      	lsrs	r3, r3, #7
34005072:	b29a      	uxth	r2, r3
34005074:	89bb      	ldrh	r3, [r7, #12]
34005076:	4053      	eors	r3, r2
34005078:	b29b      	uxth	r3, r3
3400507a:	f003 0306 	and.w	r3, r3, #6
3400507e:	2b00      	cmp	r3, #0
34005080:	d11c      	bne.n	340050bc <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
34005082:	897b      	ldrh	r3, [r7, #10]
34005084:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
34005086:	687b      	ldr	r3, [r7, #4]
34005088:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400508a:	1c5a      	adds	r2, r3, #1
3400508c:	687b      	ldr	r3, [r7, #4]
3400508e:	649a      	str	r2, [r3, #72]	@ 0x48
        if (hi2c->AddrEventCount == 2U)
34005090:	687b      	ldr	r3, [r7, #4]
34005092:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34005094:	2b02      	cmp	r3, #2
34005096:	d13b      	bne.n	34005110 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
34005098:	687b      	ldr	r3, [r7, #4]
3400509a:	2200      	movs	r2, #0
3400509c:	649a      	str	r2, [r3, #72]	@ 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
3400509e:	687b      	ldr	r3, [r7, #4]
340050a0:	681b      	ldr	r3, [r3, #0]
340050a2:	2208      	movs	r2, #8
340050a4:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
340050a6:	687b      	ldr	r3, [r7, #4]
340050a8:	2200      	movs	r2, #0
340050aa:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
340050ae:	89ba      	ldrh	r2, [r7, #12]
340050b0:	7bfb      	ldrb	r3, [r7, #15]
340050b2:	4619      	mov	r1, r3
340050b4:	6878      	ldr	r0, [r7, #4]
340050b6:	f7ff fa52 	bl	3400455e <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
340050ba:	e029      	b.n	34005110 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
340050bc:	893b      	ldrh	r3, [r7, #8]
340050be:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
340050c0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340050c4:	6878      	ldr	r0, [r7, #4]
340050c6:	f000 fd6f 	bl	34005ba8 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
340050ca:	687b      	ldr	r3, [r7, #4]
340050cc:	2200      	movs	r2, #0
340050ce:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
340050d2:	89ba      	ldrh	r2, [r7, #12]
340050d4:	7bfb      	ldrb	r3, [r7, #15]
340050d6:	4619      	mov	r1, r3
340050d8:	6878      	ldr	r0, [r7, #4]
340050da:	f7ff fa40 	bl	3400455e <HAL_I2C_AddrCallback>
}
340050de:	e017      	b.n	34005110 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
340050e0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340050e4:	6878      	ldr	r0, [r7, #4]
340050e6:	f000 fd5f 	bl	34005ba8 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
340050ea:	687b      	ldr	r3, [r7, #4]
340050ec:	2200      	movs	r2, #0
340050ee:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
340050f2:	89ba      	ldrh	r2, [r7, #12]
340050f4:	7bfb      	ldrb	r3, [r7, #15]
340050f6:	4619      	mov	r1, r3
340050f8:	6878      	ldr	r0, [r7, #4]
340050fa:	f7ff fa30 	bl	3400455e <HAL_I2C_AddrCallback>
}
340050fe:	e007      	b.n	34005110 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
34005100:	687b      	ldr	r3, [r7, #4]
34005102:	681b      	ldr	r3, [r3, #0]
34005104:	2208      	movs	r2, #8
34005106:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
34005108:	687b      	ldr	r3, [r7, #4]
3400510a:	2200      	movs	r2, #0
3400510c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
}
34005110:	bf00      	nop
34005112:	3710      	adds	r7, #16
34005114:	46bd      	mov	sp, r7
34005116:	bd80      	pop	{r7, pc}

34005118 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
34005118:	b580      	push	{r7, lr}
3400511a:	b082      	sub	sp, #8
3400511c:	af00      	add	r7, sp, #0
3400511e:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
34005120:	687b      	ldr	r3, [r7, #4]
34005122:	2200      	movs	r2, #0
34005124:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
34005128:	687b      	ldr	r3, [r7, #4]
3400512a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400512e:	b2db      	uxtb	r3, r3
34005130:	2b21      	cmp	r3, #33	@ 0x21
34005132:	d115      	bne.n	34005160 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
34005134:	687b      	ldr	r3, [r7, #4]
34005136:	2220      	movs	r2, #32
34005138:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
3400513c:	687b      	ldr	r3, [r7, #4]
3400513e:	2211      	movs	r2, #17
34005140:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->XferISR       = NULL;
34005142:	687b      	ldr	r3, [r7, #4]
34005144:	2200      	movs	r2, #0
34005146:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34005148:	2101      	movs	r1, #1
3400514a:	6878      	ldr	r0, [r7, #4]
3400514c:	f000 fd2c 	bl	34005ba8 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005150:	687b      	ldr	r3, [r7, #4]
34005152:	2200      	movs	r2, #0
34005154:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
34005158:	6878      	ldr	r0, [r7, #4]
3400515a:	f008 f957 	bl	3400d40c <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
3400515e:	e014      	b.n	3400518a <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
34005160:	687b      	ldr	r3, [r7, #4]
34005162:	2220      	movs	r2, #32
34005164:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
34005168:	687b      	ldr	r3, [r7, #4]
3400516a:	2212      	movs	r2, #18
3400516c:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->XferISR       = NULL;
3400516e:	687b      	ldr	r3, [r7, #4]
34005170:	2200      	movs	r2, #0
34005172:	635a      	str	r2, [r3, #52]	@ 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
34005174:	2102      	movs	r1, #2
34005176:	6878      	ldr	r0, [r7, #4]
34005178:	f000 fd16 	bl	34005ba8 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
3400517c:	687b      	ldr	r3, [r7, #4]
3400517e:	2200      	movs	r2, #0
34005180:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
34005184:	6878      	ldr	r0, [r7, #4]
34005186:	f008 f935 	bl	3400d3f4 <HAL_I2C_MasterRxCpltCallback>
}
3400518a:	bf00      	nop
3400518c:	3708      	adds	r7, #8
3400518e:	46bd      	mov	sp, r7
34005190:	bd80      	pop	{r7, pc}

34005192 <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
34005192:	b580      	push	{r7, lr}
34005194:	b084      	sub	sp, #16
34005196:	af00      	add	r7, sp, #0
34005198:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
3400519a:	687b      	ldr	r3, [r7, #4]
3400519c:	681b      	ldr	r3, [r3, #0]
3400519e:	681b      	ldr	r3, [r3, #0]
340051a0:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
340051a2:	687b      	ldr	r3, [r7, #4]
340051a4:	2200      	movs	r2, #0
340051a6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
340051aa:	68fb      	ldr	r3, [r7, #12]
340051ac:	0b9b      	lsrs	r3, r3, #14
340051ae:	f003 0301 	and.w	r3, r3, #1
340051b2:	2b00      	cmp	r3, #0
340051b4:	d008      	beq.n	340051c8 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
340051b6:	687b      	ldr	r3, [r7, #4]
340051b8:	681b      	ldr	r3, [r3, #0]
340051ba:	681a      	ldr	r2, [r3, #0]
340051bc:	687b      	ldr	r3, [r7, #4]
340051be:	681b      	ldr	r3, [r3, #0]
340051c0:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
340051c4:	601a      	str	r2, [r3, #0]
340051c6:	e00d      	b.n	340051e4 <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
340051c8:	68fb      	ldr	r3, [r7, #12]
340051ca:	0bdb      	lsrs	r3, r3, #15
340051cc:	f003 0301 	and.w	r3, r3, #1
340051d0:	2b00      	cmp	r3, #0
340051d2:	d007      	beq.n	340051e4 <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340051d4:	687b      	ldr	r3, [r7, #4]
340051d6:	681b      	ldr	r3, [r3, #0]
340051d8:	681a      	ldr	r2, [r3, #0]
340051da:	687b      	ldr	r3, [r7, #4]
340051dc:	681b      	ldr	r3, [r3, #0]
340051de:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340051e2:	601a      	str	r2, [r3, #0]
  {
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
340051e4:	687b      	ldr	r3, [r7, #4]
340051e6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340051ea:	b2db      	uxtb	r3, r3
340051ec:	2b29      	cmp	r3, #41	@ 0x29
340051ee:	d112      	bne.n	34005216 <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
340051f0:	687b      	ldr	r3, [r7, #4]
340051f2:	2228      	movs	r2, #40	@ 0x28
340051f4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
340051f8:	687b      	ldr	r3, [r7, #4]
340051fa:	2221      	movs	r2, #33	@ 0x21
340051fc:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
340051fe:	2101      	movs	r1, #1
34005200:	6878      	ldr	r0, [r7, #4]
34005202:	f000 fcd1 	bl	34005ba8 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005206:	687b      	ldr	r3, [r7, #4]
34005208:	2200      	movs	r2, #0
3400520a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
3400520e:	6878      	ldr	r0, [r7, #4]
34005210:	f008 f914 	bl	3400d43c <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
34005214:	e017      	b.n	34005246 <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
34005216:	687b      	ldr	r3, [r7, #4]
34005218:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400521c:	b2db      	uxtb	r3, r3
3400521e:	2b2a      	cmp	r3, #42	@ 0x2a
34005220:	d111      	bne.n	34005246 <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
34005222:	687b      	ldr	r3, [r7, #4]
34005224:	2228      	movs	r2, #40	@ 0x28
34005226:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
3400522a:	687b      	ldr	r3, [r7, #4]
3400522c:	2222      	movs	r2, #34	@ 0x22
3400522e:	631a      	str	r2, [r3, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
34005230:	2102      	movs	r1, #2
34005232:	6878      	ldr	r0, [r7, #4]
34005234:	f000 fcb8 	bl	34005ba8 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
34005238:	687b      	ldr	r3, [r7, #4]
3400523a:	2200      	movs	r2, #0
3400523c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
34005240:	6878      	ldr	r0, [r7, #4]
34005242:	f008 f8ef 	bl	3400d424 <HAL_I2C_SlaveRxCpltCallback>
}
34005246:	bf00      	nop
34005248:	3710      	adds	r7, #16
3400524a:	46bd      	mov	sp, r7
3400524c:	bd80      	pop	{r7, pc}
	...

34005250 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
34005250:	b580      	push	{r7, lr}
34005252:	b086      	sub	sp, #24
34005254:	af00      	add	r7, sp, #0
34005256:	6078      	str	r0, [r7, #4]
34005258:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
3400525a:	683b      	ldr	r3, [r7, #0]
3400525c:	617b      	str	r3, [r7, #20]
  __IO uint32_t tmpreg;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400525e:	687b      	ldr	r3, [r7, #4]
34005260:	681b      	ldr	r3, [r3, #0]
34005262:	2220      	movs	r2, #32
34005264:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
34005266:	687b      	ldr	r3, [r7, #4]
34005268:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400526c:	b2db      	uxtb	r3, r3
3400526e:	2b21      	cmp	r3, #33	@ 0x21
34005270:	d107      	bne.n	34005282 <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34005272:	2101      	movs	r1, #1
34005274:	6878      	ldr	r0, [r7, #4]
34005276:	f000 fc97 	bl	34005ba8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
3400527a:	687b      	ldr	r3, [r7, #4]
3400527c:	2211      	movs	r2, #17
3400527e:	631a      	str	r2, [r3, #48]	@ 0x30
34005280:	e00c      	b.n	3400529c <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005282:	687b      	ldr	r3, [r7, #4]
34005284:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005288:	b2db      	uxtb	r3, r3
3400528a:	2b22      	cmp	r3, #34	@ 0x22
3400528c:	d106      	bne.n	3400529c <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
3400528e:	2102      	movs	r1, #2
34005290:	6878      	ldr	r0, [r7, #4]
34005292:	f000 fc89 	bl	34005ba8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
34005296:	687b      	ldr	r3, [r7, #4]
34005298:	2212      	movs	r2, #18
3400529a:	631a      	str	r2, [r3, #48]	@ 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
3400529c:	687b      	ldr	r3, [r7, #4]
3400529e:	681b      	ldr	r3, [r3, #0]
340052a0:	6859      	ldr	r1, [r3, #4]
340052a2:	687b      	ldr	r3, [r7, #4]
340052a4:	681a      	ldr	r2, [r3, #0]
340052a6:	4b4d      	ldr	r3, [pc, #308]	@ (340053dc <I2C_ITMasterCplt+0x18c>)
340052a8:	400b      	ands	r3, r1
340052aa:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
340052ac:	687b      	ldr	r3, [r7, #4]
340052ae:	2200      	movs	r2, #0
340052b0:	635a      	str	r2, [r3, #52]	@ 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
340052b2:	687b      	ldr	r3, [r7, #4]
340052b4:	4a4a      	ldr	r2, [pc, #296]	@ (340053e0 <I2C_ITMasterCplt+0x190>)
340052b6:	62da      	str	r2, [r3, #44]	@ 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
340052b8:	697b      	ldr	r3, [r7, #20]
340052ba:	091b      	lsrs	r3, r3, #4
340052bc:	f003 0301 	and.w	r3, r3, #1
340052c0:	2b00      	cmp	r3, #0
340052c2:	d009      	beq.n	340052d8 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340052c4:	687b      	ldr	r3, [r7, #4]
340052c6:	681b      	ldr	r3, [r3, #0]
340052c8:	2210      	movs	r2, #16
340052ca:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340052cc:	687b      	ldr	r3, [r7, #4]
340052ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340052d0:	f043 0204 	orr.w	r2, r3, #4
340052d4:	687b      	ldr	r3, [r7, #4]
340052d6:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
340052d8:	687b      	ldr	r3, [r7, #4]
340052da:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340052de:	b2db      	uxtb	r3, r3
340052e0:	2b60      	cmp	r3, #96	@ 0x60
340052e2:	d10b      	bne.n	340052fc <I2C_ITMasterCplt+0xac>
340052e4:	697b      	ldr	r3, [r7, #20]
340052e6:	089b      	lsrs	r3, r3, #2
340052e8:	f003 0301 	and.w	r3, r3, #1
340052ec:	2b00      	cmp	r3, #0
340052ee:	d005      	beq.n	340052fc <I2C_ITMasterCplt+0xac>
  {
    /* Read data from RXDR */
    tmpreg = (uint8_t)hi2c->Instance->RXDR;
340052f0:	687b      	ldr	r3, [r7, #4]
340052f2:	681b      	ldr	r3, [r3, #0]
340052f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340052f6:	b2db      	uxtb	r3, r3
340052f8:	60fb      	str	r3, [r7, #12]
    UNUSED(tmpreg);
340052fa:	68fb      	ldr	r3, [r7, #12]
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
340052fc:	6878      	ldr	r0, [r7, #4]
340052fe:	f000 fb5a 	bl	340059b6 <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
34005302:	687b      	ldr	r3, [r7, #4]
34005304:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005306:	613b      	str	r3, [r7, #16]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
34005308:	687b      	ldr	r3, [r7, #4]
3400530a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400530e:	b2db      	uxtb	r3, r3
34005310:	2b60      	cmp	r3, #96	@ 0x60
34005312:	d002      	beq.n	3400531a <I2C_ITMasterCplt+0xca>
34005314:	693b      	ldr	r3, [r7, #16]
34005316:	2b00      	cmp	r3, #0
34005318:	d006      	beq.n	34005328 <I2C_ITMasterCplt+0xd8>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
3400531a:	687b      	ldr	r3, [r7, #4]
3400531c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400531e:	4619      	mov	r1, r3
34005320:	6878      	ldr	r0, [r7, #4]
34005322:	f000 fa31 	bl	34005788 <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
34005326:	e054      	b.n	340053d2 <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
34005328:	687b      	ldr	r3, [r7, #4]
3400532a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400532e:	b2db      	uxtb	r3, r3
34005330:	2b21      	cmp	r3, #33	@ 0x21
34005332:	d124      	bne.n	3400537e <I2C_ITMasterCplt+0x12e>
    hi2c->State = HAL_I2C_STATE_READY;
34005334:	687b      	ldr	r3, [r7, #4]
34005336:	2220      	movs	r2, #32
34005338:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
3400533c:	687b      	ldr	r3, [r7, #4]
3400533e:	2200      	movs	r2, #0
34005340:	631a      	str	r2, [r3, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
34005342:	687b      	ldr	r3, [r7, #4]
34005344:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
34005348:	b2db      	uxtb	r3, r3
3400534a:	2b40      	cmp	r3, #64	@ 0x40
3400534c:	d10b      	bne.n	34005366 <I2C_ITMasterCplt+0x116>
      hi2c->Mode = HAL_I2C_MODE_NONE;
3400534e:	687b      	ldr	r3, [r7, #4]
34005350:	2200      	movs	r2, #0
34005352:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
34005356:	687b      	ldr	r3, [r7, #4]
34005358:	2200      	movs	r2, #0
3400535a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
3400535e:	6878      	ldr	r0, [r7, #4]
34005360:	f008 f884 	bl	3400d46c <HAL_I2C_MemTxCpltCallback>
}
34005364:	e035      	b.n	340053d2 <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
34005366:	687b      	ldr	r3, [r7, #4]
34005368:	2200      	movs	r2, #0
3400536a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
3400536e:	687b      	ldr	r3, [r7, #4]
34005370:	2200      	movs	r2, #0
34005372:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
34005376:	6878      	ldr	r0, [r7, #4]
34005378:	f008 f848 	bl	3400d40c <HAL_I2C_MasterTxCpltCallback>
}
3400537c:	e029      	b.n	340053d2 <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
3400537e:	687b      	ldr	r3, [r7, #4]
34005380:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005384:	b2db      	uxtb	r3, r3
34005386:	2b22      	cmp	r3, #34	@ 0x22
34005388:	d123      	bne.n	340053d2 <I2C_ITMasterCplt+0x182>
    hi2c->State = HAL_I2C_STATE_READY;
3400538a:	687b      	ldr	r3, [r7, #4]
3400538c:	2220      	movs	r2, #32
3400538e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34005392:	687b      	ldr	r3, [r7, #4]
34005394:	2200      	movs	r2, #0
34005396:	631a      	str	r2, [r3, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
34005398:	687b      	ldr	r3, [r7, #4]
3400539a:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
3400539e:	b2db      	uxtb	r3, r3
340053a0:	2b40      	cmp	r3, #64	@ 0x40
340053a2:	d10b      	bne.n	340053bc <I2C_ITMasterCplt+0x16c>
      hi2c->Mode = HAL_I2C_MODE_NONE;
340053a4:	687b      	ldr	r3, [r7, #4]
340053a6:	2200      	movs	r2, #0
340053a8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
340053ac:	687b      	ldr	r3, [r7, #4]
340053ae:	2200      	movs	r2, #0
340053b0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
340053b4:	6878      	ldr	r0, [r7, #4]
340053b6:	f008 f84d 	bl	3400d454 <HAL_I2C_MemRxCpltCallback>
}
340053ba:	e00a      	b.n	340053d2 <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
340053bc:	687b      	ldr	r3, [r7, #4]
340053be:	2200      	movs	r2, #0
340053c0:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
340053c4:	687b      	ldr	r3, [r7, #4]
340053c6:	2200      	movs	r2, #0
340053c8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
340053cc:	6878      	ldr	r0, [r7, #4]
340053ce:	f008 f811 	bl	3400d3f4 <HAL_I2C_MasterRxCpltCallback>
}
340053d2:	bf00      	nop
340053d4:	3718      	adds	r7, #24
340053d6:	46bd      	mov	sp, r7
340053d8:	bd80      	pop	{r7, pc}
340053da:	bf00      	nop
340053dc:	fe00e800 	.word	0xfe00e800
340053e0:	ffff0000 	.word	0xffff0000

340053e4 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
340053e4:	b590      	push	{r4, r7, lr}
340053e6:	b087      	sub	sp, #28
340053e8:	af00      	add	r7, sp, #0
340053ea:	6078      	str	r0, [r7, #4]
340053ec:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
340053ee:	687b      	ldr	r3, [r7, #4]
340053f0:	681b      	ldr	r3, [r3, #0]
340053f2:	681b      	ldr	r3, [r3, #0]
340053f4:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
340053f6:	683b      	ldr	r3, [r7, #0]
340053f8:	617b      	str	r3, [r7, #20]
  uint32_t tmpoptions = hi2c->XferOptions;
340053fa:	687b      	ldr	r3, [r7, #4]
340053fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340053fe:	60fb      	str	r3, [r7, #12]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
34005400:	687b      	ldr	r3, [r7, #4]
34005402:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005406:	72fb      	strb	r3, [r7, #11]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34005408:	687b      	ldr	r3, [r7, #4]
3400540a:	681b      	ldr	r3, [r3, #0]
3400540c:	2220      	movs	r2, #32
3400540e:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
34005410:	7afb      	ldrb	r3, [r7, #11]
34005412:	2b21      	cmp	r3, #33	@ 0x21
34005414:	d002      	beq.n	3400541c <I2C_ITSlaveCplt+0x38>
34005416:	7afb      	ldrb	r3, [r7, #11]
34005418:	2b29      	cmp	r3, #41	@ 0x29
3400541a:	d108      	bne.n	3400542e <I2C_ITSlaveCplt+0x4a>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
3400541c:	f248 0101 	movw	r1, #32769	@ 0x8001
34005420:	6878      	ldr	r0, [r7, #4]
34005422:	f000 fbc1 	bl	34005ba8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
34005426:	687b      	ldr	r3, [r7, #4]
34005428:	2221      	movs	r2, #33	@ 0x21
3400542a:	631a      	str	r2, [r3, #48]	@ 0x30
3400542c:	e019      	b.n	34005462 <I2C_ITSlaveCplt+0x7e>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
3400542e:	7afb      	ldrb	r3, [r7, #11]
34005430:	2b22      	cmp	r3, #34	@ 0x22
34005432:	d002      	beq.n	3400543a <I2C_ITSlaveCplt+0x56>
34005434:	7afb      	ldrb	r3, [r7, #11]
34005436:	2b2a      	cmp	r3, #42	@ 0x2a
34005438:	d108      	bne.n	3400544c <I2C_ITSlaveCplt+0x68>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
3400543a:	f248 0102 	movw	r1, #32770	@ 0x8002
3400543e:	6878      	ldr	r0, [r7, #4]
34005440:	f000 fbb2 	bl	34005ba8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
34005444:	687b      	ldr	r3, [r7, #4]
34005446:	2222      	movs	r2, #34	@ 0x22
34005448:	631a      	str	r2, [r3, #48]	@ 0x30
3400544a:	e00a      	b.n	34005462 <I2C_ITSlaveCplt+0x7e>
  }
  else if (tmpstate == HAL_I2C_STATE_LISTEN)
3400544c:	7afb      	ldrb	r3, [r7, #11]
3400544e:	2b28      	cmp	r3, #40	@ 0x28
34005450:	d107      	bne.n	34005462 <I2C_ITSlaveCplt+0x7e>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
34005452:	f248 0103 	movw	r1, #32771	@ 0x8003
34005456:	6878      	ldr	r0, [r7, #4]
34005458:	f000 fba6 	bl	34005ba8 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_NONE;
3400545c:	687b      	ldr	r3, [r7, #4]
3400545e:	2200      	movs	r2, #0
34005460:	631a      	str	r2, [r3, #48]	@ 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
34005462:	687b      	ldr	r3, [r7, #4]
34005464:	681b      	ldr	r3, [r3, #0]
34005466:	685a      	ldr	r2, [r3, #4]
34005468:	687b      	ldr	r3, [r7, #4]
3400546a:	681b      	ldr	r3, [r3, #0]
3400546c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005470:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
34005472:	687b      	ldr	r3, [r7, #4]
34005474:	681b      	ldr	r3, [r3, #0]
34005476:	6859      	ldr	r1, [r3, #4]
34005478:	687b      	ldr	r3, [r7, #4]
3400547a:	681a      	ldr	r2, [r3, #0]
3400547c:	4b95      	ldr	r3, [pc, #596]	@ (340056d4 <I2C_ITSlaveCplt+0x2f0>)
3400547e:	400b      	ands	r3, r1
34005480:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
34005482:	6878      	ldr	r0, [r7, #4]
34005484:	f000 fa97 	bl	340059b6 <I2C_Flush_TXDR>

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
34005488:	693b      	ldr	r3, [r7, #16]
3400548a:	0b9b      	lsrs	r3, r3, #14
3400548c:	f003 0301 	and.w	r3, r3, #1
34005490:	2b00      	cmp	r3, #0
34005492:	d01c      	beq.n	340054ce <I2C_ITSlaveCplt+0xea>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
34005494:	687b      	ldr	r3, [r7, #4]
34005496:	681b      	ldr	r3, [r3, #0]
34005498:	681a      	ldr	r2, [r3, #0]
3400549a:	687b      	ldr	r3, [r7, #4]
3400549c:	681b      	ldr	r3, [r3, #0]
3400549e:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
340054a2:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
340054a4:	687b      	ldr	r3, [r7, #4]
340054a6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340054a8:	2b00      	cmp	r3, #0
340054aa:	d032      	beq.n	34005512 <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
340054ac:	687b      	ldr	r3, [r7, #4]
340054ae:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340054b0:	681b      	ldr	r3, [r3, #0]
340054b2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340054b4:	b29c      	uxth	r4, r3
340054b6:	687b      	ldr	r3, [r7, #4]
340054b8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340054ba:	4618      	mov	r0, r3
340054bc:	f7fe fba7 	bl	34003c0e <HAL_DMAEx_GetFifoLevel>
340054c0:	4603      	mov	r3, r0
340054c2:	b29b      	uxth	r3, r3
340054c4:	4423      	add	r3, r4
340054c6:	b29a      	uxth	r2, r3
340054c8:	687b      	ldr	r3, [r7, #4]
340054ca:	855a      	strh	r2, [r3, #42]	@ 0x2a
340054cc:	e021      	b.n	34005512 <I2C_ITSlaveCplt+0x12e>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
340054ce:	693b      	ldr	r3, [r7, #16]
340054d0:	0bdb      	lsrs	r3, r3, #15
340054d2:	f003 0301 	and.w	r3, r3, #1
340054d6:	2b00      	cmp	r3, #0
340054d8:	d01b      	beq.n	34005512 <I2C_ITSlaveCplt+0x12e>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340054da:	687b      	ldr	r3, [r7, #4]
340054dc:	681b      	ldr	r3, [r3, #0]
340054de:	681a      	ldr	r2, [r3, #0]
340054e0:	687b      	ldr	r3, [r7, #4]
340054e2:	681b      	ldr	r3, [r3, #0]
340054e4:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340054e8:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
340054ea:	687b      	ldr	r3, [r7, #4]
340054ec:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340054ee:	2b00      	cmp	r3, #0
340054f0:	d00f      	beq.n	34005512 <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
340054f2:	687b      	ldr	r3, [r7, #4]
340054f4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340054f6:	681b      	ldr	r3, [r3, #0]
340054f8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340054fa:	b29c      	uxth	r4, r3
340054fc:	687b      	ldr	r3, [r7, #4]
340054fe:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005500:	4618      	mov	r0, r3
34005502:	f7fe fb84 	bl	34003c0e <HAL_DMAEx_GetFifoLevel>
34005506:	4603      	mov	r3, r0
34005508:	b29b      	uxth	r3, r3
3400550a:	4423      	add	r3, r4
3400550c:	b29a      	uxth	r2, r3
3400550e:	687b      	ldr	r3, [r7, #4]
34005510:	855a      	strh	r2, [r3, #42]	@ 0x2a
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
34005512:	697b      	ldr	r3, [r7, #20]
34005514:	089b      	lsrs	r3, r3, #2
34005516:	f003 0301 	and.w	r3, r3, #1
3400551a:	2b00      	cmp	r3, #0
3400551c:	d020      	beq.n	34005560 <I2C_ITSlaveCplt+0x17c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
3400551e:	697b      	ldr	r3, [r7, #20]
34005520:	f023 0304 	bic.w	r3, r3, #4
34005524:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34005526:	687b      	ldr	r3, [r7, #4]
34005528:	681b      	ldr	r3, [r3, #0]
3400552a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400552c:	687b      	ldr	r3, [r7, #4]
3400552e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005530:	b2d2      	uxtb	r2, r2
34005532:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
34005534:	687b      	ldr	r3, [r7, #4]
34005536:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005538:	1c5a      	adds	r2, r3, #1
3400553a:	687b      	ldr	r3, [r7, #4]
3400553c:	625a      	str	r2, [r3, #36]	@ 0x24

    if (hi2c->XferSize > 0U)
3400553e:	687b      	ldr	r3, [r7, #4]
34005540:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005542:	2b00      	cmp	r3, #0
34005544:	d00c      	beq.n	34005560 <I2C_ITSlaveCplt+0x17c>
    {
      hi2c->XferSize--;
34005546:	687b      	ldr	r3, [r7, #4]
34005548:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400554a:	3b01      	subs	r3, #1
3400554c:	b29a      	uxth	r2, r3
3400554e:	687b      	ldr	r3, [r7, #4]
34005550:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
34005552:	687b      	ldr	r3, [r7, #4]
34005554:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005556:	b29b      	uxth	r3, r3
34005558:	3b01      	subs	r3, #1
3400555a:	b29a      	uxth	r2, r3
3400555c:	687b      	ldr	r3, [r7, #4]
3400555e:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
34005560:	687b      	ldr	r3, [r7, #4]
34005562:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005564:	b29b      	uxth	r3, r3
34005566:	2b00      	cmp	r3, #0
34005568:	d005      	beq.n	34005576 <I2C_ITSlaveCplt+0x192>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
3400556a:	687b      	ldr	r3, [r7, #4]
3400556c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400556e:	f043 0204 	orr.w	r2, r3, #4
34005572:	687b      	ldr	r3, [r7, #4]
34005574:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
34005576:	697b      	ldr	r3, [r7, #20]
34005578:	091b      	lsrs	r3, r3, #4
3400557a:	f003 0301 	and.w	r3, r3, #1
3400557e:	2b00      	cmp	r3, #0
34005580:	d04a      	beq.n	34005618 <I2C_ITSlaveCplt+0x234>
      (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_IT_NACKI) != RESET))
34005582:	693b      	ldr	r3, [r7, #16]
34005584:	091b      	lsrs	r3, r3, #4
34005586:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
3400558a:	2b00      	cmp	r3, #0
3400558c:	d044      	beq.n	34005618 <I2C_ITSlaveCplt+0x234>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
3400558e:	687b      	ldr	r3, [r7, #4]
34005590:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005592:	b29b      	uxth	r3, r3
34005594:	2b00      	cmp	r3, #0
34005596:	d128      	bne.n	340055ea <I2C_ITSlaveCplt+0x206>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
34005598:	687b      	ldr	r3, [r7, #4]
3400559a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400559e:	b2db      	uxtb	r3, r3
340055a0:	2b28      	cmp	r3, #40	@ 0x28
340055a2:	d108      	bne.n	340055b6 <I2C_ITSlaveCplt+0x1d2>
340055a4:	68fb      	ldr	r3, [r7, #12]
340055a6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340055aa:	d104      	bne.n	340055b6 <I2C_ITSlaveCplt+0x1d2>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
340055ac:	6979      	ldr	r1, [r7, #20]
340055ae:	6878      	ldr	r0, [r7, #4]
340055b0:	f000 f894 	bl	340056dc <I2C_ITListenCplt>
340055b4:	e030      	b.n	34005618 <I2C_ITSlaveCplt+0x234>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
340055b6:	687b      	ldr	r3, [r7, #4]
340055b8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340055bc:	b2db      	uxtb	r3, r3
340055be:	2b29      	cmp	r3, #41	@ 0x29
340055c0:	d10e      	bne.n	340055e0 <I2C_ITSlaveCplt+0x1fc>
340055c2:	68fb      	ldr	r3, [r7, #12]
340055c4:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
340055c8:	d00a      	beq.n	340055e0 <I2C_ITSlaveCplt+0x1fc>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340055ca:	687b      	ldr	r3, [r7, #4]
340055cc:	681b      	ldr	r3, [r3, #0]
340055ce:	2210      	movs	r2, #16
340055d0:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
340055d2:	6878      	ldr	r0, [r7, #4]
340055d4:	f000 f9ef 	bl	340059b6 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
340055d8:	6878      	ldr	r0, [r7, #4]
340055da:	f7ff fdda 	bl	34005192 <I2C_ITSlaveSeqCplt>
340055de:	e01b      	b.n	34005618 <I2C_ITSlaveCplt+0x234>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340055e0:	687b      	ldr	r3, [r7, #4]
340055e2:	681b      	ldr	r3, [r3, #0]
340055e4:	2210      	movs	r2, #16
340055e6:	61da      	str	r2, [r3, #28]
340055e8:	e016      	b.n	34005618 <I2C_ITSlaveCplt+0x234>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340055ea:	687b      	ldr	r3, [r7, #4]
340055ec:	681b      	ldr	r3, [r3, #0]
340055ee:	2210      	movs	r2, #16
340055f0:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340055f2:	687b      	ldr	r3, [r7, #4]
340055f4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340055f6:	f043 0204 	orr.w	r2, r3, #4
340055fa:	687b      	ldr	r3, [r7, #4]
340055fc:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
340055fe:	68fb      	ldr	r3, [r7, #12]
34005600:	2b00      	cmp	r3, #0
34005602:	d003      	beq.n	3400560c <I2C_ITSlaveCplt+0x228>
34005604:	68fb      	ldr	r3, [r7, #12]
34005606:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400560a:	d105      	bne.n	34005618 <I2C_ITSlaveCplt+0x234>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
3400560c:	687b      	ldr	r3, [r7, #4]
3400560e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005610:	4619      	mov	r1, r3
34005612:	6878      	ldr	r0, [r7, #4]
34005614:	f000 f8b8 	bl	34005788 <I2C_ITError>
      }
    }
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
34005618:	687b      	ldr	r3, [r7, #4]
3400561a:	2200      	movs	r2, #0
3400561c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
34005620:	687b      	ldr	r3, [r7, #4]
34005622:	2200      	movs	r2, #0
34005624:	635a      	str	r2, [r3, #52]	@ 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
34005626:	687b      	ldr	r3, [r7, #4]
34005628:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400562a:	2b00      	cmp	r3, #0
3400562c:	d010      	beq.n	34005650 <I2C_ITSlaveCplt+0x26c>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
3400562e:	687b      	ldr	r3, [r7, #4]
34005630:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005632:	4619      	mov	r1, r3
34005634:	6878      	ldr	r0, [r7, #4]
34005636:	f000 f8a7 	bl	34005788 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
3400563a:	687b      	ldr	r3, [r7, #4]
3400563c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005640:	b2db      	uxtb	r3, r3
34005642:	2b28      	cmp	r3, #40	@ 0x28
34005644:	d141      	bne.n	340056ca <I2C_ITSlaveCplt+0x2e6>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
34005646:	6979      	ldr	r1, [r7, #20]
34005648:	6878      	ldr	r0, [r7, #4]
3400564a:	f000 f847 	bl	340056dc <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
3400564e:	e03c      	b.n	340056ca <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
34005650:	687b      	ldr	r3, [r7, #4]
34005652:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005654:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005658:	d014      	beq.n	34005684 <I2C_ITSlaveCplt+0x2a0>
    I2C_ITSlaveSeqCplt(hi2c);
3400565a:	6878      	ldr	r0, [r7, #4]
3400565c:	f7ff fd99 	bl	34005192 <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34005660:	687b      	ldr	r3, [r7, #4]
34005662:	4a1d      	ldr	r2, [pc, #116]	@ (340056d8 <I2C_ITSlaveCplt+0x2f4>)
34005664:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
34005666:	687b      	ldr	r3, [r7, #4]
34005668:	2220      	movs	r2, #32
3400566a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
3400566e:	687b      	ldr	r3, [r7, #4]
34005670:	2200      	movs	r2, #0
34005672:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
34005674:	687b      	ldr	r3, [r7, #4]
34005676:	2200      	movs	r2, #0
34005678:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
3400567c:	6878      	ldr	r0, [r7, #4]
3400567e:	f7fe ff7c 	bl	3400457a <HAL_I2C_ListenCpltCallback>
}
34005682:	e022      	b.n	340056ca <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005684:	687b      	ldr	r3, [r7, #4]
34005686:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400568a:	b2db      	uxtb	r3, r3
3400568c:	2b22      	cmp	r3, #34	@ 0x22
3400568e:	d10e      	bne.n	340056ae <I2C_ITSlaveCplt+0x2ca>
    hi2c->State = HAL_I2C_STATE_READY;
34005690:	687b      	ldr	r3, [r7, #4]
34005692:	2220      	movs	r2, #32
34005694:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34005698:	687b      	ldr	r3, [r7, #4]
3400569a:	2200      	movs	r2, #0
3400569c:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
3400569e:	687b      	ldr	r3, [r7, #4]
340056a0:	2200      	movs	r2, #0
340056a2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
340056a6:	6878      	ldr	r0, [r7, #4]
340056a8:	f007 febc 	bl	3400d424 <HAL_I2C_SlaveRxCpltCallback>
}
340056ac:	e00d      	b.n	340056ca <I2C_ITSlaveCplt+0x2e6>
    hi2c->State = HAL_I2C_STATE_READY;
340056ae:	687b      	ldr	r3, [r7, #4]
340056b0:	2220      	movs	r2, #32
340056b2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
340056b6:	687b      	ldr	r3, [r7, #4]
340056b8:	2200      	movs	r2, #0
340056ba:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
340056bc:	687b      	ldr	r3, [r7, #4]
340056be:	2200      	movs	r2, #0
340056c0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
340056c4:	6878      	ldr	r0, [r7, #4]
340056c6:	f007 feb9 	bl	3400d43c <HAL_I2C_SlaveTxCpltCallback>
}
340056ca:	bf00      	nop
340056cc:	371c      	adds	r7, #28
340056ce:	46bd      	mov	sp, r7
340056d0:	bd90      	pop	{r4, r7, pc}
340056d2:	bf00      	nop
340056d4:	fe00e800 	.word	0xfe00e800
340056d8:	ffff0000 	.word	0xffff0000

340056dc <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
340056dc:	b580      	push	{r7, lr}
340056de:	b082      	sub	sp, #8
340056e0:	af00      	add	r7, sp, #0
340056e2:	6078      	str	r0, [r7, #4]
340056e4:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
340056e6:	687b      	ldr	r3, [r7, #4]
340056e8:	4a26      	ldr	r2, [pc, #152]	@ (34005784 <I2C_ITListenCplt+0xa8>)
340056ea:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
340056ec:	687b      	ldr	r3, [r7, #4]
340056ee:	2200      	movs	r2, #0
340056f0:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->State = HAL_I2C_STATE_READY;
340056f2:	687b      	ldr	r3, [r7, #4]
340056f4:	2220      	movs	r2, #32
340056f6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
340056fa:	687b      	ldr	r3, [r7, #4]
340056fc:	2200      	movs	r2, #0
340056fe:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
34005702:	687b      	ldr	r3, [r7, #4]
34005704:	2200      	movs	r2, #0
34005706:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
34005708:	683b      	ldr	r3, [r7, #0]
3400570a:	089b      	lsrs	r3, r3, #2
3400570c:	f003 0301 	and.w	r3, r3, #1
34005710:	2b00      	cmp	r3, #0
34005712:	d022      	beq.n	3400575a <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
34005714:	687b      	ldr	r3, [r7, #4]
34005716:	681b      	ldr	r3, [r3, #0]
34005718:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400571a:	687b      	ldr	r3, [r7, #4]
3400571c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400571e:	b2d2      	uxtb	r2, r2
34005720:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
34005722:	687b      	ldr	r3, [r7, #4]
34005724:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005726:	1c5a      	adds	r2, r3, #1
34005728:	687b      	ldr	r3, [r7, #4]
3400572a:	625a      	str	r2, [r3, #36]	@ 0x24

    if (hi2c->XferSize > 0U)
3400572c:	687b      	ldr	r3, [r7, #4]
3400572e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005730:	2b00      	cmp	r3, #0
34005732:	d012      	beq.n	3400575a <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
34005734:	687b      	ldr	r3, [r7, #4]
34005736:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005738:	3b01      	subs	r3, #1
3400573a:	b29a      	uxth	r2, r3
3400573c:	687b      	ldr	r3, [r7, #4]
3400573e:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
34005740:	687b      	ldr	r3, [r7, #4]
34005742:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005744:	b29b      	uxth	r3, r3
34005746:	3b01      	subs	r3, #1
34005748:	b29a      	uxth	r2, r3
3400574a:	687b      	ldr	r3, [r7, #4]
3400574c:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
3400574e:	687b      	ldr	r3, [r7, #4]
34005750:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005752:	f043 0204 	orr.w	r2, r3, #4
34005756:	687b      	ldr	r3, [r7, #4]
34005758:	645a      	str	r2, [r3, #68]	@ 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
3400575a:	f248 0103 	movw	r1, #32771	@ 0x8003
3400575e:	6878      	ldr	r0, [r7, #4]
34005760:	f000 fa22 	bl	34005ba8 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005764:	687b      	ldr	r3, [r7, #4]
34005766:	681b      	ldr	r3, [r3, #0]
34005768:	2210      	movs	r2, #16
3400576a:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
3400576c:	687b      	ldr	r3, [r7, #4]
3400576e:	2200      	movs	r2, #0
34005770:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
34005774:	6878      	ldr	r0, [r7, #4]
34005776:	f7fe ff00 	bl	3400457a <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
3400577a:	bf00      	nop
3400577c:	3708      	adds	r7, #8
3400577e:	46bd      	mov	sp, r7
34005780:	bd80      	pop	{r7, pc}
34005782:	bf00      	nop
34005784:	ffff0000 	.word	0xffff0000

34005788 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
34005788:	b580      	push	{r7, lr}
3400578a:	b084      	sub	sp, #16
3400578c:	af00      	add	r7, sp, #0
3400578e:	6078      	str	r0, [r7, #4]
34005790:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
34005792:	687b      	ldr	r3, [r7, #4]
34005794:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005798:	73fb      	strb	r3, [r7, #15]
#if defined(HAL_DMA_MODULE_ENABLED)
  uint32_t tmppreviousstate;
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
3400579a:	687b      	ldr	r3, [r7, #4]
3400579c:	2200      	movs	r2, #0
3400579e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
340057a2:	687b      	ldr	r3, [r7, #4]
340057a4:	4a6d      	ldr	r2, [pc, #436]	@ (3400595c <I2C_ITError+0x1d4>)
340057a6:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->XferCount     = 0U;
340057a8:	687b      	ldr	r3, [r7, #4]
340057aa:	2200      	movs	r2, #0
340057ac:	855a      	strh	r2, [r3, #42]	@ 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
340057ae:	687b      	ldr	r3, [r7, #4]
340057b0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
340057b2:	683b      	ldr	r3, [r7, #0]
340057b4:	431a      	orrs	r2, r3
340057b6:	687b      	ldr	r3, [r7, #4]
340057b8:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
340057ba:	7bfb      	ldrb	r3, [r7, #15]
340057bc:	2b28      	cmp	r3, #40	@ 0x28
340057be:	d005      	beq.n	340057cc <I2C_ITError+0x44>
340057c0:	7bfb      	ldrb	r3, [r7, #15]
340057c2:	2b29      	cmp	r3, #41	@ 0x29
340057c4:	d002      	beq.n	340057cc <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
340057c6:	7bfb      	ldrb	r3, [r7, #15]
340057c8:	2b2a      	cmp	r3, #42	@ 0x2a
340057ca:	d10b      	bne.n	340057e4 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
340057cc:	2103      	movs	r1, #3
340057ce:	6878      	ldr	r0, [r7, #4]
340057d0:	f000 f9ea 	bl	34005ba8 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
340057d4:	687b      	ldr	r3, [r7, #4]
340057d6:	2228      	movs	r2, #40	@ 0x28
340057d8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
340057dc:	687b      	ldr	r3, [r7, #4]
340057de:	4a60      	ldr	r2, [pc, #384]	@ (34005960 <I2C_ITError+0x1d8>)
340057e0:	635a      	str	r2, [r3, #52]	@ 0x34
340057e2:	e030      	b.n	34005846 <I2C_ITError+0xbe>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
340057e4:	f248 0103 	movw	r1, #32771	@ 0x8003
340057e8:	6878      	ldr	r0, [r7, #4]
340057ea:	f000 f9dd 	bl	34005ba8 <I2C_Disable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
340057ee:	6878      	ldr	r0, [r7, #4]
340057f0:	f000 f8e1 	bl	340059b6 <I2C_Flush_TXDR>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
340057f4:	687b      	ldr	r3, [r7, #4]
340057f6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340057fa:	b2db      	uxtb	r3, r3
340057fc:	2b60      	cmp	r3, #96	@ 0x60
340057fe:	d01f      	beq.n	34005840 <I2C_ITError+0xb8>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
34005800:	687b      	ldr	r3, [r7, #4]
34005802:	2220      	movs	r2, #32
34005804:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Check if a STOPF is detected */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
34005808:	687b      	ldr	r3, [r7, #4]
3400580a:	681b      	ldr	r3, [r3, #0]
3400580c:	699b      	ldr	r3, [r3, #24]
3400580e:	f003 0320 	and.w	r3, r3, #32
34005812:	2b20      	cmp	r3, #32
34005814:	d114      	bne.n	34005840 <I2C_ITError+0xb8>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
34005816:	687b      	ldr	r3, [r7, #4]
34005818:	681b      	ldr	r3, [r3, #0]
3400581a:	699b      	ldr	r3, [r3, #24]
3400581c:	f003 0310 	and.w	r3, r3, #16
34005820:	2b10      	cmp	r3, #16
34005822:	d109      	bne.n	34005838 <I2C_ITError+0xb0>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005824:	687b      	ldr	r3, [r7, #4]
34005826:	681b      	ldr	r3, [r3, #0]
34005828:	2210      	movs	r2, #16
3400582a:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
3400582c:	687b      	ldr	r3, [r7, #4]
3400582e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005830:	f043 0204 	orr.w	r2, r3, #4
34005834:	687b      	ldr	r3, [r7, #4]
34005836:	645a      	str	r2, [r3, #68]	@ 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34005838:	687b      	ldr	r3, [r7, #4]
3400583a:	681b      	ldr	r3, [r3, #0]
3400583c:	2220      	movs	r2, #32
3400583e:	61da      	str	r2, [r3, #28]
      }

    }
    hi2c->XferISR       = NULL;
34005840:	687b      	ldr	r3, [r7, #4]
34005842:	2200      	movs	r2, #0
34005844:	635a      	str	r2, [r3, #52]	@ 0x34
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
34005846:	687b      	ldr	r3, [r7, #4]
34005848:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400584a:	60bb      	str	r3, [r7, #8]

  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
3400584c:	687b      	ldr	r3, [r7, #4]
3400584e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005850:	2b00      	cmp	r3, #0
34005852:	d039      	beq.n	340058c8 <I2C_ITError+0x140>
34005854:	68bb      	ldr	r3, [r7, #8]
34005856:	2b11      	cmp	r3, #17
34005858:	d002      	beq.n	34005860 <I2C_ITError+0xd8>
3400585a:	68bb      	ldr	r3, [r7, #8]
3400585c:	2b21      	cmp	r3, #33	@ 0x21
3400585e:	d133      	bne.n	340058c8 <I2C_ITError+0x140>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
34005860:	687b      	ldr	r3, [r7, #4]
34005862:	681b      	ldr	r3, [r3, #0]
34005864:	681b      	ldr	r3, [r3, #0]
34005866:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400586a:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400586e:	d107      	bne.n	34005880 <I2C_ITError+0xf8>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
34005870:	687b      	ldr	r3, [r7, #4]
34005872:	681b      	ldr	r3, [r3, #0]
34005874:	681a      	ldr	r2, [r3, #0]
34005876:	687b      	ldr	r3, [r7, #4]
34005878:	681b      	ldr	r3, [r3, #0]
3400587a:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
3400587e:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
34005880:	687b      	ldr	r3, [r7, #4]
34005882:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005884:	4618      	mov	r0, r3
34005886:	f7fe f9b4 	bl	34003bf2 <HAL_DMA_GetState>
3400588a:	4603      	mov	r3, r0
3400588c:	2b01      	cmp	r3, #1
3400588e:	d017      	beq.n	340058c0 <I2C_ITError+0x138>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
34005890:	687b      	ldr	r3, [r7, #4]
34005892:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005894:	4a33      	ldr	r2, [pc, #204]	@ (34005964 <I2C_ITError+0x1dc>)
34005896:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
34005898:	687b      	ldr	r3, [r7, #4]
3400589a:	2200      	movs	r2, #0
3400589c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
340058a0:	687b      	ldr	r3, [r7, #4]
340058a2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340058a4:	4618      	mov	r0, r3
340058a6:	f7fe f97b 	bl	34003ba0 <HAL_DMA_Abort_IT>
340058aa:	4603      	mov	r3, r0
340058ac:	2b00      	cmp	r3, #0
340058ae:	d04d      	beq.n	3400594c <I2C_ITError+0x1c4>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
340058b0:	687b      	ldr	r3, [r7, #4]
340058b2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340058b4:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340058b6:	687a      	ldr	r2, [r7, #4]
340058b8:	6b92      	ldr	r2, [r2, #56]	@ 0x38
340058ba:	4610      	mov	r0, r2
340058bc:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
340058be:	e045      	b.n	3400594c <I2C_ITError+0x1c4>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
340058c0:	6878      	ldr	r0, [r7, #4]
340058c2:	f000 f851 	bl	34005968 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
340058c6:	e041      	b.n	3400594c <I2C_ITError+0x1c4>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
340058c8:	687b      	ldr	r3, [r7, #4]
340058ca:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340058cc:	2b00      	cmp	r3, #0
340058ce:	d039      	beq.n	34005944 <I2C_ITError+0x1bc>
340058d0:	68bb      	ldr	r3, [r7, #8]
340058d2:	2b12      	cmp	r3, #18
340058d4:	d002      	beq.n	340058dc <I2C_ITError+0x154>
340058d6:	68bb      	ldr	r3, [r7, #8]
340058d8:	2b22      	cmp	r3, #34	@ 0x22
340058da:	d133      	bne.n	34005944 <I2C_ITError+0x1bc>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
340058dc:	687b      	ldr	r3, [r7, #4]
340058de:	681b      	ldr	r3, [r3, #0]
340058e0:	681b      	ldr	r3, [r3, #0]
340058e2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340058e6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340058ea:	d107      	bne.n	340058fc <I2C_ITError+0x174>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340058ec:	687b      	ldr	r3, [r7, #4]
340058ee:	681b      	ldr	r3, [r3, #0]
340058f0:	681a      	ldr	r2, [r3, #0]
340058f2:	687b      	ldr	r3, [r7, #4]
340058f4:	681b      	ldr	r3, [r3, #0]
340058f6:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340058fa:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
340058fc:	687b      	ldr	r3, [r7, #4]
340058fe:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005900:	4618      	mov	r0, r3
34005902:	f7fe f976 	bl	34003bf2 <HAL_DMA_GetState>
34005906:	4603      	mov	r3, r0
34005908:	2b01      	cmp	r3, #1
3400590a:	d017      	beq.n	3400593c <I2C_ITError+0x1b4>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
3400590c:	687b      	ldr	r3, [r7, #4]
3400590e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005910:	4a14      	ldr	r2, [pc, #80]	@ (34005964 <I2C_ITError+0x1dc>)
34005912:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
34005914:	687b      	ldr	r3, [r7, #4]
34005916:	2200      	movs	r2, #0
34005918:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
3400591c:	687b      	ldr	r3, [r7, #4]
3400591e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005920:	4618      	mov	r0, r3
34005922:	f7fe f93d 	bl	34003ba0 <HAL_DMA_Abort_IT>
34005926:	4603      	mov	r3, r0
34005928:	2b00      	cmp	r3, #0
3400592a:	d011      	beq.n	34005950 <I2C_ITError+0x1c8>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
3400592c:	687b      	ldr	r3, [r7, #4]
3400592e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005930:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34005932:	687a      	ldr	r2, [r7, #4]
34005934:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
34005936:	4610      	mov	r0, r2
34005938:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
3400593a:	e009      	b.n	34005950 <I2C_ITError+0x1c8>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
3400593c:	6878      	ldr	r0, [r7, #4]
3400593e:	f000 f813 	bl	34005968 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
34005942:	e005      	b.n	34005950 <I2C_ITError+0x1c8>
    }
  }
  else
#endif /* HAL_DMA_MODULE_ENABLED */
  {
    I2C_TreatErrorCallback(hi2c);
34005944:	6878      	ldr	r0, [r7, #4]
34005946:	f000 f80f 	bl	34005968 <I2C_TreatErrorCallback>
  }
}
3400594a:	e002      	b.n	34005952 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
3400594c:	bf00      	nop
3400594e:	e000      	b.n	34005952 <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
34005950:	bf00      	nop
}
34005952:	bf00      	nop
34005954:	3710      	adds	r7, #16
34005956:	46bd      	mov	sp, r7
34005958:	bd80      	pop	{r7, pc}
3400595a:	bf00      	nop
3400595c:	ffff0000 	.word	0xffff0000
34005960:	340047df 	.word	0x340047df
34005964:	340059ff 	.word	0x340059ff

34005968 <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
34005968:	b580      	push	{r7, lr}
3400596a:	b082      	sub	sp, #8
3400596c:	af00      	add	r7, sp, #0
3400596e:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
34005970:	687b      	ldr	r3, [r7, #4]
34005972:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005976:	b2db      	uxtb	r3, r3
34005978:	2b60      	cmp	r3, #96	@ 0x60
3400597a:	d10e      	bne.n	3400599a <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
3400597c:	687b      	ldr	r3, [r7, #4]
3400597e:	2220      	movs	r2, #32
34005980:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34005984:	687b      	ldr	r3, [r7, #4]
34005986:	2200      	movs	r2, #0
34005988:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400598a:	687b      	ldr	r3, [r7, #4]
3400598c:	2200      	movs	r2, #0
3400598e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
34005992:	6878      	ldr	r0, [r7, #4]
34005994:	f007 fd83 	bl	3400d49e <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
34005998:	e009      	b.n	340059ae <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
3400599a:	687b      	ldr	r3, [r7, #4]
3400599c:	2200      	movs	r2, #0
3400599e:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
340059a0:	687b      	ldr	r3, [r7, #4]
340059a2:	2200      	movs	r2, #0
340059a4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ErrorCallback(hi2c);
340059a8:	6878      	ldr	r0, [r7, #4]
340059aa:	f007 fd6b 	bl	3400d484 <HAL_I2C_ErrorCallback>
}
340059ae:	bf00      	nop
340059b0:	3708      	adds	r7, #8
340059b2:	46bd      	mov	sp, r7
340059b4:	bd80      	pop	{r7, pc}

340059b6 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
340059b6:	b480      	push	{r7}
340059b8:	b083      	sub	sp, #12
340059ba:	af00      	add	r7, sp, #0
340059bc:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
340059be:	687b      	ldr	r3, [r7, #4]
340059c0:	681b      	ldr	r3, [r3, #0]
340059c2:	699b      	ldr	r3, [r3, #24]
340059c4:	f003 0302 	and.w	r3, r3, #2
340059c8:	2b02      	cmp	r3, #2
340059ca:	d103      	bne.n	340059d4 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
340059cc:	687b      	ldr	r3, [r7, #4]
340059ce:	681b      	ldr	r3, [r3, #0]
340059d0:	2200      	movs	r2, #0
340059d2:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
340059d4:	687b      	ldr	r3, [r7, #4]
340059d6:	681b      	ldr	r3, [r3, #0]
340059d8:	699b      	ldr	r3, [r3, #24]
340059da:	f003 0301 	and.w	r3, r3, #1
340059de:	2b01      	cmp	r3, #1
340059e0:	d007      	beq.n	340059f2 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
340059e2:	687b      	ldr	r3, [r7, #4]
340059e4:	681b      	ldr	r3, [r3, #0]
340059e6:	699a      	ldr	r2, [r3, #24]
340059e8:	687b      	ldr	r3, [r7, #4]
340059ea:	681b      	ldr	r3, [r3, #0]
340059ec:	f042 0201 	orr.w	r2, r2, #1
340059f0:	619a      	str	r2, [r3, #24]
  }
}
340059f2:	bf00      	nop
340059f4:	370c      	adds	r7, #12
340059f6:	46bd      	mov	sp, r7
340059f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340059fc:	4770      	bx	lr

340059fe <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
340059fe:	b580      	push	{r7, lr}
34005a00:	b084      	sub	sp, #16
34005a02:	af00      	add	r7, sp, #0
34005a04:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
34005a06:	687b      	ldr	r3, [r7, #4]
34005a08:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34005a0a:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
34005a0c:	68fb      	ldr	r3, [r7, #12]
34005a0e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005a10:	2b00      	cmp	r3, #0
34005a12:	d003      	beq.n	34005a1c <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
34005a14:	68fb      	ldr	r3, [r7, #12]
34005a16:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005a18:	2200      	movs	r2, #0
34005a1a:	66da      	str	r2, [r3, #108]	@ 0x6c
  }
  if (hi2c->hdmarx != NULL)
34005a1c:	68fb      	ldr	r3, [r7, #12]
34005a1e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005a20:	2b00      	cmp	r3, #0
34005a22:	d003      	beq.n	34005a2c <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
34005a24:	68fb      	ldr	r3, [r7, #12]
34005a26:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005a28:	2200      	movs	r2, #0
34005a2a:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  I2C_TreatErrorCallback(hi2c);
34005a2c:	68f8      	ldr	r0, [r7, #12]
34005a2e:	f7ff ff9b 	bl	34005968 <I2C_TreatErrorCallback>
}
34005a32:	bf00      	nop
34005a34:	3710      	adds	r7, #16
34005a36:	46bd      	mov	sp, r7
34005a38:	bd80      	pop	{r7, pc}
	...

34005a3c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
34005a3c:	b480      	push	{r7}
34005a3e:	b087      	sub	sp, #28
34005a40:	af00      	add	r7, sp, #0
34005a42:	60f8      	str	r0, [r7, #12]
34005a44:	607b      	str	r3, [r7, #4]
34005a46:	460b      	mov	r3, r1
34005a48:	817b      	strh	r3, [r7, #10]
34005a4a:	4613      	mov	r3, r2
34005a4c:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34005a4e:	897b      	ldrh	r3, [r7, #10]
34005a50:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34005a54:	7a7b      	ldrb	r3, [r7, #9]
34005a56:	041b      	lsls	r3, r3, #16
34005a58:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34005a5c:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34005a5e:	687b      	ldr	r3, [r7, #4]
34005a60:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34005a62:	6a3b      	ldr	r3, [r7, #32]
34005a64:	4313      	orrs	r3, r2
34005a66:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34005a6a:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
34005a6c:	68fb      	ldr	r3, [r7, #12]
34005a6e:	681b      	ldr	r3, [r3, #0]
34005a70:	685a      	ldr	r2, [r3, #4]
34005a72:	6a3b      	ldr	r3, [r7, #32]
34005a74:	0d5b      	lsrs	r3, r3, #21
34005a76:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
34005a7a:	4b08      	ldr	r3, [pc, #32]	@ (34005a9c <I2C_TransferConfig+0x60>)
34005a7c:	430b      	orrs	r3, r1
34005a7e:	43db      	mvns	r3, r3
34005a80:	ea02 0103 	and.w	r1, r2, r3
34005a84:	68fb      	ldr	r3, [r7, #12]
34005a86:	681b      	ldr	r3, [r3, #0]
34005a88:	697a      	ldr	r2, [r7, #20]
34005a8a:	430a      	orrs	r2, r1
34005a8c:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
34005a8e:	bf00      	nop
34005a90:	371c      	adds	r7, #28
34005a92:	46bd      	mov	sp, r7
34005a94:	f85d 7b04 	ldr.w	r7, [sp], #4
34005a98:	4770      	bx	lr
34005a9a:	bf00      	nop
34005a9c:	03ff63ff 	.word	0x03ff63ff

34005aa0 <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
34005aa0:	b480      	push	{r7}
34005aa2:	b085      	sub	sp, #20
34005aa4:	af00      	add	r7, sp, #0
34005aa6:	6078      	str	r0, [r7, #4]
34005aa8:	460b      	mov	r3, r1
34005aaa:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
34005aac:	2300      	movs	r3, #0
34005aae:	60fb      	str	r3, [r7, #12]

#if defined(HAL_DMA_MODULE_ENABLED)
  if ((hi2c->XferISR != I2C_Master_ISR_DMA) && \
34005ab0:	687b      	ldr	r3, [r7, #4]
34005ab2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34005ab4:	4a39      	ldr	r2, [pc, #228]	@ (34005b9c <I2C_Enable_IRQ+0xfc>)
34005ab6:	4293      	cmp	r3, r2
34005ab8:	d032      	beq.n	34005b20 <I2C_Enable_IRQ+0x80>
      (hi2c->XferISR != I2C_Slave_ISR_DMA) && \
34005aba:	687b      	ldr	r3, [r7, #4]
34005abc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  if ((hi2c->XferISR != I2C_Master_ISR_DMA) && \
34005abe:	4a38      	ldr	r2, [pc, #224]	@ (34005ba0 <I2C_Enable_IRQ+0x100>)
34005ac0:	4293      	cmp	r3, r2
34005ac2:	d02d      	beq.n	34005b20 <I2C_Enable_IRQ+0x80>
      (hi2c->XferISR != I2C_Mem_ISR_DMA))
34005ac4:	687b      	ldr	r3, [r7, #4]
34005ac6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
      (hi2c->XferISR != I2C_Slave_ISR_DMA) && \
34005ac8:	4a36      	ldr	r2, [pc, #216]	@ (34005ba4 <I2C_Enable_IRQ+0x104>)
34005aca:	4293      	cmp	r3, r2
34005acc:	d028      	beq.n	34005b20 <I2C_Enable_IRQ+0x80>
#endif /* HAL_DMA_MODULE_ENABLED */
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34005ace:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34005ad2:	2b00      	cmp	r3, #0
34005ad4:	da03      	bge.n	34005ade <I2C_Enable_IRQ+0x3e>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34005ad6:	68fb      	ldr	r3, [r7, #12]
34005ad8:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34005adc:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34005ade:	887b      	ldrh	r3, [r7, #2]
34005ae0:	f003 0301 	and.w	r3, r3, #1
34005ae4:	2b00      	cmp	r3, #0
34005ae6:	d003      	beq.n	34005af0 <I2C_Enable_IRQ+0x50>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
34005ae8:	68fb      	ldr	r3, [r7, #12]
34005aea:	f043 03f2 	orr.w	r3, r3, #242	@ 0xf2
34005aee:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34005af0:	887b      	ldrh	r3, [r7, #2]
34005af2:	f003 0302 	and.w	r3, r3, #2
34005af6:	2b00      	cmp	r3, #0
34005af8:	d003      	beq.n	34005b02 <I2C_Enable_IRQ+0x62>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
34005afa:	68fb      	ldr	r3, [r7, #12]
34005afc:	f043 03f4 	orr.w	r3, r3, #244	@ 0xf4
34005b00:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
34005b02:	887b      	ldrh	r3, [r7, #2]
34005b04:	2b10      	cmp	r3, #16
34005b06:	d103      	bne.n	34005b10 <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34005b08:	68fb      	ldr	r3, [r7, #12]
34005b0a:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34005b0e:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
34005b10:	887b      	ldrh	r3, [r7, #2]
34005b12:	2b20      	cmp	r3, #32
34005b14:	d133      	bne.n	34005b7e <I2C_Enable_IRQ+0xde>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
34005b16:	68fb      	ldr	r3, [r7, #12]
34005b18:	f043 0320 	orr.w	r3, r3, #32
34005b1c:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_CPLT_IT)
34005b1e:	e02e      	b.n	34005b7e <I2C_Enable_IRQ+0xde>
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34005b20:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34005b24:	2b00      	cmp	r3, #0
34005b26:	da03      	bge.n	34005b30 <I2C_Enable_IRQ+0x90>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34005b28:	68fb      	ldr	r3, [r7, #12]
34005b2a:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34005b2e:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34005b30:	887b      	ldrh	r3, [r7, #2]
34005b32:	f003 0301 	and.w	r3, r3, #1
34005b36:	2b00      	cmp	r3, #0
34005b38:	d003      	beq.n	34005b42 <I2C_Enable_IRQ+0xa2>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
34005b3a:	68fb      	ldr	r3, [r7, #12]
34005b3c:	f043 03f2 	orr.w	r3, r3, #242	@ 0xf2
34005b40:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34005b42:	887b      	ldrh	r3, [r7, #2]
34005b44:	f003 0302 	and.w	r3, r3, #2
34005b48:	2b00      	cmp	r3, #0
34005b4a:	d003      	beq.n	34005b54 <I2C_Enable_IRQ+0xb4>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
34005b4c:	68fb      	ldr	r3, [r7, #12]
34005b4e:	f043 03f4 	orr.w	r3, r3, #244	@ 0xf4
34005b52:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
34005b54:	887b      	ldrh	r3, [r7, #2]
34005b56:	2b10      	cmp	r3, #16
34005b58:	d103      	bne.n	34005b62 <I2C_Enable_IRQ+0xc2>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34005b5a:	68fb      	ldr	r3, [r7, #12]
34005b5c:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34005b60:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
34005b62:	887b      	ldrh	r3, [r7, #2]
34005b64:	2b20      	cmp	r3, #32
34005b66:	d103      	bne.n	34005b70 <I2C_Enable_IRQ+0xd0>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
34005b68:	68fb      	ldr	r3, [r7, #12]
34005b6a:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
34005b6e:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
34005b70:	887b      	ldrh	r3, [r7, #2]
34005b72:	2b40      	cmp	r3, #64	@ 0x40
34005b74:	d103      	bne.n	34005b7e <I2C_Enable_IRQ+0xde>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
34005b76:	68fb      	ldr	r3, [r7, #12]
34005b78:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34005b7c:	60fb      	str	r3, [r7, #12]
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
34005b7e:	687b      	ldr	r3, [r7, #4]
34005b80:	681b      	ldr	r3, [r3, #0]
34005b82:	6819      	ldr	r1, [r3, #0]
34005b84:	687b      	ldr	r3, [r7, #4]
34005b86:	681b      	ldr	r3, [r3, #0]
34005b88:	68fa      	ldr	r2, [r7, #12]
34005b8a:	430a      	orrs	r2, r1
34005b8c:	601a      	str	r2, [r3, #0]
}
34005b8e:	bf00      	nop
34005b90:	3714      	adds	r7, #20
34005b92:	46bd      	mov	sp, r7
34005b94:	f85d 7b04 	ldr.w	r7, [sp], #4
34005b98:	4770      	bx	lr
34005b9a:	bf00      	nop
34005b9c:	340049e7 	.word	0x340049e7
34005ba0:	34004e2d 	.word	0x34004e2d
34005ba4:	34004bcd 	.word	0x34004bcd

34005ba8 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
34005ba8:	b480      	push	{r7}
34005baa:	b085      	sub	sp, #20
34005bac:	af00      	add	r7, sp, #0
34005bae:	6078      	str	r0, [r7, #4]
34005bb0:	460b      	mov	r3, r1
34005bb2:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
34005bb4:	2300      	movs	r3, #0
34005bb6:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34005bb8:	887b      	ldrh	r3, [r7, #2]
34005bba:	f003 0301 	and.w	r3, r3, #1
34005bbe:	2b00      	cmp	r3, #0
34005bc0:	d00f      	beq.n	34005be2 <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
34005bc2:	68fb      	ldr	r3, [r7, #12]
34005bc4:	f043 0342 	orr.w	r3, r3, #66	@ 0x42
34005bc8:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
34005bca:	687b      	ldr	r3, [r7, #4]
34005bcc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005bd0:	b2db      	uxtb	r3, r3
34005bd2:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34005bd6:	2b28      	cmp	r3, #40	@ 0x28
34005bd8:	d003      	beq.n	34005be2 <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34005bda:	68fb      	ldr	r3, [r7, #12]
34005bdc:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
34005be0:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34005be2:	887b      	ldrh	r3, [r7, #2]
34005be4:	f003 0302 	and.w	r3, r3, #2
34005be8:	2b00      	cmp	r3, #0
34005bea:	d00f      	beq.n	34005c0c <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
34005bec:	68fb      	ldr	r3, [r7, #12]
34005bee:	f043 0344 	orr.w	r3, r3, #68	@ 0x44
34005bf2:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
34005bf4:	687b      	ldr	r3, [r7, #4]
34005bf6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005bfa:	b2db      	uxtb	r3, r3
34005bfc:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34005c00:	2b28      	cmp	r3, #40	@ 0x28
34005c02:	d003      	beq.n	34005c0c <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34005c04:	68fb      	ldr	r3, [r7, #12]
34005c06:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
34005c0a:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34005c0c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34005c10:	2b00      	cmp	r3, #0
34005c12:	da03      	bge.n	34005c1c <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34005c14:	68fb      	ldr	r3, [r7, #12]
34005c16:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34005c1a:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
34005c1c:	887b      	ldrh	r3, [r7, #2]
34005c1e:	2b10      	cmp	r3, #16
34005c20:	d103      	bne.n	34005c2a <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34005c22:	68fb      	ldr	r3, [r7, #12]
34005c24:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34005c28:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
34005c2a:	887b      	ldrh	r3, [r7, #2]
34005c2c:	2b20      	cmp	r3, #32
34005c2e:	d103      	bne.n	34005c38 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
34005c30:	68fb      	ldr	r3, [r7, #12]
34005c32:	f043 0320 	orr.w	r3, r3, #32
34005c36:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
34005c38:	887b      	ldrh	r3, [r7, #2]
34005c3a:	2b40      	cmp	r3, #64	@ 0x40
34005c3c:	d103      	bne.n	34005c46 <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
34005c3e:	68fb      	ldr	r3, [r7, #12]
34005c40:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34005c44:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
34005c46:	687b      	ldr	r3, [r7, #4]
34005c48:	681b      	ldr	r3, [r3, #0]
34005c4a:	6819      	ldr	r1, [r3, #0]
34005c4c:	68fb      	ldr	r3, [r7, #12]
34005c4e:	43da      	mvns	r2, r3
34005c50:	687b      	ldr	r3, [r7, #4]
34005c52:	681b      	ldr	r3, [r3, #0]
34005c54:	400a      	ands	r2, r1
34005c56:	601a      	str	r2, [r3, #0]
}
34005c58:	bf00      	nop
34005c5a:	3714      	adds	r7, #20
34005c5c:	46bd      	mov	sp, r7
34005c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
34005c62:	4770      	bx	lr

34005c64 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
34005c64:	b480      	push	{r7}
34005c66:	b083      	sub	sp, #12
34005c68:	af00      	add	r7, sp, #0
34005c6a:	6078      	str	r0, [r7, #4]
34005c6c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34005c6e:	687b      	ldr	r3, [r7, #4]
34005c70:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005c74:	b2db      	uxtb	r3, r3
34005c76:	2b20      	cmp	r3, #32
34005c78:	d138      	bne.n	34005cec <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34005c7a:	687b      	ldr	r3, [r7, #4]
34005c7c:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34005c80:	2b01      	cmp	r3, #1
34005c82:	d101      	bne.n	34005c88 <HAL_I2CEx_ConfigAnalogFilter+0x24>
34005c84:	2302      	movs	r3, #2
34005c86:	e032      	b.n	34005cee <HAL_I2CEx_ConfigAnalogFilter+0x8a>
34005c88:	687b      	ldr	r3, [r7, #4]
34005c8a:	2201      	movs	r2, #1
34005c8c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34005c90:	687b      	ldr	r3, [r7, #4]
34005c92:	2224      	movs	r2, #36	@ 0x24
34005c94:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34005c98:	687b      	ldr	r3, [r7, #4]
34005c9a:	681b      	ldr	r3, [r3, #0]
34005c9c:	681a      	ldr	r2, [r3, #0]
34005c9e:	687b      	ldr	r3, [r7, #4]
34005ca0:	681b      	ldr	r3, [r3, #0]
34005ca2:	f022 0201 	bic.w	r2, r2, #1
34005ca6:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34005ca8:	687b      	ldr	r3, [r7, #4]
34005caa:	681b      	ldr	r3, [r3, #0]
34005cac:	681a      	ldr	r2, [r3, #0]
34005cae:	687b      	ldr	r3, [r7, #4]
34005cb0:	681b      	ldr	r3, [r3, #0]
34005cb2:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34005cb6:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
34005cb8:	687b      	ldr	r3, [r7, #4]
34005cba:	681b      	ldr	r3, [r3, #0]
34005cbc:	6819      	ldr	r1, [r3, #0]
34005cbe:	687b      	ldr	r3, [r7, #4]
34005cc0:	681b      	ldr	r3, [r3, #0]
34005cc2:	683a      	ldr	r2, [r7, #0]
34005cc4:	430a      	orrs	r2, r1
34005cc6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34005cc8:	687b      	ldr	r3, [r7, #4]
34005cca:	681b      	ldr	r3, [r3, #0]
34005ccc:	681a      	ldr	r2, [r3, #0]
34005cce:	687b      	ldr	r3, [r7, #4]
34005cd0:	681b      	ldr	r3, [r3, #0]
34005cd2:	f042 0201 	orr.w	r2, r2, #1
34005cd6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34005cd8:	687b      	ldr	r3, [r7, #4]
34005cda:	2220      	movs	r2, #32
34005cdc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005ce0:	687b      	ldr	r3, [r7, #4]
34005ce2:	2200      	movs	r2, #0
34005ce4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34005ce8:	2300      	movs	r3, #0
34005cea:	e000      	b.n	34005cee <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
34005cec:	2302      	movs	r3, #2
  }
}
34005cee:	4618      	mov	r0, r3
34005cf0:	370c      	adds	r7, #12
34005cf2:	46bd      	mov	sp, r7
34005cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
34005cf8:	4770      	bx	lr

34005cfa <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34005cfa:	b480      	push	{r7}
34005cfc:	b085      	sub	sp, #20
34005cfe:	af00      	add	r7, sp, #0
34005d00:	6078      	str	r0, [r7, #4]
34005d02:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34005d04:	687b      	ldr	r3, [r7, #4]
34005d06:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005d0a:	b2db      	uxtb	r3, r3
34005d0c:	2b20      	cmp	r3, #32
34005d0e:	d139      	bne.n	34005d84 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34005d10:	687b      	ldr	r3, [r7, #4]
34005d12:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34005d16:	2b01      	cmp	r3, #1
34005d18:	d101      	bne.n	34005d1e <HAL_I2CEx_ConfigDigitalFilter+0x24>
34005d1a:	2302      	movs	r3, #2
34005d1c:	e033      	b.n	34005d86 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
34005d1e:	687b      	ldr	r3, [r7, #4]
34005d20:	2201      	movs	r2, #1
34005d22:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34005d26:	687b      	ldr	r3, [r7, #4]
34005d28:	2224      	movs	r2, #36	@ 0x24
34005d2a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34005d2e:	687b      	ldr	r3, [r7, #4]
34005d30:	681b      	ldr	r3, [r3, #0]
34005d32:	681a      	ldr	r2, [r3, #0]
34005d34:	687b      	ldr	r3, [r7, #4]
34005d36:	681b      	ldr	r3, [r3, #0]
34005d38:	f022 0201 	bic.w	r2, r2, #1
34005d3c:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
34005d3e:	687b      	ldr	r3, [r7, #4]
34005d40:	681b      	ldr	r3, [r3, #0]
34005d42:	681b      	ldr	r3, [r3, #0]
34005d44:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
34005d46:	68fb      	ldr	r3, [r7, #12]
34005d48:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
34005d4c:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
34005d4e:	683b      	ldr	r3, [r7, #0]
34005d50:	021b      	lsls	r3, r3, #8
34005d52:	68fa      	ldr	r2, [r7, #12]
34005d54:	4313      	orrs	r3, r2
34005d56:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
34005d58:	687b      	ldr	r3, [r7, #4]
34005d5a:	681b      	ldr	r3, [r3, #0]
34005d5c:	68fa      	ldr	r2, [r7, #12]
34005d5e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34005d60:	687b      	ldr	r3, [r7, #4]
34005d62:	681b      	ldr	r3, [r3, #0]
34005d64:	681a      	ldr	r2, [r3, #0]
34005d66:	687b      	ldr	r3, [r7, #4]
34005d68:	681b      	ldr	r3, [r3, #0]
34005d6a:	f042 0201 	orr.w	r2, r2, #1
34005d6e:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34005d70:	687b      	ldr	r3, [r7, #4]
34005d72:	2220      	movs	r2, #32
34005d74:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005d78:	687b      	ldr	r3, [r7, #4]
34005d7a:	2200      	movs	r2, #0
34005d7c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34005d80:	2300      	movs	r3, #0
34005d82:	e000      	b.n	34005d86 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
34005d84:	2302      	movs	r3, #2
  }
}
34005d86:	4618      	mov	r0, r3
34005d88:	3714      	adds	r7, #20
34005d8a:	46bd      	mov	sp, r7
34005d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34005d90:	4770      	bx	lr
	...

34005d94 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34005d94:	b480      	push	{r7}
34005d96:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34005d98:	4b05      	ldr	r3, [pc, #20]	@ (34005db0 <HAL_PWREx_EnableVddIO2+0x1c>)
34005d9a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005d9c:	4a04      	ldr	r2, [pc, #16]	@ (34005db0 <HAL_PWREx_EnableVddIO2+0x1c>)
34005d9e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34005da2:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34005da4:	bf00      	nop
34005da6:	46bd      	mov	sp, r7
34005da8:	f85d 7b04 	ldr.w	r7, [sp], #4
34005dac:	4770      	bx	lr
34005dae:	bf00      	nop
34005db0:	56024800 	.word	0x56024800

34005db4 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34005db4:	b480      	push	{r7}
34005db6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34005db8:	4b05      	ldr	r3, [pc, #20]	@ (34005dd0 <HAL_PWREx_EnableVddIO3+0x1c>)
34005dba:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005dbc:	4a04      	ldr	r2, [pc, #16]	@ (34005dd0 <HAL_PWREx_EnableVddIO3+0x1c>)
34005dbe:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
34005dc2:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34005dc4:	bf00      	nop
34005dc6:	46bd      	mov	sp, r7
34005dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
34005dcc:	4770      	bx	lr
34005dce:	bf00      	nop
34005dd0:	56024800 	.word	0x56024800

34005dd4 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
34005dd4:	b480      	push	{r7}
34005dd6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34005dd8:	4b05      	ldr	r3, [pc, #20]	@ (34005df0 <HAL_PWREx_EnableVddIO4+0x1c>)
34005dda:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34005ddc:	4a04      	ldr	r2, [pc, #16]	@ (34005df0 <HAL_PWREx_EnableVddIO4+0x1c>)
34005dde:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34005de2:	6353      	str	r3, [r2, #52]	@ 0x34
}
34005de4:	bf00      	nop
34005de6:	46bd      	mov	sp, r7
34005de8:	f85d 7b04 	ldr.w	r7, [sp], #4
34005dec:	4770      	bx	lr
34005dee:	bf00      	nop
34005df0:	56024800 	.word	0x56024800

34005df4 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
34005df4:	b480      	push	{r7}
34005df6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
34005df8:	4b05      	ldr	r3, [pc, #20]	@ (34005e10 <HAL_PWREx_EnableVddIO5+0x1c>)
34005dfa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005dfc:	4a04      	ldr	r2, [pc, #16]	@ (34005e10 <HAL_PWREx_EnableVddIO5+0x1c>)
34005dfe:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34005e02:	6393      	str	r3, [r2, #56]	@ 0x38
}
34005e04:	bf00      	nop
34005e06:	46bd      	mov	sp, r7
34005e08:	f85d 7b04 	ldr.w	r7, [sp], #4
34005e0c:	4770      	bx	lr
34005e0e:	bf00      	nop
34005e10:	56024800 	.word	0x56024800

34005e14 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  * @brief  Select the HSE as hse_div2_osc_ck output clock
  * @rmtoll HSECFGR      HSEDIV2SEL    LL_RCC_HSE_SelectHSEAsDiv2Clock
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SelectHSEAsDiv2Clock(void)
{
34005e14:	b480      	push	{r7}
34005e16:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34005e18:	4b05      	ldr	r3, [pc, #20]	@ (34005e30 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34005e1a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005e1c:	4a04      	ldr	r2, [pc, #16]	@ (34005e30 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34005e1e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34005e22:	6553      	str	r3, [r2, #84]	@ 0x54
}
34005e24:	bf00      	nop
34005e26:	46bd      	mov	sp, r7
34005e28:	f85d 7b04 	ldr.w	r7, [sp], #4
34005e2c:	4770      	bx	lr
34005e2e:	bf00      	nop
34005e30:	56028000 	.word	0x56028000

34005e34 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  * @brief  Select the HSE divided by 2 as hse_div2_osc_ck output clock
  * @rmtoll HSECFGR      HSEDIV2SEL    LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock(void)
{
34005e34:	b480      	push	{r7}
34005e36:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34005e38:	4b05      	ldr	r3, [pc, #20]	@ (34005e50 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
34005e3a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005e3c:	4a04      	ldr	r2, [pc, #16]	@ (34005e50 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
34005e3e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34005e42:	6553      	str	r3, [r2, #84]	@ 0x54
}
34005e44:	bf00      	nop
34005e46:	46bd      	mov	sp, r7
34005e48:	f85d 7b04 	ldr.w	r7, [sp], #4
34005e4c:	4770      	bx	lr
34005e4e:	bf00      	nop
34005e50:	56028000 	.word	0x56028000

34005e54 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
34005e54:	b480      	push	{r7}
34005e56:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34005e58:	4b06      	ldr	r3, [pc, #24]	@ (34005e74 <LL_RCC_LSE_IsReady+0x20>)
34005e5a:	685b      	ldr	r3, [r3, #4]
34005e5c:	f003 0302 	and.w	r3, r3, #2
34005e60:	2b00      	cmp	r3, #0
34005e62:	d001      	beq.n	34005e68 <LL_RCC_LSE_IsReady+0x14>
34005e64:	2301      	movs	r3, #1
34005e66:	e000      	b.n	34005e6a <LL_RCC_LSE_IsReady+0x16>
34005e68:	2300      	movs	r3, #0
}
34005e6a:	4618      	mov	r0, r3
34005e6c:	46bd      	mov	sp, r7
34005e6e:	f85d 7b04 	ldr.w	r7, [sp], #4
34005e72:	4770      	bx	lr
34005e74:	56028000 	.word	0x56028000

34005e78 <LL_RCC_SetClockSource>:
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClockSource(uint32_t ClkSource)
{
34005e78:	b480      	push	{r7}
34005e7a:	b085      	sub	sp, #20
34005e7c:	af00      	add	r7, sp, #0
34005e7e:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
34005e80:	687b      	ldr	r3, [r7, #4]
34005e82:	b2da      	uxtb	r2, r3
34005e84:	4b10      	ldr	r3, [pc, #64]	@ (34005ec8 <LL_RCC_SetClockSource+0x50>)
34005e86:	4413      	add	r3, r2
34005e88:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
34005e8a:	68fb      	ldr	r3, [r7, #12]
34005e8c:	681a      	ldr	r2, [r3, #0]
34005e8e:	687b      	ldr	r3, [r7, #4]
34005e90:	0e19      	lsrs	r1, r3, #24
34005e92:	687b      	ldr	r3, [r7, #4]
34005e94:	0a1b      	lsrs	r3, r3, #8
34005e96:	f003 031f 	and.w	r3, r3, #31
34005e9a:	fa01 f303 	lsl.w	r3, r1, r3
34005e9e:	43db      	mvns	r3, r3
34005ea0:	401a      	ands	r2, r3
34005ea2:	687b      	ldr	r3, [r7, #4]
34005ea4:	0c1b      	lsrs	r3, r3, #16
34005ea6:	b2d9      	uxtb	r1, r3
34005ea8:	687b      	ldr	r3, [r7, #4]
34005eaa:	0a1b      	lsrs	r3, r3, #8
34005eac:	f003 031f 	and.w	r3, r3, #31
34005eb0:	fa01 f303 	lsl.w	r3, r1, r3
34005eb4:	431a      	orrs	r2, r3
34005eb6:	68fb      	ldr	r3, [r7, #12]
34005eb8:	601a      	str	r2, [r3, #0]
}
34005eba:	bf00      	nop
34005ebc:	3714      	adds	r7, #20
34005ebe:	46bd      	mov	sp, r7
34005ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
34005ec4:	4770      	bx	lr
34005ec6:	bf00      	nop
34005ec8:	56028144 	.word	0x56028144

34005ecc <LL_RCC_SetADFClockSource>:
  *         @arg @ref LL_RCC_ADF1_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_ADF1_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetADFClockSource(uint32_t ClkSource)
{
34005ecc:	b480      	push	{r7}
34005ece:	b083      	sub	sp, #12
34005ed0:	af00      	add	r7, sp, #0
34005ed2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
34005ed4:	4b07      	ldr	r3, [pc, #28]	@ (34005ef4 <LL_RCC_SetADFClockSource+0x28>)
34005ed6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34005eda:	f023 0207 	bic.w	r2, r3, #7
34005ede:	4905      	ldr	r1, [pc, #20]	@ (34005ef4 <LL_RCC_SetADFClockSource+0x28>)
34005ee0:	687b      	ldr	r3, [r7, #4]
34005ee2:	4313      	orrs	r3, r2
34005ee4:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34005ee8:	bf00      	nop
34005eea:	370c      	adds	r7, #12
34005eec:	46bd      	mov	sp, r7
34005eee:	f85d 7b04 	ldr.w	r7, [sp], #4
34005ef2:	4770      	bx	lr
34005ef4:	56028000 	.word	0x56028000

34005ef8 <LL_RCC_SetCLKPClockSource>:
  *         @arg @ref LL_RCC_CLKP_CLKSOURCE_IC15
  *         @arg @ref LL_RCC_CLKP_CLKSOURCE_IC20
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCLKPClockSource(uint32_t ClkSource)
{
34005ef8:	b480      	push	{r7}
34005efa:	b083      	sub	sp, #12
34005efc:	af00      	add	r7, sp, #0
34005efe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
34005f00:	4b07      	ldr	r3, [pc, #28]	@ (34005f20 <LL_RCC_SetCLKPClockSource+0x28>)
34005f02:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34005f06:	f023 0207 	bic.w	r2, r3, #7
34005f0a:	4905      	ldr	r1, [pc, #20]	@ (34005f20 <LL_RCC_SetCLKPClockSource+0x28>)
34005f0c:	687b      	ldr	r3, [r7, #4]
34005f0e:	4313      	orrs	r3, r2
34005f10:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34005f14:	bf00      	nop
34005f16:	370c      	adds	r7, #12
34005f18:	46bd      	mov	sp, r7
34005f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
34005f1e:	4770      	bx	lr
34005f20:	56028000 	.word	0x56028000

34005f24 <LL_RCC_SetDCMIPPClockSource>:
  *         @arg @ref LL_RCC_DCMIPP_CLKSOURCE_IC17
  *         @arg @ref LL_RCC_DCMIPP_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetDCMIPPClockSource(uint32_t ClkSource)
{
34005f24:	b480      	push	{r7}
34005f26:	b083      	sub	sp, #12
34005f28:	af00      	add	r7, sp, #0
34005f2a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
34005f2c:	4b07      	ldr	r3, [pc, #28]	@ (34005f4c <LL_RCC_SetDCMIPPClockSource+0x28>)
34005f2e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34005f32:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
34005f36:	4905      	ldr	r1, [pc, #20]	@ (34005f4c <LL_RCC_SetDCMIPPClockSource+0x28>)
34005f38:	687b      	ldr	r3, [r7, #4]
34005f3a:	4313      	orrs	r3, r2
34005f3c:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34005f40:	bf00      	nop
34005f42:	370c      	adds	r7, #12
34005f44:	46bd      	mov	sp, r7
34005f46:	f85d 7b04 	ldr.w	r7, [sp], #4
34005f4a:	4770      	bx	lr
34005f4c:	56028000 	.word	0x56028000

34005f50 <LL_RCC_SetETHClockSource>:
  *         @arg @ref LL_RCC_ETH1_CLKSOURCE_IC12
  *         @arg @ref LL_RCC_ETH1_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHClockSource(uint32_t ClkSource)
{
34005f50:	b480      	push	{r7}
34005f52:	b083      	sub	sp, #12
34005f54:	af00      	add	r7, sp, #0
34005f56:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
34005f58:	4b07      	ldr	r3, [pc, #28]	@ (34005f78 <LL_RCC_SetETHClockSource+0x28>)
34005f5a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34005f5e:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
34005f62:	4905      	ldr	r1, [pc, #20]	@ (34005f78 <LL_RCC_SetETHClockSource+0x28>)
34005f64:	687b      	ldr	r3, [r7, #4]
34005f66:	4313      	orrs	r3, r2
34005f68:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34005f6c:	bf00      	nop
34005f6e:	370c      	adds	r7, #12
34005f70:	46bd      	mov	sp, r7
34005f72:	f85d 7b04 	ldr.w	r7, [sp], #4
34005f76:	4770      	bx	lr
34005f78:	56028000 	.word	0x56028000

34005f7c <LL_RCC_SetETHPHYInterface>:
  *         @arg @ref LL_RCC_ETH1PHY_IF_RGMII
  *         @arg @ref LL_RCC_ETH1PHY_IF_RMII
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHPHYInterface(uint32_t Interface)
{
34005f7c:	b480      	push	{r7}
34005f7e:	b083      	sub	sp, #12
34005f80:	af00      	add	r7, sp, #0
34005f82:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34005f84:	4b07      	ldr	r3, [pc, #28]	@ (34005fa4 <LL_RCC_SetETHPHYInterface+0x28>)
34005f86:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34005f8a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34005f8e:	4905      	ldr	r1, [pc, #20]	@ (34005fa4 <LL_RCC_SetETHPHYInterface+0x28>)
34005f90:	687b      	ldr	r3, [r7, #4]
34005f92:	4313      	orrs	r3, r2
34005f94:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34005f98:	bf00      	nop
34005f9a:	370c      	adds	r7, #12
34005f9c:	46bd      	mov	sp, r7
34005f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34005fa2:	4770      	bx	lr
34005fa4:	56028000 	.word	0x56028000

34005fa8 <LL_RCC_SetETHREFRXClockSource>:
  *         @arg @ref LL_RCC_ETH1REFRX_CLKSOURCE_EXT
  *         @arg @ref LL_RCC_ETH1REFRX_CLKSOURCE_INT
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHREFRXClockSource(uint32_t ClkSource)
{
34005fa8:	b480      	push	{r7}
34005faa:	b083      	sub	sp, #12
34005fac:	af00      	add	r7, sp, #0
34005fae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
34005fb0:	4b07      	ldr	r3, [pc, #28]	@ (34005fd0 <LL_RCC_SetETHREFRXClockSource+0x28>)
34005fb2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34005fb6:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34005fba:	4905      	ldr	r1, [pc, #20]	@ (34005fd0 <LL_RCC_SetETHREFRXClockSource+0x28>)
34005fbc:	687b      	ldr	r3, [r7, #4]
34005fbe:	4313      	orrs	r3, r2
34005fc0:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34005fc4:	bf00      	nop
34005fc6:	370c      	adds	r7, #12
34005fc8:	46bd      	mov	sp, r7
34005fca:	f85d 7b04 	ldr.w	r7, [sp], #4
34005fce:	4770      	bx	lr
34005fd0:	56028000 	.word	0x56028000

34005fd4 <LL_RCC_SetETHREFTXClockSource>:
  *         @arg @ref LL_RCC_ETH1REFTX_CLKSOURCE_EXT
  *         @arg @ref LL_RCC_ETH1REFTX_CLKSOURCE_INT
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHREFTXClockSource(uint32_t ClkSource)
{
34005fd4:	b480      	push	{r7}
34005fd6:	b083      	sub	sp, #12
34005fd8:	af00      	add	r7, sp, #0
34005fda:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34005fdc:	4b07      	ldr	r3, [pc, #28]	@ (34005ffc <LL_RCC_SetETHREFTXClockSource+0x28>)
34005fde:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34005fe2:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34005fe6:	4905      	ldr	r1, [pc, #20]	@ (34005ffc <LL_RCC_SetETHREFTXClockSource+0x28>)
34005fe8:	687b      	ldr	r3, [r7, #4]
34005fea:	4313      	orrs	r3, r2
34005fec:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34005ff0:	bf00      	nop
34005ff2:	370c      	adds	r7, #12
34005ff4:	46bd      	mov	sp, r7
34005ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
34005ffa:	4770      	bx	lr
34005ffc:	56028000 	.word	0x56028000

34006000 <LL_RCC_SetFDCANClockSource>:
  *         @arg @ref LL_RCC_FDCAN_CLKSOURCE_IC19
  *         @arg @ref LL_RCC_FDCAN_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetFDCANClockSource(uint32_t ClkSource)
{
34006000:	b480      	push	{r7}
34006002:	b083      	sub	sp, #12
34006004:	af00      	add	r7, sp, #0
34006006:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
34006008:	4b07      	ldr	r3, [pc, #28]	@ (34006028 <LL_RCC_SetFDCANClockSource+0x28>)
3400600a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400600e:	f023 0203 	bic.w	r2, r3, #3
34006012:	4905      	ldr	r1, [pc, #20]	@ (34006028 <LL_RCC_SetFDCANClockSource+0x28>)
34006014:	687b      	ldr	r3, [r7, #4]
34006016:	4313      	orrs	r3, r2
34006018:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3400601c:	bf00      	nop
3400601e:	370c      	adds	r7, #12
34006020:	46bd      	mov	sp, r7
34006022:	f85d 7b04 	ldr.w	r7, [sp], #4
34006026:	4770      	bx	lr
34006028:	56028000 	.word	0x56028000

3400602c <LL_RCC_SetFMCClockSource>:
  *         @arg @ref LL_RCC_FMC_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_FMC_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetFMCClockSource(uint32_t ClkSource)
{
3400602c:	b480      	push	{r7}
3400602e:	b083      	sub	sp, #12
34006030:	af00      	add	r7, sp, #0
34006032:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
34006034:	4b07      	ldr	r3, [pc, #28]	@ (34006054 <LL_RCC_SetFMCClockSource+0x28>)
34006036:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400603a:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400603e:	4905      	ldr	r1, [pc, #20]	@ (34006054 <LL_RCC_SetFMCClockSource+0x28>)
34006040:	687b      	ldr	r3, [r7, #4]
34006042:	4313      	orrs	r3, r2
34006044:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34006048:	bf00      	nop
3400604a:	370c      	adds	r7, #12
3400604c:	46bd      	mov	sp, r7
3400604e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006052:	4770      	bx	lr
34006054:	56028000 	.word	0x56028000

34006058 <LL_RCC_SetI2CClockSource>:
  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetI2CClockSource(uint32_t ClkSource)
{
34006058:	b580      	push	{r7, lr}
3400605a:	b082      	sub	sp, #8
3400605c:	af00      	add	r7, sp, #0
3400605e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006060:	6878      	ldr	r0, [r7, #4]
34006062:	f7ff ff09 	bl	34005e78 <LL_RCC_SetClockSource>
}
34006066:	bf00      	nop
34006068:	3708      	adds	r7, #8
3400606a:	46bd      	mov	sp, r7
3400606c:	bd80      	pop	{r7, pc}

3400606e <LL_RCC_SetI3CClockSource>:
  *         @arg @ref LL_RCC_I3C2_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_I3C2_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetI3CClockSource(uint32_t ClkSource)
{
3400606e:	b580      	push	{r7, lr}
34006070:	b082      	sub	sp, #8
34006072:	af00      	add	r7, sp, #0
34006074:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006076:	6878      	ldr	r0, [r7, #4]
34006078:	f7ff fefe 	bl	34005e78 <LL_RCC_SetClockSource>
}
3400607c:	bf00      	nop
3400607e:	3708      	adds	r7, #8
34006080:	46bd      	mov	sp, r7
34006082:	bd80      	pop	{r7, pc}

34006084 <LL_RCC_SetLPTIMClockSource>:
  *         @arg @ref LL_RCC_LPTIM5_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_LPTIM5_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLPTIMClockSource(uint32_t ClkSource)
{
34006084:	b580      	push	{r7, lr}
34006086:	b082      	sub	sp, #8
34006088:	af00      	add	r7, sp, #0
3400608a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400608c:	6878      	ldr	r0, [r7, #4]
3400608e:	f7ff fef3 	bl	34005e78 <LL_RCC_SetClockSource>
}
34006092:	bf00      	nop
34006094:	3708      	adds	r7, #8
34006096:	46bd      	mov	sp, r7
34006098:	bd80      	pop	{r7, pc}
	...

3400609c <LL_RCC_SetLPUARTClockSource>:
  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLPUARTClockSource(uint32_t ClkSource)
{
3400609c:	b480      	push	{r7}
3400609e:	b083      	sub	sp, #12
340060a0:	af00      	add	r7, sp, #0
340060a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
340060a4:	4b07      	ldr	r3, [pc, #28]	@ (340060c4 <LL_RCC_SetLPUARTClockSource+0x28>)
340060a6:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340060aa:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
340060ae:	4905      	ldr	r1, [pc, #20]	@ (340060c4 <LL_RCC_SetLPUARTClockSource+0x28>)
340060b0:	687b      	ldr	r3, [r7, #4]
340060b2:	4313      	orrs	r3, r2
340060b4:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
340060b8:	bf00      	nop
340060ba:	370c      	adds	r7, #12
340060bc:	46bd      	mov	sp, r7
340060be:	f85d 7b04 	ldr.w	r7, [sp], #4
340060c2:	4770      	bx	lr
340060c4:	56028000 	.word	0x56028000

340060c8 <LL_RCC_SetLTDCClockSource>:
  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_IC16
  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLTDCClockSource(uint32_t ClkSource)
{
340060c8:	b480      	push	{r7}
340060ca:	b083      	sub	sp, #12
340060cc:	af00      	add	r7, sp, #0
340060ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
340060d0:	4b07      	ldr	r3, [pc, #28]	@ (340060f0 <LL_RCC_SetLTDCClockSource+0x28>)
340060d2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
340060d6:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
340060da:	4905      	ldr	r1, [pc, #20]	@ (340060f0 <LL_RCC_SetLTDCClockSource+0x28>)
340060dc:	687b      	ldr	r3, [r7, #4]
340060de:	4313      	orrs	r3, r2
340060e0:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
340060e4:	bf00      	nop
340060e6:	370c      	adds	r7, #12
340060e8:	46bd      	mov	sp, r7
340060ea:	f85d 7b04 	ldr.w	r7, [sp], #4
340060ee:	4770      	bx	lr
340060f0:	56028000 	.word	0x56028000

340060f4 <LL_RCC_SetMDFClockSource>:
  *         @arg @ref LL_RCC_MDF1_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_MDF1_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetMDFClockSource(uint32_t ClkSource)
{
340060f4:	b480      	push	{r7}
340060f6:	b083      	sub	sp, #12
340060f8:	af00      	add	r7, sp, #0
340060fa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
340060fc:	4b07      	ldr	r3, [pc, #28]	@ (3400611c <LL_RCC_SetMDFClockSource+0x28>)
340060fe:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34006102:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34006106:	4905      	ldr	r1, [pc, #20]	@ (3400611c <LL_RCC_SetMDFClockSource+0x28>)
34006108:	687b      	ldr	r3, [r7, #4]
3400610a:	4313      	orrs	r3, r2
3400610c:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
34006110:	bf00      	nop
34006112:	370c      	adds	r7, #12
34006114:	46bd      	mov	sp, r7
34006116:	f85d 7b04 	ldr.w	r7, [sp], #4
3400611a:	4770      	bx	lr
3400611c:	56028000 	.word	0x56028000

34006120 <LL_RCC_SetOTGPHYClockSource>:
  *         @arg @ref LL_RCC_OTGPHY2_CLKSOURCE_IC15
  *         @arg @ref LL_RCC_OTGPHY2_CLKSOURCE_HSE_DIV_2_OSC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetOTGPHYClockSource(uint32_t ClkSource)
{
34006120:	b580      	push	{r7, lr}
34006122:	b082      	sub	sp, #8
34006124:	af00      	add	r7, sp, #0
34006126:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006128:	6878      	ldr	r0, [r7, #4]
3400612a:	f7ff fea5 	bl	34005e78 <LL_RCC_SetClockSource>
}
3400612e:	bf00      	nop
34006130:	3708      	adds	r7, #8
34006132:	46bd      	mov	sp, r7
34006134:	bd80      	pop	{r7, pc}

34006136 <LL_RCC_SetOTGPHYCKREFClockSource>:
  *         @arg @ref LL_RCC_OTGPHY2CKREF_CLKSOURCE_OTGPHY2
  *         @arg @ref LL_RCC_OTGPHY2CKREF_CLKSOURCE_HSE_DIV_2_OSC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetOTGPHYCKREFClockSource(uint32_t ClkSource)
{
34006136:	b580      	push	{r7, lr}
34006138:	b082      	sub	sp, #8
3400613a:	af00      	add	r7, sp, #0
3400613c:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400613e:	6878      	ldr	r0, [r7, #4]
34006140:	f7ff fe9a 	bl	34005e78 <LL_RCC_SetClockSource>
}
34006144:	bf00      	nop
34006146:	3708      	adds	r7, #8
34006148:	46bd      	mov	sp, r7
3400614a:	bd80      	pop	{r7, pc}

3400614c <LL_RCC_SetPSSIClockSource>:
  *         @arg @ref LL_RCC_PSSI_CLKSOURCE_IC20
  *         @arg @ref LL_RCC_PSSI_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetPSSIClockSource(uint32_t ClkSource)
{
3400614c:	b480      	push	{r7}
3400614e:	b083      	sub	sp, #12
34006150:	af00      	add	r7, sp, #0
34006152:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34006154:	4b07      	ldr	r3, [pc, #28]	@ (34006174 <LL_RCC_SetPSSIClockSource+0x28>)
34006156:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400615a:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400615e:	4905      	ldr	r1, [pc, #20]	@ (34006174 <LL_RCC_SetPSSIClockSource+0x28>)
34006160:	687b      	ldr	r3, [r7, #4]
34006162:	4313      	orrs	r3, r2
34006164:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34006168:	bf00      	nop
3400616a:	370c      	adds	r7, #12
3400616c:	46bd      	mov	sp, r7
3400616e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006172:	4770      	bx	lr
34006174:	56028000 	.word	0x56028000

34006178 <LL_RCC_SetSAIClockSource>:
  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_SPDIFRX1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSAIClockSource(uint32_t ClkSource)
{
34006178:	b580      	push	{r7, lr}
3400617a:	b082      	sub	sp, #8
3400617c:	af00      	add	r7, sp, #0
3400617e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006180:	6878      	ldr	r0, [r7, #4]
34006182:	f7ff fe79 	bl	34005e78 <LL_RCC_SetClockSource>
}
34006186:	bf00      	nop
34006188:	3708      	adds	r7, #8
3400618a:	46bd      	mov	sp, r7
3400618c:	bd80      	pop	{r7, pc}

3400618e <LL_RCC_SetSDMMCClockSource>:
  *         @arg @ref LL_RCC_SDMMC2_CLKSOURCE_IC4
  *         @arg @ref LL_RCC_SDMMC2_CLKSOURCE_IC5
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSDMMCClockSource(uint32_t ClkSource)
{
3400618e:	b580      	push	{r7, lr}
34006190:	b082      	sub	sp, #8
34006192:	af00      	add	r7, sp, #0
34006194:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006196:	6878      	ldr	r0, [r7, #4]
34006198:	f7ff fe6e 	bl	34005e78 <LL_RCC_SetClockSource>
}
3400619c:	bf00      	nop
3400619e:	3708      	adds	r7, #8
340061a0:	46bd      	mov	sp, r7
340061a2:	bd80      	pop	{r7, pc}

340061a4 <LL_RCC_SetSPDIFRXClockSource>:
  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSPDIFRXClockSource(uint32_t ClkSource)
{
340061a4:	b480      	push	{r7}
340061a6:	b083      	sub	sp, #12
340061a8:	af00      	add	r7, sp, #0
340061aa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
340061ac:	4b07      	ldr	r3, [pc, #28]	@ (340061cc <LL_RCC_SetSPDIFRXClockSource+0x28>)
340061ae:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
340061b2:	f023 0207 	bic.w	r2, r3, #7
340061b6:	4905      	ldr	r1, [pc, #20]	@ (340061cc <LL_RCC_SetSPDIFRXClockSource+0x28>)
340061b8:	687b      	ldr	r3, [r7, #4]
340061ba:	4313      	orrs	r3, r2
340061bc:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
340061c0:	bf00      	nop
340061c2:	370c      	adds	r7, #12
340061c4:	46bd      	mov	sp, r7
340061c6:	f85d 7b04 	ldr.w	r7, [sp], #4
340061ca:	4770      	bx	lr
340061cc:	56028000 	.word	0x56028000

340061d0 <LL_RCC_SetSPIClockSource>:
  *         @arg @ref LL_RCC_SPI6_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_SPI6_CLKSOURCE_I2S_CKIN
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSPIClockSource(uint32_t ClkSource)
{
340061d0:	b580      	push	{r7, lr}
340061d2:	b082      	sub	sp, #8
340061d4:	af00      	add	r7, sp, #0
340061d6:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340061d8:	6878      	ldr	r0, [r7, #4]
340061da:	f7ff fe4d 	bl	34005e78 <LL_RCC_SetClockSource>
}
340061de:	bf00      	nop
340061e0:	3708      	adds	r7, #8
340061e2:	46bd      	mov	sp, r7
340061e4:	bd80      	pop	{r7, pc}

340061e6 <LL_RCC_SetUSARTClockSource>:
  *         @arg @ref LL_RCC_USART10_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_USART10_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetUSARTClockSource(uint32_t ClkSource)
{
340061e6:	b580      	push	{r7, lr}
340061e8:	b082      	sub	sp, #8
340061ea:	af00      	add	r7, sp, #0
340061ec:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340061ee:	6878      	ldr	r0, [r7, #4]
340061f0:	f7ff fe42 	bl	34005e78 <LL_RCC_SetClockSource>
}
340061f4:	bf00      	nop
340061f6:	3708      	adds	r7, #8
340061f8:	46bd      	mov	sp, r7
340061fa:	bd80      	pop	{r7, pc}

340061fc <LL_RCC_SetXSPIClockSource>:
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetXSPIClockSource(uint32_t ClkSource)
{
340061fc:	b580      	push	{r7, lr}
340061fe:	b082      	sub	sp, #8
34006200:	af00      	add	r7, sp, #0
34006202:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34006204:	6878      	ldr	r0, [r7, #4]
34006206:	f7ff fe37 	bl	34005e78 <LL_RCC_SetClockSource>
}
3400620a:	bf00      	nop
3400620c:	3708      	adds	r7, #8
3400620e:	46bd      	mov	sp, r7
34006210:	bd80      	pop	{r7, pc}
	...

34006214 <LL_RCC_SetRTCClockSource>:
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRTCClockSource(uint32_t Source)
{
34006214:	b480      	push	{r7}
34006216:	b083      	sub	sp, #12
34006218:	af00      	add	r7, sp, #0
3400621a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400621c:	4b07      	ldr	r3, [pc, #28]	@ (3400623c <LL_RCC_SetRTCClockSource+0x28>)
3400621e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34006222:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
34006226:	4905      	ldr	r1, [pc, #20]	@ (3400623c <LL_RCC_SetRTCClockSource+0x28>)
34006228:	687b      	ldr	r3, [r7, #4]
3400622a:	4313      	orrs	r3, r2
3400622c:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34006230:	bf00      	nop
34006232:	370c      	adds	r7, #12
34006234:	46bd      	mov	sp, r7
34006236:	f85d 7b04 	ldr.w	r7, [sp], #4
3400623a:	4770      	bx	lr
3400623c:	56028000 	.word	0x56028000

34006240 <LL_RCC_GetRTCClockSource>:
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSE
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_GetRTCClockSource(void)
{
34006240:	b480      	push	{r7}
34006242:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
34006244:	4b04      	ldr	r3, [pc, #16]	@ (34006258 <LL_RCC_GetRTCClockSource+0x18>)
34006246:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400624a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3400624e:	4618      	mov	r0, r3
34006250:	46bd      	mov	sp, r7
34006252:	f85d 7b04 	ldr.w	r7, [sp], #4
34006256:	4770      	bx	lr
34006258:	56028000 	.word	0x56028000

3400625c <LL_RCC_SetRTC_HSEPrescaler>:
  *         @arg @ref LL_RCC_RTC_HSE_DIV_62
  *         @arg @ref LL_RCC_RTC_HSE_DIV_63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRTC_HSEPrescaler(uint32_t Prescaler)
{
3400625c:	b480      	push	{r7}
3400625e:	b083      	sub	sp, #12
34006260:	af00      	add	r7, sp, #0
34006262:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
34006264:	4b07      	ldr	r3, [pc, #28]	@ (34006284 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34006266:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400626a:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3400626e:	4905      	ldr	r1, [pc, #20]	@ (34006284 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34006270:	687b      	ldr	r3, [r7, #4]
34006272:	4313      	orrs	r3, r2
34006274:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34006278:	bf00      	nop
3400627a:	370c      	adds	r7, #12
3400627c:	46bd      	mov	sp, r7
3400627e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006282:	4770      	bx	lr
34006284:	56028000 	.word	0x56028000

34006288 <LL_RCC_SetTIMPrescaler>:
  *         @arg @ref LL_RCC_TIM_PRESCALER_4
  *         @arg @ref LL_RCC_TIM_PRESCALER_8
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetTIMPrescaler(uint32_t Prescaler)
{
34006288:	b480      	push	{r7}
3400628a:	b083      	sub	sp, #12
3400628c:	af00      	add	r7, sp, #0
3400628e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
34006290:	4b07      	ldr	r3, [pc, #28]	@ (340062b0 <LL_RCC_SetTIMPrescaler+0x28>)
34006292:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006294:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34006298:	687b      	ldr	r3, [r7, #4]
3400629a:	061b      	lsls	r3, r3, #24
3400629c:	4904      	ldr	r1, [pc, #16]	@ (340062b0 <LL_RCC_SetTIMPrescaler+0x28>)
3400629e:	4313      	orrs	r3, r2
340062a0:	624b      	str	r3, [r1, #36]	@ 0x24
}
340062a2:	bf00      	nop
340062a4:	370c      	adds	r7, #12
340062a6:	46bd      	mov	sp, r7
340062a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340062ac:	4770      	bx	lr
340062ae:	bf00      	nop
340062b0:	56028000 	.word	0x56028000

340062b4 <LL_RCC_IC3_Enable>:
  * @brief  Enable IC3
  * @rmtoll DIVENSR       IC3ENS        LL_RCC_IC3_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC3_Enable(void)
{
340062b4:	b480      	push	{r7}
340062b6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
340062b8:	4b04      	ldr	r3, [pc, #16]	@ (340062cc <LL_RCC_IC3_Enable+0x18>)
340062ba:	2204      	movs	r2, #4
340062bc:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340062c0:	bf00      	nop
340062c2:	46bd      	mov	sp, r7
340062c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340062c8:	4770      	bx	lr
340062ca:	bf00      	nop
340062cc:	56028000 	.word	0x56028000

340062d0 <LL_RCC_IC4_Enable>:
  * @brief  Enable IC4
  * @rmtoll DIVENSR       IC4ENS        LL_RCC_IC4_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC4_Enable(void)
{
340062d0:	b480      	push	{r7}
340062d2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340062d4:	4b04      	ldr	r3, [pc, #16]	@ (340062e8 <LL_RCC_IC4_Enable+0x18>)
340062d6:	2208      	movs	r2, #8
340062d8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340062dc:	bf00      	nop
340062de:	46bd      	mov	sp, r7
340062e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340062e4:	4770      	bx	lr
340062e6:	bf00      	nop
340062e8:	56028000 	.word	0x56028000

340062ec <LL_RCC_IC5_Enable>:
  * @brief  Enable IC5
  * @rmtoll DIVENSR       IC5ENS        LL_RCC_IC5_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC5_Enable(void)
{
340062ec:	b480      	push	{r7}
340062ee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
340062f0:	4b04      	ldr	r3, [pc, #16]	@ (34006304 <LL_RCC_IC5_Enable+0x18>)
340062f2:	2210      	movs	r2, #16
340062f4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340062f8:	bf00      	nop
340062fa:	46bd      	mov	sp, r7
340062fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34006300:	4770      	bx	lr
34006302:	bf00      	nop
34006304:	56028000 	.word	0x56028000

34006308 <LL_RCC_IC7_Enable>:
  * @brief  Enable IC7
  * @rmtoll DIVENSR       IC7ENS        LL_RCC_IC7_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC7_Enable(void)
{
34006308:	b480      	push	{r7}
3400630a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
3400630c:	4b04      	ldr	r3, [pc, #16]	@ (34006320 <LL_RCC_IC7_Enable+0x18>)
3400630e:	2240      	movs	r2, #64	@ 0x40
34006310:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006314:	bf00      	nop
34006316:	46bd      	mov	sp, r7
34006318:	f85d 7b04 	ldr.w	r7, [sp], #4
3400631c:	4770      	bx	lr
3400631e:	bf00      	nop
34006320:	56028000 	.word	0x56028000

34006324 <LL_RCC_IC8_Enable>:
  * @brief  Enable IC8
  * @rmtoll DIVENSR       IC8ENS        LL_RCC_IC8_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC8_Enable(void)
{
34006324:	b480      	push	{r7}
34006326:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34006328:	4b04      	ldr	r3, [pc, #16]	@ (3400633c <LL_RCC_IC8_Enable+0x18>)
3400632a:	2280      	movs	r2, #128	@ 0x80
3400632c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006330:	bf00      	nop
34006332:	46bd      	mov	sp, r7
34006334:	f85d 7b04 	ldr.w	r7, [sp], #4
34006338:	4770      	bx	lr
3400633a:	bf00      	nop
3400633c:	56028000 	.word	0x56028000

34006340 <LL_RCC_IC9_Enable>:
  * @brief  Enable IC9
  * @rmtoll DIVENSR       IC9ENS        LL_RCC_IC9_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC9_Enable(void)
{
34006340:	b480      	push	{r7}
34006342:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34006344:	4b04      	ldr	r3, [pc, #16]	@ (34006358 <LL_RCC_IC9_Enable+0x18>)
34006346:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400634a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400634e:	bf00      	nop
34006350:	46bd      	mov	sp, r7
34006352:	f85d 7b04 	ldr.w	r7, [sp], #4
34006356:	4770      	bx	lr
34006358:	56028000 	.word	0x56028000

3400635c <LL_RCC_IC10_Enable>:
  * @brief  Enable IC10
  * @rmtoll DIVENSR       IC10ENS        LL_RCC_IC10_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC10_Enable(void)
{
3400635c:	b480      	push	{r7}
3400635e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34006360:	4b04      	ldr	r3, [pc, #16]	@ (34006374 <LL_RCC_IC10_Enable+0x18>)
34006362:	f44f 7200 	mov.w	r2, #512	@ 0x200
34006366:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400636a:	bf00      	nop
3400636c:	46bd      	mov	sp, r7
3400636e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006372:	4770      	bx	lr
34006374:	56028000 	.word	0x56028000

34006378 <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
34006378:	b480      	push	{r7}
3400637a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
3400637c:	4b04      	ldr	r3, [pc, #16]	@ (34006390 <LL_RCC_IC12_Enable+0x18>)
3400637e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34006382:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006386:	bf00      	nop
34006388:	46bd      	mov	sp, r7
3400638a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400638e:	4770      	bx	lr
34006390:	56028000 	.word	0x56028000

34006394 <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
34006394:	b480      	push	{r7}
34006396:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34006398:	4b04      	ldr	r3, [pc, #16]	@ (340063ac <LL_RCC_IC13_Enable+0x18>)
3400639a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400639e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340063a2:	bf00      	nop
340063a4:	46bd      	mov	sp, r7
340063a6:	f85d 7b04 	ldr.w	r7, [sp], #4
340063aa:	4770      	bx	lr
340063ac:	56028000 	.word	0x56028000

340063b0 <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
340063b0:	b480      	push	{r7}
340063b2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340063b4:	4b04      	ldr	r3, [pc, #16]	@ (340063c8 <LL_RCC_IC14_Enable+0x18>)
340063b6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
340063ba:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340063be:	bf00      	nop
340063c0:	46bd      	mov	sp, r7
340063c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340063c6:	4770      	bx	lr
340063c8:	56028000 	.word	0x56028000

340063cc <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
340063cc:	b480      	push	{r7}
340063ce:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
340063d0:	4b04      	ldr	r3, [pc, #16]	@ (340063e4 <LL_RCC_IC15_Enable+0x18>)
340063d2:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340063d6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340063da:	bf00      	nop
340063dc:	46bd      	mov	sp, r7
340063de:	f85d 7b04 	ldr.w	r7, [sp], #4
340063e2:	4770      	bx	lr
340063e4:	56028000 	.word	0x56028000

340063e8 <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
340063e8:	b480      	push	{r7}
340063ea:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
340063ec:	4b04      	ldr	r3, [pc, #16]	@ (34006400 <LL_RCC_IC16_Enable+0x18>)
340063ee:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340063f2:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340063f6:	bf00      	nop
340063f8:	46bd      	mov	sp, r7
340063fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340063fe:	4770      	bx	lr
34006400:	56028000 	.word	0x56028000

34006404 <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
34006404:	b480      	push	{r7}
34006406:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
34006408:	4b04      	ldr	r3, [pc, #16]	@ (3400641c <LL_RCC_IC17_Enable+0x18>)
3400640a:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400640e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006412:	bf00      	nop
34006414:	46bd      	mov	sp, r7
34006416:	f85d 7b04 	ldr.w	r7, [sp], #4
3400641a:	4770      	bx	lr
3400641c:	56028000 	.word	0x56028000

34006420 <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
34006420:	b480      	push	{r7}
34006422:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
34006424:	4b04      	ldr	r3, [pc, #16]	@ (34006438 <LL_RCC_IC18_Enable+0x18>)
34006426:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
3400642a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400642e:	bf00      	nop
34006430:	46bd      	mov	sp, r7
34006432:	f85d 7b04 	ldr.w	r7, [sp], #4
34006436:	4770      	bx	lr
34006438:	56028000 	.word	0x56028000

3400643c <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
3400643c:	b480      	push	{r7}
3400643e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
34006440:	4b04      	ldr	r3, [pc, #16]	@ (34006454 <LL_RCC_IC19_Enable+0x18>)
34006442:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34006446:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400644a:	bf00      	nop
3400644c:	46bd      	mov	sp, r7
3400644e:	f85d 7b04 	ldr.w	r7, [sp], #4
34006452:	4770      	bx	lr
34006454:	56028000 	.word	0x56028000

34006458 <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
34006458:	b480      	push	{r7}
3400645a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
3400645c:	4b04      	ldr	r3, [pc, #16]	@ (34006470 <LL_RCC_IC20_Enable+0x18>)
3400645e:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
34006462:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34006466:	bf00      	nop
34006468:	46bd      	mov	sp, r7
3400646a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400646e:	4770      	bx	lr
34006470:	56028000 	.word	0x56028000

34006474 <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
34006474:	b480      	push	{r7}
34006476:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34006478:	4b04      	ldr	r3, [pc, #16]	@ (3400648c <LL_RCC_CLKP_Enable+0x18>)
3400647a:	2240      	movs	r2, #64	@ 0x40
3400647c:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
34006480:	bf00      	nop
34006482:	46bd      	mov	sp, r7
34006484:	f85d 7b04 	ldr.w	r7, [sp], #4
34006488:	4770      	bx	lr
3400648a:	bf00      	nop
3400648c:	56028000 	.word	0x56028000

34006490 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34006490:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34006494:	b0f2      	sub	sp, #456	@ 0x1c8
34006496:	af00      	add	r7, sp, #0
34006498:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
3400649c:	2300      	movs	r3, #0
3400649e:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
340064a2:	2300      	movs	r3, #0
340064a4:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
340064a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064ac:	e9d3 2300 	ldrd	r2, r3, [r3]
340064b0:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
340064b4:	2500      	movs	r5, #0
340064b6:	ea54 0305 	orrs.w	r3, r4, r5
340064ba:	d06c      	beq.n	34006596 <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
340064bc:	f7ff fec0 	bl	34006240 <LL_RCC_GetRTCClockSource>
340064c0:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
340064c4:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
340064c8:	2b00      	cmp	r3, #0
340064ca:	d018      	beq.n	340064fe <HAL_RCCEx_PeriphCLKConfig+0x6e>
340064cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064d0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340064d4:	f403 7240 	and.w	r2, r3, #768	@ 0x300
340064d8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
340064dc:	4293      	cmp	r3, r2
340064de:	d00e      	beq.n	340064fe <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
340064e0:	4bc3      	ldr	r3, [pc, #780]	@ (340067f0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340064e2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340064e4:	4ac2      	ldr	r2, [pc, #776]	@ (340067f0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340064e6:	f043 0301 	orr.w	r3, r3, #1
340064ea:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
340064ec:	4bc0      	ldr	r3, [pc, #768]	@ (340067f0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340064ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340064f0:	f003 0301 	and.w	r3, r3, #1
340064f4:	2b00      	cmp	r3, #0
340064f6:	d102      	bne.n	340064fe <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
340064f8:	2301      	movs	r3, #1
340064fa:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
340064fe:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34006502:	2b00      	cmp	r3, #0
34006504:	d143      	bne.n	3400658e <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
34006506:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400650a:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400650e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34006512:	d117      	bne.n	34006544 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34006514:	f7fb fa18 	bl	34001948 <HAL_GetTick>
34006518:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
3400651c:	e00d      	b.n	3400653a <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400651e:	f7fb fa13 	bl	34001948 <HAL_GetTick>
34006522:	4602      	mov	r2, r0
34006524:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
34006528:	1ad2      	subs	r2, r2, r3
3400652a:	f241 3388 	movw	r3, #5000	@ 0x1388
3400652e:	429a      	cmp	r2, r3
34006530:	d903      	bls.n	3400653a <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
34006532:	2303      	movs	r3, #3
34006534:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
34006538:	e004      	b.n	34006544 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
3400653a:	f7ff fc8b 	bl	34005e54 <LL_RCC_LSE_IsReady>
3400653e:	4603      	mov	r3, r0
34006540:	2b00      	cmp	r3, #0
34006542:	d0ec      	beq.n	3400651e <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
34006544:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34006548:	2b00      	cmp	r3, #0
3400654a:	d11b      	bne.n	34006584 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
3400654c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006550:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34006554:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34006558:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400655c:	d108      	bne.n	34006570 <HAL_RCCEx_PeriphCLKConfig+0xe0>
3400655e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006562:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34006566:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400656a:	4618      	mov	r0, r3
3400656c:	f7ff fe76 	bl	3400625c <LL_RCC_SetRTC_HSEPrescaler>
34006570:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006574:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34006578:	f403 7340 	and.w	r3, r3, #768	@ 0x300
3400657c:	4618      	mov	r0, r3
3400657e:	f7ff fe49 	bl	34006214 <LL_RCC_SetRTCClockSource>
34006582:	e008      	b.n	34006596 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
34006584:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34006588:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
3400658c:	e003      	b.n	34006596 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3400658e:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34006592:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
34006596:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400659a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400659e:	f002 0804 	and.w	r8, r2, #4
340065a2:	f04f 0900 	mov.w	r9, #0
340065a6:	ea58 0309 	orrs.w	r3, r8, r9
340065aa:	f000 809b 	beq.w	340066e4 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
340065ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065b2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340065b6:	2b04      	cmp	r3, #4
340065b8:	d116      	bne.n	340065e8 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
340065ba:	4b8e      	ldr	r3, [pc, #568]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340065bc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
340065c0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340065c4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340065c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065cc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
340065ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340065d4:	3b01      	subs	r3, #1
340065d6:	041b      	lsls	r3, r3, #16
340065d8:	4313      	orrs	r3, r2
340065da:	4a86      	ldr	r2, [pc, #536]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340065dc:	430b      	orrs	r3, r1
340065de:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
340065e2:	f7ff fe83 	bl	340062ec <LL_RCC_IC5_Enable>
340065e6:	e076      	b.n	340066d6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
340065e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065ec:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340065f0:	2b05      	cmp	r3, #5
340065f2:	d116      	bne.n	34006622 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340065f4:	4b7f      	ldr	r3, [pc, #508]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340065f6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340065fa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340065fe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006602:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006606:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34006608:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400660c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400660e:	3b01      	subs	r3, #1
34006610:	041b      	lsls	r3, r3, #16
34006612:	4313      	orrs	r3, r2
34006614:	4a77      	ldr	r2, [pc, #476]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34006616:	430b      	orrs	r3, r1
34006618:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400661c:	f7ff fe9e 	bl	3400635c <LL_RCC_IC10_Enable>
34006620:	e059      	b.n	340066d6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
34006622:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006626:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400662a:	2b06      	cmp	r3, #6
3400662c:	d116      	bne.n	3400665c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400662e:	4b71      	ldr	r3, [pc, #452]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34006630:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34006634:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006638:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400663c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006640:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34006642:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006646:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34006648:	3b01      	subs	r3, #1
3400664a:	041b      	lsls	r3, r3, #16
3400664c:	4313      	orrs	r3, r2
3400664e:	4a69      	ldr	r2, [pc, #420]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34006650:	430b      	orrs	r3, r1
34006652:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34006656:	f7ff feb9 	bl	340063cc <LL_RCC_IC15_Enable>
3400665a:	e03c      	b.n	340066d6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
3400665c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006660:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34006664:	2b03      	cmp	r3, #3
34006666:	d118      	bne.n	3400669a <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34006668:	4b62      	ldr	r3, [pc, #392]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400666a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400666e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006672:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006676:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400667a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3400667e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006682:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34006686:	3b01      	subs	r3, #1
34006688:	041b      	lsls	r3, r3, #16
3400668a:	4313      	orrs	r3, r2
3400668c:	4a59      	ldr	r2, [pc, #356]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400668e:	430b      	orrs	r3, r1
34006690:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34006694:	f7ff fed2 	bl	3400643c <LL_RCC_IC19_Enable>
34006698:	e01d      	b.n	340066d6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3400669a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400669e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340066a2:	2b07      	cmp	r3, #7
340066a4:	d117      	bne.n	340066d6 <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
340066a6:	4b53      	ldr	r3, [pc, #332]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340066a8:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
340066ac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340066b0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340066b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066b8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
340066bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066c0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
340066c4:	3b01      	subs	r3, #1
340066c6:	041b      	lsls	r3, r3, #16
340066c8:	4313      	orrs	r3, r2
340066ca:	4a4a      	ldr	r2, [pc, #296]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340066cc:	430b      	orrs	r3, r1
340066ce:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
340066d2:	f7ff fec1 	bl	34006458 <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
340066d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066da:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340066de:	4618      	mov	r0, r3
340066e0:	f7ff fc0a 	bl	34005ef8 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
340066e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066e8:	e9d3 2300 	ldrd	r2, r3, [r3]
340066ec:	f04f 0a00 	mov.w	sl, #0
340066f0:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
340066f4:	ea5a 030b 	orrs.w	r3, sl, fp
340066f8:	d04b      	beq.n	34006792 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
340066fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066fe:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34006702:	4b3d      	ldr	r3, [pc, #244]	@ (340067f8 <HAL_RCCEx_PeriphCLKConfig+0x368>)
34006704:	429a      	cmp	r2, r3
34006706:	d116      	bne.n	34006736 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34006708:	4b3a      	ldr	r3, [pc, #232]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400670a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400670e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006712:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006716:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400671a:	699a      	ldr	r2, [r3, #24]
3400671c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006720:	69db      	ldr	r3, [r3, #28]
34006722:	3b01      	subs	r3, #1
34006724:	041b      	lsls	r3, r3, #16
34006726:	4313      	orrs	r3, r2
34006728:	4a32      	ldr	r2, [pc, #200]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400672a:	430b      	orrs	r3, r1
3400672c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34006730:	f7ff fdc0 	bl	340062b4 <LL_RCC_IC3_Enable>
34006734:	e026      	b.n	34006784 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
34006736:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400673a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400673e:	4b2f      	ldr	r3, [pc, #188]	@ (340067fc <HAL_RCCEx_PeriphCLKConfig+0x36c>)
34006740:	429a      	cmp	r2, r3
34006742:	d116      	bne.n	34006772 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006744:	4b2b      	ldr	r3, [pc, #172]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34006746:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400674a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400674e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006752:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006756:	6a1a      	ldr	r2, [r3, #32]
34006758:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400675c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400675e:	3b01      	subs	r3, #1
34006760:	041b      	lsls	r3, r3, #16
34006762:	4313      	orrs	r3, r2
34006764:	4a23      	ldr	r2, [pc, #140]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34006766:	430b      	orrs	r3, r1
34006768:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400676c:	f7ff fdb0 	bl	340062d0 <LL_RCC_IC4_Enable>
34006770:	e008      	b.n	34006784 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
34006772:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006776:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400677a:	4b21      	ldr	r3, [pc, #132]	@ (34006800 <HAL_RCCEx_PeriphCLKConfig+0x370>)
3400677c:	429a      	cmp	r2, r3
3400677e:	d101      	bne.n	34006784 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
34006780:	f7ff fe78 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
34006784:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006788:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3400678c:	4618      	mov	r0, r3
3400678e:	f7ff fd35 	bl	340061fc <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
34006792:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006796:	e9d3 2300 	ldrd	r2, r3, [r3]
3400679a:	2100      	movs	r1, #0
3400679c:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
340067a0:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
340067a4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
340067a8:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
340067ac:	4603      	mov	r3, r0
340067ae:	460a      	mov	r2, r1
340067b0:	4313      	orrs	r3, r2
340067b2:	d057      	beq.n	34006864 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
340067b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067b8:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
340067bc:	4b11      	ldr	r3, [pc, #68]	@ (34006804 <HAL_RCCEx_PeriphCLKConfig+0x374>)
340067be:	429a      	cmp	r2, r3
340067c0:	d122      	bne.n	34006808 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
340067c2:	4b0c      	ldr	r3, [pc, #48]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340067c4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340067c8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340067cc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340067d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067d4:	699a      	ldr	r2, [r3, #24]
340067d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067da:	69db      	ldr	r3, [r3, #28]
340067dc:	3b01      	subs	r3, #1
340067de:	041b      	lsls	r3, r3, #16
340067e0:	4313      	orrs	r3, r2
340067e2:	4a04      	ldr	r2, [pc, #16]	@ (340067f4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340067e4:	430b      	orrs	r3, r1
340067e6:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
340067ea:	f7ff fd63 	bl	340062b4 <LL_RCC_IC3_Enable>
340067ee:	e032      	b.n	34006856 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
340067f0:	56024800 	.word	0x56024800
340067f4:	56028000 	.word	0x56028000
340067f8:	03020014 	.word	0x03020014
340067fc:	03030014 	.word	0x03030014
34006800:	03010014 	.word	0x03010014
34006804:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
34006808:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400680c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34006810:	4bc5      	ldr	r3, [pc, #788]	@ (34006b28 <HAL_RCCEx_PeriphCLKConfig+0x698>)
34006812:	429a      	cmp	r2, r3
34006814:	d116      	bne.n	34006844 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006816:	4bc5      	ldr	r3, [pc, #788]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006818:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400681c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006820:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006824:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006828:	6a1a      	ldr	r2, [r3, #32]
3400682a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400682e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006830:	3b01      	subs	r3, #1
34006832:	041b      	lsls	r3, r3, #16
34006834:	4313      	orrs	r3, r2
34006836:	4abd      	ldr	r2, [pc, #756]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006838:	430b      	orrs	r3, r1
3400683a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400683e:	f7ff fd47 	bl	340062d0 <LL_RCC_IC4_Enable>
34006842:	e008      	b.n	34006856 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
34006844:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006848:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
3400684c:	4bb8      	ldr	r3, [pc, #736]	@ (34006b30 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
3400684e:	429a      	cmp	r2, r3
34006850:	d101      	bne.n	34006856 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
34006852:	f7ff fe0f 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
34006856:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400685a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400685e:	4618      	mov	r0, r3
34006860:	f7ff fccc 	bl	340061fc <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
34006864:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006868:	e9d3 2300 	ldrd	r2, r3, [r3]
3400686c:	2100      	movs	r1, #0
3400686e:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
34006872:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34006876:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
3400687a:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
3400687e:	4603      	mov	r3, r0
34006880:	460a      	mov	r2, r1
34006882:	4313      	orrs	r3, r2
34006884:	d04b      	beq.n	3400691e <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
34006886:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400688a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400688e:	4ba9      	ldr	r3, [pc, #676]	@ (34006b34 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34006890:	429a      	cmp	r2, r3
34006892:	d116      	bne.n	340068c2 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34006894:	4ba5      	ldr	r3, [pc, #660]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006896:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400689a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400689e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340068a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068a6:	699a      	ldr	r2, [r3, #24]
340068a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068ac:	69db      	ldr	r3, [r3, #28]
340068ae:	3b01      	subs	r3, #1
340068b0:	041b      	lsls	r3, r3, #16
340068b2:	4313      	orrs	r3, r2
340068b4:	4a9d      	ldr	r2, [pc, #628]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340068b6:	430b      	orrs	r3, r1
340068b8:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
340068bc:	f7ff fcfa 	bl	340062b4 <LL_RCC_IC3_Enable>
340068c0:	e026      	b.n	34006910 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
340068c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068c6:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
340068ca:	4b9b      	ldr	r3, [pc, #620]	@ (34006b38 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
340068cc:	429a      	cmp	r2, r3
340068ce:	d116      	bne.n	340068fe <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340068d0:	4b96      	ldr	r3, [pc, #600]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340068d2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340068d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340068da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340068de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068e2:	6a1a      	ldr	r2, [r3, #32]
340068e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340068ea:	3b01      	subs	r3, #1
340068ec:	041b      	lsls	r3, r3, #16
340068ee:	4313      	orrs	r3, r2
340068f0:	4a8e      	ldr	r2, [pc, #568]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340068f2:	430b      	orrs	r3, r1
340068f4:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
340068f8:	f7ff fcea 	bl	340062d0 <LL_RCC_IC4_Enable>
340068fc:	e008      	b.n	34006910 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
340068fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006902:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34006906:	4b8d      	ldr	r3, [pc, #564]	@ (34006b3c <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
34006908:	429a      	cmp	r2, r3
3400690a:	d101      	bne.n	34006910 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
3400690c:	f7ff fdb2 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
34006910:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006914:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34006918:	4618      	mov	r0, r3
3400691a:	f7ff fc6f 	bl	340061fc <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
3400691e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006922:	e9d3 2300 	ldrd	r2, r3, [r3]
34006926:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3400692a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
3400692e:	2300      	movs	r3, #0
34006930:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
34006934:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
34006938:	4603      	mov	r3, r0
3400693a:	460a      	mov	r2, r1
3400693c:	4313      	orrs	r3, r2
3400693e:	d048      	beq.n	340069d2 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
34006940:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006944:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34006948:	2b20      	cmp	r3, #32
3400694a:	d116      	bne.n	3400697a <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400694c:	4b77      	ldr	r3, [pc, #476]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400694e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34006952:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006956:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400695a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400695e:	699a      	ldr	r2, [r3, #24]
34006960:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006964:	69db      	ldr	r3, [r3, #28]
34006966:	3b01      	subs	r3, #1
34006968:	041b      	lsls	r3, r3, #16
3400696a:	4313      	orrs	r3, r2
3400696c:	4a6f      	ldr	r2, [pc, #444]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400696e:	430b      	orrs	r3, r1
34006970:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34006974:	f7ff fc9e 	bl	340062b4 <LL_RCC_IC3_Enable>
34006978:	e024      	b.n	340069c4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
3400697a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400697e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34006982:	2b30      	cmp	r3, #48	@ 0x30
34006984:	d116      	bne.n	340069b4 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006986:	4b69      	ldr	r3, [pc, #420]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006988:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400698c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006990:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006994:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006998:	6a1a      	ldr	r2, [r3, #32]
3400699a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400699e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340069a0:	3b01      	subs	r3, #1
340069a2:	041b      	lsls	r3, r3, #16
340069a4:	4313      	orrs	r3, r2
340069a6:	4a61      	ldr	r2, [pc, #388]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340069a8:	430b      	orrs	r3, r1
340069aa:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
340069ae:	f7ff fc8f 	bl	340062d0 <LL_RCC_IC4_Enable>
340069b2:	e007      	b.n	340069c4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
340069b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069b8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340069bc:	2b10      	cmp	r3, #16
340069be:	d101      	bne.n	340069c4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
340069c0:	f7ff fd58 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
340069c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069c8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340069cc:	4618      	mov	r0, r3
340069ce:	f7ff fb2d 	bl	3400602c <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
340069d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069d6:	e9d3 2300 	ldrd	r2, r3, [r3]
340069da:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
340069de:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
340069e2:	2300      	movs	r3, #0
340069e4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
340069e8:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
340069ec:	4603      	mov	r3, r0
340069ee:	460a      	mov	r2, r1
340069f0:	4313      	orrs	r3, r2
340069f2:	d04b      	beq.n	34006a8c <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
340069f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069f8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340069fc:	4b50      	ldr	r3, [pc, #320]	@ (34006b40 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
340069fe:	429a      	cmp	r2, r3
34006a00:	d116      	bne.n	34006a30 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006a02:	4b4a      	ldr	r3, [pc, #296]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006a04:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34006a08:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006a0c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006a10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a14:	6a1a      	ldr	r2, [r3, #32]
34006a16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006a1c:	3b01      	subs	r3, #1
34006a1e:	041b      	lsls	r3, r3, #16
34006a20:	4313      	orrs	r3, r2
34006a22:	4a42      	ldr	r2, [pc, #264]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006a24:	430b      	orrs	r3, r1
34006a26:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34006a2a:	f7ff fc51 	bl	340062d0 <LL_RCC_IC4_Enable>
34006a2e:	e026      	b.n	34006a7e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
34006a30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a34:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34006a38:	4b42      	ldr	r3, [pc, #264]	@ (34006b44 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
34006a3a:	429a      	cmp	r2, r3
34006a3c:	d116      	bne.n	34006a6c <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34006a3e:	4b3b      	ldr	r3, [pc, #236]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006a40:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34006a44:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006a48:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006a4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a50:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34006a52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34006a58:	3b01      	subs	r3, #1
34006a5a:	041b      	lsls	r3, r3, #16
34006a5c:	4313      	orrs	r3, r2
34006a5e:	4a33      	ldr	r2, [pc, #204]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006a60:	430b      	orrs	r3, r1
34006a62:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34006a66:	f7ff fc41 	bl	340062ec <LL_RCC_IC5_Enable>
34006a6a:	e008      	b.n	34006a7e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
34006a6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a70:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34006a74:	4b34      	ldr	r3, [pc, #208]	@ (34006b48 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
34006a76:	429a      	cmp	r2, r3
34006a78:	d101      	bne.n	34006a7e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
34006a7a:	f7ff fcfb 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
34006a7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a82:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
34006a86:	4618      	mov	r0, r3
34006a88:	f7ff fb81 	bl	3400618e <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34006a8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a90:	e9d3 2300 	ldrd	r2, r3, [r3]
34006a94:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
34006a98:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34006a9c:	2300      	movs	r3, #0
34006a9e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34006aa2:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
34006aa6:	4603      	mov	r3, r0
34006aa8:	460a      	mov	r2, r1
34006aaa:	4313      	orrs	r3, r2
34006aac:	d062      	beq.n	34006b74 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34006aae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ab2:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34006ab6:	4b25      	ldr	r3, [pc, #148]	@ (34006b4c <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
34006ab8:	429a      	cmp	r2, r3
34006aba:	d116      	bne.n	34006aea <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34006abc:	4b1b      	ldr	r3, [pc, #108]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006abe:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34006ac2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006ac6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006aca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ace:	6a1a      	ldr	r2, [r3, #32]
34006ad0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ad4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006ad6:	3b01      	subs	r3, #1
34006ad8:	041b      	lsls	r3, r3, #16
34006ada:	4313      	orrs	r3, r2
34006adc:	4a13      	ldr	r2, [pc, #76]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006ade:	430b      	orrs	r3, r1
34006ae0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34006ae4:	f7ff fbf4 	bl	340062d0 <LL_RCC_IC4_Enable>
34006ae8:	e03d      	b.n	34006b66 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
34006aea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006aee:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34006af2:	4b17      	ldr	r3, [pc, #92]	@ (34006b50 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34006af4:	429a      	cmp	r2, r3
34006af6:	d12d      	bne.n	34006b54 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34006af8:	4b0c      	ldr	r3, [pc, #48]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006afa:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34006afe:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006b02:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006b06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b0a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34006b0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34006b12:	3b01      	subs	r3, #1
34006b14:	041b      	lsls	r3, r3, #16
34006b16:	4313      	orrs	r3, r2
34006b18:	4a04      	ldr	r2, [pc, #16]	@ (34006b2c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34006b1a:	430b      	orrs	r3, r1
34006b1c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34006b20:	f7ff fbe4 	bl	340062ec <LL_RCC_IC5_Enable>
34006b24:	e01f      	b.n	34006b66 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
34006b26:	bf00      	nop
34006b28:	03030414 	.word	0x03030414
34006b2c:	56028000 	.word	0x56028000
34006b30:	03010414 	.word	0x03010414
34006b34:	03020814 	.word	0x03020814
34006b38:	03030814 	.word	0x03030814
34006b3c:	03010814 	.word	0x03010814
34006b40:	0302001c 	.word	0x0302001c
34006b44:	0303001c 	.word	0x0303001c
34006b48:	0301001c 	.word	0x0301001c
34006b4c:	0302041c 	.word	0x0302041c
34006b50:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34006b54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b58:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34006b5c:	4bb3      	ldr	r3, [pc, #716]	@ (34006e2c <HAL_RCCEx_PeriphCLKConfig+0x99c>)
34006b5e:	429a      	cmp	r2, r3
34006b60:	d101      	bne.n	34006b66 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
34006b62:	f7ff fc87 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
34006b66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b6a:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
34006b6e:	4618      	mov	r0, r3
34006b70:	f7ff fb0d 	bl	3400618e <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
34006b74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b78:	e9d3 2300 	ldrd	r2, r3, [r3]
34006b7c:	f002 0301 	and.w	r3, r2, #1
34006b80:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
34006b84:	2300      	movs	r3, #0
34006b86:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
34006b8a:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34006b8e:	4603      	mov	r3, r0
34006b90:	460a      	mov	r2, r1
34006b92:	4313      	orrs	r3, r2
34006b94:	d057      	beq.n	34006c46 <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
34006b96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b9a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34006b9e:	2b20      	cmp	r3, #32
34006ba0:	d116      	bne.n	34006bd0 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006ba2:	4ba3      	ldr	r3, [pc, #652]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006ba4:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006ba8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006bac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006bb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bb4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34006bb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bba:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006bbc:	3b01      	subs	r3, #1
34006bbe:	041b      	lsls	r3, r3, #16
34006bc0:	4313      	orrs	r3, r2
34006bc2:	4a9b      	ldr	r2, [pc, #620]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006bc4:	430b      	orrs	r3, r1
34006bc6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34006bca:	f7ff fb9d 	bl	34006308 <LL_RCC_IC7_Enable>
34006bce:	e024      	b.n	34006c1a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34006bd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bd4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34006bd8:	2b30      	cmp	r3, #48	@ 0x30
34006bda:	d116      	bne.n	34006c0a <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006bdc:	4b94      	ldr	r3, [pc, #592]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006bde:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006be2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006be6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006bea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bee:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34006bf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bf4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006bf6:	3b01      	subs	r3, #1
34006bf8:	041b      	lsls	r3, r3, #16
34006bfa:	4313      	orrs	r3, r2
34006bfc:	4a8c      	ldr	r2, [pc, #560]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006bfe:	430b      	orrs	r3, r1
34006c00:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34006c04:	f7ff fb8e 	bl	34006324 <LL_RCC_IC8_Enable>
34006c08:	e007      	b.n	34006c1a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
34006c0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c0e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34006c12:	2b10      	cmp	r3, #16
34006c14:	d101      	bne.n	34006c1a <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
34006c16:	f7ff fc2d 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
34006c1a:	4b85      	ldr	r3, [pc, #532]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006c1c:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34006c20:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34006c24:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
34006c28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c2c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
34006c30:	3b01      	subs	r3, #1
34006c32:	021a      	lsls	r2, r3, #8
34006c34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c38:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34006c3c:	4313      	orrs	r3, r2
34006c3e:	4a7c      	ldr	r2, [pc, #496]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006c40:	430b      	orrs	r3, r1
34006c42:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34006c46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c4a:	e9d3 2300 	ldrd	r2, r3, [r3]
34006c4e:	f002 0302 	and.w	r3, r2, #2
34006c52:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
34006c56:	2300      	movs	r3, #0
34006c58:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
34006c5c:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34006c60:	4603      	mov	r3, r0
34006c62:	460a      	mov	r2, r1
34006c64:	4313      	orrs	r3, r2
34006c66:	d048      	beq.n	34006cfa <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34006c68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c6c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006c70:	2b02      	cmp	r3, #2
34006c72:	d116      	bne.n	34006ca2 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006c74:	4b6e      	ldr	r3, [pc, #440]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006c76:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006c7a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006c7e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006c82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c86:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34006c88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c8c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006c8e:	3b01      	subs	r3, #1
34006c90:	041b      	lsls	r3, r3, #16
34006c92:	4313      	orrs	r3, r2
34006c94:	4a66      	ldr	r2, [pc, #408]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006c96:	430b      	orrs	r3, r1
34006c98:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34006c9c:	f7ff fb34 	bl	34006308 <LL_RCC_IC7_Enable>
34006ca0:	e024      	b.n	34006cec <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34006ca2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ca6:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006caa:	2b03      	cmp	r3, #3
34006cac:	d116      	bne.n	34006cdc <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006cae:	4b60      	ldr	r3, [pc, #384]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006cb0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006cb4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006cb8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006cbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cc0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34006cc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cc6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006cc8:	3b01      	subs	r3, #1
34006cca:	041b      	lsls	r3, r3, #16
34006ccc:	4313      	orrs	r3, r2
34006cce:	4a58      	ldr	r2, [pc, #352]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006cd0:	430b      	orrs	r3, r1
34006cd2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34006cd6:	f7ff fb25 	bl	34006324 <LL_RCC_IC8_Enable>
34006cda:	e007      	b.n	34006cec <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
34006cdc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ce0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006ce4:	2b01      	cmp	r3, #1
34006ce6:	d101      	bne.n	34006cec <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
34006ce8:	f7ff fbc4 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
34006cec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cf0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006cf4:	4618      	mov	r0, r3
34006cf6:	f7ff f8e9 	bl	34005ecc <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
34006cfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cfe:	e9d3 2300 	ldrd	r2, r3, [r3]
34006d02:	f002 0308 	and.w	r3, r2, #8
34006d06:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
34006d0a:	2300      	movs	r3, #0
34006d0c:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34006d10:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34006d14:	4603      	mov	r3, r0
34006d16:	460a      	mov	r2, r1
34006d18:	4313      	orrs	r3, r2
34006d1a:	d017      	beq.n	34006d4c <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34006d1c:	4b44      	ldr	r3, [pc, #272]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006d1e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34006d22:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006d26:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006d2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d2e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34006d32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d36:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34006d3a:	3b01      	subs	r3, #1
34006d3c:	041b      	lsls	r3, r3, #16
34006d3e:	4313      	orrs	r3, r2
34006d40:	4a3b      	ldr	r2, [pc, #236]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006d42:	430b      	orrs	r3, r1
34006d44:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34006d48:	f7ff fb6a 	bl	34006420 <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
34006d4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d50:	e9d3 2300 	ldrd	r2, r3, [r3]
34006d54:	f002 0310 	and.w	r3, r2, #16
34006d58:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
34006d5c:	2300      	movs	r3, #0
34006d5e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
34006d62:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
34006d66:	4603      	mov	r3, r0
34006d68:	460a      	mov	r2, r1
34006d6a:	4313      	orrs	r3, r2
34006d6c:	d02f      	beq.n	34006dce <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
34006d6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d72:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34006d76:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34006d7a:	d118      	bne.n	34006dae <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
34006d7c:	4b2c      	ldr	r3, [pc, #176]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006d7e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34006d82:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006d86:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006d8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d8e:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34006d92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d96:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34006d9a:	3b01      	subs	r3, #1
34006d9c:	041b      	lsls	r3, r3, #16
34006d9e:	4313      	orrs	r3, r2
34006da0:	4a23      	ldr	r2, [pc, #140]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006da2:	430b      	orrs	r3, r1
34006da4:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34006da8:	f7ff fb2c 	bl	34006404 <LL_RCC_IC17_Enable>
34006dac:	e008      	b.n	34006dc0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
34006dae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006db2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34006db6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34006dba:	d101      	bne.n	34006dc0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
34006dbc:	f7ff fb5a 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
34006dc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dc4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34006dc8:	4618      	mov	r0, r3
34006dca:	f7ff f8ab 	bl	34005f24 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
34006dce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dd2:	e9d3 2300 	ldrd	r2, r3, [r3]
34006dd6:	f002 0320 	and.w	r3, r2, #32
34006dda:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
34006dde:	2300      	movs	r3, #0
34006de0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34006de4:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
34006de8:	4603      	mov	r3, r0
34006dea:	460a      	mov	r2, r1
34006dec:	4313      	orrs	r3, r2
34006dee:	d031      	beq.n	34006e54 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
34006df0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006df4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34006df8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34006dfc:	d11a      	bne.n	34006e34 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
34006dfe:	4b0c      	ldr	r3, [pc, #48]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006e00:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34006e04:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006e08:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006e0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e10:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34006e12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e16:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34006e18:	3b01      	subs	r3, #1
34006e1a:	041b      	lsls	r3, r3, #16
34006e1c:	4313      	orrs	r3, r2
34006e1e:	4a04      	ldr	r2, [pc, #16]	@ (34006e30 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34006e20:	430b      	orrs	r3, r1
34006e22:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34006e26:	f7ff faa7 	bl	34006378 <LL_RCC_IC12_Enable>
34006e2a:	e00c      	b.n	34006e46 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
34006e2c:	0301041c 	.word	0x0301041c
34006e30:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34006e34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e38:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34006e3c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34006e40:	d101      	bne.n	34006e46 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
34006e42:	f7ff fb17 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34006e46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e4a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34006e4e:	4618      	mov	r0, r3
34006e50:	f7ff f87e 	bl	34005f50 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34006e54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e58:	e9d3 2300 	ldrd	r2, r3, [r3]
34006e5c:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34006e60:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34006e64:	2300      	movs	r3, #0
34006e66:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
34006e6a:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
34006e6e:	4603      	mov	r3, r0
34006e70:	460a      	mov	r2, r1
34006e72:	4313      	orrs	r3, r2
34006e74:	d006      	beq.n	34006e84 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34006e76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e7a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34006e7e:	4618      	mov	r0, r3
34006e80:	f7ff f87c 	bl	34005f7c <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34006e84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e88:	e9d3 2300 	ldrd	r2, r3, [r3]
34006e8c:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34006e90:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34006e94:	2300      	movs	r3, #0
34006e96:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34006e9a:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
34006e9e:	4603      	mov	r3, r0
34006ea0:	460a      	mov	r2, r1
34006ea2:	4313      	orrs	r3, r2
34006ea4:	d006      	beq.n	34006eb4 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34006ea6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006eaa:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34006eae:	4618      	mov	r0, r3
34006eb0:	f7ff f87a 	bl	34005fa8 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34006eb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006eb8:	e9d3 2300 	ldrd	r2, r3, [r3]
34006ebc:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34006ec0:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34006ec4:	2300      	movs	r3, #0
34006ec6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34006eca:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
34006ece:	4603      	mov	r3, r0
34006ed0:	460a      	mov	r2, r1
34006ed2:	4313      	orrs	r3, r2
34006ed4:	d006      	beq.n	34006ee4 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
34006ed6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006eda:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34006ede:	4618      	mov	r0, r3
34006ee0:	f7ff f878 	bl	34005fd4 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34006ee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ee8:	e9d3 2300 	ldrd	r2, r3, [r3]
34006eec:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34006ef0:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34006ef4:	2300      	movs	r3, #0
34006ef6:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34006efa:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
34006efe:	4603      	mov	r3, r0
34006f00:	460a      	mov	r2, r1
34006f02:	4313      	orrs	r3, r2
34006f04:	d038      	beq.n	34006f78 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
34006f06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f0a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006f0e:	2b02      	cmp	r3, #2
34006f10:	d116      	bne.n	34006f40 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34006f12:	4bbc      	ldr	r3, [pc, #752]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006f14:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34006f18:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006f1c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006f20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f24:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34006f26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f2a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34006f2c:	3b01      	subs	r3, #1
34006f2e:	041b      	lsls	r3, r3, #16
34006f30:	4313      	orrs	r3, r2
34006f32:	4ab4      	ldr	r2, [pc, #720]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006f34:	430b      	orrs	r3, r1
34006f36:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
34006f3a:	f7ff fa2b 	bl	34006394 <LL_RCC_IC13_Enable>
34006f3e:	e007      	b.n	34006f50 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34006f40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f44:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006f48:	2b01      	cmp	r3, #1
34006f4a:	d101      	bne.n	34006f50 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
34006f4c:	f7ff fa92 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34006f50:	4bac      	ldr	r3, [pc, #688]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006f52:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34006f56:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
34006f5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f5e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006f62:	3b01      	subs	r3, #1
34006f64:	011a      	lsls	r2, r3, #4
34006f66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f6a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006f6e:	4313      	orrs	r3, r2
34006f70:	4aa4      	ldr	r2, [pc, #656]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006f72:	430b      	orrs	r3, r1
34006f74:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34006f78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f7c:	e9d3 2300 	ldrd	r2, r3, [r3]
34006f80:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34006f84:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34006f88:	2300      	movs	r3, #0
34006f8a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34006f8e:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34006f92:	4603      	mov	r3, r0
34006f94:	460a      	mov	r2, r1
34006f96:	4313      	orrs	r3, r2
34006f98:	d02d      	beq.n	34006ff6 <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
34006f9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f9e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006fa2:	2b02      	cmp	r3, #2
34006fa4:	d118      	bne.n	34006fd8 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34006fa6:	4b97      	ldr	r3, [pc, #604]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006fa8:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34006fac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006fb0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006fb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fb8:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34006fbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fc0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34006fc4:	3b01      	subs	r3, #1
34006fc6:	041b      	lsls	r3, r3, #16
34006fc8:	4313      	orrs	r3, r2
34006fca:	4a8e      	ldr	r2, [pc, #568]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34006fcc:	430b      	orrs	r3, r1
34006fce:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34006fd2:	f7ff fa33 	bl	3400643c <LL_RCC_IC19_Enable>
34006fd6:	e007      	b.n	34006fe8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
34006fd8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fdc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006fe0:	2b01      	cmp	r3, #1
34006fe2:	d101      	bne.n	34006fe8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
34006fe4:	f7ff fa46 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
34006fe8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fec:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006ff0:	4618      	mov	r0, r3
34006ff2:	f7ff f805 	bl	34006000 <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
34006ff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ffa:	e9d3 2300 	ldrd	r2, r3, [r3]
34006ffe:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34007002:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
34007006:	2300      	movs	r3, #0
34007008:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
3400700c:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34007010:	4603      	mov	r3, r0
34007012:	460a      	mov	r2, r1
34007014:	4313      	orrs	r3, r2
34007016:	d04b      	beq.n	340070b0 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34007018:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400701c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34007020:	4b79      	ldr	r3, [pc, #484]	@ (34007208 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34007022:	429a      	cmp	r2, r3
34007024:	d116      	bne.n	34007054 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34007026:	4b77      	ldr	r3, [pc, #476]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34007028:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400702c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007030:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007034:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007038:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400703a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400703e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34007040:	3b01      	subs	r3, #1
34007042:	041b      	lsls	r3, r3, #16
34007044:	4313      	orrs	r3, r2
34007046:	4a6f      	ldr	r2, [pc, #444]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34007048:	430b      	orrs	r3, r1
3400704a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400704e:	f7ff f985 	bl	3400635c <LL_RCC_IC10_Enable>
34007052:	e026      	b.n	340070a2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
34007054:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007058:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400705c:	4b6b      	ldr	r3, [pc, #428]	@ (3400720c <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
3400705e:	429a      	cmp	r2, r3
34007060:	d116      	bne.n	34007090 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007062:	4b68      	ldr	r3, [pc, #416]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34007064:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007068:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400706c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007070:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007074:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34007076:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400707a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400707c:	3b01      	subs	r3, #1
3400707e:	041b      	lsls	r3, r3, #16
34007080:	4313      	orrs	r3, r2
34007082:	4a60      	ldr	r2, [pc, #384]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34007084:	430b      	orrs	r3, r1
34007086:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400708a:	f7ff f99f 	bl	340063cc <LL_RCC_IC15_Enable>
3400708e:	e008      	b.n	340070a2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34007090:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007094:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34007098:	4b5d      	ldr	r3, [pc, #372]	@ (34007210 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
3400709a:	429a      	cmp	r2, r3
3400709c:	d101      	bne.n	340070a2 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
3400709e:	f7ff f9e9 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
340070a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070a6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340070aa:	4618      	mov	r0, r3
340070ac:	f7fe ffd4 	bl	34006058 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
340070b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070b4:	e9d3 2300 	ldrd	r2, r3, [r3]
340070b8:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
340070bc:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
340070c0:	2300      	movs	r3, #0
340070c2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
340070c6:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
340070ca:	4603      	mov	r3, r0
340070cc:	460a      	mov	r2, r1
340070ce:	4313      	orrs	r3, r2
340070d0:	d04b      	beq.n	3400716a <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
340070d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070d6:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
340070da:	4b4e      	ldr	r3, [pc, #312]	@ (34007214 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
340070dc:	429a      	cmp	r2, r3
340070de:	d116      	bne.n	3400710e <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340070e0:	4b48      	ldr	r3, [pc, #288]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340070e2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340070e6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340070ea:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340070ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070f2:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340070f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070f8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340070fa:	3b01      	subs	r3, #1
340070fc:	041b      	lsls	r3, r3, #16
340070fe:	4313      	orrs	r3, r2
34007100:	4a40      	ldr	r2, [pc, #256]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34007102:	430b      	orrs	r3, r1
34007104:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34007108:	f7ff f928 	bl	3400635c <LL_RCC_IC10_Enable>
3400710c:	e026      	b.n	3400715c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400710e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007112:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34007116:	4b40      	ldr	r3, [pc, #256]	@ (34007218 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
34007118:	429a      	cmp	r2, r3
3400711a:	d116      	bne.n	3400714a <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400711c:	4b39      	ldr	r3, [pc, #228]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400711e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007122:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007126:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400712a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400712e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34007130:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007134:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34007136:	3b01      	subs	r3, #1
34007138:	041b      	lsls	r3, r3, #16
3400713a:	4313      	orrs	r3, r2
3400713c:	4a31      	ldr	r2, [pc, #196]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400713e:	430b      	orrs	r3, r1
34007140:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007144:	f7ff f942 	bl	340063cc <LL_RCC_IC15_Enable>
34007148:	e008      	b.n	3400715c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3400714a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400714e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34007152:	4b32      	ldr	r3, [pc, #200]	@ (3400721c <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
34007154:	429a      	cmp	r2, r3
34007156:	d101      	bne.n	3400715c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34007158:	f7ff f98c 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3400715c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007160:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34007164:	4618      	mov	r0, r3
34007166:	f7fe ff77 	bl	34006058 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3400716a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400716e:	e9d3 2300 	ldrd	r2, r3, [r3]
34007172:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34007176:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3400717a:	2300      	movs	r3, #0
3400717c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34007180:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34007184:	4603      	mov	r3, r0
34007186:	460a      	mov	r2, r1
34007188:	4313      	orrs	r3, r2
3400718a:	d05d      	beq.n	34007248 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3400718c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007190:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34007194:	4b22      	ldr	r3, [pc, #136]	@ (34007220 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34007196:	429a      	cmp	r2, r3
34007198:	d116      	bne.n	340071c8 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400719a:	4b1a      	ldr	r3, [pc, #104]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400719c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340071a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340071a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340071a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071ac:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340071ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071b2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340071b4:	3b01      	subs	r3, #1
340071b6:	041b      	lsls	r3, r3, #16
340071b8:	4313      	orrs	r3, r2
340071ba:	4a12      	ldr	r2, [pc, #72]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340071bc:	430b      	orrs	r3, r1
340071be:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340071c2:	f7ff f8cb 	bl	3400635c <LL_RCC_IC10_Enable>
340071c6:	e038      	b.n	3400723a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
340071c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071cc:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
340071d0:	4b14      	ldr	r3, [pc, #80]	@ (34007224 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
340071d2:	429a      	cmp	r2, r3
340071d4:	d128      	bne.n	34007228 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340071d6:	4b0b      	ldr	r3, [pc, #44]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340071d8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340071dc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340071e0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340071e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071e8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340071ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071ee:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340071f0:	3b01      	subs	r3, #1
340071f2:	041b      	lsls	r3, r3, #16
340071f4:	4313      	orrs	r3, r2
340071f6:	4a03      	ldr	r2, [pc, #12]	@ (34007204 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340071f8:	430b      	orrs	r3, r1
340071fa:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340071fe:	f7ff f8e5 	bl	340063cc <LL_RCC_IC15_Enable>
34007202:	e01a      	b.n	3400723a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
34007204:	56028000 	.word	0x56028000
34007208:	0702000c 	.word	0x0702000c
3400720c:	0703000c 	.word	0x0703000c
34007210:	0701000c 	.word	0x0701000c
34007214:	0702040c 	.word	0x0702040c
34007218:	0703040c 	.word	0x0703040c
3400721c:	0701040c 	.word	0x0701040c
34007220:	0702080c 	.word	0x0702080c
34007224:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34007228:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400722c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34007230:	4bc8      	ldr	r3, [pc, #800]	@ (34007554 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
34007232:	429a      	cmp	r2, r3
34007234:	d101      	bne.n	3400723a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
34007236:	f7ff f91d 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
3400723a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400723e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34007242:	4618      	mov	r0, r3
34007244:	f7fe ff08 	bl	34006058 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34007248:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400724c:	e9d3 2300 	ldrd	r2, r3, [r3]
34007250:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34007254:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34007258:	2300      	movs	r3, #0
3400725a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
3400725e:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
34007262:	4603      	mov	r3, r0
34007264:	460a      	mov	r2, r1
34007266:	4313      	orrs	r3, r2
34007268:	d04b      	beq.n	34007302 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3400726a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400726e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34007272:	4bb9      	ldr	r3, [pc, #740]	@ (34007558 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
34007274:	429a      	cmp	r2, r3
34007276:	d116      	bne.n	340072a6 <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34007278:	4bb8      	ldr	r3, [pc, #736]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400727a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400727e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007282:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007286:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400728a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400728c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007290:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34007292:	3b01      	subs	r3, #1
34007294:	041b      	lsls	r3, r3, #16
34007296:	4313      	orrs	r3, r2
34007298:	4ab0      	ldr	r2, [pc, #704]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400729a:	430b      	orrs	r3, r1
3400729c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340072a0:	f7ff f85c 	bl	3400635c <LL_RCC_IC10_Enable>
340072a4:	e026      	b.n	340072f4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
340072a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072aa:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340072ae:	4bac      	ldr	r3, [pc, #688]	@ (34007560 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
340072b0:	429a      	cmp	r2, r3
340072b2:	d116      	bne.n	340072e2 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340072b4:	4ba9      	ldr	r3, [pc, #676]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340072b6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340072ba:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340072be:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340072c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072c6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340072c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072cc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340072ce:	3b01      	subs	r3, #1
340072d0:	041b      	lsls	r3, r3, #16
340072d2:	4313      	orrs	r3, r2
340072d4:	4aa1      	ldr	r2, [pc, #644]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340072d6:	430b      	orrs	r3, r1
340072d8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340072dc:	f7ff f876 	bl	340063cc <LL_RCC_IC15_Enable>
340072e0:	e008      	b.n	340072f4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
340072e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072e6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340072ea:	4b9e      	ldr	r3, [pc, #632]	@ (34007564 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
340072ec:	429a      	cmp	r2, r3
340072ee:	d101      	bne.n	340072f4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
340072f0:	f7ff f8c0 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
340072f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072f8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
340072fc:	4618      	mov	r0, r3
340072fe:	f7fe feab 	bl	34006058 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
34007302:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007306:	e9d3 2300 	ldrd	r2, r3, [r3]
3400730a:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3400730e:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
34007312:	2300      	movs	r3, #0
34007314:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34007318:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
3400731c:	4603      	mov	r3, r0
3400731e:	460a      	mov	r2, r1
34007320:	4313      	orrs	r3, r2
34007322:	d04b      	beq.n	340073bc <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34007324:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007328:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3400732c:	4b8e      	ldr	r3, [pc, #568]	@ (34007568 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
3400732e:	429a      	cmp	r2, r3
34007330:	d116      	bne.n	34007360 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34007332:	4b8a      	ldr	r3, [pc, #552]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007334:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34007338:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400733c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007340:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007344:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34007346:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400734a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400734c:	3b01      	subs	r3, #1
3400734e:	041b      	lsls	r3, r3, #16
34007350:	4313      	orrs	r3, r2
34007352:	4a82      	ldr	r2, [pc, #520]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007354:	430b      	orrs	r3, r1
34007356:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400735a:	f7fe ffff 	bl	3400635c <LL_RCC_IC10_Enable>
3400735e:	e026      	b.n	340073ae <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34007360:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007364:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34007368:	4b80      	ldr	r3, [pc, #512]	@ (3400756c <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
3400736a:	429a      	cmp	r2, r3
3400736c:	d116      	bne.n	3400739c <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400736e:	4b7b      	ldr	r3, [pc, #492]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007370:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007374:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007378:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400737c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007380:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34007382:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007386:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34007388:	3b01      	subs	r3, #1
3400738a:	041b      	lsls	r3, r3, #16
3400738c:	4313      	orrs	r3, r2
3400738e:	4a73      	ldr	r2, [pc, #460]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007390:	430b      	orrs	r3, r1
34007392:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007396:	f7ff f819 	bl	340063cc <LL_RCC_IC15_Enable>
3400739a:	e008      	b.n	340073ae <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3400739c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073a0:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
340073a4:	4b72      	ldr	r3, [pc, #456]	@ (34007570 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
340073a6:	429a      	cmp	r2, r3
340073a8:	d101      	bne.n	340073ae <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
340073aa:	f7ff f863 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
340073ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073b2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340073b6:	4618      	mov	r0, r3
340073b8:	f7fe fe59 	bl	3400606e <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
340073bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073c0:	e9d3 2300 	ldrd	r2, r3, [r3]
340073c4:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
340073c8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
340073cc:	2300      	movs	r3, #0
340073ce:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
340073d2:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
340073d6:	4603      	mov	r3, r0
340073d8:	460a      	mov	r2, r1
340073da:	4313      	orrs	r3, r2
340073dc:	d04b      	beq.n	34007476 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
340073de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073e2:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
340073e6:	4b63      	ldr	r3, [pc, #396]	@ (34007574 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
340073e8:	429a      	cmp	r2, r3
340073ea:	d116      	bne.n	3400741a <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340073ec:	4b5b      	ldr	r3, [pc, #364]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340073ee:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340073f2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340073f6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340073fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073fe:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34007400:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007404:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34007406:	3b01      	subs	r3, #1
34007408:	041b      	lsls	r3, r3, #16
3400740a:	4313      	orrs	r3, r2
3400740c:	4a53      	ldr	r2, [pc, #332]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400740e:	430b      	orrs	r3, r1
34007410:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34007414:	f7fe ffa2 	bl	3400635c <LL_RCC_IC10_Enable>
34007418:	e026      	b.n	34007468 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
3400741a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400741e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34007422:	4b55      	ldr	r3, [pc, #340]	@ (34007578 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
34007424:	429a      	cmp	r2, r3
34007426:	d116      	bne.n	34007456 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007428:	4b4c      	ldr	r3, [pc, #304]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400742a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400742e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007432:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007436:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400743a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400743c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007440:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34007442:	3b01      	subs	r3, #1
34007444:	041b      	lsls	r3, r3, #16
34007446:	4313      	orrs	r3, r2
34007448:	4a44      	ldr	r2, [pc, #272]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400744a:	430b      	orrs	r3, r1
3400744c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007450:	f7fe ffbc 	bl	340063cc <LL_RCC_IC15_Enable>
34007454:	e008      	b.n	34007468 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
34007456:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400745a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400745e:	4b47      	ldr	r3, [pc, #284]	@ (3400757c <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
34007460:	429a      	cmp	r2, r3
34007462:	d101      	bne.n	34007468 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
34007464:	f7ff f806 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34007468:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400746c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007470:	4618      	mov	r0, r3
34007472:	f7fe fdfc 	bl	3400606e <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34007476:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400747a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400747e:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
34007482:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34007486:	2300      	movs	r3, #0
34007488:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3400748c:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34007490:	4603      	mov	r3, r0
34007492:	460a      	mov	r2, r1
34007494:	4313      	orrs	r3, r2
34007496:	d02d      	beq.n	340074f4 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34007498:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400749c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
340074a0:	4b37      	ldr	r3, [pc, #220]	@ (34007580 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
340074a2:	429a      	cmp	r2, r3
340074a4:	d116      	bne.n	340074d4 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340074a6:	4b2d      	ldr	r3, [pc, #180]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340074a8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340074ac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340074b0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340074b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340074b8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340074ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340074be:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340074c0:	3b01      	subs	r3, #1
340074c2:	041b      	lsls	r3, r3, #16
340074c4:	4313      	orrs	r3, r2
340074c6:	4a25      	ldr	r2, [pc, #148]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340074c8:	430b      	orrs	r3, r1
340074ca:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340074ce:	f7fe ff7d 	bl	340063cc <LL_RCC_IC15_Enable>
340074d2:	e008      	b.n	340074e6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
340074d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340074d8:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
340074dc:	4b29      	ldr	r3, [pc, #164]	@ (34007584 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
340074de:	429a      	cmp	r2, r3
340074e0:	d101      	bne.n	340074e6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
340074e2:	f7fe ffc7 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
340074e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340074ea:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
340074ee:	4618      	mov	r0, r3
340074f0:	f7fe fdc8 	bl	34006084 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
340074f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340074f8:	e9d3 2300 	ldrd	r2, r3, [r3]
340074fc:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
34007500:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
34007504:	2300      	movs	r3, #0
34007506:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3400750a:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
3400750e:	4603      	mov	r3, r0
34007510:	460a      	mov	r2, r1
34007512:	4313      	orrs	r3, r2
34007514:	d04a      	beq.n	340075ac <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34007516:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400751a:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400751e:	4b1a      	ldr	r3, [pc, #104]	@ (34007588 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
34007520:	429a      	cmp	r2, r3
34007522:	d133      	bne.n	3400758c <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34007524:	4b0d      	ldr	r3, [pc, #52]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007526:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400752a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400752e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007532:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007536:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34007538:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400753c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400753e:	3b01      	subs	r3, #1
34007540:	041b      	lsls	r3, r3, #16
34007542:	4313      	orrs	r3, r2
34007544:	4a05      	ldr	r2, [pc, #20]	@ (3400755c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34007546:	430b      	orrs	r3, r1
34007548:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400754c:	f7fe ff3e 	bl	340063cc <LL_RCC_IC15_Enable>
34007550:	e025      	b.n	3400759e <HAL_RCCEx_PeriphCLKConfig+0x110e>
34007552:	bf00      	nop
34007554:	0701080c 	.word	0x0701080c
34007558:	07020c0c 	.word	0x07020c0c
3400755c:	56028000 	.word	0x56028000
34007560:	07030c0c 	.word	0x07030c0c
34007564:	07010c0c 	.word	0x07010c0c
34007568:	0702100c 	.word	0x0702100c
3400756c:	0703100c 	.word	0x0703100c
34007570:	0701100c 	.word	0x0701100c
34007574:	0702140c 	.word	0x0702140c
34007578:	0703140c 	.word	0x0703140c
3400757c:	0701140c 	.word	0x0701140c
34007580:	0702082c 	.word	0x0702082c
34007584:	0701082c 	.word	0x0701082c
34007588:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
3400758c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007590:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34007594:	4bca      	ldr	r3, [pc, #808]	@ (340078c0 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
34007596:	429a      	cmp	r2, r3
34007598:	d101      	bne.n	3400759e <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
3400759a:	f7fe ff6b 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
3400759e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340075a2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
340075a6:	4618      	mov	r0, r3
340075a8:	f7fe fd6c 	bl	34006084 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
340075ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340075b0:	e9d3 2300 	ldrd	r2, r3, [r3]
340075b4:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
340075b8:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
340075bc:	2300      	movs	r3, #0
340075be:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
340075c2:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
340075c6:	4603      	mov	r3, r0
340075c8:	460a      	mov	r2, r1
340075ca:	4313      	orrs	r3, r2
340075cc:	d02d      	beq.n	3400762a <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
340075ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340075d2:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
340075d6:	4bbb      	ldr	r3, [pc, #748]	@ (340078c4 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
340075d8:	429a      	cmp	r2, r3
340075da:	d116      	bne.n	3400760a <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340075dc:	4bba      	ldr	r3, [pc, #744]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340075de:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340075e2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340075e6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340075ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340075ee:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340075f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340075f4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340075f6:	3b01      	subs	r3, #1
340075f8:	041b      	lsls	r3, r3, #16
340075fa:	4313      	orrs	r3, r2
340075fc:	4ab2      	ldr	r2, [pc, #712]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340075fe:	430b      	orrs	r3, r1
34007600:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007604:	f7fe fee2 	bl	340063cc <LL_RCC_IC15_Enable>
34007608:	e008      	b.n	3400761c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
3400760a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400760e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34007612:	4bae      	ldr	r3, [pc, #696]	@ (340078cc <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34007614:	429a      	cmp	r2, r3
34007616:	d101      	bne.n	3400761c <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
34007618:	f7fe ff2c 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
3400761c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007620:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34007624:	4618      	mov	r0, r3
34007626:	f7fe fd2d 	bl	34006084 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
3400762a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400762e:	e9d3 2300 	ldrd	r2, r3, [r3]
34007632:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
34007636:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3400763a:	2300      	movs	r3, #0
3400763c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34007640:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
34007644:	4603      	mov	r3, r0
34007646:	460a      	mov	r2, r1
34007648:	4313      	orrs	r3, r2
3400764a:	d02d      	beq.n	340076a8 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
3400764c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007650:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34007654:	4b9e      	ldr	r3, [pc, #632]	@ (340078d0 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
34007656:	429a      	cmp	r2, r3
34007658:	d116      	bne.n	34007688 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400765a:	4b9b      	ldr	r3, [pc, #620]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400765c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007660:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007664:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007668:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400766c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400766e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007672:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34007674:	3b01      	subs	r3, #1
34007676:	041b      	lsls	r3, r3, #16
34007678:	4313      	orrs	r3, r2
3400767a:	4a93      	ldr	r2, [pc, #588]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400767c:	430b      	orrs	r3, r1
3400767e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007682:	f7fe fea3 	bl	340063cc <LL_RCC_IC15_Enable>
34007686:	e008      	b.n	3400769a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34007688:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400768c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34007690:	4b90      	ldr	r3, [pc, #576]	@ (340078d4 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
34007692:	429a      	cmp	r2, r3
34007694:	d101      	bne.n	3400769a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
34007696:	f7fe feed 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
3400769a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400769e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
340076a2:	4618      	mov	r0, r3
340076a4:	f7fe fcee 	bl	34006084 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
340076a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340076ac:	e9d3 2300 	ldrd	r2, r3, [r3]
340076b0:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
340076b4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
340076b8:	2300      	movs	r3, #0
340076ba:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
340076be:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
340076c2:	4603      	mov	r3, r0
340076c4:	460a      	mov	r2, r1
340076c6:	4313      	orrs	r3, r2
340076c8:	d02d      	beq.n	34007726 <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
340076ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340076ce:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
340076d2:	4b81      	ldr	r3, [pc, #516]	@ (340078d8 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
340076d4:	429a      	cmp	r2, r3
340076d6:	d116      	bne.n	34007706 <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340076d8:	4b7b      	ldr	r3, [pc, #492]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340076da:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340076de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340076e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340076e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340076ea:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340076ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340076f0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340076f2:	3b01      	subs	r3, #1
340076f4:	041b      	lsls	r3, r3, #16
340076f6:	4313      	orrs	r3, r2
340076f8:	4a73      	ldr	r2, [pc, #460]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340076fa:	430b      	orrs	r3, r1
340076fc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007700:	f7fe fe64 	bl	340063cc <LL_RCC_IC15_Enable>
34007704:	e008      	b.n	34007718 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34007706:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400770a:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400770e:	4b73      	ldr	r3, [pc, #460]	@ (340078dc <HAL_RCCEx_PeriphCLKConfig+0x144c>)
34007710:	429a      	cmp	r2, r3
34007712:	d101      	bne.n	34007718 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34007714:	f7fe feae 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
34007718:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400771c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34007720:	4618      	mov	r0, r3
34007722:	f7fe fcaf 	bl	34006084 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
34007726:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400772a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400772e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
34007732:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
34007736:	2300      	movs	r3, #0
34007738:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3400773c:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
34007740:	4603      	mov	r3, r0
34007742:	460a      	mov	r2, r1
34007744:	4313      	orrs	r3, r2
34007746:	d04b      	beq.n	340077e0 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34007748:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400774c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34007750:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34007754:	d116      	bne.n	34007784 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007756:	4b5c      	ldr	r3, [pc, #368]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007758:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400775c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007760:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007764:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007768:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400776a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400776e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007770:	3b01      	subs	r3, #1
34007772:	041b      	lsls	r3, r3, #16
34007774:	4313      	orrs	r3, r2
34007776:	4a54      	ldr	r2, [pc, #336]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007778:	430b      	orrs	r3, r1
3400777a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400777e:	f7fe fddf 	bl	34006340 <LL_RCC_IC9_Enable>
34007782:	e026      	b.n	340077d2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
34007784:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007788:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400778c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34007790:	d116      	bne.n	340077c0 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007792:	4b4d      	ldr	r3, [pc, #308]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007794:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34007798:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400779c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340077a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340077a4:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340077a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340077aa:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340077ac:	3b01      	subs	r3, #1
340077ae:	041b      	lsls	r3, r3, #16
340077b0:	4313      	orrs	r3, r2
340077b2:	4a45      	ldr	r2, [pc, #276]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340077b4:	430b      	orrs	r3, r1
340077b6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340077ba:	f7fe fdf9 	bl	340063b0 <LL_RCC_IC14_Enable>
340077be:	e008      	b.n	340077d2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
340077c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340077c4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340077c8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340077cc:	d101      	bne.n	340077d2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
340077ce:	f7fe fe51 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
340077d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340077d6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340077da:	4618      	mov	r0, r3
340077dc:	f7fe fc5e 	bl	3400609c <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
340077e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340077e4:	e9d3 2300 	ldrd	r2, r3, [r3]
340077e8:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
340077ec:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
340077f0:	2300      	movs	r3, #0
340077f2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
340077f6:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
340077fa:	4603      	mov	r3, r0
340077fc:	460a      	mov	r2, r1
340077fe:	4313      	orrs	r3, r2
34007800:	d02f      	beq.n	34007862 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34007802:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007806:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400780a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400780e:	d118      	bne.n	34007842 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34007810:	4b2d      	ldr	r3, [pc, #180]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007812:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34007816:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400781a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400781e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007822:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34007826:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400782a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400782e:	3b01      	subs	r3, #1
34007830:	041b      	lsls	r3, r3, #16
34007832:	4313      	orrs	r3, r2
34007834:	4a24      	ldr	r2, [pc, #144]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007836:	430b      	orrs	r3, r1
34007838:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
3400783c:	f7fe fdd4 	bl	340063e8 <LL_RCC_IC16_Enable>
34007840:	e008      	b.n	34007854 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34007842:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007846:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400784a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3400784e:	d101      	bne.n	34007854 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
34007850:	f7fe fe10 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
34007854:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007858:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400785c:	4618      	mov	r0, r3
3400785e:	f7fe fc33 	bl	340060c8 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34007862:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007866:	e9d3 2300 	ldrd	r2, r3, [r3]
3400786a:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
3400786e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34007872:	2300      	movs	r3, #0
34007874:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34007878:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
3400787c:	4603      	mov	r3, r0
3400787e:	460a      	mov	r2, r1
34007880:	4313      	orrs	r3, r2
34007882:	d05b      	beq.n	3400793c <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34007884:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007888:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400788c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34007890:	d126      	bne.n	340078e0 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34007892:	4b0d      	ldr	r3, [pc, #52]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34007894:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34007898:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400789c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340078a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340078a4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340078a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340078aa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340078ac:	3b01      	subs	r3, #1
340078ae:	041b      	lsls	r3, r3, #16
340078b0:	4313      	orrs	r3, r2
340078b2:	4a05      	ldr	r2, [pc, #20]	@ (340078c8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340078b4:	430b      	orrs	r3, r1
340078b6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
340078ba:	f7fe fd25 	bl	34006308 <LL_RCC_IC7_Enable>
340078be:	e036      	b.n	3400792e <HAL_RCCEx_PeriphCLKConfig+0x149e>
340078c0:	07010c2c 	.word	0x07010c2c
340078c4:	0702102c 	.word	0x0702102c
340078c8:	56028000 	.word	0x56028000
340078cc:	0701102c 	.word	0x0701102c
340078d0:	0702142c 	.word	0x0702142c
340078d4:	0701142c 	.word	0x0701142c
340078d8:	0702182c 	.word	0x0702182c
340078dc:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
340078e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340078e4:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340078e8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
340078ec:	d116      	bne.n	3400791c <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340078ee:	4bb5      	ldr	r3, [pc, #724]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340078f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340078f4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340078f8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340078fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007900:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007902:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007906:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007908:	3b01      	subs	r3, #1
3400790a:	041b      	lsls	r3, r3, #16
3400790c:	4313      	orrs	r3, r2
3400790e:	4aad      	ldr	r2, [pc, #692]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007910:	430b      	orrs	r3, r1
34007912:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007916:	f7fe fd05 	bl	34006324 <LL_RCC_IC8_Enable>
3400791a:	e008      	b.n	3400792e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
3400791c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007920:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34007924:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007928:	d101      	bne.n	3400792e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
3400792a:	f7fe fda3 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
3400792e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007932:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34007936:	4618      	mov	r0, r3
34007938:	f7fe fbdc 	bl	340060f4 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
3400793c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007940:	e9d3 2300 	ldrd	r2, r3, [r3]
34007944:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34007948:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3400794c:	2300      	movs	r3, #0
3400794e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34007952:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
34007956:	4603      	mov	r3, r0
34007958:	460a      	mov	r2, r1
3400795a:	4313      	orrs	r3, r2
3400795c:	d02d      	beq.n	340079ba <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
3400795e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007962:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34007966:	2b20      	cmp	r3, #32
34007968:	d118      	bne.n	3400799c <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400796a:	4b96      	ldr	r3, [pc, #600]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400796c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34007970:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007974:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007978:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400797c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34007980:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007984:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34007988:	3b01      	subs	r3, #1
3400798a:	041b      	lsls	r3, r3, #16
3400798c:	4313      	orrs	r3, r2
3400798e:	4a8d      	ldr	r2, [pc, #564]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007990:	430b      	orrs	r3, r1
34007992:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34007996:	f7fe fd5f 	bl	34006458 <LL_RCC_IC20_Enable>
3400799a:	e007      	b.n	340079ac <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
3400799c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340079a0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340079a4:	2b10      	cmp	r3, #16
340079a6:	d101      	bne.n	340079ac <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
340079a8:	f7fe fd64 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
340079ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340079b0:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340079b4:	4618      	mov	r0, r3
340079b6:	f7fe fbc9 	bl	3400614c <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
340079ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340079be:	e9d3 2300 	ldrd	r2, r3, [r3]
340079c2:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
340079c6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
340079ca:	2300      	movs	r3, #0
340079cc:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
340079d0:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
340079d4:	4603      	mov	r3, r0
340079d6:	460a      	mov	r2, r1
340079d8:	4313      	orrs	r3, r2
340079da:	d04b      	beq.n	34007a74 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
340079dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340079e0:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340079e4:	4b78      	ldr	r3, [pc, #480]	@ (34007bc8 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
340079e6:	429a      	cmp	r2, r3
340079e8:	d116      	bne.n	34007a18 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340079ea:	4b76      	ldr	r3, [pc, #472]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340079ec:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340079f0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340079f4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340079f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340079fc:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340079fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a02:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007a04:	3b01      	subs	r3, #1
34007a06:	041b      	lsls	r3, r3, #16
34007a08:	4313      	orrs	r3, r2
34007a0a:	4a6e      	ldr	r2, [pc, #440]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007a0c:	430b      	orrs	r3, r1
34007a0e:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34007a12:	f7fe fc79 	bl	34006308 <LL_RCC_IC7_Enable>
34007a16:	e026      	b.n	34007a66 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
34007a18:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a1c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34007a20:	4b6a      	ldr	r3, [pc, #424]	@ (34007bcc <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34007a22:	429a      	cmp	r2, r3
34007a24:	d116      	bne.n	34007a54 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007a26:	4b67      	ldr	r3, [pc, #412]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007a28:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007a2c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007a30:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007a34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a38:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007a3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a3e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007a40:	3b01      	subs	r3, #1
34007a42:	041b      	lsls	r3, r3, #16
34007a44:	4313      	orrs	r3, r2
34007a46:	4a5f      	ldr	r2, [pc, #380]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007a48:	430b      	orrs	r3, r1
34007a4a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007a4e:	f7fe fc69 	bl	34006324 <LL_RCC_IC8_Enable>
34007a52:	e008      	b.n	34007a66 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34007a54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a58:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34007a5c:	4b5c      	ldr	r3, [pc, #368]	@ (34007bd0 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
34007a5e:	429a      	cmp	r2, r3
34007a60:	d101      	bne.n	34007a66 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
34007a62:	f7fe fd07 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
34007a66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a6a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34007a6e:	4618      	mov	r0, r3
34007a70:	f7fe fb82 	bl	34006178 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34007a74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a78:	e9d3 2300 	ldrd	r2, r3, [r3]
34007a7c:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
34007a80:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
34007a84:	2300      	movs	r3, #0
34007a86:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
34007a8a:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34007a8e:	4603      	mov	r3, r0
34007a90:	460a      	mov	r2, r1
34007a92:	4313      	orrs	r3, r2
34007a94:	d04b      	beq.n	34007b2e <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34007a96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007a9a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34007a9e:	4b4d      	ldr	r3, [pc, #308]	@ (34007bd4 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34007aa0:	429a      	cmp	r2, r3
34007aa2:	d116      	bne.n	34007ad2 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34007aa4:	4b47      	ldr	r3, [pc, #284]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007aa6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34007aaa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007aae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007ab2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007ab6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34007ab8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007abc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007abe:	3b01      	subs	r3, #1
34007ac0:	041b      	lsls	r3, r3, #16
34007ac2:	4313      	orrs	r3, r2
34007ac4:	4a3f      	ldr	r2, [pc, #252]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007ac6:	430b      	orrs	r3, r1
34007ac8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34007acc:	f7fe fc1c 	bl	34006308 <LL_RCC_IC7_Enable>
34007ad0:	e026      	b.n	34007b20 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34007ad2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007ad6:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34007ada:	4b3f      	ldr	r3, [pc, #252]	@ (34007bd8 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34007adc:	429a      	cmp	r2, r3
34007ade:	d116      	bne.n	34007b0e <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007ae0:	4b38      	ldr	r3, [pc, #224]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007ae2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007ae6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007aea:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007aee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007af2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007af4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007af8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007afa:	3b01      	subs	r3, #1
34007afc:	041b      	lsls	r3, r3, #16
34007afe:	4313      	orrs	r3, r2
34007b00:	4a30      	ldr	r2, [pc, #192]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007b02:	430b      	orrs	r3, r1
34007b04:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007b08:	f7fe fc0c 	bl	34006324 <LL_RCC_IC8_Enable>
34007b0c:	e008      	b.n	34007b20 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34007b0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b12:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34007b16:	4b31      	ldr	r3, [pc, #196]	@ (34007bdc <HAL_RCCEx_PeriphCLKConfig+0x174c>)
34007b18:	429a      	cmp	r2, r3
34007b1a:	d101      	bne.n	34007b20 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34007b1c:	f7fe fcaa 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34007b20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b24:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34007b28:	4618      	mov	r0, r3
34007b2a:	f7fe fb25 	bl	34006178 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
34007b2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b32:	e9d3 2300 	ldrd	r2, r3, [r3]
34007b36:	2100      	movs	r1, #0
34007b38:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
34007b3c:	f003 0301 	and.w	r3, r3, #1
34007b40:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34007b44:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34007b48:	4603      	mov	r3, r0
34007b4a:	460a      	mov	r2, r1
34007b4c:	4313      	orrs	r3, r2
34007b4e:	d056      	beq.n	34007bfe <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34007b50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b54:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34007b58:	2b02      	cmp	r3, #2
34007b5a:	d116      	bne.n	34007b8a <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34007b5c:	4b19      	ldr	r3, [pc, #100]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007b5e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34007b62:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007b66:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007b6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b6e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34007b70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b74:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34007b76:	3b01      	subs	r3, #1
34007b78:	041b      	lsls	r3, r3, #16
34007b7a:	4313      	orrs	r3, r2
34007b7c:	4a11      	ldr	r2, [pc, #68]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007b7e:	430b      	orrs	r3, r1
34007b80:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34007b84:	f7fe fbc0 	bl	34006308 <LL_RCC_IC7_Enable>
34007b88:	e032      	b.n	34007bf0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
34007b8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007b8e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34007b92:	2b03      	cmp	r3, #3
34007b94:	d124      	bne.n	34007be0 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007b96:	4b0b      	ldr	r3, [pc, #44]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007b98:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007b9c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007ba0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007ba4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007ba8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007baa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007bae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007bb0:	3b01      	subs	r3, #1
34007bb2:	041b      	lsls	r3, r3, #16
34007bb4:	4313      	orrs	r3, r2
34007bb6:	4a03      	ldr	r2, [pc, #12]	@ (34007bc4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34007bb8:	430b      	orrs	r3, r1
34007bba:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007bbe:	f7fe fbb1 	bl	34006324 <LL_RCC_IC8_Enable>
34007bc2:	e015      	b.n	34007bf0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
34007bc4:	56028000 	.word	0x56028000
34007bc8:	07021418 	.word	0x07021418
34007bcc:	07031418 	.word	0x07031418
34007bd0:	07011418 	.word	0x07011418
34007bd4:	07021818 	.word	0x07021818
34007bd8:	07031818 	.word	0x07031818
34007bdc:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34007be0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007be4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34007be8:	2b01      	cmp	r3, #1
34007bea:	d101      	bne.n	34007bf0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
34007bec:	f7fe fc42 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34007bf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007bf4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34007bf8:	4618      	mov	r0, r3
34007bfa:	f7fe fad3 	bl	340061a4 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34007bfe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c02:	e9d3 2300 	ldrd	r2, r3, [r3]
34007c06:	2100      	movs	r1, #0
34007c08:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34007c0c:	f003 0302 	and.w	r3, r3, #2
34007c10:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34007c14:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34007c18:	4603      	mov	r3, r0
34007c1a:	460a      	mov	r2, r1
34007c1c:	4313      	orrs	r3, r2
34007c1e:	d04b      	beq.n	34007cb8 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34007c20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c24:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34007c28:	4bc6      	ldr	r3, [pc, #792]	@ (34007f44 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
34007c2a:	429a      	cmp	r2, r3
34007c2c:	d116      	bne.n	34007c5c <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007c2e:	4bc6      	ldr	r3, [pc, #792]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007c30:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007c34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007c38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007c3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c40:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007c42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c46:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007c48:	3b01      	subs	r3, #1
34007c4a:	041b      	lsls	r3, r3, #16
34007c4c:	4313      	orrs	r3, r2
34007c4e:	4abe      	ldr	r2, [pc, #760]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007c50:	430b      	orrs	r3, r1
34007c52:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007c56:	f7fe fb65 	bl	34006324 <LL_RCC_IC8_Enable>
34007c5a:	e026      	b.n	34007caa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
34007c5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c60:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34007c64:	4bb9      	ldr	r3, [pc, #740]	@ (34007f4c <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
34007c66:	429a      	cmp	r2, r3
34007c68:	d116      	bne.n	34007c98 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007c6a:	4bb7      	ldr	r3, [pc, #732]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007c6c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007c70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007c74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007c78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c7c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34007c7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c82:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007c84:	3b01      	subs	r3, #1
34007c86:	041b      	lsls	r3, r3, #16
34007c88:	4313      	orrs	r3, r2
34007c8a:	4aaf      	ldr	r2, [pc, #700]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007c8c:	430b      	orrs	r3, r1
34007c8e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007c92:	f7fe fb55 	bl	34006340 <LL_RCC_IC9_Enable>
34007c96:	e008      	b.n	34007caa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34007c98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007c9c:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34007ca0:	4bab      	ldr	r3, [pc, #684]	@ (34007f50 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34007ca2:	429a      	cmp	r2, r3
34007ca4:	d101      	bne.n	34007caa <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
34007ca6:	f7fe fbe5 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
34007caa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007cae:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34007cb2:	4618      	mov	r0, r3
34007cb4:	f7fe fa8c 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34007cb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007cbc:	e9d3 2300 	ldrd	r2, r3, [r3]
34007cc0:	2100      	movs	r1, #0
34007cc2:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
34007cc6:	f003 0304 	and.w	r3, r3, #4
34007cca:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34007cce:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34007cd2:	4603      	mov	r3, r0
34007cd4:	460a      	mov	r2, r1
34007cd6:	4313      	orrs	r3, r2
34007cd8:	d04b      	beq.n	34007d72 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
34007cda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007cde:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34007ce2:	4b9c      	ldr	r3, [pc, #624]	@ (34007f54 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
34007ce4:	429a      	cmp	r2, r3
34007ce6:	d116      	bne.n	34007d16 <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007ce8:	4b97      	ldr	r3, [pc, #604]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007cea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007cee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007cf2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007cf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007cfa:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007cfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d00:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007d02:	3b01      	subs	r3, #1
34007d04:	041b      	lsls	r3, r3, #16
34007d06:	4313      	orrs	r3, r2
34007d08:	4a8f      	ldr	r2, [pc, #572]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007d0a:	430b      	orrs	r3, r1
34007d0c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007d10:	f7fe fb08 	bl	34006324 <LL_RCC_IC8_Enable>
34007d14:	e026      	b.n	34007d64 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
34007d16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d1a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34007d1e:	4b8e      	ldr	r3, [pc, #568]	@ (34007f58 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34007d20:	429a      	cmp	r2, r3
34007d22:	d116      	bne.n	34007d52 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007d24:	4b88      	ldr	r3, [pc, #544]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007d26:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007d2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007d2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007d32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d36:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34007d38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d3c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007d3e:	3b01      	subs	r3, #1
34007d40:	041b      	lsls	r3, r3, #16
34007d42:	4313      	orrs	r3, r2
34007d44:	4a80      	ldr	r2, [pc, #512]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007d46:	430b      	orrs	r3, r1
34007d48:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007d4c:	f7fe faf8 	bl	34006340 <LL_RCC_IC9_Enable>
34007d50:	e008      	b.n	34007d64 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
34007d52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d56:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34007d5a:	4b80      	ldr	r3, [pc, #512]	@ (34007f5c <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
34007d5c:	429a      	cmp	r2, r3
34007d5e:	d101      	bne.n	34007d64 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
34007d60:	f7fe fb88 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
34007d64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d68:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
34007d6c:	4618      	mov	r0, r3
34007d6e:	f7fe fa2f 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34007d72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d76:	e9d3 2300 	ldrd	r2, r3, [r3]
34007d7a:	2100      	movs	r1, #0
34007d7c:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
34007d80:	f003 0308 	and.w	r3, r3, #8
34007d84:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34007d88:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
34007d8c:	4603      	mov	r3, r0
34007d8e:	460a      	mov	r2, r1
34007d90:	4313      	orrs	r3, r2
34007d92:	d04b      	beq.n	34007e2c <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34007d94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007d98:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34007d9c:	4b70      	ldr	r3, [pc, #448]	@ (34007f60 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
34007d9e:	429a      	cmp	r2, r3
34007da0:	d116      	bne.n	34007dd0 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34007da2:	4b69      	ldr	r3, [pc, #420]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007da4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34007da8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007dac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007db0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007db4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34007db6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007dba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34007dbc:	3b01      	subs	r3, #1
34007dbe:	041b      	lsls	r3, r3, #16
34007dc0:	4313      	orrs	r3, r2
34007dc2:	4a61      	ldr	r2, [pc, #388]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007dc4:	430b      	orrs	r3, r1
34007dc6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34007dca:	f7fe faab 	bl	34006324 <LL_RCC_IC8_Enable>
34007dce:	e026      	b.n	34007e1e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
34007dd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007dd4:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34007dd8:	4b62      	ldr	r3, [pc, #392]	@ (34007f64 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
34007dda:	429a      	cmp	r2, r3
34007ddc:	d116      	bne.n	34007e0c <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007dde:	4b5a      	ldr	r3, [pc, #360]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007de0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007de4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007de8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007dec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007df0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34007df2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007df6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007df8:	3b01      	subs	r3, #1
34007dfa:	041b      	lsls	r3, r3, #16
34007dfc:	4313      	orrs	r3, r2
34007dfe:	4a52      	ldr	r2, [pc, #328]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007e00:	430b      	orrs	r3, r1
34007e02:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007e06:	f7fe fa9b 	bl	34006340 <LL_RCC_IC9_Enable>
34007e0a:	e008      	b.n	34007e1e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
34007e0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e10:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34007e14:	4b54      	ldr	r3, [pc, #336]	@ (34007f68 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
34007e16:	429a      	cmp	r2, r3
34007e18:	d101      	bne.n	34007e1e <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
34007e1a:	f7fe fb2b 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
34007e1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e22:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
34007e26:	4618      	mov	r0, r3
34007e28:	f7fe f9d2 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
34007e2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e30:	e9d3 2300 	ldrd	r2, r3, [r3]
34007e34:	2100      	movs	r1, #0
34007e36:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
34007e3a:	f003 0310 	and.w	r3, r3, #16
34007e3e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34007e42:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
34007e46:	4603      	mov	r3, r0
34007e48:	460a      	mov	r2, r1
34007e4a:	4313      	orrs	r3, r2
34007e4c:	d04b      	beq.n	34007ee6 <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
34007e4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e52:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34007e56:	4b45      	ldr	r3, [pc, #276]	@ (34007f6c <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
34007e58:	429a      	cmp	r2, r3
34007e5a:	d116      	bne.n	34007e8a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007e5c:	4b3a      	ldr	r3, [pc, #232]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007e5e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007e62:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007e66:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007e6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e6e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34007e70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e74:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007e76:	3b01      	subs	r3, #1
34007e78:	041b      	lsls	r3, r3, #16
34007e7a:	4313      	orrs	r3, r2
34007e7c:	4a32      	ldr	r2, [pc, #200]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007e7e:	430b      	orrs	r3, r1
34007e80:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007e84:	f7fe fa5c 	bl	34006340 <LL_RCC_IC9_Enable>
34007e88:	e026      	b.n	34007ed8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
34007e8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007e8e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34007e92:	4b37      	ldr	r3, [pc, #220]	@ (34007f70 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34007e94:	429a      	cmp	r2, r3
34007e96:	d116      	bne.n	34007ec6 <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007e98:	4b2b      	ldr	r3, [pc, #172]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007e9a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34007e9e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007ea2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007ea6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007eaa:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34007eac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007eb0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34007eb2:	3b01      	subs	r3, #1
34007eb4:	041b      	lsls	r3, r3, #16
34007eb6:	4313      	orrs	r3, r2
34007eb8:	4a23      	ldr	r2, [pc, #140]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007eba:	430b      	orrs	r3, r1
34007ebc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34007ec0:	f7fe fa76 	bl	340063b0 <LL_RCC_IC14_Enable>
34007ec4:	e008      	b.n	34007ed8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
34007ec6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007eca:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34007ece:	4b29      	ldr	r3, [pc, #164]	@ (34007f74 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
34007ed0:	429a      	cmp	r2, r3
34007ed2:	d101      	bne.n	34007ed8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
34007ed4:	f7fe face 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
34007ed8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007edc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
34007ee0:	4618      	mov	r0, r3
34007ee2:	f7fe f975 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
34007ee6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007eea:	e9d3 2300 	ldrd	r2, r3, [r3]
34007eee:	2100      	movs	r1, #0
34007ef0:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
34007ef4:	f003 0320 	and.w	r3, r3, #32
34007ef8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34007efc:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
34007f00:	4603      	mov	r3, r0
34007f02:	460a      	mov	r2, r1
34007f04:	4313      	orrs	r3, r2
34007f06:	d067      	beq.n	34007fd8 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
34007f08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007f0c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34007f10:	4b19      	ldr	r3, [pc, #100]	@ (34007f78 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34007f12:	429a      	cmp	r2, r3
34007f14:	d132      	bne.n	34007f7c <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007f16:	4b0c      	ldr	r3, [pc, #48]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007f18:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007f1c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007f20:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007f24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007f28:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34007f2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007f2e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007f30:	3b01      	subs	r3, #1
34007f32:	041b      	lsls	r3, r3, #16
34007f34:	4313      	orrs	r3, r2
34007f36:	4a04      	ldr	r2, [pc, #16]	@ (34007f48 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34007f38:	430b      	orrs	r3, r1
34007f3a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007f3e:	f7fe f9ff 	bl	34006340 <LL_RCC_IC9_Enable>
34007f42:	e042      	b.n	34007fca <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34007f44:	07020420 	.word	0x07020420
34007f48:	56028000 	.word	0x56028000
34007f4c:	07030420 	.word	0x07030420
34007f50:	07010420 	.word	0x07010420
34007f54:	07020820 	.word	0x07020820
34007f58:	07030820 	.word	0x07030820
34007f5c:	07010820 	.word	0x07010820
34007f60:	07020c20 	.word	0x07020c20
34007f64:	07030c20 	.word	0x07030c20
34007f68:	07010c20 	.word	0x07010c20
34007f6c:	07021020 	.word	0x07021020
34007f70:	07031020 	.word	0x07031020
34007f74:	07011020 	.word	0x07011020
34007f78:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
34007f7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007f80:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34007f84:	4bc2      	ldr	r3, [pc, #776]	@ (34008290 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
34007f86:	429a      	cmp	r2, r3
34007f88:	d116      	bne.n	34007fb8 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007f8a:	4bc2      	ldr	r3, [pc, #776]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34007f8c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34007f90:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007f94:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007f98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007f9c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34007f9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007fa2:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34007fa4:	3b01      	subs	r3, #1
34007fa6:	041b      	lsls	r3, r3, #16
34007fa8:	4313      	orrs	r3, r2
34007faa:	4aba      	ldr	r2, [pc, #744]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34007fac:	430b      	orrs	r3, r1
34007fae:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34007fb2:	f7fe f9fd 	bl	340063b0 <LL_RCC_IC14_Enable>
34007fb6:	e008      	b.n	34007fca <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34007fb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007fbc:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34007fc0:	4bb5      	ldr	r3, [pc, #724]	@ (34008298 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
34007fc2:	429a      	cmp	r2, r3
34007fc4:	d101      	bne.n	34007fca <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
34007fc6:	f7fe fa55 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
34007fca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007fce:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34007fd2:	4618      	mov	r0, r3
34007fd4:	f7fe f8fc 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
34007fd8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007fdc:	e9d3 2300 	ldrd	r2, r3, [r3]
34007fe0:	2100      	movs	r1, #0
34007fe2:	67b9      	str	r1, [r7, #120]	@ 0x78
34007fe4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007fe8:	67fb      	str	r3, [r7, #124]	@ 0x7c
34007fea:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
34007fee:	4603      	mov	r3, r0
34007ff0:	460a      	mov	r2, r1
34007ff2:	4313      	orrs	r3, r2
34007ff4:	d04b      	beq.n	3400808e <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
34007ff6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007ffa:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34007ffe:	4ba7      	ldr	r3, [pc, #668]	@ (3400829c <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
34008000:	429a      	cmp	r2, r3
34008002:	d116      	bne.n	34008032 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34008004:	4ba3      	ldr	r3, [pc, #652]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008006:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400800a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400800e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008012:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008016:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34008018:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400801c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400801e:	3b01      	subs	r3, #1
34008020:	041b      	lsls	r3, r3, #16
34008022:	4313      	orrs	r3, r2
34008024:	4a9b      	ldr	r2, [pc, #620]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008026:	430b      	orrs	r3, r1
34008028:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400802c:	f7fe f97a 	bl	34006324 <LL_RCC_IC8_Enable>
34008030:	e026      	b.n	34008080 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34008032:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008036:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400803a:	4b99      	ldr	r3, [pc, #612]	@ (340082a0 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
3400803c:	429a      	cmp	r2, r3
3400803e:	d116      	bne.n	3400806e <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008040:	4b94      	ldr	r3, [pc, #592]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008042:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34008046:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400804a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400804e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008052:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34008054:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008058:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400805a:	3b01      	subs	r3, #1
3400805c:	041b      	lsls	r3, r3, #16
3400805e:	4313      	orrs	r3, r2
34008060:	4a8c      	ldr	r2, [pc, #560]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008062:	430b      	orrs	r3, r1
34008064:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34008068:	f7fe f96a 	bl	34006340 <LL_RCC_IC9_Enable>
3400806c:	e008      	b.n	34008080 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400806e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008072:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34008076:	4b8b      	ldr	r3, [pc, #556]	@ (340082a4 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
34008078:	429a      	cmp	r2, r3
3400807a:	d101      	bne.n	34008080 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
3400807c:	f7fe f9fa 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
34008080:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008084:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008088:	4618      	mov	r0, r3
3400808a:	f7fe f8a1 	bl	340061d0 <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400808e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008092:	e9d3 2300 	ldrd	r2, r3, [r3]
34008096:	2100      	movs	r1, #0
34008098:	6739      	str	r1, [r7, #112]	@ 0x70
3400809a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400809e:	677b      	str	r3, [r7, #116]	@ 0x74
340080a0:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
340080a4:	4603      	mov	r3, r0
340080a6:	460a      	mov	r2, r1
340080a8:	4313      	orrs	r3, r2
340080aa:	d04b      	beq.n	34008144 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
340080ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340080b0:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340080b4:	4b7c      	ldr	r3, [pc, #496]	@ (340082a8 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
340080b6:	429a      	cmp	r2, r3
340080b8:	d116      	bne.n	340080e8 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340080ba:	4b76      	ldr	r3, [pc, #472]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340080bc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340080c0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340080c4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340080c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340080cc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340080ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340080d2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340080d4:	3b01      	subs	r3, #1
340080d6:	041b      	lsls	r3, r3, #16
340080d8:	4313      	orrs	r3, r2
340080da:	4a6e      	ldr	r2, [pc, #440]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340080dc:	430b      	orrs	r3, r1
340080de:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340080e2:	f7fe f92d 	bl	34006340 <LL_RCC_IC9_Enable>
340080e6:	e026      	b.n	34008136 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
340080e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340080ec:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340080f0:	4b6e      	ldr	r3, [pc, #440]	@ (340082ac <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
340080f2:	429a      	cmp	r2, r3
340080f4:	d116      	bne.n	34008124 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340080f6:	4b67      	ldr	r3, [pc, #412]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340080f8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340080fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008100:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008104:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008108:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400810a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400810e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34008110:	3b01      	subs	r3, #1
34008112:	041b      	lsls	r3, r3, #16
34008114:	4313      	orrs	r3, r2
34008116:	4a5f      	ldr	r2, [pc, #380]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008118:	430b      	orrs	r3, r1
3400811a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400811e:	f7fe f947 	bl	340063b0 <LL_RCC_IC14_Enable>
34008122:	e008      	b.n	34008136 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34008124:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008128:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400812c:	4b60      	ldr	r3, [pc, #384]	@ (340082b0 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
3400812e:	429a      	cmp	r2, r3
34008130:	d101      	bne.n	34008136 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34008132:	f7fe f99f 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34008136:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400813a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400813e:	4618      	mov	r0, r3
34008140:	f7fe f851 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34008144:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008148:	e9d3 2300 	ldrd	r2, r3, [r3]
3400814c:	2100      	movs	r1, #0
3400814e:	66b9      	str	r1, [r7, #104]	@ 0x68
34008150:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34008154:	66fb      	str	r3, [r7, #108]	@ 0x6c
34008156:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
3400815a:	4603      	mov	r3, r0
3400815c:	460a      	mov	r2, r1
3400815e:	4313      	orrs	r3, r2
34008160:	d04b      	beq.n	340081fa <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34008162:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008166:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400816a:	4b52      	ldr	r3, [pc, #328]	@ (340082b4 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
3400816c:	429a      	cmp	r2, r3
3400816e:	d116      	bne.n	3400819e <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008170:	4b48      	ldr	r3, [pc, #288]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008172:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34008176:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400817a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400817e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008182:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34008184:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008188:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400818a:	3b01      	subs	r3, #1
3400818c:	041b      	lsls	r3, r3, #16
3400818e:	4313      	orrs	r3, r2
34008190:	4a40      	ldr	r2, [pc, #256]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008192:	430b      	orrs	r3, r1
34008194:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34008198:	f7fe f8d2 	bl	34006340 <LL_RCC_IC9_Enable>
3400819c:	e026      	b.n	340081ec <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400819e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081a2:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
340081a6:	4b44      	ldr	r3, [pc, #272]	@ (340082b8 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
340081a8:	429a      	cmp	r2, r3
340081aa:	d116      	bne.n	340081da <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340081ac:	4b39      	ldr	r3, [pc, #228]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340081ae:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340081b2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340081b6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340081ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081be:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340081c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081c4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340081c6:	3b01      	subs	r3, #1
340081c8:	041b      	lsls	r3, r3, #16
340081ca:	4313      	orrs	r3, r2
340081cc:	4a31      	ldr	r2, [pc, #196]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340081ce:	430b      	orrs	r3, r1
340081d0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340081d4:	f7fe f8ec 	bl	340063b0 <LL_RCC_IC14_Enable>
340081d8:	e008      	b.n	340081ec <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
340081da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081de:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
340081e2:	4b36      	ldr	r3, [pc, #216]	@ (340082bc <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
340081e4:	429a      	cmp	r2, r3
340081e6:	d101      	bne.n	340081ec <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
340081e8:	f7fe f944 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
340081ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081f0:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
340081f4:	4618      	mov	r0, r3
340081f6:	f7fd fff6 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
340081fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340081fe:	e9d3 2300 	ldrd	r2, r3, [r3]
34008202:	2100      	movs	r1, #0
34008204:	6639      	str	r1, [r7, #96]	@ 0x60
34008206:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400820a:	667b      	str	r3, [r7, #100]	@ 0x64
3400820c:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34008210:	4603      	mov	r3, r0
34008212:	460a      	mov	r2, r1
34008214:	4313      	orrs	r3, r2
34008216:	d067      	beq.n	340082e8 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34008218:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400821c:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34008220:	4b27      	ldr	r3, [pc, #156]	@ (340082c0 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34008222:	429a      	cmp	r2, r3
34008224:	d116      	bne.n	34008254 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008226:	4b1b      	ldr	r3, [pc, #108]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008228:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400822c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008230:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008234:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008238:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400823a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400823e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34008240:	3b01      	subs	r3, #1
34008242:	041b      	lsls	r3, r3, #16
34008244:	4313      	orrs	r3, r2
34008246:	4a13      	ldr	r2, [pc, #76]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008248:	430b      	orrs	r3, r1
3400824a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400824e:	f7fe f877 	bl	34006340 <LL_RCC_IC9_Enable>
34008252:	e042      	b.n	340082da <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34008254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008258:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400825c:	4b19      	ldr	r3, [pc, #100]	@ (340082c4 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
3400825e:	429a      	cmp	r2, r3
34008260:	d132      	bne.n	340082c8 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34008262:	4b0c      	ldr	r3, [pc, #48]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008264:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008268:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400826c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008270:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008274:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34008276:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400827a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400827c:	3b01      	subs	r3, #1
3400827e:	041b      	lsls	r3, r3, #16
34008280:	4313      	orrs	r3, r2
34008282:	4a04      	ldr	r2, [pc, #16]	@ (34008294 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34008284:	430b      	orrs	r3, r1
34008286:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400828a:	f7fe f891 	bl	340063b0 <LL_RCC_IC14_Enable>
3400828e:	e024      	b.n	340082da <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34008290:	07031420 	.word	0x07031420
34008294:	56028000 	.word	0x56028000
34008298:	07011420 	.word	0x07011420
3400829c:	07021820 	.word	0x07021820
340082a0:	07031820 	.word	0x07031820
340082a4:	07011820 	.word	0x07011820
340082a8:	07020030 	.word	0x07020030
340082ac:	07030030 	.word	0x07030030
340082b0:	07010030 	.word	0x07010030
340082b4:	07020430 	.word	0x07020430
340082b8:	07030430 	.word	0x07030430
340082bc:	07010430 	.word	0x07010430
340082c0:	07020830 	.word	0x07020830
340082c4:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
340082c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340082cc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
340082d0:	4bb3      	ldr	r3, [pc, #716]	@ (340085a0 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
340082d2:	429a      	cmp	r2, r3
340082d4:	d101      	bne.n	340082da <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
340082d6:	f7fe f8cd 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
340082da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340082de:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
340082e2:	4618      	mov	r0, r3
340082e4:	f7fd ff7f 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
340082e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340082ec:	e9d3 2300 	ldrd	r2, r3, [r3]
340082f0:	2100      	movs	r1, #0
340082f2:	65b9      	str	r1, [r7, #88]	@ 0x58
340082f4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340082f8:	65fb      	str	r3, [r7, #92]	@ 0x5c
340082fa:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
340082fe:	4603      	mov	r3, r0
34008300:	460a      	mov	r2, r1
34008302:	4313      	orrs	r3, r2
34008304:	d04b      	beq.n	3400839e <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
34008306:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400830a:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400830e:	4ba5      	ldr	r3, [pc, #660]	@ (340085a4 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
34008310:	429a      	cmp	r2, r3
34008312:	d116      	bne.n	34008342 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008314:	4ba4      	ldr	r3, [pc, #656]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008316:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400831a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400831e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008322:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008326:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34008328:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400832c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400832e:	3b01      	subs	r3, #1
34008330:	041b      	lsls	r3, r3, #16
34008332:	4313      	orrs	r3, r2
34008334:	4a9c      	ldr	r2, [pc, #624]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008336:	430b      	orrs	r3, r1
34008338:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400833c:	f7fe f800 	bl	34006340 <LL_RCC_IC9_Enable>
34008340:	e026      	b.n	34008390 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34008342:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008346:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400834a:	4b98      	ldr	r3, [pc, #608]	@ (340085ac <HAL_RCCEx_PeriphCLKConfig+0x211c>)
3400834c:	429a      	cmp	r2, r3
3400834e:	d116      	bne.n	3400837e <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34008350:	4b95      	ldr	r3, [pc, #596]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008352:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008356:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400835a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400835e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008362:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34008364:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008368:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400836a:	3b01      	subs	r3, #1
3400836c:	041b      	lsls	r3, r3, #16
3400836e:	4313      	orrs	r3, r2
34008370:	4a8d      	ldr	r2, [pc, #564]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008372:	430b      	orrs	r3, r1
34008374:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34008378:	f7fe f81a 	bl	340063b0 <LL_RCC_IC14_Enable>
3400837c:	e008      	b.n	34008390 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400837e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008382:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34008386:	4b8a      	ldr	r3, [pc, #552]	@ (340085b0 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34008388:	429a      	cmp	r2, r3
3400838a:	d101      	bne.n	34008390 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
3400838c:	f7fe f872 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34008390:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008394:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008398:	4618      	mov	r0, r3
3400839a:	f7fd ff24 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400839e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340083a2:	e9d3 2300 	ldrd	r2, r3, [r3]
340083a6:	2100      	movs	r1, #0
340083a8:	6539      	str	r1, [r7, #80]	@ 0x50
340083aa:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340083ae:	657b      	str	r3, [r7, #84]	@ 0x54
340083b0:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
340083b4:	4603      	mov	r3, r0
340083b6:	460a      	mov	r2, r1
340083b8:	4313      	orrs	r3, r2
340083ba:	d04b      	beq.n	34008454 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
340083bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340083c0:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340083c4:	4b7b      	ldr	r3, [pc, #492]	@ (340085b4 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
340083c6:	429a      	cmp	r2, r3
340083c8:	d116      	bne.n	340083f8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340083ca:	4b77      	ldr	r3, [pc, #476]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340083cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340083d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340083d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340083d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340083dc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340083de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340083e2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340083e4:	3b01      	subs	r3, #1
340083e6:	041b      	lsls	r3, r3, #16
340083e8:	4313      	orrs	r3, r2
340083ea:	4a6f      	ldr	r2, [pc, #444]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340083ec:	430b      	orrs	r3, r1
340083ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340083f2:	f7fd ffa5 	bl	34006340 <LL_RCC_IC9_Enable>
340083f6:	e026      	b.n	34008446 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
340083f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340083fc:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34008400:	4b6d      	ldr	r3, [pc, #436]	@ (340085b8 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
34008402:	429a      	cmp	r2, r3
34008404:	d116      	bne.n	34008434 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34008406:	4b68      	ldr	r3, [pc, #416]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008408:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400840c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008410:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008414:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008418:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400841a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400841e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34008420:	3b01      	subs	r3, #1
34008422:	041b      	lsls	r3, r3, #16
34008424:	4313      	orrs	r3, r2
34008426:	4a60      	ldr	r2, [pc, #384]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008428:	430b      	orrs	r3, r1
3400842a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400842e:	f7fd ffbf 	bl	340063b0 <LL_RCC_IC14_Enable>
34008432:	e008      	b.n	34008446 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34008434:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008438:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400843c:	4b5f      	ldr	r3, [pc, #380]	@ (340085bc <HAL_RCCEx_PeriphCLKConfig+0x212c>)
3400843e:	429a      	cmp	r2, r3
34008440:	d101      	bne.n	34008446 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
34008442:	f7fe f817 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
34008446:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400844a:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3400844e:	4618      	mov	r0, r3
34008450:	f7fd fec9 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
34008454:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008458:	e9d3 2300 	ldrd	r2, r3, [r3]
3400845c:	2100      	movs	r1, #0
3400845e:	64b9      	str	r1, [r7, #72]	@ 0x48
34008460:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34008464:	64fb      	str	r3, [r7, #76]	@ 0x4c
34008466:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3400846a:	4603      	mov	r3, r0
3400846c:	460a      	mov	r2, r1
3400846e:	4313      	orrs	r3, r2
34008470:	d04b      	beq.n	3400850a <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34008472:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008476:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400847a:	4b51      	ldr	r3, [pc, #324]	@ (340085c0 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
3400847c:	429a      	cmp	r2, r3
3400847e:	d116      	bne.n	340084ae <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008480:	4b49      	ldr	r3, [pc, #292]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008482:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34008486:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400848a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400848e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008492:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34008494:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008498:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400849a:	3b01      	subs	r3, #1
3400849c:	041b      	lsls	r3, r3, #16
3400849e:	4313      	orrs	r3, r2
340084a0:	4a41      	ldr	r2, [pc, #260]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340084a2:	430b      	orrs	r3, r1
340084a4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340084a8:	f7fd ff4a 	bl	34006340 <LL_RCC_IC9_Enable>
340084ac:	e026      	b.n	340084fc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
340084ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340084b2:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340084b6:	4b43      	ldr	r3, [pc, #268]	@ (340085c4 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
340084b8:	429a      	cmp	r2, r3
340084ba:	d116      	bne.n	340084ea <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340084bc:	4b3a      	ldr	r3, [pc, #232]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340084be:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340084c2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340084c6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340084ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340084ce:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340084d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340084d4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340084d6:	3b01      	subs	r3, #1
340084d8:	041b      	lsls	r3, r3, #16
340084da:	4313      	orrs	r3, r2
340084dc:	4a32      	ldr	r2, [pc, #200]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340084de:	430b      	orrs	r3, r1
340084e0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340084e4:	f7fd ff64 	bl	340063b0 <LL_RCC_IC14_Enable>
340084e8:	e008      	b.n	340084fc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
340084ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340084ee:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340084f2:	4b35      	ldr	r3, [pc, #212]	@ (340085c8 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
340084f4:	429a      	cmp	r2, r3
340084f6:	d101      	bne.n	340084fc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
340084f8:	f7fd ffbc 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
340084fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008500:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34008504:	4618      	mov	r0, r3
34008506:	f7fd fe6e 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400850a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400850e:	e9d3 2300 	ldrd	r2, r3, [r3]
34008512:	2100      	movs	r1, #0
34008514:	6439      	str	r1, [r7, #64]	@ 0x40
34008516:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400851a:	647b      	str	r3, [r7, #68]	@ 0x44
3400851c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34008520:	4603      	mov	r3, r0
34008522:	460a      	mov	r2, r1
34008524:	4313      	orrs	r3, r2
34008526:	d065      	beq.n	340085f4 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34008528:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400852c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34008530:	4b26      	ldr	r3, [pc, #152]	@ (340085cc <HAL_RCCEx_PeriphCLKConfig+0x213c>)
34008532:	429a      	cmp	r2, r3
34008534:	d116      	bne.n	34008564 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008536:	4b1c      	ldr	r3, [pc, #112]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008538:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400853c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008540:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008548:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400854a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400854e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34008550:	3b01      	subs	r3, #1
34008552:	041b      	lsls	r3, r3, #16
34008554:	4313      	orrs	r3, r2
34008556:	4a14      	ldr	r2, [pc, #80]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008558:	430b      	orrs	r3, r1
3400855a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400855e:	f7fd feef 	bl	34006340 <LL_RCC_IC9_Enable>
34008562:	e040      	b.n	340085e6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34008564:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008568:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400856c:	4b18      	ldr	r3, [pc, #96]	@ (340085d0 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
3400856e:	429a      	cmp	r2, r3
34008570:	d130      	bne.n	340085d4 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34008572:	4b0d      	ldr	r3, [pc, #52]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008574:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008578:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400857c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008580:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008584:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34008586:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400858a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400858c:	3b01      	subs	r3, #1
3400858e:	041b      	lsls	r3, r3, #16
34008590:	4313      	orrs	r3, r2
34008592:	4a05      	ldr	r2, [pc, #20]	@ (340085a8 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34008594:	430b      	orrs	r3, r1
34008596:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400859a:	f7fd ff09 	bl	340063b0 <LL_RCC_IC14_Enable>
3400859e:	e022      	b.n	340085e6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
340085a0:	07010830 	.word	0x07010830
340085a4:	07020c30 	.word	0x07020c30
340085a8:	56028000 	.word	0x56028000
340085ac:	07030c30 	.word	0x07030c30
340085b0:	07010c30 	.word	0x07010c30
340085b4:	07021030 	.word	0x07021030
340085b8:	07031030 	.word	0x07031030
340085bc:	07011030 	.word	0x07011030
340085c0:	07021430 	.word	0x07021430
340085c4:	07031430 	.word	0x07031430
340085c8:	07011430 	.word	0x07011430
340085cc:	07021830 	.word	0x07021830
340085d0:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
340085d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340085d8:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
340085dc:	4bc8      	ldr	r3, [pc, #800]	@ (34008900 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
340085de:	429a      	cmp	r2, r3
340085e0:	d101      	bne.n	340085e6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
340085e2:	f7fd ff47 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
340085e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340085ea:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
340085ee:	4618      	mov	r0, r3
340085f0:	f7fd fdf9 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
340085f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340085f8:	e9d3 2300 	ldrd	r2, r3, [r3]
340085fc:	2100      	movs	r1, #0
340085fe:	63b9      	str	r1, [r7, #56]	@ 0x38
34008600:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34008604:	63fb      	str	r3, [r7, #60]	@ 0x3c
34008606:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
3400860a:	4603      	mov	r3, r0
3400860c:	460a      	mov	r2, r1
3400860e:	4313      	orrs	r3, r2
34008610:	d04b      	beq.n	340086aa <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34008612:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008616:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400861a:	4bba      	ldr	r3, [pc, #744]	@ (34008904 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400861c:	429a      	cmp	r2, r3
3400861e:	d116      	bne.n	3400864e <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34008620:	4bb9      	ldr	r3, [pc, #740]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34008622:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34008626:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400862a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400862e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008632:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34008634:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008638:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400863a:	3b01      	subs	r3, #1
3400863c:	041b      	lsls	r3, r3, #16
3400863e:	4313      	orrs	r3, r2
34008640:	4ab1      	ldr	r2, [pc, #708]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34008642:	430b      	orrs	r3, r1
34008644:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34008648:	f7fd fe7a 	bl	34006340 <LL_RCC_IC9_Enable>
3400864c:	e026      	b.n	3400869c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400864e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008652:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34008656:	4bad      	ldr	r3, [pc, #692]	@ (3400890c <HAL_RCCEx_PeriphCLKConfig+0x247c>)
34008658:	429a      	cmp	r2, r3
3400865a:	d116      	bne.n	3400868a <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400865c:	4baa      	ldr	r3, [pc, #680]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400865e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008662:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008666:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400866a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400866e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34008670:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008674:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34008676:	3b01      	subs	r3, #1
34008678:	041b      	lsls	r3, r3, #16
3400867a:	4313      	orrs	r3, r2
3400867c:	4aa2      	ldr	r2, [pc, #648]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400867e:	430b      	orrs	r3, r1
34008680:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34008684:	f7fd fe94 	bl	340063b0 <LL_RCC_IC14_Enable>
34008688:	e008      	b.n	3400869c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400868a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400868e:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34008692:	4b9f      	ldr	r3, [pc, #636]	@ (34008910 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34008694:	429a      	cmp	r2, r3
34008696:	d101      	bne.n	3400869c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
34008698:	f7fd feec 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
3400869c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340086a0:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
340086a4:	4618      	mov	r0, r3
340086a6:	f7fd fd9e 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
340086aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340086ae:	e9d3 2300 	ldrd	r2, r3, [r3]
340086b2:	2100      	movs	r1, #0
340086b4:	6339      	str	r1, [r7, #48]	@ 0x30
340086b6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340086ba:	637b      	str	r3, [r7, #52]	@ 0x34
340086bc:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
340086c0:	4603      	mov	r3, r0
340086c2:	460a      	mov	r2, r1
340086c4:	4313      	orrs	r3, r2
340086c6:	d04b      	beq.n	34008760 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
340086c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340086cc:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340086d0:	4a90      	ldr	r2, [pc, #576]	@ (34008914 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
340086d2:	4293      	cmp	r3, r2
340086d4:	d116      	bne.n	34008704 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340086d6:	4b8c      	ldr	r3, [pc, #560]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340086d8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340086dc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340086e0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340086e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340086e8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340086ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340086ee:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340086f0:	3b01      	subs	r3, #1
340086f2:	041b      	lsls	r3, r3, #16
340086f4:	4313      	orrs	r3, r2
340086f6:	4a84      	ldr	r2, [pc, #528]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340086f8:	430b      	orrs	r3, r1
340086fa:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340086fe:	f7fd fe1f 	bl	34006340 <LL_RCC_IC9_Enable>
34008702:	e026      	b.n	34008752 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34008704:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008708:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400870c:	4a82      	ldr	r2, [pc, #520]	@ (34008918 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3400870e:	4293      	cmp	r3, r2
34008710:	d116      	bne.n	34008740 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34008712:	4b7d      	ldr	r3, [pc, #500]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34008714:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34008718:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400871c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008720:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008724:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34008726:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400872a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400872c:	3b01      	subs	r3, #1
3400872e:	041b      	lsls	r3, r3, #16
34008730:	4313      	orrs	r3, r2
34008732:	4a75      	ldr	r2, [pc, #468]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34008734:	430b      	orrs	r3, r1
34008736:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400873a:	f7fd fe39 	bl	340063b0 <LL_RCC_IC14_Enable>
3400873e:	e008      	b.n	34008752 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34008740:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008744:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34008748:	4a74      	ldr	r2, [pc, #464]	@ (3400891c <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3400874a:	4293      	cmp	r3, r2
3400874c:	d101      	bne.n	34008752 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
3400874e:	f7fd fe91 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
34008752:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008756:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400875a:	4618      	mov	r0, r3
3400875c:	f7fd fd43 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34008760:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008764:	e9d3 2300 	ldrd	r2, r3, [r3]
34008768:	2100      	movs	r1, #0
3400876a:	62b9      	str	r1, [r7, #40]	@ 0x28
3400876c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34008770:	62fb      	str	r3, [r7, #44]	@ 0x2c
34008772:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
34008776:	4603      	mov	r3, r0
34008778:	460a      	mov	r2, r1
3400877a:	4313      	orrs	r3, r2
3400877c:	d04b      	beq.n	34008816 <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3400877e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008782:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34008786:	4a66      	ldr	r2, [pc, #408]	@ (34008920 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
34008788:	4293      	cmp	r3, r2
3400878a:	d116      	bne.n	340087ba <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400878c:	4b5e      	ldr	r3, [pc, #376]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400878e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34008792:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34008796:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400879a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400879e:	6c91      	ldr	r1, [r2, #72]	@ 0x48
340087a0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340087a4:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
340087a6:	3a01      	subs	r2, #1
340087a8:	0412      	lsls	r2, r2, #16
340087aa:	430a      	orrs	r2, r1
340087ac:	4956      	ldr	r1, [pc, #344]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340087ae:	4313      	orrs	r3, r2
340087b0:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340087b4:	f7fd fdc4 	bl	34006340 <LL_RCC_IC9_Enable>
340087b8:	e026      	b.n	34008808 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
340087ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340087be:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
340087c2:	4a58      	ldr	r2, [pc, #352]	@ (34008924 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
340087c4:	4293      	cmp	r3, r2
340087c6:	d116      	bne.n	340087f6 <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340087c8:	4b4f      	ldr	r3, [pc, #316]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340087ca:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340087ce:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340087d2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340087d6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340087da:	6f11      	ldr	r1, [r2, #112]	@ 0x70
340087dc:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340087e0:	6f52      	ldr	r2, [r2, #116]	@ 0x74
340087e2:	3a01      	subs	r2, #1
340087e4:	0412      	lsls	r2, r2, #16
340087e6:	430a      	orrs	r2, r1
340087e8:	4947      	ldr	r1, [pc, #284]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340087ea:	4313      	orrs	r3, r2
340087ec:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340087f0:	f7fd fdde 	bl	340063b0 <LL_RCC_IC14_Enable>
340087f4:	e008      	b.n	34008808 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
340087f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340087fa:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
340087fe:	4a4a      	ldr	r2, [pc, #296]	@ (34008928 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
34008800:	4293      	cmp	r3, r2
34008802:	d101      	bne.n	34008808 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34008804:	f7fd fe36 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34008808:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400880c:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34008810:	4618      	mov	r0, r3
34008812:	f7fd fce8 	bl	340061e6 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34008816:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400881a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400881e:	2100      	movs	r1, #0
34008820:	6239      	str	r1, [r7, #32]
34008822:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34008826:	627b      	str	r3, [r7, #36]	@ 0x24
34008828:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
3400882c:	4603      	mov	r3, r0
3400882e:	460a      	mov	r2, r1
34008830:	4313      	orrs	r3, r2
34008832:	d014      	beq.n	3400885e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34008834:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008838:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400883c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34008840:	4618      	mov	r0, r3
34008842:	f7fd fc78 	bl	34006136 <LL_RCC_SetOTGPHYCKREFClockSource>
34008846:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400884a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400884e:	0fdb      	lsrs	r3, r3, #31
34008850:	2b01      	cmp	r3, #1
34008852:	d102      	bne.n	3400885a <HAL_RCCEx_PeriphCLKConfig+0x23ca>
34008854:	f7fd faee 	bl	34005e34 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34008858:	e001      	b.n	3400885e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
3400885a:	f7fd fadb 	bl	34005e14 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400885e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008862:	e9d3 2300 	ldrd	r2, r3, [r3]
34008866:	2100      	movs	r1, #0
34008868:	61b9      	str	r1, [r7, #24]
3400886a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400886e:	61fb      	str	r3, [r7, #28]
34008870:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34008874:	4603      	mov	r3, r0
34008876:	460a      	mov	r2, r1
34008878:	4313      	orrs	r3, r2
3400887a:	d014      	beq.n	340088a6 <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400887c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008880:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34008884:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34008888:	4618      	mov	r0, r3
3400888a:	f7fd fc54 	bl	34006136 <LL_RCC_SetOTGPHYCKREFClockSource>
3400888e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008892:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34008896:	0fdb      	lsrs	r3, r3, #31
34008898:	2b01      	cmp	r3, #1
3400889a:	d102      	bne.n	340088a2 <HAL_RCCEx_PeriphCLKConfig+0x2412>
3400889c:	f7fd faca 	bl	34005e34 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
340088a0:	e001      	b.n	340088a6 <HAL_RCCEx_PeriphCLKConfig+0x2416>
340088a2:	f7fd fab7 	bl	34005e14 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
340088a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088aa:	e9d3 2300 	ldrd	r2, r3, [r3]
340088ae:	2100      	movs	r1, #0
340088b0:	6139      	str	r1, [r7, #16]
340088b2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
340088b6:	617b      	str	r3, [r7, #20]
340088b8:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
340088bc:	4603      	mov	r3, r0
340088be:	460a      	mov	r2, r1
340088c0:	4313      	orrs	r3, r2
340088c2:	d053      	beq.n	3400896c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
340088c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088c8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
340088cc:	4a17      	ldr	r2, [pc, #92]	@ (3400892c <HAL_RCCEx_PeriphCLKConfig+0x249c>)
340088ce:	4293      	cmp	r3, r2
340088d0:	d12e      	bne.n	34008930 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340088d2:	4b0d      	ldr	r3, [pc, #52]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340088d4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340088d8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340088dc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340088e0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340088e4:	6f91      	ldr	r1, [r2, #120]	@ 0x78
340088e6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340088ea:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340088ec:	3a01      	subs	r2, #1
340088ee:	0412      	lsls	r2, r2, #16
340088f0:	430a      	orrs	r2, r1
340088f2:	4905      	ldr	r1, [pc, #20]	@ (34008908 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
340088f4:	4313      	orrs	r3, r2
340088f6:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340088fa:	f7fd fd67 	bl	340063cc <LL_RCC_IC15_Enable>
340088fe:	e020      	b.n	34008942 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
34008900:	07011830 	.word	0x07011830
34008904:	07021c30 	.word	0x07021c30
34008908:	56028000 	.word	0x56028000
3400890c:	07031c30 	.word	0x07031c30
34008910:	07011c30 	.word	0x07011c30
34008914:	07020034 	.word	0x07020034
34008918:	07030034 	.word	0x07030034
3400891c:	07010034 	.word	0x07010034
34008920:	07020434 	.word	0x07020434
34008924:	07030434 	.word	0x07030434
34008928:	07010434 	.word	0x07010434
3400892c:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34008930:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008934:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34008938:	4a43      	ldr	r2, [pc, #268]	@ (34008a48 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
3400893a:	4293      	cmp	r3, r2
3400893c:	d101      	bne.n	34008942 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
3400893e:	f7fd fd99 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34008942:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008946:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400894a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400894e:	4618      	mov	r0, r3
34008950:	f7fd fbe6 	bl	34006120 <LL_RCC_SetOTGPHYClockSource>
34008954:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008958:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400895c:	0fdb      	lsrs	r3, r3, #31
3400895e:	2b01      	cmp	r3, #1
34008960:	d102      	bne.n	34008968 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
34008962:	f7fd fa67 	bl	34005e34 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34008966:	e001      	b.n	3400896c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
34008968:	f7fd fa54 	bl	34005e14 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3400896c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008970:	e9d3 2300 	ldrd	r2, r3, [r3]
34008974:	2100      	movs	r1, #0
34008976:	60b9      	str	r1, [r7, #8]
34008978:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400897c:	60fb      	str	r3, [r7, #12]
3400897e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34008982:	4603      	mov	r3, r0
34008984:	460a      	mov	r2, r1
34008986:	4313      	orrs	r3, r2
34008988:	d03b      	beq.n	34008a02 <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3400898a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400898e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34008992:	4a2e      	ldr	r2, [pc, #184]	@ (34008a4c <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
34008994:	4293      	cmp	r3, r2
34008996:	d116      	bne.n	340089c6 <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34008998:	4b2d      	ldr	r3, [pc, #180]	@ (34008a50 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
3400899a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400899e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340089a2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340089a6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340089aa:	6f91      	ldr	r1, [r2, #120]	@ 0x78
340089ac:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340089b0:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340089b2:	3a01      	subs	r2, #1
340089b4:	0412      	lsls	r2, r2, #16
340089b6:	430a      	orrs	r2, r1
340089b8:	4925      	ldr	r1, [pc, #148]	@ (34008a50 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
340089ba:	4313      	orrs	r3, r2
340089bc:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340089c0:	f7fd fd04 	bl	340063cc <LL_RCC_IC15_Enable>
340089c4:	e008      	b.n	340089d8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
340089c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089ca:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340089ce:	4a21      	ldr	r2, [pc, #132]	@ (34008a54 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
340089d0:	4293      	cmp	r3, r2
340089d2:	d101      	bne.n	340089d8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
340089d4:	f7fd fd4e 	bl	34006474 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
340089d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089dc:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340089e0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
340089e4:	4618      	mov	r0, r3
340089e6:	f7fd fb9b 	bl	34006120 <LL_RCC_SetOTGPHYClockSource>
340089ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089ee:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
340089f2:	0fdb      	lsrs	r3, r3, #31
340089f4:	2b01      	cmp	r3, #1
340089f6:	d102      	bne.n	340089fe <HAL_RCCEx_PeriphCLKConfig+0x256e>
340089f8:	f7fd fa1c 	bl	34005e34 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
340089fc:	e001      	b.n	34008a02 <HAL_RCCEx_PeriphCLKConfig+0x2572>
340089fe:	f7fd fa09 	bl	34005e14 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34008a02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a06:	e9d3 2300 	ldrd	r2, r3, [r3]
34008a0a:	2100      	movs	r1, #0
34008a0c:	6039      	str	r1, [r7, #0]
34008a0e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34008a12:	607b      	str	r3, [r7, #4]
34008a14:	e9d7 0100 	ldrd	r0, r1, [r7]
34008a18:	4603      	mov	r3, r0
34008a1a:	460a      	mov	r2, r1
34008a1c:	4313      	orrs	r3, r2
34008a1e:	d006      	beq.n	34008a2e <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
34008a20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a24:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34008a28:	4618      	mov	r0, r3
34008a2a:	f7fd fc2d 	bl	34006288 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
34008a2e:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
34008a32:	2b00      	cmp	r3, #0
34008a34:	d101      	bne.n	34008a3a <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
34008a36:	2300      	movs	r3, #0
34008a38:	e000      	b.n	34008a3c <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
34008a3a:	2301      	movs	r3, #1
}
34008a3c:	4618      	mov	r0, r3
34008a3e:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
34008a42:	46bd      	mov	sp, r7
34008a44:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34008a48:	03010c14 	.word	0x03010c14
34008a4c:	03021414 	.word	0x03021414
34008a50:	56028000 	.word	0x56028000
34008a54:	03011414 	.word	0x03011414

34008a58 <msdi_openfn>:

/*
 * Open function
 */
LOCAL ER msdi_openfn( ID devid, UINT omode, T_MSDI *msdi )
{
34008a58:	b580      	push	{r7, lr}
34008a5a:	b086      	sub	sp, #24
34008a5c:	af00      	add	r7, sp, #0
34008a5e:	60f8      	str	r0, [r7, #12]
34008a60:	60b9      	str	r1, [r7, #8]
34008a62:	607a      	str	r2, [r7, #4]
	ER	err;

	if ( msdi->dmsdi.openfn == NULL ) return E_OK;
34008a64:	687b      	ldr	r3, [r7, #4]
34008a66:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34008a68:	2b00      	cmp	r3, #0
34008a6a:	d101      	bne.n	34008a70 <msdi_openfn+0x18>
34008a6c:	2300      	movs	r3, #0
34008a6e:	e011      	b.n	34008a94 <msdi_openfn+0x3c>

	Lock(&msdi->lock);
34008a70:	687b      	ldr	r3, [r7, #4]
34008a72:	3304      	adds	r3, #4
34008a74:	4618      	mov	r0, r3
34008a76:	f003 fa85 	bl	3400bf84 <Lock>
	err = (*msdi->dmsdi.openfn)(devid, omode, msdi);
34008a7a:	687b      	ldr	r3, [r7, #4]
34008a7c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34008a7e:	687a      	ldr	r2, [r7, #4]
34008a80:	68b9      	ldr	r1, [r7, #8]
34008a82:	68f8      	ldr	r0, [r7, #12]
34008a84:	4798      	blx	r3
34008a86:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
34008a88:	687b      	ldr	r3, [r7, #4]
34008a8a:	3304      	adds	r3, #4
34008a8c:	4618      	mov	r0, r3
34008a8e:	f003 fa8f 	bl	3400bfb0 <Unlock>

	return err;
34008a92:	697b      	ldr	r3, [r7, #20]
}
34008a94:	4618      	mov	r0, r3
34008a96:	3718      	adds	r7, #24
34008a98:	46bd      	mov	sp, r7
34008a9a:	bd80      	pop	{r7, pc}

34008a9c <msdi_closefn>:

/*
 * Close cunction
 */
LOCAL ER msdi_closefn( ID devid, UINT option, T_MSDI *msdi )
{
34008a9c:	b580      	push	{r7, lr}
34008a9e:	b086      	sub	sp, #24
34008aa0:	af00      	add	r7, sp, #0
34008aa2:	60f8      	str	r0, [r7, #12]
34008aa4:	60b9      	str	r1, [r7, #8]
34008aa6:	607a      	str	r2, [r7, #4]
	ER	err;

	if ( msdi->dmsdi.closefn == NULL ) return E_OK;
34008aa8:	687b      	ldr	r3, [r7, #4]
34008aaa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34008aac:	2b00      	cmp	r3, #0
34008aae:	d101      	bne.n	34008ab4 <msdi_closefn+0x18>
34008ab0:	2300      	movs	r3, #0
34008ab2:	e011      	b.n	34008ad8 <msdi_closefn+0x3c>

	Lock(&msdi->lock);
34008ab4:	687b      	ldr	r3, [r7, #4]
34008ab6:	3304      	adds	r3, #4
34008ab8:	4618      	mov	r0, r3
34008aba:	f003 fa63 	bl	3400bf84 <Lock>
	err = (*msdi->dmsdi.closefn)(devid, option, msdi);
34008abe:	687b      	ldr	r3, [r7, #4]
34008ac0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34008ac2:	687a      	ldr	r2, [r7, #4]
34008ac4:	68b9      	ldr	r1, [r7, #8]
34008ac6:	68f8      	ldr	r0, [r7, #12]
34008ac8:	4798      	blx	r3
34008aca:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
34008acc:	687b      	ldr	r3, [r7, #4]
34008ace:	3304      	adds	r3, #4
34008ad0:	4618      	mov	r0, r3
34008ad2:	f003 fa6d 	bl	3400bfb0 <Unlock>

	return err;
34008ad6:	697b      	ldr	r3, [r7, #20]
}
34008ad8:	4618      	mov	r0, r3
34008ada:	3718      	adds	r7, #24
34008adc:	46bd      	mov	sp, r7
34008ade:	bd80      	pop	{r7, pc}

34008ae0 <msdi_execfn>:

/*
 * Processing start function
 */
LOCAL ER msdi_execfn( T_DEVREQ *req, TMO tmout, T_MSDI *msdi )
{
34008ae0:	b580      	push	{r7, lr}
34008ae2:	b086      	sub	sp, #24
34008ae4:	af00      	add	r7, sp, #0
34008ae6:	60f8      	str	r0, [r7, #12]
34008ae8:	60b9      	str	r1, [r7, #8]
34008aea:	607a      	str	r2, [r7, #4]
	INT	(*fp)( T_DEVREQ*, T_MSDI* );
	ER	err;

	fp = ( req->cmd == TDC_READ )? msdi->dmsdi.readfn: msdi->dmsdi.writefn;
34008aec:	68fb      	ldr	r3, [r7, #12]
34008aee:	7b1b      	ldrb	r3, [r3, #12]
34008af0:	f003 030f 	and.w	r3, r3, #15
34008af4:	b2db      	uxtb	r3, r3
34008af6:	2b01      	cmp	r3, #1
34008af8:	d102      	bne.n	34008b00 <msdi_execfn+0x20>
34008afa:	687b      	ldr	r3, [r7, #4]
34008afc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34008afe:	e001      	b.n	34008b04 <msdi_execfn+0x24>
34008b00:	687b      	ldr	r3, [r7, #4]
34008b02:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34008b04:	617b      	str	r3, [r7, #20]
	if ( fp == NULL ) return E_NOSPT;
34008b06:	697b      	ldr	r3, [r7, #20]
34008b08:	2b00      	cmp	r3, #0
34008b0a:	d102      	bne.n	34008b12 <msdi_execfn+0x32>
34008b0c:	f06f 0308 	mvn.w	r3, #8
34008b10:	e01d      	b.n	34008b4e <msdi_execfn+0x6e>

	if ( req->start >= 0 && msdi->dmsdi.blksz <= 0) return E_NOSPT;
34008b12:	68fb      	ldr	r3, [r7, #12]
34008b14:	691b      	ldr	r3, [r3, #16]
34008b16:	2b00      	cmp	r3, #0
34008b18:	db06      	blt.n	34008b28 <msdi_execfn+0x48>
34008b1a:	687b      	ldr	r3, [r7, #4]
34008b1c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34008b1e:	2b00      	cmp	r3, #0
34008b20:	dc02      	bgt.n	34008b28 <msdi_execfn+0x48>
34008b22:	f06f 0308 	mvn.w	r3, #8
34008b26:	e012      	b.n	34008b4e <msdi_execfn+0x6e>

	/* I/O processing */
	Lock(&msdi->lock);
34008b28:	687b      	ldr	r3, [r7, #4]
34008b2a:	3304      	adds	r3, #4
34008b2c:	4618      	mov	r0, r3
34008b2e:	f003 fa29 	bl	3400bf84 <Lock>
	err = (*fp)(req, msdi);
34008b32:	697b      	ldr	r3, [r7, #20]
34008b34:	6879      	ldr	r1, [r7, #4]
34008b36:	68f8      	ldr	r0, [r7, #12]
34008b38:	4798      	blx	r3
34008b3a:	6138      	str	r0, [r7, #16]
	Unlock(&msdi->lock);
34008b3c:	687b      	ldr	r3, [r7, #4]
34008b3e:	3304      	adds	r3, #4
34008b40:	4618      	mov	r0, r3
34008b42:	f003 fa35 	bl	3400bfb0 <Unlock>

	req->error = err;
34008b46:	68fb      	ldr	r3, [r7, #12]
34008b48:	693a      	ldr	r2, [r7, #16]
34008b4a:	621a      	str	r2, [r3, #32]
	return E_OK;
34008b4c:	2300      	movs	r3, #0
}
34008b4e:	4618      	mov	r0, r3
34008b50:	3718      	adds	r7, #24
34008b52:	46bd      	mov	sp, r7
34008b54:	bd80      	pop	{r7, pc}

34008b56 <msdi_waitfn>:

/*
 * Wait-for-completion function
 */
LOCAL INT msdi_waitfn( T_DEVREQ *req, INT nreq, TMO tmout, T_MSDI *msdi )
{
34008b56:	b480      	push	{r7}
34008b58:	b085      	sub	sp, #20
34008b5a:	af00      	add	r7, sp, #0
34008b5c:	60f8      	str	r0, [r7, #12]
34008b5e:	60b9      	str	r1, [r7, #8]
34008b60:	607a      	str	r2, [r7, #4]
34008b62:	603b      	str	r3, [r7, #0]
	return 0;
34008b64:	2300      	movs	r3, #0
}
34008b66:	4618      	mov	r0, r3
34008b68:	3714      	adds	r7, #20
34008b6a:	46bd      	mov	sp, r7
34008b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b70:	4770      	bx	lr

34008b72 <msdi_abortfn>:

/*
 * Abort processing function
 */
LOCAL ER msdi_abortfn( ID tskid, T_DEVREQ *req, INT nreq, T_MSDI *msdi )
{
34008b72:	b480      	push	{r7}
34008b74:	b085      	sub	sp, #20
34008b76:	af00      	add	r7, sp, #0
34008b78:	60f8      	str	r0, [r7, #12]
34008b7a:	60b9      	str	r1, [r7, #8]
34008b7c:	607a      	str	r2, [r7, #4]
34008b7e:	603b      	str	r3, [r7, #0]
	return E_OK;
34008b80:	2300      	movs	r3, #0
}
34008b82:	4618      	mov	r0, r3
34008b84:	3714      	adds	r7, #20
34008b86:	46bd      	mov	sp, r7
34008b88:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b8c:	4770      	bx	lr

34008b8e <msdi_eventfn>:

/*
 * Event function
 */
LOCAL INT msdi_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi )
{
34008b8e:	b580      	push	{r7, lr}
34008b90:	b086      	sub	sp, #24
34008b92:	af00      	add	r7, sp, #0
34008b94:	60f8      	str	r0, [r7, #12]
34008b96:	60b9      	str	r1, [r7, #8]
34008b98:	607a      	str	r2, [r7, #4]
	INT	ret;

	if ( msdi->dmsdi.eventfn == NULL ) return E_OK;
34008b9a:	687b      	ldr	r3, [r7, #4]
34008b9c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34008b9e:	2b00      	cmp	r3, #0
34008ba0:	d101      	bne.n	34008ba6 <msdi_eventfn+0x18>
34008ba2:	2300      	movs	r3, #0
34008ba4:	e011      	b.n	34008bca <msdi_eventfn+0x3c>

	Lock(&msdi->lock);
34008ba6:	687b      	ldr	r3, [r7, #4]
34008ba8:	3304      	adds	r3, #4
34008baa:	4618      	mov	r0, r3
34008bac:	f003 f9ea 	bl	3400bf84 <Lock>
	ret = (*msdi->dmsdi.eventfn)(evttyp, evtinf, msdi);
34008bb0:	687b      	ldr	r3, [r7, #4]
34008bb2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34008bb4:	687a      	ldr	r2, [r7, #4]
34008bb6:	68b9      	ldr	r1, [r7, #8]
34008bb8:	68f8      	ldr	r0, [r7, #12]
34008bba:	4798      	blx	r3
34008bbc:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
34008bbe:	687b      	ldr	r3, [r7, #4]
34008bc0:	3304      	adds	r3, #4
34008bc2:	4618      	mov	r0, r3
34008bc4:	f003 f9f4 	bl	3400bfb0 <Unlock>

	return ret;
34008bc8:	697b      	ldr	r3, [r7, #20]
}
34008bca:	4618      	mov	r0, r3
34008bcc:	3718      	adds	r7, #24
34008bce:	46bd      	mov	sp, r7
34008bd0:	bd80      	pop	{r7, pc}
	...

34008bd4 <msdi_def_dev>:

/*
 * SDI Device registration
 */
EXPORT ER msdi_def_dev( T_DMSDI *dmsdi, T_IDEV *idev, T_MSDI **p_msdi )
{
34008bd4:	b5b0      	push	{r4, r5, r7, lr}
34008bd6:	b092      	sub	sp, #72	@ 0x48
34008bd8:	af00      	add	r7, sp, #0
34008bda:	60f8      	str	r0, [r7, #12]
34008bdc:	60b9      	str	r1, [r7, #8]
34008bde:	607a      	str	r2, [r7, #4]
	T_MSDI	*msdi;
	T_DDEV	ddev;
	ER	err;

	/* Create "SDI"*/
	msdi = Kmalloc(sizeof(T_MSDI));
34008be0:	2044      	movs	r0, #68	@ 0x44
34008be2:	f003 fb6f 	bl	3400c2c4 <Kmalloc>
34008be6:	6438      	str	r0, [r7, #64]	@ 0x40
	if ( msdi == NULL ) {
34008be8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008bea:	2b00      	cmp	r3, #0
34008bec:	d103      	bne.n	34008bf6 <msdi_def_dev+0x22>
		err = E_NOMEM;
34008bee:	f06f 0320 	mvn.w	r3, #32
34008bf2:	647b      	str	r3, [r7, #68]	@ 0x44
		goto err_ret1;
34008bf4:	e054      	b.n	34008ca0 <msdi_def_dev+0xcc>
	}

	msdi->dmsdi = *dmsdi;		/* Structure Copy */
34008bf6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008bf8:	68fa      	ldr	r2, [r7, #12]
34008bfa:	f103 0410 	add.w	r4, r3, #16
34008bfe:	4615      	mov	r5, r2
34008c00:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34008c02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34008c04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34008c06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34008c08:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34008c0a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34008c0c:	682b      	ldr	r3, [r5, #0]
34008c0e:	6023      	str	r3, [r4, #0]

	/* Create the lock for exclusive access control */
	err = CreateLock(&msdi->lock, dmsdi->devnm);
34008c10:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008c12:	1d1a      	adds	r2, r3, #4
34008c14:	68fb      	ldr	r3, [r7, #12]
34008c16:	3304      	adds	r3, #4
34008c18:	4619      	mov	r1, r3
34008c1a:	4610      	mov	r0, r2
34008c1c:	f003 f9dc 	bl	3400bfd8 <CreateLock>
34008c20:	6478      	str	r0, [r7, #68]	@ 0x44
	if ( err < E_OK ) goto err_ret2;
34008c22:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34008c24:	2b00      	cmp	r3, #0
34008c26:	db37      	blt.n	34008c98 <msdi_def_dev+0xc4>

	/* Device registration */
	ddev.exinf   = msdi;
34008c28:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008c2a:	617b      	str	r3, [r7, #20]
	ddev.drvatr  = dmsdi->drvatr;
34008c2c:	68fb      	ldr	r3, [r7, #12]
34008c2e:	691b      	ldr	r3, [r3, #16]
34008c30:	61bb      	str	r3, [r7, #24]
	ddev.devatr  = dmsdi->devatr;
34008c32:	68fb      	ldr	r3, [r7, #12]
34008c34:	695b      	ldr	r3, [r3, #20]
34008c36:	61fb      	str	r3, [r7, #28]
	ddev.nsub    = dmsdi->nsub;
34008c38:	68fb      	ldr	r3, [r7, #12]
34008c3a:	699b      	ldr	r3, [r3, #24]
34008c3c:	623b      	str	r3, [r7, #32]
	ddev.blksz   = dmsdi->blksz;
34008c3e:	68fb      	ldr	r3, [r7, #12]
34008c40:	69db      	ldr	r3, [r3, #28]
34008c42:	627b      	str	r3, [r7, #36]	@ 0x24
	ddev.openfn  = (FP)msdi_openfn;
34008c44:	4b19      	ldr	r3, [pc, #100]	@ (34008cac <msdi_def_dev+0xd8>)
34008c46:	62bb      	str	r3, [r7, #40]	@ 0x28
	ddev.closefn = (FP)msdi_closefn;
34008c48:	4b19      	ldr	r3, [pc, #100]	@ (34008cb0 <msdi_def_dev+0xdc>)
34008c4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
	ddev.execfn  = (FP)msdi_execfn;
34008c4c:	4b19      	ldr	r3, [pc, #100]	@ (34008cb4 <msdi_def_dev+0xe0>)
34008c4e:	633b      	str	r3, [r7, #48]	@ 0x30
	ddev.waitfn  = (FP)msdi_waitfn;
34008c50:	4b19      	ldr	r3, [pc, #100]	@ (34008cb8 <msdi_def_dev+0xe4>)
34008c52:	637b      	str	r3, [r7, #52]	@ 0x34
	ddev.abortfn = (FP)msdi_abortfn;
34008c54:	4b19      	ldr	r3, [pc, #100]	@ (34008cbc <msdi_def_dev+0xe8>)
34008c56:	63bb      	str	r3, [r7, #56]	@ 0x38
	ddev.eventfn = (FP)msdi_eventfn;
34008c58:	4b19      	ldr	r3, [pc, #100]	@ (34008cc0 <msdi_def_dev+0xec>)
34008c5a:	63fb      	str	r3, [r7, #60]	@ 0x3c

	err = tk_def_dev(msdi->dmsdi.devnm, &ddev, idev);
34008c5c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008c5e:	3314      	adds	r3, #20
34008c60:	f107 0114 	add.w	r1, r7, #20
34008c64:	68ba      	ldr	r2, [r7, #8]
34008c66:	4618      	mov	r0, r3
34008c68:	f000 f9ca 	bl	34009000 <tk_def_dev>
34008c6c:	6478      	str	r0, [r7, #68]	@ 0x44
	if ( err < E_OK )	goto err_ret3;
34008c6e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34008c70:	2b00      	cmp	r3, #0
34008c72:	db0a      	blt.n	34008c8a <msdi_def_dev+0xb6>
	
	msdi->devid = (ID)err;
34008c74:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008c76:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34008c78:	601a      	str	r2, [r3, #0]
	if(p_msdi != NULL) {
34008c7a:	687b      	ldr	r3, [r7, #4]
34008c7c:	2b00      	cmp	r3, #0
34008c7e:	d002      	beq.n	34008c86 <msdi_def_dev+0xb2>
		*p_msdi = msdi;
34008c80:	687b      	ldr	r3, [r7, #4]
34008c82:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34008c84:	601a      	str	r2, [r3, #0]
	}

	return E_OK;
34008c86:	2300      	movs	r3, #0
34008c88:	e00b      	b.n	34008ca2 <msdi_def_dev+0xce>
	if ( err < E_OK )	goto err_ret3;
34008c8a:	bf00      	nop

err_ret3:
	DeleteLock(&msdi->lock);
34008c8c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34008c8e:	3304      	adds	r3, #4
34008c90:	4618      	mov	r0, r3
34008c92:	f003 f9df 	bl	3400c054 <DeleteLock>
34008c96:	e000      	b.n	34008c9a <msdi_def_dev+0xc6>
	if ( err < E_OK ) goto err_ret2;
34008c98:	bf00      	nop
err_ret2:
	Kfree(msdi);
34008c9a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
34008c9c:	f003 fb1f 	bl	3400c2de <Kfree>
err_ret1:
	return err;
34008ca0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34008ca2:	4618      	mov	r0, r3
34008ca4:	3748      	adds	r7, #72	@ 0x48
34008ca6:	46bd      	mov	sp, r7
34008ca8:	bdb0      	pop	{r4, r5, r7, pc}
34008caa:	bf00      	nop
34008cac:	34008a59 	.word	0x34008a59
34008cb0:	34008a9d 	.word	0x34008a9d
34008cb4:	34008ae1 	.word	0x34008ae1
34008cb8:	34008b57 	.word	0x34008b57
34008cbc:	34008b73 	.word	0x34008b73
34008cc0:	34008b8f 	.word	0x34008b8f

34008cc4 <start_system>:
 * Start System
 *	Start each subsystem and each device driver.
 *	Return from function after starting.
 */
LOCAL ER start_system( void )
{
34008cc4:	b580      	push	{r7, lr}
34008cc6:	b082      	sub	sp, #8
34008cc8:	af00      	add	r7, sp, #0
	ER	ercd;

#if USE_DEVICE
	/* Initialize Device manager */
	ercd = knl_initialize_devmgr();
34008cca:	f000 fa83 	bl	340091d4 <knl_initialize_devmgr>
34008cce:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) return ercd;
34008cd0:	687b      	ldr	r3, [r7, #4]
34008cd2:	2b00      	cmp	r3, #0
34008cd4:	da01      	bge.n	34008cda <start_system+0x16>
34008cd6:	687b      	ldr	r3, [r7, #4]
34008cd8:	e003      	b.n	34008ce2 <start_system+0x1e>
#endif

	/* Start system dependent sequence */
	ercd = knl_start_device();
34008cda:	f004 fdb1 	bl	3400d840 <knl_start_device>
34008cde:	6078      	str	r0, [r7, #4]

	return ercd;
34008ce0:	687b      	ldr	r3, [r7, #4]
}
34008ce2:	4618      	mov	r0, r3
34008ce4:	3708      	adds	r7, #8
34008ce6:	46bd      	mov	sp, r7
34008ce8:	bd80      	pop	{r7, pc}
	...

34008cec <shutdown_system>:
 *		-3 : Normal re-start		(Boot -> Start)
 *
 *	fin are not always supported.
 */
LOCAL void shutdown_system( INT fin )
{
34008cec:	b580      	push	{r7, lr}
34008cee:	b082      	sub	sp, #8
34008cf0:	af00      	add	r7, sp, #0
34008cf2:	6078      	str	r0, [r7, #4]
#if USE_SHUTDOWN
	/* Platform dependent finalize sequence */
	knl_finish_device();
34008cf4:	f004 fddc 	bl	3400d8b0 <knl_finish_device>

	/* Shutdown message output */
	if ( fin >= 0 ) {
34008cf8:	687b      	ldr	r3, [r7, #4]
34008cfa:	2b00      	cmp	r3, #0
34008cfc:	db02      	blt.n	34008d04 <shutdown_system+0x18>
		SYSTEM_MESSAGE("\n<< SYSTEM SHUTDOWN >>\n");
34008cfe:	4807      	ldr	r0, [pc, #28]	@ (34008d1c <shutdown_system+0x30>)
34008d00:	f003 fb22 	bl	3400c348 <tm_putstring>
	}

	if ( fin < 0 ) {
34008d04:	687b      	ldr	r3, [r7, #4]
34008d06:	2b00      	cmp	r3, #0
34008d08:	da02      	bge.n	34008d10 <shutdown_system+0x24>
		/* Re-start sequence (platform dependent) */
		knl_restart_hw(fin);
34008d0a:	6878      	ldr	r0, [r7, #4]
34008d0c:	f004 fde6 	bl	3400d8dc <knl_restart_hw>
	}

	knl_tkernel_exit();		/* Stop system */
34008d10:	f000 f894 	bl	34008e3c <knl_tkernel_exit>
	DISABLE_INTERRUPT;
	for(;;) {
		;
	}
#endif /* USE_SHUTDOWN */
}
34008d14:	bf00      	nop
34008d16:	3708      	adds	r7, #8
34008d18:	46bd      	mov	sp, r7
34008d1a:	bd80      	pop	{r7, pc}
34008d1c:	3400dd0c 	.word	0x3400dd0c

34008d20 <init_task_main>:

/*
 * Initial task main
 */
LOCAL void init_task_main(void)
{
34008d20:	b580      	push	{r7, lr}
34008d22:	b082      	sub	sp, #8
34008d24:	af00      	add	r7, sp, #0
	INT	fin = 1;
34008d26:	2301      	movs	r3, #1
34008d28:	607b      	str	r3, [r7, #4]
	ER	ercd;

	ercd = start_system();		/* Start Sub-system & device driver */
34008d2a:	f7ff ffcb 	bl	34008cc4 <start_system>
34008d2e:	6038      	str	r0, [r7, #0]
	if(ercd  >= E_OK) {
34008d30:	683b      	ldr	r3, [r7, #0]
34008d32:	2b00      	cmp	r3, #0
34008d34:	db0b      	blt.n	34008d4e <init_task_main+0x2e>

#if (USE_SYSTEM_MESSAGE && USE_TMONITOR)
		tm_printf((UB*)"\n\nmicroT-Kernel Version %x.%02x\n\n", VER_MAJOR, VER_MINOR);
34008d36:	2200      	movs	r2, #0
34008d38:	2103      	movs	r1, #3
34008d3a:	480a      	ldr	r0, [pc, #40]	@ (34008d64 <init_task_main+0x44>)
34008d3c:	f003 fea4 	bl	3400ca88 <tm_printf>

#if USE_USERINIT
		/* Perform user defined initialization sequence */
		fin = (*(MAIN_FP)RI_USERINIT)(0, NULL);
#endif
		if ( fin > 0 ) {
34008d40:	687b      	ldr	r3, [r7, #4]
34008d42:	2b00      	cmp	r3, #0
34008d44:	dd06      	ble.n	34008d54 <init_task_main+0x34>
			fin = usermain();	/* User Main Program */
34008d46:	f7f7 fe9b 	bl	34000a80 <usermain>
34008d4a:	6078      	str	r0, [r7, #4]
34008d4c:	e002      	b.n	34008d54 <init_task_main+0x34>
		/* Perform user defined finalization sequence */
		(*(MAIN_FP)RI_USERINIT)(-1, NULL);
#endif

	} else {
		SYSTEM_MESSAGE("!ERROR! Init Task start\n");	/* Start message */
34008d4e:	4806      	ldr	r0, [pc, #24]	@ (34008d68 <init_task_main+0x48>)
34008d50:	f003 fafa 	bl	3400c348 <tm_putstring>
	}

	shutdown_system(fin);	/* Never return */
34008d54:	6878      	ldr	r0, [r7, #4]
34008d56:	f7ff ffc9 	bl	34008cec <shutdown_system>
}
34008d5a:	bf00      	nop
34008d5c:	3708      	adds	r7, #8
34008d5e:	46bd      	mov	sp, r7
34008d60:	bd80      	pop	{r7, pc}
34008d62:	bf00      	nop
34008d64:	3400dd24 	.word	0x3400dd24
34008d68:	3400dd48 	.word	0x3400dd48

34008d6c <knl_main>:
#ifndef ADD_PREFIX_KNL_TO_GLOBAL_NAME
EXPORT INT main( void )
#else
EXPORT INT knl_main( void )
#endif	/* ADD_PREFIX_KNL_TO_GLOBAL_NAME */
{
34008d6c:	b580      	push	{r7, lr}
34008d6e:	b082      	sub	sp, #8
34008d70:	af00      	add	r7, sp, #0
	ER	ercd;

	DISABLE_INTERRUPT;
34008d72:	f004 fe08 	bl	3400d986 <disint>

#if USE_TMONITOR
	/* Initialize T-Monitor Compatible Library */
	libtm_init();
34008d76:	f003 fabd 	bl	3400c2f4 <libtm_init>
#endif

#if USE_IMALLOC
	/* Initialize Internal memory allocation (Imalloc) */
	ercd = knl_init_Imalloc();
34008d7a:	f001 fac3 	bl	3400a304 <knl_init_Imalloc>
34008d7e:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34008d80:	687b      	ldr	r3, [r7, #4]
34008d82:	2b00      	cmp	r3, #0
34008d84:	da03      	bge.n	34008d8e <knl_main+0x22>
		SYSTEM_MESSAGE("!ERROR! init_Imalloc\n");
34008d86:	4825      	ldr	r0, [pc, #148]	@ (34008e1c <knl_main+0xb0>)
34008d88:	f003 fade 	bl	3400c348 <tm_putstring>
		goto err_ret;
34008d8c:	e044      	b.n	34008e18 <knl_main+0xac>
	}
#endif /* USE_IMALLOC */

	/* Initialize Device before micro T-Kernel starts */
	ercd = knl_init_device();
34008d8e:	f004 fd4f 	bl	3400d830 <knl_init_device>
34008d92:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34008d94:	687b      	ldr	r3, [r7, #4]
34008d96:	2b00      	cmp	r3, #0
34008d98:	da03      	bge.n	34008da2 <knl_main+0x36>
		SYSTEM_MESSAGE("!ERROR! init_device\n");
34008d9a:	4821      	ldr	r0, [pc, #132]	@ (34008e20 <knl_main+0xb4>)
34008d9c:	f003 fad4 	bl	3400c348 <tm_putstring>
		goto err_ret;
34008da0:	e03a      	b.n	34008e18 <knl_main+0xac>
	}

	/* Interrupt initialize */
	ercd = knl_init_interrupt();
34008da2:	f003 ff51 	bl	3400cc48 <knl_init_interrupt>
34008da6:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34008da8:	687b      	ldr	r3, [r7, #4]
34008daa:	2b00      	cmp	r3, #0
34008dac:	da03      	bge.n	34008db6 <knl_main+0x4a>
		SYSTEM_MESSAGE("!ERROR! init_initialize\n");
34008dae:	481d      	ldr	r0, [pc, #116]	@ (34008e24 <knl_main+0xb8>)
34008db0:	f003 faca 	bl	3400c348 <tm_putstring>
		goto err_ret;
34008db4:	e030      	b.n	34008e18 <knl_main+0xac>
	}

	/* Initialize Kernel-objects  */
	ercd = knl_init_object();
34008db6:	f002 fde3 	bl	3400b980 <knl_init_object>
34008dba:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34008dbc:	687b      	ldr	r3, [r7, #4]
34008dbe:	2b00      	cmp	r3, #0
34008dc0:	da03      	bge.n	34008dca <knl_main+0x5e>
		SYSTEM_MESSAGE("!ERROR! kernel object initialize\n");
34008dc2:	4819      	ldr	r0, [pc, #100]	@ (34008e28 <knl_main+0xbc>)
34008dc4:	f003 fac0 	bl	3400c348 <tm_putstring>
		goto err_ret1;
34008dc8:	e024      	b.n	34008e14 <knl_main+0xa8>
	}

	/* Start System Timer */
	ercd = knl_timer_startup();
34008dca:	f002 fce1 	bl	3400b790 <knl_timer_startup>
34008dce:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34008dd0:	687b      	ldr	r3, [r7, #4]
34008dd2:	2b00      	cmp	r3, #0
34008dd4:	da03      	bge.n	34008dde <knl_main+0x72>
		SYSTEM_MESSAGE("!ERROR! System timer startup\n");
34008dd6:	4815      	ldr	r0, [pc, #84]	@ (34008e2c <knl_main+0xc0>)
34008dd8:	f003 fab6 	bl	3400c348 <tm_putstring>
		goto err_ret1;
34008ddc:	e01a      	b.n	34008e14 <knl_main+0xa8>
	}

	/* Create & start initial task */
	ercd = tk_cre_tsk((CONST T_CTSK *)&knl_init_ctsk);
34008dde:	4814      	ldr	r0, [pc, #80]	@ (34008e30 <knl_main+0xc4>)
34008de0:	f002 f972 	bl	3400b0c8 <tk_cre_tsk>
34008de4:	6078      	str	r0, [r7, #4]
	if ( ercd >= E_OK ) {
34008de6:	687b      	ldr	r3, [r7, #4]
34008de8:	2b00      	cmp	r3, #0
34008dea:	db0e      	blt.n	34008e0a <knl_main+0x9e>
		ercd = tk_sta_tsk((ID)ercd, 0);
34008dec:	2100      	movs	r1, #0
34008dee:	6878      	ldr	r0, [r7, #4]
34008df0:	f002 fa18 	bl	3400b224 <tk_sta_tsk>
34008df4:	6078      	str	r0, [r7, #4]
		if ( ercd >= E_OK ) {
34008df6:	687b      	ldr	r3, [r7, #4]
34008df8:	2b00      	cmp	r3, #0
34008dfa:	db02      	blt.n	34008e02 <knl_main+0x96>
			knl_force_dispatch();
34008dfc:	f003 fe6c 	bl	3400cad8 <knl_force_dispatch>
34008e00:	e006      	b.n	34008e10 <knl_main+0xa4>
			/**** Start Initial Task. ****/
			/**** No return ****/
		} else {
			SYSTEM_MESSAGE("!ERROR! Initial Task can not start\n");
34008e02:	480c      	ldr	r0, [pc, #48]	@ (34008e34 <knl_main+0xc8>)
34008e04:	f003 faa0 	bl	3400c348 <tm_putstring>
34008e08:	e002      	b.n	34008e10 <knl_main+0xa4>
		}
	} else {
		SYSTEM_MESSAGE("!ERROR! Initial Task can not creat\n");
34008e0a:	480b      	ldr	r0, [pc, #44]	@ (34008e38 <knl_main+0xcc>)
34008e0c:	f003 fa9c 	bl	3400c348 <tm_putstring>
	}

	/* After this, Error handling */

#if USE_SHUTDOWN
	knl_timer_shutdown();	/* Stop System timer */
34008e10:	f002 fcdc 	bl	3400b7cc <knl_timer_shutdown>
err_ret1:
	knl_shutdown_hw();	/* Hardware-dependent Finalization */
34008e14:	f004 fd5b 	bl	3400d8ce <knl_shutdown_hw>
#else
err_ret1:
#endif /* USE_SHUTDOWN */

err_ret:
	while(1);
34008e18:	bf00      	nop
34008e1a:	e7fd      	b.n	34008e18 <knl_main+0xac>
34008e1c:	3400dd64 	.word	0x3400dd64
34008e20:	3400dd7c 	.word	0x3400dd7c
34008e24:	3400dd94 	.word	0x3400dd94
34008e28:	3400ddb0 	.word	0x3400ddb0
34008e2c:	3400ddd4 	.word	0x3400ddd4
34008e30:	3400e00c 	.word	0x3400e00c
34008e34:	3400ddf4 	.word	0x3400ddf4
34008e38:	3400de18 	.word	0x3400de18

34008e3c <knl_tkernel_exit>:
/*
 * Exit micro T-Kernel from Initial Task.
 */
#if USE_SHUTDOWN
EXPORT void knl_tkernel_exit( void )
{
34008e3c:	b580      	push	{r7, lr}
34008e3e:	af00      	add	r7, sp, #0
	knl_timer_shutdown();	/* Stop System timer */
34008e40:	f002 fcc4 	bl	3400b7cc <knl_timer_shutdown>
	knl_shutdown_hw();	/* Hardware-dependent Finalization */
34008e44:	f004 fd43 	bl	3400d8ce <knl_shutdown_hw>
	/**** No return ****/

	while(1);
34008e48:	bf00      	nop
34008e4a:	e7fd      	b.n	34008e48 <knl_tkernel_exit+0xc>

34008e4c <QueInit>:

/*
 * Queue initialization 
 */
Inline void QueInit( QUEUE *que )
{
34008e4c:	b480      	push	{r7}
34008e4e:	b083      	sub	sp, #12
34008e50:	af00      	add	r7, sp, #0
34008e52:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
34008e54:	687b      	ldr	r3, [r7, #4]
34008e56:	687a      	ldr	r2, [r7, #4]
34008e58:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
34008e5a:	687b      	ldr	r3, [r7, #4]
34008e5c:	687a      	ldr	r2, [r7, #4]
34008e5e:	605a      	str	r2, [r3, #4]
}
34008e60:	bf00      	nop
34008e62:	370c      	adds	r7, #12
34008e64:	46bd      	mov	sp, r7
34008e66:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e6a:	4770      	bx	lr

34008e6c <isQueEmpty>:

/*
 * TRUE if the queue is empty 
 */
Inline BOOL isQueEmpty( QUEUE *que )
{
34008e6c:	b480      	push	{r7}
34008e6e:	b083      	sub	sp, #12
34008e70:	af00      	add	r7, sp, #0
34008e72:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
34008e74:	687b      	ldr	r3, [r7, #4]
34008e76:	681b      	ldr	r3, [r3, #0]
34008e78:	687a      	ldr	r2, [r7, #4]
34008e7a:	429a      	cmp	r2, r3
34008e7c:	bf0c      	ite	eq
34008e7e:	2301      	moveq	r3, #1
34008e80:	2300      	movne	r3, #0
34008e82:	b2db      	uxtb	r3, r3
}
34008e84:	4618      	mov	r0, r3
34008e86:	370c      	adds	r7, #12
34008e88:	46bd      	mov	sp, r7
34008e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e8e:	4770      	bx	lr

34008e90 <QueInsert>:
/*
 * Insert in queue 
 *	Inserts entry directly prior to que 
 */
Inline void QueInsert( QUEUE *entry, QUEUE *que )
{
34008e90:	b480      	push	{r7}
34008e92:	b083      	sub	sp, #12
34008e94:	af00      	add	r7, sp, #0
34008e96:	6078      	str	r0, [r7, #4]
34008e98:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
34008e9a:	683b      	ldr	r3, [r7, #0]
34008e9c:	685a      	ldr	r2, [r3, #4]
34008e9e:	687b      	ldr	r3, [r7, #4]
34008ea0:	605a      	str	r2, [r3, #4]
	entry->next = que;
34008ea2:	687b      	ldr	r3, [r7, #4]
34008ea4:	683a      	ldr	r2, [r7, #0]
34008ea6:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
34008ea8:	683b      	ldr	r3, [r7, #0]
34008eaa:	685b      	ldr	r3, [r3, #4]
34008eac:	687a      	ldr	r2, [r7, #4]
34008eae:	601a      	str	r2, [r3, #0]
	que->prev = entry;
34008eb0:	683b      	ldr	r3, [r7, #0]
34008eb2:	687a      	ldr	r2, [r7, #4]
34008eb4:	605a      	str	r2, [r3, #4]
}
34008eb6:	bf00      	nop
34008eb8:	370c      	adds	r7, #12
34008eba:	46bd      	mov	sp, r7
34008ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ec0:	4770      	bx	lr

34008ec2 <QueRemove>:
 * Delete from queue 
 *	Deletes entry from queue 
 *	No action is performed if entry is empty. 
 */
Inline void QueRemove( QUEUE *entry )
{
34008ec2:	b480      	push	{r7}
34008ec4:	b083      	sub	sp, #12
34008ec6:	af00      	add	r7, sp, #0
34008ec8:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
34008eca:	687b      	ldr	r3, [r7, #4]
34008ecc:	681b      	ldr	r3, [r3, #0]
34008ece:	687a      	ldr	r2, [r7, #4]
34008ed0:	429a      	cmp	r2, r3
34008ed2:	d009      	beq.n	34008ee8 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
34008ed4:	687b      	ldr	r3, [r7, #4]
34008ed6:	685b      	ldr	r3, [r3, #4]
34008ed8:	687a      	ldr	r2, [r7, #4]
34008eda:	6812      	ldr	r2, [r2, #0]
34008edc:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
34008ede:	687b      	ldr	r3, [r7, #4]
34008ee0:	681b      	ldr	r3, [r3, #0]
34008ee2:	687a      	ldr	r2, [r7, #4]
34008ee4:	6852      	ldr	r2, [r2, #4]
34008ee6:	605a      	str	r2, [r3, #4]
	}
}
34008ee8:	bf00      	nop
34008eea:	370c      	adds	r7, #12
34008eec:	46bd      	mov	sp, r7
34008eee:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ef2:	4770      	bx	lr

34008ef4 <QueRemoveNext>:
 *	Deletes the entry directly after que from the queue,
 *	and returns the deleted entry.
 *	Returns NULL if que is empty.
 */
Inline QUEUE* QueRemoveNext( QUEUE *que )
{
34008ef4:	b480      	push	{r7}
34008ef6:	b085      	sub	sp, #20
34008ef8:	af00      	add	r7, sp, #0
34008efa:	6078      	str	r0, [r7, #4]
	QUEUE	*entry;

	if ( que->next == que ) {
34008efc:	687b      	ldr	r3, [r7, #4]
34008efe:	681b      	ldr	r3, [r3, #0]
34008f00:	687a      	ldr	r2, [r7, #4]
34008f02:	429a      	cmp	r2, r3
34008f04:	d101      	bne.n	34008f0a <QueRemoveNext+0x16>
		return NULL;
34008f06:	2300      	movs	r3, #0
34008f08:	e00b      	b.n	34008f22 <QueRemoveNext+0x2e>
	}

	entry = que->next;
34008f0a:	687b      	ldr	r3, [r7, #4]
34008f0c:	681b      	ldr	r3, [r3, #0]
34008f0e:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
34008f10:	68fb      	ldr	r3, [r7, #12]
34008f12:	681a      	ldr	r2, [r3, #0]
34008f14:	687b      	ldr	r3, [r7, #4]
34008f16:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
34008f18:	68fb      	ldr	r3, [r7, #12]
34008f1a:	681b      	ldr	r3, [r3, #0]
34008f1c:	687a      	ldr	r2, [r7, #4]
34008f1e:	605a      	str	r2, [r3, #4]

	return entry;
34008f20:	68fb      	ldr	r3, [r7, #12]
}
34008f22:	4618      	mov	r0, r3
34008f24:	3714      	adds	r7, #20
34008f26:	46bd      	mov	sp, r7
34008f28:	f85d 7b04 	ldr.w	r7, [sp], #4
34008f2c:	4770      	bx	lr
	...

34008f30 <knl_searchDevCB>:

/*
 * Search registration device
 */
EXPORT DevCB* knl_searchDevCB( CONST UB *devnm )
{
34008f30:	b580      	push	{r7, lr}
34008f32:	b084      	sub	sp, #16
34008f34:	af00      	add	r7, sp, #0
34008f36:	6078      	str	r0, [r7, #4]
	QUEUE	*q;
	DevCB	*devcb;

	for ( q = knl_UsedDevCB.next; q != &knl_UsedDevCB; q = q->next ) {
34008f38:	4b11      	ldr	r3, [pc, #68]	@ (34008f80 <knl_searchDevCB+0x50>)
34008f3a:	681b      	ldr	r3, [r3, #0]
34008f3c:	60fb      	str	r3, [r7, #12]
34008f3e:	e015      	b.n	34008f6c <knl_searchDevCB+0x3c>
		devcb = (DevCB*)q;
34008f40:	68fb      	ldr	r3, [r7, #12]
34008f42:	60bb      	str	r3, [r7, #8]

		if ( devcb->devnm[0] == devnm[0] && knl_strcmp((char*)devcb->devnm, (char*)devnm) == 0 ) {
34008f44:	68bb      	ldr	r3, [r7, #8]
34008f46:	7a1a      	ldrb	r2, [r3, #8]
34008f48:	687b      	ldr	r3, [r7, #4]
34008f4a:	781b      	ldrb	r3, [r3, #0]
34008f4c:	429a      	cmp	r2, r3
34008f4e:	d10a      	bne.n	34008f66 <knl_searchDevCB+0x36>
34008f50:	68bb      	ldr	r3, [r7, #8]
34008f52:	3308      	adds	r3, #8
34008f54:	6879      	ldr	r1, [r7, #4]
34008f56:	4618      	mov	r0, r3
34008f58:	f002 ffc5 	bl	3400bee6 <knl_strcmp>
34008f5c:	4603      	mov	r3, r0
34008f5e:	2b00      	cmp	r3, #0
34008f60:	d101      	bne.n	34008f66 <knl_searchDevCB+0x36>
			return devcb; /* Found */
34008f62:	68bb      	ldr	r3, [r7, #8]
34008f64:	e007      	b.n	34008f76 <knl_searchDevCB+0x46>
	for ( q = knl_UsedDevCB.next; q != &knl_UsedDevCB; q = q->next ) {
34008f66:	68fb      	ldr	r3, [r7, #12]
34008f68:	681b      	ldr	r3, [r3, #0]
34008f6a:	60fb      	str	r3, [r7, #12]
34008f6c:	68fb      	ldr	r3, [r7, #12]
34008f6e:	4a04      	ldr	r2, [pc, #16]	@ (34008f80 <knl_searchDevCB+0x50>)
34008f70:	4293      	cmp	r3, r2
34008f72:	d1e5      	bne.n	34008f40 <knl_searchDevCB+0x10>
		}
	}

	return NULL;
34008f74:	2300      	movs	r3, #0
}
34008f76:	4618      	mov	r0, r3
34008f78:	3710      	adds	r7, #16
34008f7a:	46bd      	mov	sp, r7
34008f7c:	bd80      	pop	{r7, pc}
34008f7e:	bf00      	nop
34008f80:	3400f94c 	.word	0x3400f94c

34008f84 <newDevCB>:

/*
 * Get DevCB for new registration
 */
LOCAL DevCB* newDevCB( CONST UB *devnm )
{
34008f84:	b580      	push	{r7, lr}
34008f86:	b084      	sub	sp, #16
34008f88:	af00      	add	r7, sp, #0
34008f8a:	6078      	str	r0, [r7, #4]
	DevCB	*devcb;

	devcb = (DevCB*)QueRemoveNext(&knl_FreeDevCB);
34008f8c:	480f      	ldr	r0, [pc, #60]	@ (34008fcc <newDevCB+0x48>)
34008f8e:	f7ff ffb1 	bl	34008ef4 <QueRemoveNext>
34008f92:	60f8      	str	r0, [r7, #12]
	if ( devcb == NULL ) {
34008f94:	68fb      	ldr	r3, [r7, #12]
34008f96:	2b00      	cmp	r3, #0
34008f98:	d101      	bne.n	34008f9e <newDevCB+0x1a>
		return NULL; /* No space */
34008f9a:	2300      	movs	r3, #0
34008f9c:	e011      	b.n	34008fc2 <newDevCB+0x3e>
	}

	knl_strncpy((char*)devcb->devnm, (char*)devnm, L_DEVNM+1);
34008f9e:	68fb      	ldr	r3, [r7, #12]
34008fa0:	3308      	adds	r3, #8
34008fa2:	2209      	movs	r2, #9
34008fa4:	6879      	ldr	r1, [r7, #4]
34008fa6:	4618      	mov	r0, r3
34008fa8:	f002 ff74 	bl	3400be94 <knl_strncpy>
	QueInit(&devcb->openq);
34008fac:	68fb      	ldr	r3, [r7, #12]
34008fae:	3340      	adds	r3, #64	@ 0x40
34008fb0:	4618      	mov	r0, r3
34008fb2:	f7ff ff4b 	bl	34008e4c <QueInit>

	QueInsert(&devcb->q, &knl_UsedDevCB);
34008fb6:	68fb      	ldr	r3, [r7, #12]
34008fb8:	4905      	ldr	r1, [pc, #20]	@ (34008fd0 <newDevCB+0x4c>)
34008fba:	4618      	mov	r0, r3
34008fbc:	f7ff ff68 	bl	34008e90 <QueInsert>

	return devcb;
34008fc0:	68fb      	ldr	r3, [r7, #12]
}
34008fc2:	4618      	mov	r0, r3
34008fc4:	3710      	adds	r7, #16
34008fc6:	46bd      	mov	sp, r7
34008fc8:	bd80      	pop	{r7, pc}
34008fca:	bf00      	nop
34008fcc:	3400f954 	.word	0x3400f954
34008fd0:	3400f94c 	.word	0x3400f94c

34008fd4 <delDevCB>:

/*
 * Free DevCB
 */
LOCAL void delDevCB( DevCB *devcb )
{
34008fd4:	b580      	push	{r7, lr}
34008fd6:	b082      	sub	sp, #8
34008fd8:	af00      	add	r7, sp, #0
34008fda:	6078      	str	r0, [r7, #4]
	QueRemove(&devcb->q);
34008fdc:	687b      	ldr	r3, [r7, #4]
34008fde:	4618      	mov	r0, r3
34008fe0:	f7ff ff6f 	bl	34008ec2 <QueRemove>
	QueInsert(&devcb->q, &knl_FreeDevCB);
34008fe4:	687b      	ldr	r3, [r7, #4]
34008fe6:	4905      	ldr	r1, [pc, #20]	@ (34008ffc <delDevCB+0x28>)
34008fe8:	4618      	mov	r0, r3
34008fea:	f7ff ff51 	bl	34008e90 <QueInsert>
	devcb->devnm[0] = '\0';
34008fee:	687b      	ldr	r3, [r7, #4]
34008ff0:	2200      	movs	r2, #0
34008ff2:	721a      	strb	r2, [r3, #8]
}
34008ff4:	bf00      	nop
34008ff6:	3708      	adds	r7, #8
34008ff8:	46bd      	mov	sp, r7
34008ffa:	bd80      	pop	{r7, pc}
34008ffc:	3400f954 	.word	0x3400f954

34009000 <tk_def_dev>:

/*
 * Device registration
 */
SYSCALL ID tk_def_dev( CONST UB *devnm, CONST T_DDEV *pk_ddev, T_IDEV *pk_idev )
{
34009000:	b5b0      	push	{r4, r5, r7, lr}
34009002:	b088      	sub	sp, #32
34009004:	af00      	add	r7, sp, #0
34009006:	60f8      	str	r0, [r7, #12]
34009008:	60b9      	str	r1, [r7, #8]
3400900a:	607a      	str	r2, [r7, #4]
	DevCB	*devcb;
	INT	len;
	ER	ercd;

	LockREG();
3400900c:	2101      	movs	r1, #1
3400900e:	484f      	ldr	r0, [pc, #316]	@ (3400914c <tk_def_dev+0x14c>)
34009010:	f003 f8c9 	bl	3400c1a6 <MLock>

	len = knl_strlen((char*)devnm);
34009014:	68f8      	ldr	r0, [r7, #12]
34009016:	f002 ff15 	bl	3400be44 <knl_strlen>
3400901a:	61b8      	str	r0, [r7, #24]
	if ( len == 0 || len > L_DEVNM ) {
3400901c:	69bb      	ldr	r3, [r7, #24]
3400901e:	2b00      	cmp	r3, #0
34009020:	d002      	beq.n	34009028 <tk_def_dev+0x28>
34009022:	69bb      	ldr	r3, [r7, #24]
34009024:	2b08      	cmp	r3, #8
34009026:	dd03      	ble.n	34009030 <tk_def_dev+0x30>
		ercd = E_PAR;
34009028:	f06f 0310 	mvn.w	r3, #16
3400902c:	617b      	str	r3, [r7, #20]
		goto err_ret1;
3400902e:	e084      	b.n	3400913a <tk_def_dev+0x13a>
	}

	if ( pk_ddev != NULL ) {
34009030:	68bb      	ldr	r3, [r7, #8]
34009032:	2b00      	cmp	r3, #0
34009034:	d027      	beq.n	34009086 <tk_def_dev+0x86>
		if ( pk_ddev->nsub < 0 || pk_ddev->nsub > MAX_UNIT ) {
34009036:	68bb      	ldr	r3, [r7, #8]
34009038:	68db      	ldr	r3, [r3, #12]
3400903a:	2b00      	cmp	r3, #0
3400903c:	db03      	blt.n	34009046 <tk_def_dev+0x46>
3400903e:	68bb      	ldr	r3, [r7, #8]
34009040:	68db      	ldr	r3, [r3, #12]
34009042:	2bff      	cmp	r3, #255	@ 0xff
34009044:	dd03      	ble.n	3400904e <tk_def_dev+0x4e>
			ercd = E_PAR;
34009046:	f06f 0310 	mvn.w	r3, #16
3400904a:	617b      	str	r3, [r7, #20]
			goto err_ret1;
3400904c:	e075      	b.n	3400913a <tk_def_dev+0x13a>
		}

		/* Make sure that the length of the logical device name
		   does not exceed the character limit */
		if ( pk_ddev->nsub > 0   ) {
3400904e:	68bb      	ldr	r3, [r7, #8]
34009050:	68db      	ldr	r3, [r3, #12]
34009052:	2b00      	cmp	r3, #0
34009054:	dd02      	ble.n	3400905c <tk_def_dev+0x5c>
			++len;
34009056:	69bb      	ldr	r3, [r7, #24]
34009058:	3301      	adds	r3, #1
3400905a:	61bb      	str	r3, [r7, #24]
		}
		if ( pk_ddev->nsub > 10  ) {
3400905c:	68bb      	ldr	r3, [r7, #8]
3400905e:	68db      	ldr	r3, [r3, #12]
34009060:	2b0a      	cmp	r3, #10
34009062:	dd02      	ble.n	3400906a <tk_def_dev+0x6a>
			++len;
34009064:	69bb      	ldr	r3, [r7, #24]
34009066:	3301      	adds	r3, #1
34009068:	61bb      	str	r3, [r7, #24]
		}
		if ( pk_ddev->nsub > 100 ) {
3400906a:	68bb      	ldr	r3, [r7, #8]
3400906c:	68db      	ldr	r3, [r3, #12]
3400906e:	2b64      	cmp	r3, #100	@ 0x64
34009070:	dd02      	ble.n	34009078 <tk_def_dev+0x78>
			++len;
34009072:	69bb      	ldr	r3, [r7, #24]
34009074:	3301      	adds	r3, #1
34009076:	61bb      	str	r3, [r7, #24]
		}
		if ( len > L_DEVNM ) {
34009078:	69bb      	ldr	r3, [r7, #24]
3400907a:	2b08      	cmp	r3, #8
3400907c:	dd03      	ble.n	34009086 <tk_def_dev+0x86>
			ercd = E_PAR;
3400907e:	f06f 0310 	mvn.w	r3, #16
34009082:	617b      	str	r3, [r7, #20]
			goto err_ret1;
34009084:	e059      	b.n	3400913a <tk_def_dev+0x13a>
		}
	}

	LockDM();
34009086:	2100      	movs	r1, #0
34009088:	4830      	ldr	r0, [pc, #192]	@ (3400914c <tk_def_dev+0x14c>)
3400908a:	f003 f88c 	bl	3400c1a6 <MLock>

	/* Search whether 'devnm' device is registered */
	devcb = knl_searchDevCB(devnm);
3400908e:	68f8      	ldr	r0, [r7, #12]
34009090:	f7ff ff4e 	bl	34008f30 <knl_searchDevCB>
34009094:	61f8      	str	r0, [r7, #28]
	if ( devcb == NULL ) {
34009096:	69fb      	ldr	r3, [r7, #28]
34009098:	2b00      	cmp	r3, #0
3400909a:	d111      	bne.n	340090c0 <tk_def_dev+0xc0>
		if ( pk_ddev == NULL ) {
3400909c:	68bb      	ldr	r3, [r7, #8]
3400909e:	2b00      	cmp	r3, #0
340090a0:	d103      	bne.n	340090aa <tk_def_dev+0xaa>
			ercd = E_NOEXS;
340090a2:	f06f 0329 	mvn.w	r3, #41	@ 0x29
340090a6:	617b      	str	r3, [r7, #20]
			goto err_ret2;
340090a8:	e043      	b.n	34009132 <tk_def_dev+0x132>
		}

		/* Get 'devcb' for new registration because it is not
		   registered */
		devcb = newDevCB(devnm);
340090aa:	68f8      	ldr	r0, [r7, #12]
340090ac:	f7ff ff6a 	bl	34008f84 <newDevCB>
340090b0:	61f8      	str	r0, [r7, #28]
		if ( devcb == NULL ) {
340090b2:	69fb      	ldr	r3, [r7, #28]
340090b4:	2b00      	cmp	r3, #0
340090b6:	d103      	bne.n	340090c0 <tk_def_dev+0xc0>
			ercd = E_LIMIT;
340090b8:	f06f 0321 	mvn.w	r3, #33	@ 0x21
340090bc:	617b      	str	r3, [r7, #20]
			goto err_ret2;
340090be:	e038      	b.n	34009132 <tk_def_dev+0x132>
		}
	}

	if ( pk_ddev != NULL ) {
340090c0:	68bb      	ldr	r3, [r7, #8]
340090c2:	2b00      	cmp	r3, #0
340090c4:	d014      	beq.n	340090f0 <tk_def_dev+0xf0>
		/* Set/update device registration information */
		devcb->ddev = *pk_ddev;
340090c6:	69fb      	ldr	r3, [r7, #28]
340090c8:	68ba      	ldr	r2, [r7, #8]
340090ca:	f103 0414 	add.w	r4, r3, #20
340090ce:	4615      	mov	r5, r2
340090d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
340090d2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
340090d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
340090d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
340090d8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
340090dc:	e884 0007 	stmia.w	r4, {r0, r1, r2}

		if ( pk_idev != NULL ) {
340090e0:	687b      	ldr	r3, [r7, #4]
340090e2:	2b00      	cmp	r3, #0
340090e4:	d013      	beq.n	3400910e <tk_def_dev+0x10e>
			/* Device initial setting information */
			*pk_idev = knl_DefaultIDev;
340090e6:	687b      	ldr	r3, [r7, #4]
340090e8:	4a19      	ldr	r2, [pc, #100]	@ (34009150 <tk_def_dev+0x150>)
340090ea:	6812      	ldr	r2, [r2, #0]
340090ec:	601a      	str	r2, [r3, #0]
340090ee:	e00e      	b.n	3400910e <tk_def_dev+0x10e>
		}
	} else {
		if ( !isQueEmpty(&devcb->openq) ) {
340090f0:	69fb      	ldr	r3, [r7, #28]
340090f2:	3340      	adds	r3, #64	@ 0x40
340090f4:	4618      	mov	r0, r3
340090f6:	f7ff feb9 	bl	34008e6c <isQueEmpty>
340090fa:	4603      	mov	r3, r0
340090fc:	2b00      	cmp	r3, #0
340090fe:	d103      	bne.n	34009108 <tk_def_dev+0x108>
			/* In use (open) */
			ercd = E_BUSY;
34009100:	f06f 0340 	mvn.w	r3, #64	@ 0x40
34009104:	617b      	str	r3, [r7, #20]
			goto err_ret2;
34009106:	e014      	b.n	34009132 <tk_def_dev+0x132>
		}

		/* Device unregistration */
		delDevCB(devcb);
34009108:	69f8      	ldr	r0, [r7, #28]
3400910a:	f7ff ff63 	bl	34008fd4 <delDevCB>
	}

	UnlockDM();
3400910e:	2100      	movs	r1, #0
34009110:	480e      	ldr	r0, [pc, #56]	@ (3400914c <tk_def_dev+0x14c>)
34009112:	f003 f858 	bl	3400c1c6 <MUnlock>
	UnlockREG();
34009116:	2101      	movs	r1, #1
34009118:	480c      	ldr	r0, [pc, #48]	@ (3400914c <tk_def_dev+0x14c>)
3400911a:	f003 f854 	bl	3400c1c6 <MUnlock>

	return DID(devcb);
3400911e:	69fb      	ldr	r3, [r7, #28]
34009120:	4a0c      	ldr	r2, [pc, #48]	@ (34009154 <tk_def_dev+0x154>)
34009122:	1a9b      	subs	r3, r3, r2
34009124:	10db      	asrs	r3, r3, #3
34009126:	4a0c      	ldr	r2, [pc, #48]	@ (34009158 <tk_def_dev+0x158>)
34009128:	fb02 f303 	mul.w	r3, r2, r3
3400912c:	3301      	adds	r3, #1
3400912e:	021b      	lsls	r3, r3, #8
34009130:	e008      	b.n	34009144 <tk_def_dev+0x144>

err_ret2:
	UnlockDM();
34009132:	2100      	movs	r1, #0
34009134:	4805      	ldr	r0, [pc, #20]	@ (3400914c <tk_def_dev+0x14c>)
34009136:	f003 f846 	bl	3400c1c6 <MUnlock>
err_ret1:
	UnlockREG();
3400913a:	2101      	movs	r1, #1
3400913c:	4803      	ldr	r0, [pc, #12]	@ (3400914c <tk_def_dev+0x14c>)
3400913e:	f003 f842 	bl	3400c1c6 <MUnlock>
	return ercd;
34009142:	697b      	ldr	r3, [r7, #20]
}
34009144:	4618      	mov	r0, r3
34009146:	3720      	adds	r7, #32
34009148:	46bd      	mov	sp, r7
3400914a:	bdb0      	pop	{r4, r5, r7, pc}
3400914c:	3400f6f8 	.word	0x3400f6f8
34009150:	3400f708 	.word	0x3400f708
34009154:	3400f70c 	.word	0x3400f70c
34009158:	38e38e39 	.word	0x38e38e39

3400915c <initDevCB>:

/*
 * Initialization of device registration information table
 */
LOCAL ER initDevCB( void )
{
3400915c:	b580      	push	{r7, lr}
3400915e:	b082      	sub	sp, #8
34009160:	af00      	add	r7, sp, #0
	DevCB	*devcb;
	INT	num = MAX_REGDEV;
34009162:	2308      	movs	r3, #8
34009164:	603b      	str	r3, [r7, #0]

	QueInit(&knl_UsedDevCB);
34009166:	480f      	ldr	r0, [pc, #60]	@ (340091a4 <initDevCB+0x48>)
34009168:	f7ff fe70 	bl	34008e4c <QueInit>
	QueInit(&knl_FreeDevCB);
3400916c:	480e      	ldr	r0, [pc, #56]	@ (340091a8 <initDevCB+0x4c>)
3400916e:	f7ff fe6d 	bl	34008e4c <QueInit>

	devcb = knl_DevCBtbl;
34009172:	4b0e      	ldr	r3, [pc, #56]	@ (340091ac <initDevCB+0x50>)
34009174:	607b      	str	r3, [r7, #4]
	while ( num-- > 0 ) {
34009176:	e00a      	b.n	3400918e <initDevCB+0x32>
		QueInsert(&devcb->q, &knl_FreeDevCB);
34009178:	687b      	ldr	r3, [r7, #4]
3400917a:	490b      	ldr	r1, [pc, #44]	@ (340091a8 <initDevCB+0x4c>)
3400917c:	4618      	mov	r0, r3
3400917e:	f7ff fe87 	bl	34008e90 <QueInsert>
		devcb->devnm[0] = '\0';
34009182:	687b      	ldr	r3, [r7, #4]
34009184:	2200      	movs	r2, #0
34009186:	721a      	strb	r2, [r3, #8]
		devcb++;
34009188:	687b      	ldr	r3, [r7, #4]
3400918a:	3348      	adds	r3, #72	@ 0x48
3400918c:	607b      	str	r3, [r7, #4]
	while ( num-- > 0 ) {
3400918e:	683b      	ldr	r3, [r7, #0]
34009190:	1e5a      	subs	r2, r3, #1
34009192:	603a      	str	r2, [r7, #0]
34009194:	2b00      	cmp	r3, #0
34009196:	dcef      	bgt.n	34009178 <initDevCB+0x1c>
	}

	return E_OK;
34009198:	2300      	movs	r3, #0
}
3400919a:	4618      	mov	r0, r3
3400919c:	3708      	adds	r7, #8
3400919e:	46bd      	mov	sp, r7
340091a0:	bd80      	pop	{r7, pc}
340091a2:	bf00      	nop
340091a4:	3400f94c 	.word	0x3400f94c
340091a8:	3400f954 	.word	0x3400f954
340091ac:	3400f70c 	.word	0x3400f70c

340091b0 <initIDev>:

/*
 * Initialization of device initial setting information
 */
LOCAL ER initIDev( void )
{
340091b0:	b480      	push	{r7}
340091b2:	b083      	sub	sp, #12
340091b4:	af00      	add	r7, sp, #0
	if ( ercd < E_OK ) {
		knl_DefaultIDev.evtmbfid = 0;
		goto err_ret;
	}
#else	/* Do not use message buffer for event notification */
	ercd = E_OK;
340091b6:	2300      	movs	r3, #0
340091b8:	607b      	str	r3, [r7, #4]
#endif
	knl_DefaultIDev.evtmbfid = ercd;
340091ba:	4a05      	ldr	r2, [pc, #20]	@ (340091d0 <initIDev+0x20>)
340091bc:	687b      	ldr	r3, [r7, #4]
340091be:	6013      	str	r3, [r2, #0]

#if DEVT_MBFSZ0 >= 0
err_ret:
#endif
	return ercd;
340091c0:	687b      	ldr	r3, [r7, #4]
}
340091c2:	4618      	mov	r0, r3
340091c4:	370c      	adds	r7, #12
340091c6:	46bd      	mov	sp, r7
340091c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340091cc:	4770      	bx	lr
340091ce:	bf00      	nop
340091d0:	3400f708 	.word	0x3400f708

340091d4 <knl_initialize_devmgr>:

/*
 * Initialization of Device management
 */
EXPORT ER knl_initialize_devmgr( void )
{
340091d4:	b580      	push	{r7, lr}
340091d6:	b082      	sub	sp, #8
340091d8:	af00      	add	r7, sp, #0
	ER	ercd;

	/* Generate lock for device management exclusive control */
	ercd = CreateMLock(&knl_DevMgrLock, (UB*)OBJNAME_DMLOCK);
340091da:	4916      	ldr	r1, [pc, #88]	@ (34009234 <knl_initialize_devmgr+0x60>)
340091dc:	4816      	ldr	r0, [pc, #88]	@ (34009238 <knl_initialize_devmgr+0x64>)
340091de:	f003 f815 	bl	3400c20c <CreateMLock>
340091e2:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
340091e4:	687b      	ldr	r3, [r7, #4]
340091e6:	2b00      	cmp	r3, #0
340091e8:	db15      	blt.n	34009216 <knl_initialize_devmgr+0x42>
		goto err_ret;
	}

	/* Generate device registration information table */
	ercd = initDevCB();
340091ea:	f7ff ffb7 	bl	3400915c <initDevCB>
340091ee:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
340091f0:	687b      	ldr	r3, [r7, #4]
340091f2:	2b00      	cmp	r3, #0
340091f4:	db11      	blt.n	3400921a <knl_initialize_devmgr+0x46>
		goto err_ret;
	}

	/* Initialization of device input/output-related */
	ercd = knl_initDevIO();
340091f6:	f000 fabf 	bl	34009778 <knl_initDevIO>
340091fa:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
340091fc:	687b      	ldr	r3, [r7, #4]
340091fe:	2b00      	cmp	r3, #0
34009200:	db0d      	blt.n	3400921e <knl_initialize_devmgr+0x4a>
		goto err_ret;
	}

	/* Initialization of device initial setting information */
	ercd = initIDev();
34009202:	f7ff ffd5 	bl	340091b0 <initIDev>
34009206:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
34009208:	687b      	ldr	r3, [r7, #4]
3400920a:	2b00      	cmp	r3, #0
3400920c:	db09      	blt.n	34009222 <knl_initialize_devmgr+0x4e>
		goto err_ret;
	}

	knl_devmgr_startup();
3400920e:	f000 fa5f 	bl	340096d0 <knl_devmgr_startup>

	return E_OK;
34009212:	2300      	movs	r3, #0
34009214:	e009      	b.n	3400922a <knl_initialize_devmgr+0x56>
		goto err_ret;
34009216:	bf00      	nop
34009218:	e004      	b.n	34009224 <knl_initialize_devmgr+0x50>
		goto err_ret;
3400921a:	bf00      	nop
3400921c:	e002      	b.n	34009224 <knl_initialize_devmgr+0x50>
		goto err_ret;
3400921e:	bf00      	nop
34009220:	e000      	b.n	34009224 <knl_initialize_devmgr+0x50>
		goto err_ret;
34009222:	bf00      	nop

err_ret:
	knl_finish_devmgr();
34009224:	f000 f816 	bl	34009254 <knl_finish_devmgr>
	return ercd;
34009228:	687b      	ldr	r3, [r7, #4]
}
3400922a:	4618      	mov	r0, r3
3400922c:	3708      	adds	r7, #8
3400922e:	46bd      	mov	sp, r7
34009230:	bd80      	pop	{r7, pc}
34009232:	bf00      	nop
34009234:	3400de3c 	.word	0x3400de3c
34009238:	3400f6f8 	.word	0x3400f6f8

3400923c <delIDev>:

/*
 * Unregister device initial setting information
 */
LOCAL ER delIDev( void )
{
3400923c:	b480      	push	{r7}
3400923e:	b083      	sub	sp, #12
34009240:	af00      	add	r7, sp, #0
	ER	ercd = E_OK;
34009242:	2300      	movs	r3, #0
34009244:	607b      	str	r3, [r7, #4]
	}


#endif /* DEVT_MBFSZ0 >= 0 */

	return ercd;
34009246:	687b      	ldr	r3, [r7, #4]
}
34009248:	4618      	mov	r0, r3
3400924a:	370c      	adds	r7, #12
3400924c:	46bd      	mov	sp, r7
3400924e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009252:	4770      	bx	lr

34009254 <knl_finish_devmgr>:

/*
 * Finalization sequence of system management 
 */
EXPORT ER knl_finish_devmgr( void )
{
34009254:	b580      	push	{r7, lr}
34009256:	b082      	sub	sp, #8
34009258:	af00      	add	r7, sp, #0
	ER	ercd;

	knl_devmgr_cleanup();
3400925a:	f000 fa4f 	bl	340096fc <knl_devmgr_cleanup>

	/* Unregister device initial setting information */
	ercd = delIDev();
3400925e:	f7ff ffed 	bl	3400923c <delIDev>
34009262:	6078      	str	r0, [r7, #4]

	/* Finalization sequence of device input/output-related */
	ercd = knl_finishDevIO();
34009264:	f000 fad2 	bl	3400980c <knl_finishDevIO>
34009268:	6078      	str	r0, [r7, #4]

	/* Delete lock for device management exclusive control */
	DeleteMLock(&knl_DevMgrLock);
3400926a:	4804      	ldr	r0, [pc, #16]	@ (3400927c <knl_finish_devmgr+0x28>)
3400926c:	f003 f80c 	bl	3400c288 <DeleteMLock>

	return ercd;
34009270:	687b      	ldr	r3, [r7, #4]
}
34009272:	4618      	mov	r0, r3
34009274:	3708      	adds	r7, #8
34009276:	46bd      	mov	sp, r7
34009278:	bd80      	pop	{r7, pc}
3400927a:	bf00      	nop
3400927c:	3400f6f8 	.word	0x3400f6f8

34009280 <QueInit>:
{
34009280:	b480      	push	{r7}
34009282:	b083      	sub	sp, #12
34009284:	af00      	add	r7, sp, #0
34009286:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
34009288:	687b      	ldr	r3, [r7, #4]
3400928a:	687a      	ldr	r2, [r7, #4]
3400928c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400928e:	687b      	ldr	r3, [r7, #4]
34009290:	687a      	ldr	r2, [r7, #4]
34009292:	605a      	str	r2, [r3, #4]
}
34009294:	bf00      	nop
34009296:	370c      	adds	r7, #12
34009298:	46bd      	mov	sp, r7
3400929a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400929e:	4770      	bx	lr

340092a0 <isQueEmpty>:
{
340092a0:	b480      	push	{r7}
340092a2:	b083      	sub	sp, #12
340092a4:	af00      	add	r7, sp, #0
340092a6:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
340092a8:	687b      	ldr	r3, [r7, #4]
340092aa:	681b      	ldr	r3, [r3, #0]
340092ac:	687a      	ldr	r2, [r7, #4]
340092ae:	429a      	cmp	r2, r3
340092b0:	bf0c      	ite	eq
340092b2:	2301      	moveq	r3, #1
340092b4:	2300      	movne	r3, #0
340092b6:	b2db      	uxtb	r3, r3
}
340092b8:	4618      	mov	r0, r3
340092ba:	370c      	adds	r7, #12
340092bc:	46bd      	mov	sp, r7
340092be:	f85d 7b04 	ldr.w	r7, [sp], #4
340092c2:	4770      	bx	lr

340092c4 <QueInsert>:
{
340092c4:	b480      	push	{r7}
340092c6:	b083      	sub	sp, #12
340092c8:	af00      	add	r7, sp, #0
340092ca:	6078      	str	r0, [r7, #4]
340092cc:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
340092ce:	683b      	ldr	r3, [r7, #0]
340092d0:	685a      	ldr	r2, [r3, #4]
340092d2:	687b      	ldr	r3, [r7, #4]
340092d4:	605a      	str	r2, [r3, #4]
	entry->next = que;
340092d6:	687b      	ldr	r3, [r7, #4]
340092d8:	683a      	ldr	r2, [r7, #0]
340092da:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
340092dc:	683b      	ldr	r3, [r7, #0]
340092de:	685b      	ldr	r3, [r3, #4]
340092e0:	687a      	ldr	r2, [r7, #4]
340092e2:	601a      	str	r2, [r3, #0]
	que->prev = entry;
340092e4:	683b      	ldr	r3, [r7, #0]
340092e6:	687a      	ldr	r2, [r7, #4]
340092e8:	605a      	str	r2, [r3, #4]
}
340092ea:	bf00      	nop
340092ec:	370c      	adds	r7, #12
340092ee:	46bd      	mov	sp, r7
340092f0:	f85d 7b04 	ldr.w	r7, [sp], #4
340092f4:	4770      	bx	lr

340092f6 <QueRemove>:
{
340092f6:	b480      	push	{r7}
340092f8:	b083      	sub	sp, #12
340092fa:	af00      	add	r7, sp, #0
340092fc:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
340092fe:	687b      	ldr	r3, [r7, #4]
34009300:	681b      	ldr	r3, [r3, #0]
34009302:	687a      	ldr	r2, [r7, #4]
34009304:	429a      	cmp	r2, r3
34009306:	d009      	beq.n	3400931c <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
34009308:	687b      	ldr	r3, [r7, #4]
3400930a:	685b      	ldr	r3, [r3, #4]
3400930c:	687a      	ldr	r2, [r7, #4]
3400930e:	6812      	ldr	r2, [r2, #0]
34009310:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
34009312:	687b      	ldr	r3, [r7, #4]
34009314:	681b      	ldr	r3, [r3, #0]
34009316:	687a      	ldr	r2, [r7, #4]
34009318:	6852      	ldr	r2, [r2, #4]
3400931a:	605a      	str	r2, [r3, #4]
}
3400931c:	bf00      	nop
3400931e:	370c      	adds	r7, #12
34009320:	46bd      	mov	sp, r7
34009322:	f85d 7b04 	ldr.w	r7, [sp], #4
34009326:	4770      	bx	lr

34009328 <knl_delOpnCB>:

/*
 * Free open management block
 */
EXPORT void knl_delOpnCB( OpnCB *opncb, BOOL free )
{
34009328:	b580      	push	{r7, lr}
3400932a:	b082      	sub	sp, #8
3400932c:	af00      	add	r7, sp, #0
3400932e:	6078      	str	r0, [r7, #4]
34009330:	6039      	str	r1, [r7, #0]
	QueRemove(&opncb->q);
34009332:	687b      	ldr	r3, [r7, #4]
34009334:	4618      	mov	r0, r3
34009336:	f7ff ffde 	bl	340092f6 <QueRemove>
	QueRemove(&opncb->resq);
3400933a:	687b      	ldr	r3, [r7, #4]
3400933c:	3308      	adds	r3, #8
3400933e:	4618      	mov	r0, r3
34009340:	f7ff ffd9 	bl	340092f6 <QueRemove>

	if ( free ) {
34009344:	683b      	ldr	r3, [r7, #0]
34009346:	2b00      	cmp	r3, #0
34009348:	d004      	beq.n	34009354 <knl_delOpnCB+0x2c>
		QueInsert(&opncb->q, &knl_FreeOpnCB);
3400934a:	687b      	ldr	r3, [r7, #4]
3400934c:	4905      	ldr	r1, [pc, #20]	@ (34009364 <knl_delOpnCB+0x3c>)
3400934e:	4618      	mov	r0, r3
34009350:	f7ff ffb8 	bl	340092c4 <QueInsert>
	}
	opncb->resid = 0;
34009354:	687b      	ldr	r3, [r7, #4]
34009356:	2200      	movs	r2, #0
34009358:	611a      	str	r2, [r3, #16]
}
3400935a:	bf00      	nop
3400935c:	3708      	adds	r7, #8
3400935e:	46bd      	mov	sp, r7
34009360:	bd80      	pop	{r7, pc}
34009362:	bf00      	nop
34009364:	3400fd5c 	.word	0x3400fd5c

34009368 <knl_delReqCB>:

/*
 * Free request management block
 */
EXPORT void knl_delReqCB( ReqCB *reqcb )
{
34009368:	b580      	push	{r7, lr}
3400936a:	b082      	sub	sp, #8
3400936c:	af00      	add	r7, sp, #0
3400936e:	6078      	str	r0, [r7, #4]
	QueRemove(&reqcb->q);
34009370:	687b      	ldr	r3, [r7, #4]
34009372:	4618      	mov	r0, r3
34009374:	f7ff ffbf 	bl	340092f6 <QueRemove>

	QueInsert(&reqcb->q, &knl_FreeReqCB);
34009378:	687b      	ldr	r3, [r7, #4]
3400937a:	4905      	ldr	r1, [pc, #20]	@ (34009390 <knl_delReqCB+0x28>)
3400937c:	4618      	mov	r0, r3
3400937e:	f7ff ffa1 	bl	340092c4 <QueInsert>
	reqcb->opncb = NULL;
34009382:	687b      	ldr	r3, [r7, #4]
34009384:	2200      	movs	r2, #0
34009386:	609a      	str	r2, [r3, #8]
}
34009388:	bf00      	nop
3400938a:	3708      	adds	r7, #8
3400938c:	46bd      	mov	sp, r7
3400938e:	bd80      	pop	{r7, pc}
34009390:	340100a4 	.word	0x340100a4

34009394 <knl_chkopen>:

/*
 * TRUE if specified device is open.
 */
EXPORT BOOL knl_chkopen( DevCB *devcb, INT unitno )
{
34009394:	b480      	push	{r7}
34009396:	b085      	sub	sp, #20
34009398:	af00      	add	r7, sp, #0
3400939a:	6078      	str	r0, [r7, #4]
3400939c:	6039      	str	r1, [r7, #0]
	QUEUE	*q;

	for ( q = devcb->openq.next; q != &devcb->openq; q = q->next ) {
3400939e:	687b      	ldr	r3, [r7, #4]
340093a0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340093a2:	60fb      	str	r3, [r7, #12]
340093a4:	e009      	b.n	340093ba <knl_chkopen+0x26>
		if ( ((OpnCB*)q)->unitno == unitno ) {
340093a6:	68fb      	ldr	r3, [r7, #12]
340093a8:	699b      	ldr	r3, [r3, #24]
340093aa:	683a      	ldr	r2, [r7, #0]
340093ac:	429a      	cmp	r2, r3
340093ae:	d101      	bne.n	340093b4 <knl_chkopen+0x20>
			return TRUE;
340093b0:	2301      	movs	r3, #1
340093b2:	e008      	b.n	340093c6 <knl_chkopen+0x32>
	for ( q = devcb->openq.next; q != &devcb->openq; q = q->next ) {
340093b4:	68fb      	ldr	r3, [r7, #12]
340093b6:	681b      	ldr	r3, [r3, #0]
340093b8:	60fb      	str	r3, [r7, #12]
340093ba:	687b      	ldr	r3, [r7, #4]
340093bc:	3340      	adds	r3, #64	@ 0x40
340093be:	68fa      	ldr	r2, [r7, #12]
340093c0:	429a      	cmp	r2, r3
340093c2:	d1f0      	bne.n	340093a6 <knl_chkopen+0x12>
		}
	}
	return FALSE;
340093c4:	2300      	movs	r3, #0
}
340093c6:	4618      	mov	r0, r3
340093c8:	3714      	adds	r7, #20
340093ca:	46bd      	mov	sp, r7
340093cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340093d0:	4770      	bx	lr
	...

340093d4 <abort_allrequest>:

/*
 * Abort all requests
 */
LOCAL void abort_allrequest( OpnCB *opncb )
{
340093d4:	b590      	push	{r4, r7, lr}
340093d6:	b089      	sub	sp, #36	@ 0x24
340093d8:	af00      	add	r7, sp, #0
340093da:	6078      	str	r0, [r7, #4]
	DevCB	*devcb;
	ReqCB	*reqcb;
	QUEUE	*q;

	/* If 'execfn' and 'waitfn' are called, execute abort request. */
	LockDM();
340093dc:	2100      	movs	r1, #0
340093de:	4876      	ldr	r0, [pc, #472]	@ (340095b8 <abort_allrequest+0x1e4>)
340093e0:	f002 fee1 	bl	3400c1a6 <MLock>

	devcb = opncb->devcb;
340093e4:	687b      	ldr	r3, [r7, #4]
340093e6:	695b      	ldr	r3, [r3, #20]
340093e8:	61bb      	str	r3, [r7, #24]
	abortfn = (ABTFN)devcb->ddev.abortfn;
340093ea:	69bb      	ldr	r3, [r7, #24]
340093ec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340093ee:	617b      	str	r3, [r7, #20]
	waitfn  = (WAIFN)devcb->ddev.waitfn;
340093f0:	69bb      	ldr	r3, [r7, #24]
340093f2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340093f4:	613b      	str	r3, [r7, #16]
	exinf   = devcb->ddev.exinf;
340093f6:	69bb      	ldr	r3, [r7, #24]
340093f8:	695b      	ldr	r3, [r3, #20]
340093fa:	60fb      	str	r3, [r7, #12]

	opncb->abort_tskid = tk_get_tid();
340093fc:	f001 ff86 	bl	3400b30c <tk_get_tid>
34009400:	4602      	mov	r2, r0
34009402:	687b      	ldr	r3, [r7, #4]
34009404:	635a      	str	r2, [r3, #52]	@ 0x34
	opncb->abort_cnt = 0;
34009406:	687b      	ldr	r3, [r7, #4]
34009408:	2200      	movs	r2, #0
3400940a:	639a      	str	r2, [r3, #56]	@ 0x38

	if ( opncb->nwaireq > 0 ) {
3400940c:	687b      	ldr	r3, [r7, #4]
3400940e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34009410:	2b00      	cmp	r3, #0
34009412:	dd2e      	ble.n	34009472 <abort_allrequest+0x9e>
		/* Multiple requests wait */
		reqcb = DEVREQ_REQCB(opncb->waireqlst);
34009414:	687b      	ldr	r3, [r7, #4]
34009416:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34009418:	3b10      	subs	r3, #16
3400941a:	60bb      	str	r3, [r7, #8]

		/* Device driver call */
		DISABLE_INTERRUPT;
3400941c:	f004 fab3 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode++;
34009420:	4b66      	ldr	r3, [pc, #408]	@ (340095bc <abort_allrequest+0x1e8>)
34009422:	681b      	ldr	r3, [r3, #0]
34009424:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
34009428:	b292      	uxth	r2, r2
3400942a:	3201      	adds	r2, #1
3400942c:	b292      	uxth	r2, r2
3400942e:	b212      	sxth	r2, r2
34009430:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009432:	2000      	movs	r0, #0
34009434:	f004 fa8b 	bl	3400d94e <set_basepri>
		(*abortfn)(reqcb->tskid, opncb->waireqlst, opncb->nwaireq, exinf);
34009438:	68bb      	ldr	r3, [r7, #8]
3400943a:	68d8      	ldr	r0, [r3, #12]
3400943c:	687b      	ldr	r3, [r7, #4]
3400943e:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34009440:	687b      	ldr	r3, [r7, #4]
34009442:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
34009444:	697c      	ldr	r4, [r7, #20]
34009446:	68fb      	ldr	r3, [r7, #12]
34009448:	47a0      	blx	r4
		DISABLE_INTERRUPT;
3400944a:	f004 fa9c 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode--;
3400944e:	4b5b      	ldr	r3, [pc, #364]	@ (340095bc <abort_allrequest+0x1e8>)
34009450:	681b      	ldr	r3, [r3, #0]
34009452:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
34009456:	b292      	uxth	r2, r2
34009458:	3a01      	subs	r2, #1
3400945a:	b292      	uxth	r2, r2
3400945c:	b212      	sxth	r2, r2
3400945e:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009460:	2000      	movs	r0, #0
34009462:	f004 fa74 	bl	3400d94e <set_basepri>

		opncb->abort_cnt++;
34009466:	687b      	ldr	r3, [r7, #4]
34009468:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400946a:	1c5a      	adds	r2, r3, #1
3400946c:	687b      	ldr	r3, [r7, #4]
3400946e:	639a      	str	r2, [r3, #56]	@ 0x38
34009470:	e042      	b.n	340094f8 <abort_allrequest+0x124>
	} else {
		/* Start request or single request wait */
		for ( q = opncb->requestq.next; q != &opncb->requestq; q = q->next ) {
34009472:	687b      	ldr	r3, [r7, #4]
34009474:	6a1b      	ldr	r3, [r3, #32]
34009476:	61fb      	str	r3, [r7, #28]
34009478:	e039      	b.n	340094ee <abort_allrequest+0x11a>
			reqcb = (ReqCB*)q;
3400947a:	69fb      	ldr	r3, [r7, #28]
3400947c:	60bb      	str	r3, [r7, #8]
			if ( reqcb->tskid == 0 ) {
3400947e:	68bb      	ldr	r3, [r7, #8]
34009480:	68db      	ldr	r3, [r3, #12]
34009482:	2b00      	cmp	r3, #0
34009484:	d02f      	beq.n	340094e6 <abort_allrequest+0x112>
				continue;
			}

			reqcb->req.abort = TRUE;
34009486:	68ba      	ldr	r2, [r7, #8]
34009488:	7f13      	ldrb	r3, [r2, #28]
3400948a:	f043 0310 	orr.w	r3, r3, #16
3400948e:	7713      	strb	r3, [r2, #28]

			/* Device driver call */
			DISABLE_INTERRUPT;
34009490:	f004 fa79 	bl	3400d986 <disint>
			knl_ctxtsk->sysmode++;
34009494:	4b49      	ldr	r3, [pc, #292]	@ (340095bc <abort_allrequest+0x1e8>)
34009496:	681b      	ldr	r3, [r3, #0]
34009498:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400949c:	b292      	uxth	r2, r2
3400949e:	3201      	adds	r2, #1
340094a0:	b292      	uxth	r2, r2
340094a2:	b212      	sxth	r2, r2
340094a4:	845a      	strh	r2, [r3, #34]	@ 0x22
			ENABLE_INTERRUPT;
340094a6:	2000      	movs	r0, #0
340094a8:	f004 fa51 	bl	3400d94e <set_basepri>
			(*abortfn)(reqcb->tskid, &reqcb->req, 1, exinf);
340094ac:	68bb      	ldr	r3, [r7, #8]
340094ae:	68d8      	ldr	r0, [r3, #12]
340094b0:	68bb      	ldr	r3, [r7, #8]
340094b2:	f103 0110 	add.w	r1, r3, #16
340094b6:	697c      	ldr	r4, [r7, #20]
340094b8:	68fb      	ldr	r3, [r7, #12]
340094ba:	2201      	movs	r2, #1
340094bc:	47a0      	blx	r4
			DISABLE_INTERRUPT;
340094be:	f004 fa62 	bl	3400d986 <disint>
			knl_ctxtsk->sysmode--;
340094c2:	4b3e      	ldr	r3, [pc, #248]	@ (340095bc <abort_allrequest+0x1e8>)
340094c4:	681b      	ldr	r3, [r3, #0]
340094c6:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
340094ca:	b292      	uxth	r2, r2
340094cc:	3a01      	subs	r2, #1
340094ce:	b292      	uxth	r2, r2
340094d0:	b212      	sxth	r2, r2
340094d2:	845a      	strh	r2, [r3, #34]	@ 0x22
			ENABLE_INTERRUPT;
340094d4:	2000      	movs	r0, #0
340094d6:	f004 fa3a 	bl	3400d94e <set_basepri>

			opncb->abort_cnt++;
340094da:	687b      	ldr	r3, [r7, #4]
340094dc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340094de:	1c5a      	adds	r2, r3, #1
340094e0:	687b      	ldr	r3, [r7, #4]
340094e2:	639a      	str	r2, [r3, #56]	@ 0x38
340094e4:	e000      	b.n	340094e8 <abort_allrequest+0x114>
				continue;
340094e6:	bf00      	nop
		for ( q = opncb->requestq.next; q != &opncb->requestq; q = q->next ) {
340094e8:	69fb      	ldr	r3, [r7, #28]
340094ea:	681b      	ldr	r3, [r3, #0]
340094ec:	61fb      	str	r3, [r7, #28]
340094ee:	687b      	ldr	r3, [r7, #4]
340094f0:	3320      	adds	r3, #32
340094f2:	69fa      	ldr	r2, [r7, #28]
340094f4:	429a      	cmp	r2, r3
340094f6:	d1c0      	bne.n	3400947a <abort_allrequest+0xa6>
		}
	}

	UnlockDM();
340094f8:	2100      	movs	r1, #0
340094fa:	482f      	ldr	r0, [pc, #188]	@ (340095b8 <abort_allrequest+0x1e4>)
340094fc:	f002 fe63 	bl	3400c1c6 <MUnlock>

	if ( opncb->abort_cnt > 0 ) {
34009500:	687b      	ldr	r3, [r7, #4]
34009502:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34009504:	2b00      	cmp	r3, #0
34009506:	dd07      	ble.n	34009518 <abort_allrequest+0x144>
		/* Wait for completion of abort request processing */
		tk_wai_sem(opncb->abort_semid, 1, TMO_FEVR);
34009508:	687b      	ldr	r3, [r7, #4]
3400950a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400950c:	f04f 32ff 	mov.w	r2, #4294967295
34009510:	2101      	movs	r1, #1
34009512:	4618      	mov	r0, r3
34009514:	f001 faca 	bl	3400aaac <tk_wai_sem>
	}
	opncb->abort_tskid = 0;
34009518:	687b      	ldr	r3, [r7, #4]
3400951a:	2200      	movs	r2, #0
3400951c:	635a      	str	r2, [r3, #52]	@ 0x34

	/* Abort remaining requests and wait for completion */
	LockDM();
3400951e:	2100      	movs	r1, #0
34009520:	4825      	ldr	r0, [pc, #148]	@ (340095b8 <abort_allrequest+0x1e4>)
34009522:	f002 fe40 	bl	3400c1a6 <MLock>
	while ( !isQueEmpty(&opncb->requestq) ) {
34009526:	e037      	b.n	34009598 <abort_allrequest+0x1c4>
		reqcb = (ReqCB*)opncb->requestq.next;
34009528:	687b      	ldr	r3, [r7, #4]
3400952a:	6a1b      	ldr	r3, [r3, #32]
3400952c:	60bb      	str	r3, [r7, #8]
		reqcb->req.abort = TRUE;
3400952e:	68ba      	ldr	r2, [r7, #8]
34009530:	7f13      	ldrb	r3, [r2, #28]
34009532:	f043 0310 	orr.w	r3, r3, #16
34009536:	7713      	strb	r3, [r2, #28]

		UnlockDM();
34009538:	2100      	movs	r1, #0
3400953a:	481f      	ldr	r0, [pc, #124]	@ (340095b8 <abort_allrequest+0x1e4>)
3400953c:	f002 fe43 	bl	3400c1c6 <MUnlock>

		/* Device driver call */
		DISABLE_INTERRUPT;
34009540:	f004 fa21 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode++;
34009544:	4b1d      	ldr	r3, [pc, #116]	@ (340095bc <abort_allrequest+0x1e8>)
34009546:	681b      	ldr	r3, [r3, #0]
34009548:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400954c:	b292      	uxth	r2, r2
3400954e:	3201      	adds	r2, #1
34009550:	b292      	uxth	r2, r2
34009552:	b212      	sxth	r2, r2
34009554:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009556:	2000      	movs	r0, #0
34009558:	f004 f9f9 	bl	3400d94e <set_basepri>
		(*waitfn)(&reqcb->req, 1, TMO_FEVR, exinf);
3400955c:	68bb      	ldr	r3, [r7, #8]
3400955e:	f103 0010 	add.w	r0, r3, #16
34009562:	693c      	ldr	r4, [r7, #16]
34009564:	68fb      	ldr	r3, [r7, #12]
34009566:	f04f 32ff 	mov.w	r2, #4294967295
3400956a:	2101      	movs	r1, #1
3400956c:	47a0      	blx	r4
		DISABLE_INTERRUPT;
3400956e:	f004 fa0a 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode--;
34009572:	4b12      	ldr	r3, [pc, #72]	@ (340095bc <abort_allrequest+0x1e8>)
34009574:	681b      	ldr	r3, [r3, #0]
34009576:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400957a:	b292      	uxth	r2, r2
3400957c:	3a01      	subs	r2, #1
3400957e:	b292      	uxth	r2, r2
34009580:	b212      	sxth	r2, r2
34009582:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009584:	2000      	movs	r0, #0
34009586:	f004 f9e2 	bl	3400d94e <set_basepri>

		LockDM();
3400958a:	2100      	movs	r1, #0
3400958c:	480a      	ldr	r0, [pc, #40]	@ (340095b8 <abort_allrequest+0x1e4>)
3400958e:	f002 fe0a 	bl	3400c1a6 <MLock>

		/* Unregister completed request */
		knl_delReqCB(reqcb);
34009592:	68b8      	ldr	r0, [r7, #8]
34009594:	f7ff fee8 	bl	34009368 <knl_delReqCB>
	while ( !isQueEmpty(&opncb->requestq) ) {
34009598:	687b      	ldr	r3, [r7, #4]
3400959a:	3320      	adds	r3, #32
3400959c:	4618      	mov	r0, r3
3400959e:	f7ff fe7f 	bl	340092a0 <isQueEmpty>
340095a2:	4603      	mov	r3, r0
340095a4:	2b00      	cmp	r3, #0
340095a6:	d0bf      	beq.n	34009528 <abort_allrequest+0x154>
	}
	UnlockDM();
340095a8:	2100      	movs	r1, #0
340095aa:	4803      	ldr	r0, [pc, #12]	@ (340095b8 <abort_allrequest+0x1e4>)
340095ac:	f002 fe0b 	bl	3400c1c6 <MUnlock>
}
340095b0:	bf00      	nop
340095b2:	3724      	adds	r7, #36	@ 0x24
340095b4:	46bd      	mov	sp, r7
340095b6:	bd90      	pop	{r4, r7, pc}
340095b8:	3400f6f8 	.word	0x3400f6f8
340095bc:	340109c8 	.word	0x340109c8

340095c0 <knl_close_device>:

/*
 * Device close processing
 */
EXPORT ER knl_close_device( OpnCB *opncb, UINT option )
{
340095c0:	b580      	push	{r7, lr}
340095c2:	b088      	sub	sp, #32
340095c4:	af00      	add	r7, sp, #0
340095c6:	6078      	str	r0, [r7, #4]
340095c8:	6039      	str	r1, [r7, #0]
	CLSFN	closefn;
	void	*exinf;
	ID	devid;
	DevCB	*devcb;
	INT	unitno;
	ER	ercd = E_OK;
340095ca:	2300      	movs	r3, #0
340095cc:	61bb      	str	r3, [r7, #24]

	/* Abort all requests during processing */
	abort_allrequest(opncb);
340095ce:	6878      	ldr	r0, [r7, #4]
340095d0:	f7ff ff00 	bl	340093d4 <abort_allrequest>

	LockDM();
340095d4:	2100      	movs	r1, #0
340095d6:	4839      	ldr	r0, [pc, #228]	@ (340096bc <knl_close_device+0xfc>)
340095d8:	f002 fde5 	bl	3400c1a6 <MLock>

	devcb  = opncb->devcb;
340095dc:	687b      	ldr	r3, [r7, #4]
340095de:	695b      	ldr	r3, [r3, #20]
340095e0:	617b      	str	r3, [r7, #20]
	unitno = opncb->unitno;
340095e2:	687b      	ldr	r3, [r7, #4]
340095e4:	699b      	ldr	r3, [r3, #24]
340095e6:	613b      	str	r3, [r7, #16]
	closefn = (CLSFN)devcb->ddev.closefn;
340095e8:	697b      	ldr	r3, [r7, #20]
340095ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340095ec:	61fb      	str	r3, [r7, #28]
	exinf = devcb->ddev.exinf;
340095ee:	697b      	ldr	r3, [r7, #20]
340095f0:	695b      	ldr	r3, [r3, #20]
340095f2:	60fb      	str	r3, [r7, #12]
	devid = DEVID(devcb, unitno);
340095f4:	697b      	ldr	r3, [r7, #20]
340095f6:	4a32      	ldr	r2, [pc, #200]	@ (340096c0 <knl_close_device+0x100>)
340095f8:	1a9b      	subs	r3, r3, r2
340095fa:	10db      	asrs	r3, r3, #3
340095fc:	4a31      	ldr	r2, [pc, #196]	@ (340096c4 <knl_close_device+0x104>)
340095fe:	fb02 f303 	mul.w	r3, r2, r3
34009602:	3301      	adds	r3, #1
34009604:	021b      	lsls	r3, r3, #8
34009606:	693a      	ldr	r2, [r7, #16]
34009608:	4413      	add	r3, r2
3400960a:	60bb      	str	r3, [r7, #8]

	/* Delete semaphore for completion check of abortion */
	tk_del_sem(opncb->abort_semid);
3400960c:	687b      	ldr	r3, [r7, #4]
3400960e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34009610:	4618      	mov	r0, r3
34009612:	f001 f923 	bl	3400a85c <tk_del_sem>

	/* Free open management block */
	knl_delOpnCB(opncb, FALSE);
34009616:	2100      	movs	r1, #0
34009618:	6878      	ldr	r0, [r7, #4]
3400961a:	f7ff fe85 	bl	34009328 <knl_delOpnCB>

	/* Is device driver call required? */
	if ( knl_chkopen(devcb, unitno) ) {
3400961e:	6939      	ldr	r1, [r7, #16]
34009620:	6978      	ldr	r0, [r7, #20]
34009622:	f7ff feb7 	bl	34009394 <knl_chkopen>
34009626:	4603      	mov	r3, r0
34009628:	2b00      	cmp	r3, #0
3400962a:	d00b      	beq.n	34009644 <knl_close_device+0x84>
		option &= ~TD_EJECT;
3400962c:	683b      	ldr	r3, [r7, #0]
3400962e:	f023 0301 	bic.w	r3, r3, #1
34009632:	603b      	str	r3, [r7, #0]
		if ( (devcb->ddev.drvatr & TDA_OPENREQ) == 0 ) {
34009634:	697b      	ldr	r3, [r7, #20]
34009636:	699b      	ldr	r3, [r3, #24]
34009638:	f003 0301 	and.w	r3, r3, #1
3400963c:	2b00      	cmp	r3, #0
3400963e:	d101      	bne.n	34009644 <knl_close_device+0x84>
			closefn = NULL;
34009640:	2300      	movs	r3, #0
34009642:	61fb      	str	r3, [r7, #28]
		}
	}

	UnlockDM();
34009644:	2100      	movs	r1, #0
34009646:	481d      	ldr	r0, [pc, #116]	@ (340096bc <knl_close_device+0xfc>)
34009648:	f002 fdbd 	bl	3400c1c6 <MUnlock>

	if ( closefn != NULL ) {
3400964c:	69fb      	ldr	r3, [r7, #28]
3400964e:	2b00      	cmp	r3, #0
34009650:	d021      	beq.n	34009696 <knl_close_device+0xd6>
		/* Device driver call */
		DISABLE_INTERRUPT;
34009652:	f004 f998 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode++;
34009656:	4b1c      	ldr	r3, [pc, #112]	@ (340096c8 <knl_close_device+0x108>)
34009658:	681b      	ldr	r3, [r3, #0]
3400965a:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400965e:	b292      	uxth	r2, r2
34009660:	3201      	adds	r2, #1
34009662:	b292      	uxth	r2, r2
34009664:	b212      	sxth	r2, r2
34009666:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009668:	2000      	movs	r0, #0
3400966a:	f004 f970 	bl	3400d94e <set_basepri>
		ercd = (*closefn)(devid, option, exinf);
3400966e:	69fb      	ldr	r3, [r7, #28]
34009670:	68fa      	ldr	r2, [r7, #12]
34009672:	6839      	ldr	r1, [r7, #0]
34009674:	68b8      	ldr	r0, [r7, #8]
34009676:	4798      	blx	r3
34009678:	61b8      	str	r0, [r7, #24]
		DISABLE_INTERRUPT;
3400967a:	f004 f984 	bl	3400d986 <disint>
		knl_ctxtsk->sysmode--;
3400967e:	4b12      	ldr	r3, [pc, #72]	@ (340096c8 <knl_close_device+0x108>)
34009680:	681b      	ldr	r3, [r3, #0]
34009682:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
34009686:	b292      	uxth	r2, r2
34009688:	3a01      	subs	r2, #1
3400968a:	b292      	uxth	r2, r2
3400968c:	b212      	sxth	r2, r2
3400968e:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
34009690:	2000      	movs	r0, #0
34009692:	f004 f95c 	bl	3400d94e <set_basepri>
	}

	LockDM();
34009696:	2100      	movs	r1, #0
34009698:	4808      	ldr	r0, [pc, #32]	@ (340096bc <knl_close_device+0xfc>)
3400969a:	f002 fd84 	bl	3400c1a6 <MLock>
	/* Return open management block to FreeQue */
	QueInsert(&opncb->q, &knl_FreeOpnCB);
3400969e:	687b      	ldr	r3, [r7, #4]
340096a0:	490a      	ldr	r1, [pc, #40]	@ (340096cc <knl_close_device+0x10c>)
340096a2:	4618      	mov	r0, r3
340096a4:	f7ff fe0e 	bl	340092c4 <QueInsert>
	UnlockDM();
340096a8:	2100      	movs	r1, #0
340096aa:	4804      	ldr	r0, [pc, #16]	@ (340096bc <knl_close_device+0xfc>)
340096ac:	f002 fd8b 	bl	3400c1c6 <MUnlock>

	return ercd;
340096b0:	69bb      	ldr	r3, [r7, #24]
}
340096b2:	4618      	mov	r0, r3
340096b4:	3720      	adds	r7, #32
340096b6:	46bd      	mov	sp, r7
340096b8:	bd80      	pop	{r7, pc}
340096ba:	bf00      	nop
340096bc:	3400f6f8 	.word	0x3400f6f8
340096c0:	3400f70c 	.word	0x3400f70c
340096c4:	38e38e39 	.word	0x38e38e39
340096c8:	340109c8 	.word	0x340109c8
340096cc:	3400fd5c 	.word	0x3400fd5c

340096d0 <knl_devmgr_startup>:

/*
 * Device management startup function
 */
EXPORT void knl_devmgr_startup( void )
{
340096d0:	b580      	push	{r7, lr}
340096d2:	af00      	add	r7, sp, #0
	LockDM();
340096d4:	2100      	movs	r1, #0
340096d6:	4807      	ldr	r0, [pc, #28]	@ (340096f4 <knl_devmgr_startup+0x24>)
340096d8:	f002 fd65 	bl	3400c1a6 <MLock>

	/* Initialization of open device management queue */
	QueInit(&(knl_resource_control_block.openq));
340096dc:	4806      	ldr	r0, [pc, #24]	@ (340096f8 <knl_devmgr_startup+0x28>)
340096de:	f7ff fdcf 	bl	34009280 <QueInit>
	knl_resource_control_block.dissus = 0;
340096e2:	4b05      	ldr	r3, [pc, #20]	@ (340096f8 <knl_devmgr_startup+0x28>)
340096e4:	2200      	movs	r2, #0
340096e6:	609a      	str	r2, [r3, #8]
	
	UnlockDM();
340096e8:	2100      	movs	r1, #0
340096ea:	4802      	ldr	r0, [pc, #8]	@ (340096f4 <knl_devmgr_startup+0x24>)
340096ec:	f002 fd6b 	bl	3400c1c6 <MUnlock>

	return;
340096f0:	bf00      	nop
}
340096f2:	bd80      	pop	{r7, pc}
340096f4:	3400f6f8 	.word	0x3400f6f8
340096f8:	340100ac 	.word	0x340100ac

340096fc <knl_devmgr_cleanup>:

/*
 * Device management cleanup function
 */
EXPORT void knl_devmgr_cleanup( void )
{
340096fc:	b580      	push	{r7, lr}
340096fe:	b082      	sub	sp, #8
34009700:	af00      	add	r7, sp, #0
	OpnCB	*opncb;

	/* Do nothing if it is not used even once */
	if ( knl_resource_control_block.openq.next == NULL ) {
34009702:	4b1a      	ldr	r3, [pc, #104]	@ (3400976c <knl_devmgr_cleanup+0x70>)
34009704:	681b      	ldr	r3, [r3, #0]
34009706:	2b00      	cmp	r3, #0
34009708:	d02c      	beq.n	34009764 <knl_devmgr_cleanup+0x68>
		return;
	}

	LockDM();
3400970a:	2100      	movs	r1, #0
3400970c:	4818      	ldr	r0, [pc, #96]	@ (34009770 <knl_devmgr_cleanup+0x74>)
3400970e:	f002 fd4a 	bl	3400c1a6 <MLock>

	/* Free suspend disable request */
	knl_DisSusCnt -= knl_resource_control_block.dissus;
34009712:	4b18      	ldr	r3, [pc, #96]	@ (34009774 <knl_devmgr_cleanup+0x78>)
34009714:	681a      	ldr	r2, [r3, #0]
34009716:	4b15      	ldr	r3, [pc, #84]	@ (3400976c <knl_devmgr_cleanup+0x70>)
34009718:	689b      	ldr	r3, [r3, #8]
3400971a:	1ad3      	subs	r3, r2, r3
3400971c:	4a15      	ldr	r2, [pc, #84]	@ (34009774 <knl_devmgr_cleanup+0x78>)
3400971e:	6013      	str	r3, [r2, #0]
	knl_resource_control_block.dissus = 0;
34009720:	4b12      	ldr	r3, [pc, #72]	@ (3400976c <knl_devmgr_cleanup+0x70>)
34009722:	2200      	movs	r2, #0
34009724:	609a      	str	r2, [r3, #8]

	/* Close all open devices */
	while ( !isQueEmpty(&(knl_resource_control_block.openq)) ) {
34009726:	e012      	b.n	3400974e <knl_devmgr_cleanup+0x52>
		opncb = RESQ_OPNCB(knl_resource_control_block.openq.next);
34009728:	4b10      	ldr	r3, [pc, #64]	@ (3400976c <knl_devmgr_cleanup+0x70>)
3400972a:	681b      	ldr	r3, [r3, #0]
3400972c:	3b08      	subs	r3, #8
3400972e:	607b      	str	r3, [r7, #4]

		/* Indicate that it is during close processing */
		opncb->resid = 0;
34009730:	687b      	ldr	r3, [r7, #4]
34009732:	2200      	movs	r2, #0
34009734:	611a      	str	r2, [r3, #16]

		UnlockDM();
34009736:	2100      	movs	r1, #0
34009738:	480d      	ldr	r0, [pc, #52]	@ (34009770 <knl_devmgr_cleanup+0x74>)
3400973a:	f002 fd44 	bl	3400c1c6 <MUnlock>

		/* Device close processing */
		knl_close_device(opncb, 0);
3400973e:	2100      	movs	r1, #0
34009740:	6878      	ldr	r0, [r7, #4]
34009742:	f7ff ff3d 	bl	340095c0 <knl_close_device>

		LockDM();
34009746:	2100      	movs	r1, #0
34009748:	4809      	ldr	r0, [pc, #36]	@ (34009770 <knl_devmgr_cleanup+0x74>)
3400974a:	f002 fd2c 	bl	3400c1a6 <MLock>
	while ( !isQueEmpty(&(knl_resource_control_block.openq)) ) {
3400974e:	4807      	ldr	r0, [pc, #28]	@ (3400976c <knl_devmgr_cleanup+0x70>)
34009750:	f7ff fda6 	bl	340092a0 <isQueEmpty>
34009754:	4603      	mov	r3, r0
34009756:	2b00      	cmp	r3, #0
34009758:	d0e6      	beq.n	34009728 <knl_devmgr_cleanup+0x2c>
	}
	UnlockDM();
3400975a:	2100      	movs	r1, #0
3400975c:	4804      	ldr	r0, [pc, #16]	@ (34009770 <knl_devmgr_cleanup+0x74>)
3400975e:	f002 fd32 	bl	3400c1c6 <MUnlock>

	return;
34009762:	e000      	b.n	34009766 <knl_devmgr_cleanup+0x6a>
		return;
34009764:	bf00      	nop
}
34009766:	3708      	adds	r7, #8
34009768:	46bd      	mov	sp, r7
3400976a:	bd80      	pop	{r7, pc}
3400976c:	340100ac 	.word	0x340100ac
34009770:	3400f6f8 	.word	0x3400f6f8
34009774:	3400f2a8 	.word	0x3400f2a8

34009778 <knl_initDevIO>:

/*
 * Initialization sequence of device input/output-related
 */
EXPORT ER knl_initDevIO( void )
{
34009778:	b580      	push	{r7, lr}
3400977a:	b082      	sub	sp, #8
3400977c:	af00      	add	r7, sp, #0
	INT	i;

	QueInit(&knl_FreeOpnCB);
3400977e:	481f      	ldr	r0, [pc, #124]	@ (340097fc <knl_initDevIO+0x84>)
34009780:	f7ff fd7e 	bl	34009280 <QueInit>
	for ( i = 0; i < MAX_OPNDEV; ++i ) {
34009784:	2300      	movs	r3, #0
34009786:	607b      	str	r3, [r7, #4]
34009788:	e011      	b.n	340097ae <knl_initDevIO+0x36>
		knl_OpnCBtbl[i].resid = 0;
3400978a:	4a1d      	ldr	r2, [pc, #116]	@ (34009800 <knl_initDevIO+0x88>)
3400978c:	687b      	ldr	r3, [r7, #4]
3400978e:	019b      	lsls	r3, r3, #6
34009790:	4413      	add	r3, r2
34009792:	3310      	adds	r3, #16
34009794:	2200      	movs	r2, #0
34009796:	601a      	str	r2, [r3, #0]
		QueInsert(&knl_OpnCBtbl[i].q, &knl_FreeOpnCB);
34009798:	687b      	ldr	r3, [r7, #4]
3400979a:	019b      	lsls	r3, r3, #6
3400979c:	4a18      	ldr	r2, [pc, #96]	@ (34009800 <knl_initDevIO+0x88>)
3400979e:	4413      	add	r3, r2
340097a0:	4916      	ldr	r1, [pc, #88]	@ (340097fc <knl_initDevIO+0x84>)
340097a2:	4618      	mov	r0, r3
340097a4:	f7ff fd8e 	bl	340092c4 <QueInsert>
	for ( i = 0; i < MAX_OPNDEV; ++i ) {
340097a8:	687b      	ldr	r3, [r7, #4]
340097aa:	3301      	adds	r3, #1
340097ac:	607b      	str	r3, [r7, #4]
340097ae:	687b      	ldr	r3, [r7, #4]
340097b0:	2b0f      	cmp	r3, #15
340097b2:	ddea      	ble.n	3400978a <knl_initDevIO+0x12>
	}

	QueInit(&knl_FreeReqCB);
340097b4:	4813      	ldr	r0, [pc, #76]	@ (34009804 <knl_initDevIO+0x8c>)
340097b6:	f7ff fd63 	bl	34009280 <QueInit>
	for ( i = 0; i < MAX_REQDEV; ++i ) {
340097ba:	2300      	movs	r3, #0
340097bc:	607b      	str	r3, [r7, #4]
340097be:	e015      	b.n	340097ec <knl_initDevIO+0x74>
		knl_ReqCBtbl[i].opncb = NULL;
340097c0:	4a11      	ldr	r2, [pc, #68]	@ (34009808 <knl_initDevIO+0x90>)
340097c2:	687b      	ldr	r3, [r7, #4]
340097c4:	2134      	movs	r1, #52	@ 0x34
340097c6:	fb01 f303 	mul.w	r3, r1, r3
340097ca:	4413      	add	r3, r2
340097cc:	3308      	adds	r3, #8
340097ce:	2200      	movs	r2, #0
340097d0:	601a      	str	r2, [r3, #0]
		QueInsert(&knl_ReqCBtbl[i].q, &knl_FreeReqCB);
340097d2:	687b      	ldr	r3, [r7, #4]
340097d4:	2234      	movs	r2, #52	@ 0x34
340097d6:	fb02 f303 	mul.w	r3, r2, r3
340097da:	4a0b      	ldr	r2, [pc, #44]	@ (34009808 <knl_initDevIO+0x90>)
340097dc:	4413      	add	r3, r2
340097de:	4909      	ldr	r1, [pc, #36]	@ (34009804 <knl_initDevIO+0x8c>)
340097e0:	4618      	mov	r0, r3
340097e2:	f7ff fd6f 	bl	340092c4 <QueInsert>
	for ( i = 0; i < MAX_REQDEV; ++i ) {
340097e6:	687b      	ldr	r3, [r7, #4]
340097e8:	3301      	adds	r3, #1
340097ea:	607b      	str	r3, [r7, #4]
340097ec:	687b      	ldr	r3, [r7, #4]
340097ee:	2b0f      	cmp	r3, #15
340097f0:	dde6      	ble.n	340097c0 <knl_initDevIO+0x48>
	}

	return E_OK;
340097f2:	2300      	movs	r3, #0
}
340097f4:	4618      	mov	r0, r3
340097f6:	3708      	adds	r7, #8
340097f8:	46bd      	mov	sp, r7
340097fa:	bd80      	pop	{r7, pc}
340097fc:	3400fd5c 	.word	0x3400fd5c
34009800:	3400f95c 	.word	0x3400f95c
34009804:	340100a4 	.word	0x340100a4
34009808:	3400fd64 	.word	0x3400fd64

3400980c <knl_finishDevIO>:

/*
 * Finalization sequence of device input/output-related
 */
EXPORT ER knl_finishDevIO( void )
{
3400980c:	b480      	push	{r7}
3400980e:	af00      	add	r7, sp, #0
	return E_OK;
34009810:	2300      	movs	r3, #0
}
34009812:	4618      	mov	r0, r3
34009814:	46bd      	mov	sp, r7
34009816:	f85d 7b04 	ldr.w	r7, [sp], #4
3400981a:	4770      	bx	lr

3400981c <QueInit>:
{
3400981c:	b480      	push	{r7}
3400981e:	b083      	sub	sp, #12
34009820:	af00      	add	r7, sp, #0
34009822:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
34009824:	687b      	ldr	r3, [r7, #4]
34009826:	687a      	ldr	r2, [r7, #4]
34009828:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400982a:	687b      	ldr	r3, [r7, #4]
3400982c:	687a      	ldr	r2, [r7, #4]
3400982e:	605a      	str	r2, [r3, #4]
}
34009830:	bf00      	nop
34009832:	370c      	adds	r7, #12
34009834:	46bd      	mov	sp, r7
34009836:	f85d 7b04 	ldr.w	r7, [sp], #4
3400983a:	4770      	bx	lr

3400983c <isQueEmpty>:
{
3400983c:	b480      	push	{r7}
3400983e:	b083      	sub	sp, #12
34009840:	af00      	add	r7, sp, #0
34009842:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
34009844:	687b      	ldr	r3, [r7, #4]
34009846:	681b      	ldr	r3, [r3, #0]
34009848:	687a      	ldr	r2, [r7, #4]
3400984a:	429a      	cmp	r2, r3
3400984c:	bf0c      	ite	eq
3400984e:	2301      	moveq	r3, #1
34009850:	2300      	movne	r3, #0
34009852:	b2db      	uxtb	r3, r3
}
34009854:	4618      	mov	r0, r3
34009856:	370c      	adds	r7, #12
34009858:	46bd      	mov	sp, r7
3400985a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400985e:	4770      	bx	lr

34009860 <QueInsert>:
{
34009860:	b480      	push	{r7}
34009862:	b083      	sub	sp, #12
34009864:	af00      	add	r7, sp, #0
34009866:	6078      	str	r0, [r7, #4]
34009868:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400986a:	683b      	ldr	r3, [r7, #0]
3400986c:	685a      	ldr	r2, [r3, #4]
3400986e:	687b      	ldr	r3, [r7, #4]
34009870:	605a      	str	r2, [r3, #4]
	entry->next = que;
34009872:	687b      	ldr	r3, [r7, #4]
34009874:	683a      	ldr	r2, [r7, #0]
34009876:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
34009878:	683b      	ldr	r3, [r7, #0]
3400987a:	685b      	ldr	r3, [r3, #4]
3400987c:	687a      	ldr	r2, [r7, #4]
3400987e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
34009880:	683b      	ldr	r3, [r7, #0]
34009882:	687a      	ldr	r2, [r7, #4]
34009884:	605a      	str	r2, [r3, #4]
}
34009886:	bf00      	nop
34009888:	370c      	adds	r7, #12
3400988a:	46bd      	mov	sp, r7
3400988c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009890:	4770      	bx	lr

34009892 <QueRemoveNext>:
{
34009892:	b480      	push	{r7}
34009894:	b085      	sub	sp, #20
34009896:	af00      	add	r7, sp, #0
34009898:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400989a:	687b      	ldr	r3, [r7, #4]
3400989c:	681b      	ldr	r3, [r3, #0]
3400989e:	687a      	ldr	r2, [r7, #4]
340098a0:	429a      	cmp	r2, r3
340098a2:	d101      	bne.n	340098a8 <QueRemoveNext+0x16>
		return NULL;
340098a4:	2300      	movs	r3, #0
340098a6:	e00b      	b.n	340098c0 <QueRemoveNext+0x2e>
	entry = que->next;
340098a8:	687b      	ldr	r3, [r7, #4]
340098aa:	681b      	ldr	r3, [r3, #0]
340098ac:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
340098ae:	68fb      	ldr	r3, [r7, #12]
340098b0:	681a      	ldr	r2, [r3, #0]
340098b2:	687b      	ldr	r3, [r7, #4]
340098b4:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
340098b6:	68fb      	ldr	r3, [r7, #12]
340098b8:	681b      	ldr	r3, [r3, #0]
340098ba:	687a      	ldr	r2, [r7, #4]
340098bc:	605a      	str	r2, [r3, #4]
	return entry;
340098be:	68fb      	ldr	r3, [r7, #12]
}
340098c0:	4618      	mov	r0, r3
340098c2:	3714      	adds	r7, #20
340098c4:	46bd      	mov	sp, r7
340098c6:	f85d 7b04 	ldr.w	r7, [sp], #4
340098ca:	4770      	bx	lr

340098cc <knl_isTaskIndependent>:

/*
 * If it is the task-independent part, TRUE
 */
Inline BOOL knl_isTaskIndependent( void )
{
340098cc:	b480      	push	{r7}
340098ce:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
340098d0:	4b05      	ldr	r3, [pc, #20]	@ (340098e8 <knl_isTaskIndependent+0x1c>)
340098d2:	681b      	ldr	r3, [r3, #0]
340098d4:	2b00      	cmp	r3, #0
340098d6:	bfcc      	ite	gt
340098d8:	2301      	movgt	r3, #1
340098da:	2300      	movle	r3, #0
340098dc:	b2db      	uxtb	r3, r3
}
340098de:	4618      	mov	r0, r3
340098e0:	46bd      	mov	sp, r7
340098e2:	f85d 7b04 	ldr.w	r7, [sp], #4
340098e6:	4770      	bx	lr
340098e8:	3400f6b0 	.word	0x3400f6b0

340098ec <knl_eventflag_cond>:

/*
 * Check for event flag wait release condition
 */
Inline BOOL knl_eventflag_cond( FLGCB *flgcb, UINT waiptn, UINT wfmode )
{
340098ec:	b480      	push	{r7}
340098ee:	b085      	sub	sp, #20
340098f0:	af00      	add	r7, sp, #0
340098f2:	60f8      	str	r0, [r7, #12]
340098f4:	60b9      	str	r1, [r7, #8]
340098f6:	607a      	str	r2, [r7, #4]
	if ( (wfmode & TWF_ORW) != 0 ) {
340098f8:	687b      	ldr	r3, [r7, #4]
340098fa:	f003 0301 	and.w	r3, r3, #1
340098fe:	2b00      	cmp	r3, #0
34009900:	d009      	beq.n	34009916 <knl_eventflag_cond+0x2a>
		return ( (flgcb->flgptn & waiptn) != 0 );
34009902:	68fb      	ldr	r3, [r7, #12]
34009904:	695a      	ldr	r2, [r3, #20]
34009906:	68bb      	ldr	r3, [r7, #8]
34009908:	4013      	ands	r3, r2
3400990a:	2b00      	cmp	r3, #0
3400990c:	bf14      	ite	ne
3400990e:	2301      	movne	r3, #1
34009910:	2300      	moveq	r3, #0
34009912:	b2db      	uxtb	r3, r3
34009914:	e009      	b.n	3400992a <knl_eventflag_cond+0x3e>
	} else {
		return ( (flgcb->flgptn & waiptn) == waiptn );
34009916:	68fb      	ldr	r3, [r7, #12]
34009918:	695a      	ldr	r2, [r3, #20]
3400991a:	68bb      	ldr	r3, [r7, #8]
3400991c:	4013      	ands	r3, r2
3400991e:	68ba      	ldr	r2, [r7, #8]
34009920:	429a      	cmp	r2, r3
34009922:	bf0c      	ite	eq
34009924:	2301      	moveq	r3, #1
34009926:	2300      	movne	r3, #0
34009928:	b2db      	uxtb	r3, r3
	}
}
3400992a:	4618      	mov	r0, r3
3400992c:	3714      	adds	r7, #20
3400992e:	46bd      	mov	sp, r7
34009930:	f85d 7b04 	ldr.w	r7, [sp], #4
34009934:	4770      	bx	lr
	...

34009938 <knl_eventflag_initialize>:

/*
 * Initialization of event flag control block 
 */
EXPORT ER knl_eventflag_initialize( void )
{
34009938:	b580      	push	{r7, lr}
3400993a:	b082      	sub	sp, #8
3400993c:	af00      	add	r7, sp, #0
	if ( NUM_FLGID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_flgcb);
3400993e:	480e      	ldr	r0, [pc, #56]	@ (34009978 <knl_eventflag_initialize+0x40>)
34009940:	f7ff ff6c 	bl	3400981c <QueInit>
	end = knl_flgcb_table + NUM_FLGID;
34009944:	4b0d      	ldr	r3, [pc, #52]	@ (3400997c <knl_eventflag_initialize+0x44>)
34009946:	603b      	str	r3, [r7, #0]
	for ( flgcb = knl_flgcb_table; flgcb < end; flgcb++ ) {
34009948:	4b0d      	ldr	r3, [pc, #52]	@ (34009980 <knl_eventflag_initialize+0x48>)
3400994a:	607b      	str	r3, [r7, #4]
3400994c:	e00a      	b.n	34009964 <knl_eventflag_initialize+0x2c>
		flgcb->flgid = 0;
3400994e:	687b      	ldr	r3, [r7, #4]
34009950:	2200      	movs	r2, #0
34009952:	609a      	str	r2, [r3, #8]
		QueInsert(&flgcb->wait_queue, &knl_free_flgcb);
34009954:	687b      	ldr	r3, [r7, #4]
34009956:	4908      	ldr	r1, [pc, #32]	@ (34009978 <knl_eventflag_initialize+0x40>)
34009958:	4618      	mov	r0, r3
3400995a:	f7ff ff81 	bl	34009860 <QueInsert>
	for ( flgcb = knl_flgcb_table; flgcb < end; flgcb++ ) {
3400995e:	687b      	ldr	r3, [r7, #4]
34009960:	3318      	adds	r3, #24
34009962:	607b      	str	r3, [r7, #4]
34009964:	687a      	ldr	r2, [r7, #4]
34009966:	683b      	ldr	r3, [r7, #0]
34009968:	429a      	cmp	r2, r3
3400996a:	d3f0      	bcc.n	3400994e <knl_eventflag_initialize+0x16>
	}

	return E_OK;
3400996c:	2300      	movs	r3, #0
}
3400996e:	4618      	mov	r0, r3
34009970:	3708      	adds	r7, #8
34009972:	46bd      	mov	sp, r7
34009974:	bd80      	pop	{r7, pc}
34009976:	bf00      	nop
34009978:	34010238 	.word	0x34010238
3400997c:	34010238 	.word	0x34010238
34009980:	340100b8 	.word	0x340100b8

34009984 <tk_cre_flg>:

/*
 * Create event flag
 */
SYSCALL ID tk_cre_flg( CONST T_CFLG *pk_cflg )
{
34009984:	b580      	push	{r7, lr}
34009986:	b088      	sub	sp, #32
34009988:	af00      	add	r7, sp, #0
3400998a:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_FLGATR = {
3400998c:	2309      	movs	r3, #9
3400998e:	61bb      	str	r3, [r7, #24]
#endif
	FLGCB	*flgcb;
	ID	flgid;
	ER	ercd;

	CHECK_RSATR(pk_cflg->flgatr, VALID_FLGATR);
34009990:	687b      	ldr	r3, [r7, #4]
34009992:	685a      	ldr	r2, [r3, #4]
34009994:	69bb      	ldr	r3, [r7, #24]
34009996:	43db      	mvns	r3, r3
34009998:	4013      	ands	r3, r2
3400999a:	2b00      	cmp	r3, #0
3400999c:	d002      	beq.n	340099a4 <tk_cre_flg+0x20>
3400999e:	f06f 030a 	mvn.w	r3, #10
340099a2:	e03e      	b.n	34009a22 <tk_cre_flg+0x9e>

	BEGIN_CRITICAL_SECTION;
340099a4:	f003 ffef 	bl	3400d986 <disint>
340099a8:	6178      	str	r0, [r7, #20]
	/* Get control block from FreeQue */
	flgcb = (FLGCB*)QueRemoveNext(&knl_free_flgcb);
340099aa:	4820      	ldr	r0, [pc, #128]	@ (34009a2c <tk_cre_flg+0xa8>)
340099ac:	f7ff ff71 	bl	34009892 <QueRemoveNext>
340099b0:	6138      	str	r0, [r7, #16]
	if ( flgcb == NULL ) {
340099b2:	693b      	ldr	r3, [r7, #16]
340099b4:	2b00      	cmp	r3, #0
340099b6:	d103      	bne.n	340099c0 <tk_cre_flg+0x3c>
		ercd = E_LIMIT;
340099b8:	f06f 0321 	mvn.w	r3, #33	@ 0x21
340099bc:	61fb      	str	r3, [r7, #28]
340099be:	e01d      	b.n	340099fc <tk_cre_flg+0x78>
	} else {
		flgid = ID_FLG(flgcb - knl_flgcb_table);
340099c0:	693b      	ldr	r3, [r7, #16]
340099c2:	4a1b      	ldr	r2, [pc, #108]	@ (34009a30 <tk_cre_flg+0xac>)
340099c4:	1a9b      	subs	r3, r3, r2
340099c6:	10db      	asrs	r3, r3, #3
340099c8:	4a1a      	ldr	r2, [pc, #104]	@ (34009a34 <tk_cre_flg+0xb0>)
340099ca:	fb02 f303 	mul.w	r3, r2, r3
340099ce:	3301      	adds	r3, #1
340099d0:	60fb      	str	r3, [r7, #12]

		/* Initialize control block */
		QueInit(&flgcb->wait_queue);
340099d2:	693b      	ldr	r3, [r7, #16]
340099d4:	4618      	mov	r0, r3
340099d6:	f7ff ff21 	bl	3400981c <QueInit>
		flgcb->flgid = flgid;
340099da:	693b      	ldr	r3, [r7, #16]
340099dc:	68fa      	ldr	r2, [r7, #12]
340099de:	609a      	str	r2, [r3, #8]
		flgcb->exinf = pk_cflg->exinf;
340099e0:	687b      	ldr	r3, [r7, #4]
340099e2:	681a      	ldr	r2, [r3, #0]
340099e4:	693b      	ldr	r3, [r7, #16]
340099e6:	60da      	str	r2, [r3, #12]
		flgcb->flgatr = pk_cflg->flgatr;
340099e8:	687b      	ldr	r3, [r7, #4]
340099ea:	685a      	ldr	r2, [r3, #4]
340099ec:	693b      	ldr	r3, [r7, #16]
340099ee:	611a      	str	r2, [r3, #16]
		flgcb->flgptn = pk_cflg->iflgptn;
340099f0:	687b      	ldr	r3, [r7, #4]
340099f2:	689a      	ldr	r2, [r3, #8]
340099f4:	693b      	ldr	r3, [r7, #16]
340099f6:	615a      	str	r2, [r3, #20]
		if ( (pk_cflg->flgatr & TA_DSNAME) != 0 ) {
			knl_strncpy((char*)flgcb->name, (char*)pk_cflg->dsname,
				OBJECT_NAME_LENGTH);
		}
#endif
		ercd = flgid;
340099f8:	68fb      	ldr	r3, [r7, #12]
340099fa:	61fb      	str	r3, [r7, #28]
	}
	END_CRITICAL_SECTION;
340099fc:	697b      	ldr	r3, [r7, #20]
340099fe:	2b00      	cmp	r3, #0
34009a00:	d10b      	bne.n	34009a1a <tk_cre_flg+0x96>
34009a02:	4b0d      	ldr	r3, [pc, #52]	@ (34009a38 <tk_cre_flg+0xb4>)
34009a04:	681a      	ldr	r2, [r3, #0]
34009a06:	4b0d      	ldr	r3, [pc, #52]	@ (34009a3c <tk_cre_flg+0xb8>)
34009a08:	681b      	ldr	r3, [r3, #0]
34009a0a:	429a      	cmp	r2, r3
34009a0c:	d005      	beq.n	34009a1a <tk_cre_flg+0x96>
34009a0e:	4b0c      	ldr	r3, [pc, #48]	@ (34009a40 <tk_cre_flg+0xbc>)
34009a10:	681b      	ldr	r3, [r3, #0]
34009a12:	2b00      	cmp	r3, #0
34009a14:	d101      	bne.n	34009a1a <tk_cre_flg+0x96>
34009a16:	f003 f877 	bl	3400cb08 <knl_dispatch>
34009a1a:	6978      	ldr	r0, [r7, #20]
34009a1c:	f003 ff97 	bl	3400d94e <set_basepri>

	return ercd;
34009a20:	69fb      	ldr	r3, [r7, #28]
}
34009a22:	4618      	mov	r0, r3
34009a24:	3720      	adds	r7, #32
34009a26:	46bd      	mov	sp, r7
34009a28:	bd80      	pop	{r7, pc}
34009a2a:	bf00      	nop
34009a2c:	34010238 	.word	0x34010238
34009a30:	340100b8 	.word	0x340100b8
34009a34:	aaaaaaab 	.word	0xaaaaaaab
34009a38:	340109c8 	.word	0x340109c8
34009a3c:	340109cc 	.word	0x340109cc
34009a40:	340109c4 	.word	0x340109c4

34009a44 <tk_del_flg>:
#ifdef USE_FUNC_TK_DEL_FLG
/*
 * Delete event flag
 */
SYSCALL ER tk_del_flg( ID flgid )
{
34009a44:	b580      	push	{r7, lr}
34009a46:	b086      	sub	sp, #24
34009a48:	af00      	add	r7, sp, #0
34009a4a:	6078      	str	r0, [r7, #4]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
34009a4c:	2300      	movs	r3, #0
34009a4e:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
34009a50:	687b      	ldr	r3, [r7, #4]
34009a52:	2b00      	cmp	r3, #0
34009a54:	dd02      	ble.n	34009a5c <tk_del_flg+0x18>
34009a56:	687b      	ldr	r3, [r7, #4]
34009a58:	2b10      	cmp	r3, #16
34009a5a:	dd02      	ble.n	34009a62 <tk_del_flg+0x1e>
34009a5c:	f06f 0311 	mvn.w	r3, #17
34009a60:	e032      	b.n	34009ac8 <tk_del_flg+0x84>

	flgcb = get_flgcb(flgid);
34009a62:	687b      	ldr	r3, [r7, #4]
34009a64:	1e5a      	subs	r2, r3, #1
34009a66:	4613      	mov	r3, r2
34009a68:	005b      	lsls	r3, r3, #1
34009a6a:	4413      	add	r3, r2
34009a6c:	00db      	lsls	r3, r3, #3
34009a6e:	4a18      	ldr	r2, [pc, #96]	@ (34009ad0 <tk_del_flg+0x8c>)
34009a70:	4413      	add	r3, r2
34009a72:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
34009a74:	f003 ff87 	bl	3400d986 <disint>
34009a78:	60f8      	str	r0, [r7, #12]
	if ( flgcb->flgid == 0 ) {
34009a7a:	693b      	ldr	r3, [r7, #16]
34009a7c:	689b      	ldr	r3, [r3, #8]
34009a7e:	2b00      	cmp	r3, #0
34009a80:	d103      	bne.n	34009a8a <tk_del_flg+0x46>
		ercd = E_NOEXS;
34009a82:	f06f 0329 	mvn.w	r3, #41	@ 0x29
34009a86:	617b      	str	r3, [r7, #20]
34009a88:	e00b      	b.n	34009aa2 <tk_del_flg+0x5e>
	} else {
		/* Release wait state of task (E_DLT) */
		knl_wait_delete(&flgcb->wait_queue);
34009a8a:	693b      	ldr	r3, [r7, #16]
34009a8c:	4618      	mov	r0, r3
34009a8e:	f002 f901 	bl	3400bc94 <knl_wait_delete>

		/* Return to FreeQue */
		QueInsert(&flgcb->wait_queue, &knl_free_flgcb);
34009a92:	693b      	ldr	r3, [r7, #16]
34009a94:	490f      	ldr	r1, [pc, #60]	@ (34009ad4 <tk_del_flg+0x90>)
34009a96:	4618      	mov	r0, r3
34009a98:	f7ff fee2 	bl	34009860 <QueInsert>
		flgcb->flgid = 0;
34009a9c:	693b      	ldr	r3, [r7, #16]
34009a9e:	2200      	movs	r2, #0
34009aa0:	609a      	str	r2, [r3, #8]
	}
	END_CRITICAL_SECTION;
34009aa2:	68fb      	ldr	r3, [r7, #12]
34009aa4:	2b00      	cmp	r3, #0
34009aa6:	d10b      	bne.n	34009ac0 <tk_del_flg+0x7c>
34009aa8:	4b0b      	ldr	r3, [pc, #44]	@ (34009ad8 <tk_del_flg+0x94>)
34009aaa:	681a      	ldr	r2, [r3, #0]
34009aac:	4b0b      	ldr	r3, [pc, #44]	@ (34009adc <tk_del_flg+0x98>)
34009aae:	681b      	ldr	r3, [r3, #0]
34009ab0:	429a      	cmp	r2, r3
34009ab2:	d005      	beq.n	34009ac0 <tk_del_flg+0x7c>
34009ab4:	4b0a      	ldr	r3, [pc, #40]	@ (34009ae0 <tk_del_flg+0x9c>)
34009ab6:	681b      	ldr	r3, [r3, #0]
34009ab8:	2b00      	cmp	r3, #0
34009aba:	d101      	bne.n	34009ac0 <tk_del_flg+0x7c>
34009abc:	f003 f824 	bl	3400cb08 <knl_dispatch>
34009ac0:	68f8      	ldr	r0, [r7, #12]
34009ac2:	f003 ff44 	bl	3400d94e <set_basepri>

	return ercd;
34009ac6:	697b      	ldr	r3, [r7, #20]
}
34009ac8:	4618      	mov	r0, r3
34009aca:	3718      	adds	r7, #24
34009acc:	46bd      	mov	sp, r7
34009ace:	bd80      	pop	{r7, pc}
34009ad0:	340100b8 	.word	0x340100b8
34009ad4:	34010238 	.word	0x34010238
34009ad8:	340109c8 	.word	0x340109c8
34009adc:	340109cc 	.word	0x340109cc
34009ae0:	340109c4 	.word	0x340109c4

34009ae4 <tk_set_flg>:

/*
 * Event flag set
 */
SYSCALL ER tk_set_flg( ID flgid, UINT setptn )
{
34009ae4:	b580      	push	{r7, lr}
34009ae6:	b08a      	sub	sp, #40	@ 0x28
34009ae8:	af00      	add	r7, sp, #0
34009aea:	6078      	str	r0, [r7, #4]
34009aec:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;
	TCB	*tcb;
	QUEUE	*queue;
	UINT	wfmode, waiptn;
	ER	ercd = E_OK;
34009aee:	2300      	movs	r3, #0
34009af0:	623b      	str	r3, [r7, #32]

	CHECK_FLGID(flgid);
34009af2:	687b      	ldr	r3, [r7, #4]
34009af4:	2b00      	cmp	r3, #0
34009af6:	dd02      	ble.n	34009afe <tk_set_flg+0x1a>
34009af8:	687b      	ldr	r3, [r7, #4]
34009afa:	2b10      	cmp	r3, #16
34009afc:	dd02      	ble.n	34009b04 <tk_set_flg+0x20>
34009afe:	f06f 0311 	mvn.w	r3, #17
34009b02:	e06a      	b.n	34009bda <tk_set_flg+0xf6>

	flgcb = get_flgcb(flgid);
34009b04:	687b      	ldr	r3, [r7, #4]
34009b06:	1e5a      	subs	r2, r3, #1
34009b08:	4613      	mov	r3, r2
34009b0a:	005b      	lsls	r3, r3, #1
34009b0c:	4413      	add	r3, r2
34009b0e:	00db      	lsls	r3, r3, #3
34009b10:	4a34      	ldr	r2, [pc, #208]	@ (34009be4 <tk_set_flg+0x100>)
34009b12:	4413      	add	r3, r2
34009b14:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
34009b16:	f003 ff36 	bl	3400d986 <disint>
34009b1a:	61b8      	str	r0, [r7, #24]
	if ( flgcb->flgid == 0 ) {
34009b1c:	69fb      	ldr	r3, [r7, #28]
34009b1e:	689b      	ldr	r3, [r3, #8]
34009b20:	2b00      	cmp	r3, #0
34009b22:	d103      	bne.n	34009b2c <tk_set_flg+0x48>
		ercd = E_NOEXS;
34009b24:	f06f 0329 	mvn.w	r3, #41	@ 0x29
34009b28:	623b      	str	r3, [r7, #32]
		goto error_exit;
34009b2a:	e043      	b.n	34009bb4 <tk_set_flg+0xd0>
	}

	/* Set event flag */
	flgcb->flgptn |= setptn;
34009b2c:	69fb      	ldr	r3, [r7, #28]
34009b2e:	695a      	ldr	r2, [r3, #20]
34009b30:	683b      	ldr	r3, [r7, #0]
34009b32:	431a      	orrs	r2, r3
34009b34:	69fb      	ldr	r3, [r7, #28]
34009b36:	615a      	str	r2, [r3, #20]

	/* Search task which should be released */
	queue = flgcb->wait_queue.next;
34009b38:	69fb      	ldr	r3, [r7, #28]
34009b3a:	681b      	ldr	r3, [r3, #0]
34009b3c:	627b      	str	r3, [r7, #36]	@ 0x24
	while ( queue != &flgcb->wait_queue ) {
34009b3e:	e033      	b.n	34009ba8 <tk_set_flg+0xc4>
		tcb = (TCB*)queue;
34009b40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34009b42:	617b      	str	r3, [r7, #20]
		queue = queue->next;
34009b44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34009b46:	681b      	ldr	r3, [r3, #0]
34009b48:	627b      	str	r3, [r7, #36]	@ 0x24

		/* Meet condition for release wait? */
		waiptn = tcb->winfo.flg.waiptn;
34009b4a:	697b      	ldr	r3, [r7, #20]
34009b4c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34009b4e:	613b      	str	r3, [r7, #16]
		wfmode = tcb->winfo.flg.wfmode;
34009b50:	697b      	ldr	r3, [r7, #20]
34009b52:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009b54:	60fb      	str	r3, [r7, #12]
		if ( knl_eventflag_cond(flgcb, waiptn, wfmode) ) {
34009b56:	68fa      	ldr	r2, [r7, #12]
34009b58:	6939      	ldr	r1, [r7, #16]
34009b5a:	69f8      	ldr	r0, [r7, #28]
34009b5c:	f7ff fec6 	bl	340098ec <knl_eventflag_cond>
34009b60:	4603      	mov	r3, r0
34009b62:	2b00      	cmp	r3, #0
34009b64:	d020      	beq.n	34009ba8 <tk_set_flg+0xc4>

			/* Release wait */
			*tcb->winfo.flg.p_flgptn = flgcb->flgptn;
34009b66:	697b      	ldr	r3, [r7, #20]
34009b68:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34009b6a:	69fa      	ldr	r2, [r7, #28]
34009b6c:	6952      	ldr	r2, [r2, #20]
34009b6e:	601a      	str	r2, [r3, #0]
			knl_wait_release_ok(tcb);
34009b70:	6978      	ldr	r0, [r7, #20]
34009b72:	f002 f802 	bl	3400bb7a <knl_wait_release_ok>

			/* Clear event flag */
			if ( (wfmode & TWF_BITCLR) != 0 ) {
34009b76:	68fb      	ldr	r3, [r7, #12]
34009b78:	f003 0320 	and.w	r3, r3, #32
34009b7c:	2b00      	cmp	r3, #0
34009b7e:	d00a      	beq.n	34009b96 <tk_set_flg+0xb2>
				if ( (flgcb->flgptn &= ~waiptn) == 0 ) {
34009b80:	69fb      	ldr	r3, [r7, #28]
34009b82:	695a      	ldr	r2, [r3, #20]
34009b84:	693b      	ldr	r3, [r7, #16]
34009b86:	43db      	mvns	r3, r3
34009b88:	401a      	ands	r2, r3
34009b8a:	69fb      	ldr	r3, [r7, #28]
34009b8c:	615a      	str	r2, [r3, #20]
34009b8e:	69fb      	ldr	r3, [r7, #28]
34009b90:	695b      	ldr	r3, [r3, #20]
34009b92:	2b00      	cmp	r3, #0
34009b94:	d00d      	beq.n	34009bb2 <tk_set_flg+0xce>
					break;
				}
			}
			if ( (wfmode & TWF_CLR) != 0 ) {
34009b96:	68fb      	ldr	r3, [r7, #12]
34009b98:	f003 0310 	and.w	r3, r3, #16
34009b9c:	2b00      	cmp	r3, #0
34009b9e:	d003      	beq.n	34009ba8 <tk_set_flg+0xc4>
				flgcb->flgptn = 0;
34009ba0:	69fb      	ldr	r3, [r7, #28]
34009ba2:	2200      	movs	r2, #0
34009ba4:	615a      	str	r2, [r3, #20]
				break;
34009ba6:	e005      	b.n	34009bb4 <tk_set_flg+0xd0>
	while ( queue != &flgcb->wait_queue ) {
34009ba8:	69fb      	ldr	r3, [r7, #28]
34009baa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34009bac:	429a      	cmp	r2, r3
34009bae:	d1c7      	bne.n	34009b40 <tk_set_flg+0x5c>
			}
		}
	}

    error_exit:
34009bb0:	e000      	b.n	34009bb4 <tk_set_flg+0xd0>
					break;
34009bb2:	bf00      	nop
	END_CRITICAL_SECTION;
34009bb4:	69bb      	ldr	r3, [r7, #24]
34009bb6:	2b00      	cmp	r3, #0
34009bb8:	d10b      	bne.n	34009bd2 <tk_set_flg+0xee>
34009bba:	4b0b      	ldr	r3, [pc, #44]	@ (34009be8 <tk_set_flg+0x104>)
34009bbc:	681a      	ldr	r2, [r3, #0]
34009bbe:	4b0b      	ldr	r3, [pc, #44]	@ (34009bec <tk_set_flg+0x108>)
34009bc0:	681b      	ldr	r3, [r3, #0]
34009bc2:	429a      	cmp	r2, r3
34009bc4:	d005      	beq.n	34009bd2 <tk_set_flg+0xee>
34009bc6:	4b0a      	ldr	r3, [pc, #40]	@ (34009bf0 <tk_set_flg+0x10c>)
34009bc8:	681b      	ldr	r3, [r3, #0]
34009bca:	2b00      	cmp	r3, #0
34009bcc:	d101      	bne.n	34009bd2 <tk_set_flg+0xee>
34009bce:	f002 ff9b 	bl	3400cb08 <knl_dispatch>
34009bd2:	69b8      	ldr	r0, [r7, #24]
34009bd4:	f003 febb 	bl	3400d94e <set_basepri>

	return ercd;
34009bd8:	6a3b      	ldr	r3, [r7, #32]
}
34009bda:	4618      	mov	r0, r3
34009bdc:	3728      	adds	r7, #40	@ 0x28
34009bde:	46bd      	mov	sp, r7
34009be0:	bd80      	pop	{r7, pc}
34009be2:	bf00      	nop
34009be4:	340100b8 	.word	0x340100b8
34009be8:	340109c8 	.word	0x340109c8
34009bec:	340109cc 	.word	0x340109cc
34009bf0:	340109c4 	.word	0x340109c4

34009bf4 <tk_clr_flg>:

/*
 * Clear event flag 
 */
SYSCALL ER tk_clr_flg( ID flgid, UINT clrptn )
{
34009bf4:	b580      	push	{r7, lr}
34009bf6:	b086      	sub	sp, #24
34009bf8:	af00      	add	r7, sp, #0
34009bfa:	6078      	str	r0, [r7, #4]
34009bfc:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
34009bfe:	2300      	movs	r3, #0
34009c00:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
34009c02:	687b      	ldr	r3, [r7, #4]
34009c04:	2b00      	cmp	r3, #0
34009c06:	dd02      	ble.n	34009c0e <tk_clr_flg+0x1a>
34009c08:	687b      	ldr	r3, [r7, #4]
34009c0a:	2b10      	cmp	r3, #16
34009c0c:	dd02      	ble.n	34009c14 <tk_clr_flg+0x20>
34009c0e:	f06f 0311 	mvn.w	r3, #17
34009c12:	e02c      	b.n	34009c6e <tk_clr_flg+0x7a>

	flgcb = get_flgcb(flgid);
34009c14:	687b      	ldr	r3, [r7, #4]
34009c16:	1e5a      	subs	r2, r3, #1
34009c18:	4613      	mov	r3, r2
34009c1a:	005b      	lsls	r3, r3, #1
34009c1c:	4413      	add	r3, r2
34009c1e:	00db      	lsls	r3, r3, #3
34009c20:	4a15      	ldr	r2, [pc, #84]	@ (34009c78 <tk_clr_flg+0x84>)
34009c22:	4413      	add	r3, r2
34009c24:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
34009c26:	f003 feae 	bl	3400d986 <disint>
34009c2a:	60f8      	str	r0, [r7, #12]
	if ( flgcb->flgid == 0 ) {
34009c2c:	693b      	ldr	r3, [r7, #16]
34009c2e:	689b      	ldr	r3, [r3, #8]
34009c30:	2b00      	cmp	r3, #0
34009c32:	d103      	bne.n	34009c3c <tk_clr_flg+0x48>
		ercd = E_NOEXS;
34009c34:	f06f 0329 	mvn.w	r3, #41	@ 0x29
34009c38:	617b      	str	r3, [r7, #20]
34009c3a:	e005      	b.n	34009c48 <tk_clr_flg+0x54>
	} else {
		flgcb->flgptn &= clrptn;
34009c3c:	693b      	ldr	r3, [r7, #16]
34009c3e:	695a      	ldr	r2, [r3, #20]
34009c40:	683b      	ldr	r3, [r7, #0]
34009c42:	401a      	ands	r2, r3
34009c44:	693b      	ldr	r3, [r7, #16]
34009c46:	615a      	str	r2, [r3, #20]
	}
	END_CRITICAL_SECTION;
34009c48:	68fb      	ldr	r3, [r7, #12]
34009c4a:	2b00      	cmp	r3, #0
34009c4c:	d10b      	bne.n	34009c66 <tk_clr_flg+0x72>
34009c4e:	4b0b      	ldr	r3, [pc, #44]	@ (34009c7c <tk_clr_flg+0x88>)
34009c50:	681a      	ldr	r2, [r3, #0]
34009c52:	4b0b      	ldr	r3, [pc, #44]	@ (34009c80 <tk_clr_flg+0x8c>)
34009c54:	681b      	ldr	r3, [r3, #0]
34009c56:	429a      	cmp	r2, r3
34009c58:	d005      	beq.n	34009c66 <tk_clr_flg+0x72>
34009c5a:	4b0a      	ldr	r3, [pc, #40]	@ (34009c84 <tk_clr_flg+0x90>)
34009c5c:	681b      	ldr	r3, [r3, #0]
34009c5e:	2b00      	cmp	r3, #0
34009c60:	d101      	bne.n	34009c66 <tk_clr_flg+0x72>
34009c62:	f002 ff51 	bl	3400cb08 <knl_dispatch>
34009c66:	68f8      	ldr	r0, [r7, #12]
34009c68:	f003 fe71 	bl	3400d94e <set_basepri>

	return ercd;
34009c6c:	697b      	ldr	r3, [r7, #20]
}
34009c6e:	4618      	mov	r0, r3
34009c70:	3718      	adds	r7, #24
34009c72:	46bd      	mov	sp, r7
34009c74:	bd80      	pop	{r7, pc}
34009c76:	bf00      	nop
34009c78:	340100b8 	.word	0x340100b8
34009c7c:	340109c8 	.word	0x340109c8
34009c80:	340109cc 	.word	0x340109cc
34009c84:	340109c4 	.word	0x340109c4

34009c88 <flg_chg_pri>:

/*
 * Processing if the priority of wait task changes
 */
LOCAL void flg_chg_pri( TCB *tcb, INT oldpri )
{
34009c88:	b580      	push	{r7, lr}
34009c8a:	b084      	sub	sp, #16
34009c8c:	af00      	add	r7, sp, #0
34009c8e:	6078      	str	r0, [r7, #4]
34009c90:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;

	flgcb = get_flgcb(tcb->wid);
34009c92:	687b      	ldr	r3, [r7, #4]
34009c94:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34009c96:	1e5a      	subs	r2, r3, #1
34009c98:	4613      	mov	r3, r2
34009c9a:	005b      	lsls	r3, r3, #1
34009c9c:	4413      	add	r3, r2
34009c9e:	00db      	lsls	r3, r3, #3
34009ca0:	4a05      	ldr	r2, [pc, #20]	@ (34009cb8 <flg_chg_pri+0x30>)
34009ca2:	4413      	add	r3, r2
34009ca4:	60fb      	str	r3, [r7, #12]
	knl_gcb_change_priority((GCB*)flgcb, tcb);
34009ca6:	6879      	ldr	r1, [r7, #4]
34009ca8:	68f8      	ldr	r0, [r7, #12]
34009caa:	f002 f845 	bl	3400bd38 <knl_gcb_change_priority>
}
34009cae:	bf00      	nop
34009cb0:	3710      	adds	r7, #16
34009cb2:	46bd      	mov	sp, r7
34009cb4:	bd80      	pop	{r7, pc}
34009cb6:	bf00      	nop
34009cb8:	340100b8 	.word	0x340100b8

34009cbc <tk_wai_flg>:

/*
 * Event flag wait
 */
SYSCALL ER tk_wai_flg( ID flgid, UINT waiptn, UINT wfmode, UINT *p_flgptn, TMO tmout )
{
34009cbc:	b580      	push	{r7, lr}
34009cbe:	b088      	sub	sp, #32
34009cc0:	af00      	add	r7, sp, #0
34009cc2:	60f8      	str	r0, [r7, #12]
34009cc4:	60b9      	str	r1, [r7, #8]
34009cc6:	607a      	str	r2, [r7, #4]
34009cc8:	603b      	str	r3, [r7, #0]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
34009cca:	2300      	movs	r3, #0
34009ccc:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
34009cce:	68fb      	ldr	r3, [r7, #12]
34009cd0:	2b00      	cmp	r3, #0
34009cd2:	dd02      	ble.n	34009cda <tk_wai_flg+0x1e>
34009cd4:	68fb      	ldr	r3, [r7, #12]
34009cd6:	2b10      	cmp	r3, #16
34009cd8:	dd02      	ble.n	34009ce0 <tk_wai_flg+0x24>
34009cda:	f06f 0311 	mvn.w	r3, #17
34009cde:	e0a3      	b.n	34009e28 <tk_wai_flg+0x16c>
	CHECK_PAR(waiptn != 0);
34009ce0:	68bb      	ldr	r3, [r7, #8]
34009ce2:	2b00      	cmp	r3, #0
34009ce4:	d102      	bne.n	34009cec <tk_wai_flg+0x30>
34009ce6:	f06f 0310 	mvn.w	r3, #16
34009cea:	e09d      	b.n	34009e28 <tk_wai_flg+0x16c>
	CHECK_PAR((wfmode & ~(TWF_ORW|TWF_CLR|TWF_BITCLR)) == 0);
34009cec:	687b      	ldr	r3, [r7, #4]
34009cee:	f023 0331 	bic.w	r3, r3, #49	@ 0x31
34009cf2:	2b00      	cmp	r3, #0
34009cf4:	d002      	beq.n	34009cfc <tk_wai_flg+0x40>
34009cf6:	f06f 0310 	mvn.w	r3, #16
34009cfa:	e095      	b.n	34009e28 <tk_wai_flg+0x16c>
	CHECK_TMOUT(tmout);
34009cfc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34009cfe:	f1b3 3fff 	cmp.w	r3, #4294967295
34009d02:	da02      	bge.n	34009d0a <tk_wai_flg+0x4e>
34009d04:	f06f 0310 	mvn.w	r3, #16
34009d08:	e08e      	b.n	34009e28 <tk_wai_flg+0x16c>
	CHECK_DISPATCH();
34009d0a:	4b49      	ldr	r3, [pc, #292]	@ (34009e30 <tk_wai_flg+0x174>)
34009d0c:	681b      	ldr	r3, [r3, #0]
34009d0e:	2b00      	cmp	r3, #0
34009d10:	d10d      	bne.n	34009d2e <tk_wai_flg+0x72>
34009d12:	f7ff fddb 	bl	340098cc <knl_isTaskIndependent>
34009d16:	4603      	mov	r3, r0
34009d18:	2b00      	cmp	r3, #0
34009d1a:	d108      	bne.n	34009d2e <tk_wai_flg+0x72>
34009d1c:	4b45      	ldr	r3, [pc, #276]	@ (34009e34 <tk_wai_flg+0x178>)
34009d1e:	681b      	ldr	r3, [r3, #0]
34009d20:	2b00      	cmp	r3, #0
34009d22:	d004      	beq.n	34009d2e <tk_wai_flg+0x72>
34009d24:	f003 fe22 	bl	3400d96c <get_basepri>
34009d28:	4603      	mov	r3, r0
34009d2a:	2b00      	cmp	r3, #0
34009d2c:	d002      	beq.n	34009d34 <tk_wai_flg+0x78>
34009d2e:	f06f 0318 	mvn.w	r3, #24
34009d32:	e079      	b.n	34009e28 <tk_wai_flg+0x16c>

	flgcb = get_flgcb(flgid);
34009d34:	68fb      	ldr	r3, [r7, #12]
34009d36:	1e5a      	subs	r2, r3, #1
34009d38:	4613      	mov	r3, r2
34009d3a:	005b      	lsls	r3, r3, #1
34009d3c:	4413      	add	r3, r2
34009d3e:	00db      	lsls	r3, r3, #3
34009d40:	4a3d      	ldr	r2, [pc, #244]	@ (34009e38 <tk_wai_flg+0x17c>)
34009d42:	4413      	add	r3, r2
34009d44:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
34009d46:	f003 fe1e 	bl	3400d986 <disint>
34009d4a:	61b8      	str	r0, [r7, #24]
	if ( flgcb->flgid == 0 ) {
34009d4c:	69fb      	ldr	r3, [r7, #28]
34009d4e:	689b      	ldr	r3, [r3, #8]
34009d50:	2b00      	cmp	r3, #0
34009d52:	d103      	bne.n	34009d5c <tk_wai_flg+0xa0>
		ercd = E_NOEXS;
34009d54:	f06f 0329 	mvn.w	r3, #41	@ 0x29
34009d58:	617b      	str	r3, [r7, #20]
		goto error_exit;
34009d5a:	e052      	b.n	34009e02 <tk_wai_flg+0x146>
	}
	if ( (flgcb->flgatr & TA_WMUL) == 0 && !isQueEmpty(&flgcb->wait_queue) ) {
34009d5c:	69fb      	ldr	r3, [r7, #28]
34009d5e:	691b      	ldr	r3, [r3, #16]
34009d60:	f003 0308 	and.w	r3, r3, #8
34009d64:	2b00      	cmp	r3, #0
34009d66:	d10a      	bne.n	34009d7e <tk_wai_flg+0xc2>
34009d68:	69fb      	ldr	r3, [r7, #28]
34009d6a:	4618      	mov	r0, r3
34009d6c:	f7ff fd66 	bl	3400983c <isQueEmpty>
34009d70:	4603      	mov	r3, r0
34009d72:	2b00      	cmp	r3, #0
34009d74:	d103      	bne.n	34009d7e <tk_wai_flg+0xc2>
		/* Disable multiple tasks wait */
		ercd = E_OBJ;
34009d76:	f06f 0328 	mvn.w	r3, #40	@ 0x28
34009d7a:	617b      	str	r3, [r7, #20]
		goto error_exit;
34009d7c:	e041      	b.n	34009e02 <tk_wai_flg+0x146>
	}

	/* Meet condition for release wait? */
	if ( knl_eventflag_cond(flgcb, waiptn, wfmode) ) {
34009d7e:	687a      	ldr	r2, [r7, #4]
34009d80:	68b9      	ldr	r1, [r7, #8]
34009d82:	69f8      	ldr	r0, [r7, #28]
34009d84:	f7ff fdb2 	bl	340098ec <knl_eventflag_cond>
34009d88:	4603      	mov	r3, r0
34009d8a:	2b00      	cmp	r3, #0
34009d8c:	d018      	beq.n	34009dc0 <tk_wai_flg+0x104>
		*p_flgptn = flgcb->flgptn;
34009d8e:	69fb      	ldr	r3, [r7, #28]
34009d90:	695a      	ldr	r2, [r3, #20]
34009d92:	683b      	ldr	r3, [r7, #0]
34009d94:	601a      	str	r2, [r3, #0]

		/* Clear event flag */
		if ( (wfmode & TWF_BITCLR) != 0 ) {
34009d96:	687b      	ldr	r3, [r7, #4]
34009d98:	f003 0320 	and.w	r3, r3, #32
34009d9c:	2b00      	cmp	r3, #0
34009d9e:	d006      	beq.n	34009dae <tk_wai_flg+0xf2>
			flgcb->flgptn &= ~waiptn;
34009da0:	69fb      	ldr	r3, [r7, #28]
34009da2:	695a      	ldr	r2, [r3, #20]
34009da4:	68bb      	ldr	r3, [r7, #8]
34009da6:	43db      	mvns	r3, r3
34009da8:	401a      	ands	r2, r3
34009daa:	69fb      	ldr	r3, [r7, #28]
34009dac:	615a      	str	r2, [r3, #20]
		}
		if ( (wfmode & TWF_CLR) != 0 ) {
34009dae:	687b      	ldr	r3, [r7, #4]
34009db0:	f003 0310 	and.w	r3, r3, #16
34009db4:	2b00      	cmp	r3, #0
34009db6:	d024      	beq.n	34009e02 <tk_wai_flg+0x146>
			flgcb->flgptn = 0;
34009db8:	69fb      	ldr	r3, [r7, #28]
34009dba:	2200      	movs	r2, #0
34009dbc:	615a      	str	r2, [r3, #20]
34009dbe:	e020      	b.n	34009e02 <tk_wai_flg+0x146>
		}
	} else {
		/* Ready for wait */
		knl_ctxtsk->wspec = ( (flgcb->flgatr & TA_TPRI) != 0 )?
34009dc0:	69fb      	ldr	r3, [r7, #28]
34009dc2:	691b      	ldr	r3, [r3, #16]
34009dc4:	f003 0301 	and.w	r3, r3, #1
					&knl_wspec_flg_tpri: &knl_wspec_flg_tfifo;
34009dc8:	2b00      	cmp	r3, #0
34009dca:	d001      	beq.n	34009dd0 <tk_wai_flg+0x114>
34009dcc:	4a1b      	ldr	r2, [pc, #108]	@ (34009e3c <tk_wai_flg+0x180>)
34009dce:	e000      	b.n	34009dd2 <tk_wai_flg+0x116>
34009dd0:	4a1b      	ldr	r2, [pc, #108]	@ (34009e40 <tk_wai_flg+0x184>)
		knl_ctxtsk->wspec = ( (flgcb->flgatr & TA_TPRI) != 0 )?
34009dd2:	4b18      	ldr	r3, [pc, #96]	@ (34009e34 <tk_wai_flg+0x178>)
34009dd4:	681b      	ldr	r3, [r3, #0]
34009dd6:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wercd = &ercd;
34009dd8:	4b16      	ldr	r3, [pc, #88]	@ (34009e34 <tk_wai_flg+0x178>)
34009dda:	681b      	ldr	r3, [r3, #0]
34009ddc:	f107 0214 	add.w	r2, r7, #20
34009de0:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_ctxtsk->winfo.flg.waiptn = waiptn;
34009de2:	4b14      	ldr	r3, [pc, #80]	@ (34009e34 <tk_wai_flg+0x178>)
34009de4:	681b      	ldr	r3, [r3, #0]
34009de6:	68ba      	ldr	r2, [r7, #8]
34009de8:	641a      	str	r2, [r3, #64]	@ 0x40
		knl_ctxtsk->winfo.flg.wfmode = wfmode;
34009dea:	4b12      	ldr	r3, [pc, #72]	@ (34009e34 <tk_wai_flg+0x178>)
34009dec:	681b      	ldr	r3, [r3, #0]
34009dee:	687a      	ldr	r2, [r7, #4]
34009df0:	645a      	str	r2, [r3, #68]	@ 0x44
		knl_ctxtsk->winfo.flg.p_flgptn = p_flgptn;
34009df2:	4b10      	ldr	r3, [pc, #64]	@ (34009e34 <tk_wai_flg+0x178>)
34009df4:	681b      	ldr	r3, [r3, #0]
34009df6:	683a      	ldr	r2, [r7, #0]
34009df8:	649a      	str	r2, [r3, #72]	@ 0x48
		knl_gcb_make_wait((GCB*)flgcb, tmout);
34009dfa:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34009dfc:	69f8      	ldr	r0, [r7, #28]
34009dfe:	f001 ff65 	bl	3400bccc <knl_gcb_make_wait>
	}

    error_exit:
	END_CRITICAL_SECTION;
34009e02:	69bb      	ldr	r3, [r7, #24]
34009e04:	2b00      	cmp	r3, #0
34009e06:	d10b      	bne.n	34009e20 <tk_wai_flg+0x164>
34009e08:	4b0a      	ldr	r3, [pc, #40]	@ (34009e34 <tk_wai_flg+0x178>)
34009e0a:	681a      	ldr	r2, [r3, #0]
34009e0c:	4b0d      	ldr	r3, [pc, #52]	@ (34009e44 <tk_wai_flg+0x188>)
34009e0e:	681b      	ldr	r3, [r3, #0]
34009e10:	429a      	cmp	r2, r3
34009e12:	d005      	beq.n	34009e20 <tk_wai_flg+0x164>
34009e14:	4b06      	ldr	r3, [pc, #24]	@ (34009e30 <tk_wai_flg+0x174>)
34009e16:	681b      	ldr	r3, [r3, #0]
34009e18:	2b00      	cmp	r3, #0
34009e1a:	d101      	bne.n	34009e20 <tk_wai_flg+0x164>
34009e1c:	f002 fe74 	bl	3400cb08 <knl_dispatch>
34009e20:	69b8      	ldr	r0, [r7, #24]
34009e22:	f003 fd94 	bl	3400d94e <set_basepri>

	return ercd;
34009e26:	697b      	ldr	r3, [r7, #20]
}
34009e28:	4618      	mov	r0, r3
34009e2a:	3720      	adds	r7, #32
34009e2c:	46bd      	mov	sp, r7
34009e2e:	bd80      	pop	{r7, pc}
34009e30:	340109c4 	.word	0x340109c4
34009e34:	340109c8 	.word	0x340109c8
34009e38:	340100b8 	.word	0x340100b8
34009e3c:	3400e030 	.word	0x3400e030
34009e40:	3400e024 	.word	0x3400e024
34009e44:	340109cc 	.word	0x340109cc

34009e48 <QueInit>:
{
34009e48:	b480      	push	{r7}
34009e4a:	b083      	sub	sp, #12
34009e4c:	af00      	add	r7, sp, #0
34009e4e:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
34009e50:	687b      	ldr	r3, [r7, #4]
34009e52:	687a      	ldr	r2, [r7, #4]
34009e54:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
34009e56:	687b      	ldr	r3, [r7, #4]
34009e58:	687a      	ldr	r2, [r7, #4]
34009e5a:	605a      	str	r2, [r3, #4]
}
34009e5c:	bf00      	nop
34009e5e:	370c      	adds	r7, #12
34009e60:	46bd      	mov	sp, r7
34009e62:	f85d 7b04 	ldr.w	r7, [sp], #4
34009e66:	4770      	bx	lr

34009e68 <QueInsert>:
{
34009e68:	b480      	push	{r7}
34009e6a:	b083      	sub	sp, #12
34009e6c:	af00      	add	r7, sp, #0
34009e6e:	6078      	str	r0, [r7, #4]
34009e70:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
34009e72:	683b      	ldr	r3, [r7, #0]
34009e74:	685a      	ldr	r2, [r3, #4]
34009e76:	687b      	ldr	r3, [r7, #4]
34009e78:	605a      	str	r2, [r3, #4]
	entry->next = que;
34009e7a:	687b      	ldr	r3, [r7, #4]
34009e7c:	683a      	ldr	r2, [r7, #0]
34009e7e:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
34009e80:	683b      	ldr	r3, [r7, #0]
34009e82:	685b      	ldr	r3, [r3, #4]
34009e84:	687a      	ldr	r2, [r7, #4]
34009e86:	601a      	str	r2, [r3, #0]
	que->prev = entry;
34009e88:	683b      	ldr	r3, [r7, #0]
34009e8a:	687a      	ldr	r2, [r7, #4]
34009e8c:	605a      	str	r2, [r3, #4]
}
34009e8e:	bf00      	nop
34009e90:	370c      	adds	r7, #12
34009e92:	46bd      	mov	sp, r7
34009e94:	f85d 7b04 	ldr.w	r7, [sp], #4
34009e98:	4770      	bx	lr
	...

34009e9c <knl_mailbox_initialize>:

/*
 * Initialization of mailbox control block 
 */
EXPORT ER knl_mailbox_initialize( void )
{
34009e9c:	b580      	push	{r7, lr}
34009e9e:	b082      	sub	sp, #8
34009ea0:	af00      	add	r7, sp, #0
	if ( NUM_MBXID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mbxcb);
34009ea2:	480e      	ldr	r0, [pc, #56]	@ (34009edc <knl_mailbox_initialize+0x40>)
34009ea4:	f7ff ffd0 	bl	34009e48 <QueInit>
	end = knl_mbxcb_table + NUM_MBXID;
34009ea8:	4b0d      	ldr	r3, [pc, #52]	@ (34009ee0 <knl_mailbox_initialize+0x44>)
34009eaa:	603b      	str	r3, [r7, #0]
	for ( mbxcb = knl_mbxcb_table; mbxcb < end; mbxcb++ ) {
34009eac:	4b0d      	ldr	r3, [pc, #52]	@ (34009ee4 <knl_mailbox_initialize+0x48>)
34009eae:	607b      	str	r3, [r7, #4]
34009eb0:	e00a      	b.n	34009ec8 <knl_mailbox_initialize+0x2c>
		mbxcb->mbxid = 0;
34009eb2:	687b      	ldr	r3, [r7, #4]
34009eb4:	2200      	movs	r2, #0
34009eb6:	609a      	str	r2, [r3, #8]
		QueInsert(&mbxcb->wait_queue, &knl_free_mbxcb);
34009eb8:	687b      	ldr	r3, [r7, #4]
34009eba:	4908      	ldr	r1, [pc, #32]	@ (34009edc <knl_mailbox_initialize+0x40>)
34009ebc:	4618      	mov	r0, r3
34009ebe:	f7ff ffd3 	bl	34009e68 <QueInsert>
	for ( mbxcb = knl_mbxcb_table; mbxcb < end; mbxcb++ ) {
34009ec2:	687b      	ldr	r3, [r7, #4]
34009ec4:	331c      	adds	r3, #28
34009ec6:	607b      	str	r3, [r7, #4]
34009ec8:	687a      	ldr	r2, [r7, #4]
34009eca:	683b      	ldr	r3, [r7, #0]
34009ecc:	429a      	cmp	r2, r3
34009ece:	d3f0      	bcc.n	34009eb2 <knl_mailbox_initialize+0x16>
	}

	return E_OK;
34009ed0:	2300      	movs	r3, #0
}
34009ed2:	4618      	mov	r0, r3
34009ed4:	3708      	adds	r7, #8
34009ed6:	46bd      	mov	sp, r7
34009ed8:	bd80      	pop	{r7, pc}
34009eda:	bf00      	nop
34009edc:	34010320 	.word	0x34010320
34009ee0:	34010320 	.word	0x34010320
34009ee4:	34010240 	.word	0x34010240

34009ee8 <QueInit>:
{
34009ee8:	b480      	push	{r7}
34009eea:	b083      	sub	sp, #12
34009eec:	af00      	add	r7, sp, #0
34009eee:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
34009ef0:	687b      	ldr	r3, [r7, #4]
34009ef2:	687a      	ldr	r2, [r7, #4]
34009ef4:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
34009ef6:	687b      	ldr	r3, [r7, #4]
34009ef8:	687a      	ldr	r2, [r7, #4]
34009efa:	605a      	str	r2, [r3, #4]
}
34009efc:	bf00      	nop
34009efe:	370c      	adds	r7, #12
34009f00:	46bd      	mov	sp, r7
34009f02:	f85d 7b04 	ldr.w	r7, [sp], #4
34009f06:	4770      	bx	lr

34009f08 <QueInsert>:
{
34009f08:	b480      	push	{r7}
34009f0a:	b083      	sub	sp, #12
34009f0c:	af00      	add	r7, sp, #0
34009f0e:	6078      	str	r0, [r7, #4]
34009f10:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
34009f12:	683b      	ldr	r3, [r7, #0]
34009f14:	685a      	ldr	r2, [r3, #4]
34009f16:	687b      	ldr	r3, [r7, #4]
34009f18:	605a      	str	r2, [r3, #4]
	entry->next = que;
34009f1a:	687b      	ldr	r3, [r7, #4]
34009f1c:	683a      	ldr	r2, [r7, #0]
34009f1e:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
34009f20:	683b      	ldr	r3, [r7, #0]
34009f22:	685b      	ldr	r3, [r3, #4]
34009f24:	687a      	ldr	r2, [r7, #4]
34009f26:	601a      	str	r2, [r3, #0]
	que->prev = entry;
34009f28:	683b      	ldr	r3, [r7, #0]
34009f2a:	687a      	ldr	r2, [r7, #4]
34009f2c:	605a      	str	r2, [r3, #4]
}
34009f2e:	bf00      	nop
34009f30:	370c      	adds	r7, #12
34009f32:	46bd      	mov	sp, r7
34009f34:	f85d 7b04 	ldr.w	r7, [sp], #4
34009f38:	4770      	bx	lr

34009f3a <QueRemove>:
{
34009f3a:	b480      	push	{r7}
34009f3c:	b083      	sub	sp, #12
34009f3e:	af00      	add	r7, sp, #0
34009f40:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
34009f42:	687b      	ldr	r3, [r7, #4]
34009f44:	681b      	ldr	r3, [r3, #0]
34009f46:	687a      	ldr	r2, [r7, #4]
34009f48:	429a      	cmp	r2, r3
34009f4a:	d009      	beq.n	34009f60 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
34009f4c:	687b      	ldr	r3, [r7, #4]
34009f4e:	685b      	ldr	r3, [r3, #4]
34009f50:	687a      	ldr	r2, [r7, #4]
34009f52:	6812      	ldr	r2, [r2, #0]
34009f54:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
34009f56:	687b      	ldr	r3, [r7, #4]
34009f58:	681b      	ldr	r3, [r3, #0]
34009f5a:	687a      	ldr	r2, [r7, #4]
34009f5c:	6852      	ldr	r2, [r2, #4]
34009f5e:	605a      	str	r2, [r3, #4]
}
34009f60:	bf00      	nop
34009f62:	370c      	adds	r7, #12
34009f64:	46bd      	mov	sp, r7
34009f66:	f85d 7b04 	ldr.w	r7, [sp], #4
34009f6a:	4770      	bx	lr

34009f6c <knl_searchFreeArea>:
 *	or larger than
 *      'blksz' but closest.
 *	If it does not exist, return '&imacb->freeque'.
 */
EXPORT QUEUE* knl_searchFreeArea( IMACB *imacb, W blksz )
{
34009f6c:	b480      	push	{r7}
34009f6e:	b085      	sub	sp, #20
34009f70:	af00      	add	r7, sp, #0
34009f72:	6078      	str	r0, [r7, #4]
34009f74:	6039      	str	r1, [r7, #0]
	QUEUE	*q = &imacb->freeque;
34009f76:	687b      	ldr	r3, [r7, #4]
34009f78:	330c      	adds	r3, #12
34009f7a:	60fb      	str	r3, [r7, #12]

	/* For area whose memory pool size is less than 1/4,
	   search from smaller size.
	   Otherwise, search from larger size. */
	if ( blksz > imacb->memsz / 4 ) {
34009f7c:	687b      	ldr	r3, [r7, #4]
34009f7e:	681b      	ldr	r3, [r3, #0]
34009f80:	2b00      	cmp	r3, #0
34009f82:	da00      	bge.n	34009f86 <knl_searchFreeArea+0x1a>
34009f84:	3303      	adds	r3, #3
34009f86:	109b      	asrs	r3, r3, #2
34009f88:	461a      	mov	r2, r3
34009f8a:	683b      	ldr	r3, [r7, #0]
34009f8c:	4293      	cmp	r3, r2
34009f8e:	dd2b      	ble.n	34009fe8 <knl_searchFreeArea+0x7c>
		/* Search from larger size. */
		W fsz = 0;
34009f90:	2300      	movs	r3, #0
34009f92:	60bb      	str	r3, [r7, #8]
		while ( (q = q->prev) != &imacb->freeque ) {
34009f94:	e010      	b.n	34009fb8 <knl_searchFreeArea+0x4c>
			fsz = FreeSize(q);
34009f96:	68fb      	ldr	r3, [r7, #12]
34009f98:	3308      	adds	r3, #8
34009f9a:	685b      	ldr	r3, [r3, #4]
34009f9c:	60bb      	str	r3, [r7, #8]
			if ( fsz <= blksz ) {
34009f9e:	68ba      	ldr	r2, [r7, #8]
34009fa0:	683b      	ldr	r3, [r7, #0]
34009fa2:	429a      	cmp	r2, r3
34009fa4:	dc08      	bgt.n	34009fb8 <knl_searchFreeArea+0x4c>
				return ( fsz < blksz )? q->next: q;
34009fa6:	68ba      	ldr	r2, [r7, #8]
34009fa8:	683b      	ldr	r3, [r7, #0]
34009faa:	429a      	cmp	r2, r3
34009fac:	da02      	bge.n	34009fb4 <knl_searchFreeArea+0x48>
34009fae:	68fb      	ldr	r3, [r7, #12]
34009fb0:	681b      	ldr	r3, [r3, #0]
34009fb2:	e024      	b.n	34009ffe <knl_searchFreeArea+0x92>
34009fb4:	68fb      	ldr	r3, [r7, #12]
34009fb6:	e022      	b.n	34009ffe <knl_searchFreeArea+0x92>
		while ( (q = q->prev) != &imacb->freeque ) {
34009fb8:	68fb      	ldr	r3, [r7, #12]
34009fba:	685b      	ldr	r3, [r3, #4]
34009fbc:	60fb      	str	r3, [r7, #12]
34009fbe:	687b      	ldr	r3, [r7, #4]
34009fc0:	330c      	adds	r3, #12
34009fc2:	68fa      	ldr	r2, [r7, #12]
34009fc4:	429a      	cmp	r2, r3
34009fc6:	d1e6      	bne.n	34009f96 <knl_searchFreeArea+0x2a>
			}
		}
		return ( fsz >= blksz )? q->next: q;
34009fc8:	68ba      	ldr	r2, [r7, #8]
34009fca:	683b      	ldr	r3, [r7, #0]
34009fcc:	429a      	cmp	r2, r3
34009fce:	db02      	blt.n	34009fd6 <knl_searchFreeArea+0x6a>
34009fd0:	68fb      	ldr	r3, [r7, #12]
34009fd2:	681b      	ldr	r3, [r3, #0]
34009fd4:	e013      	b.n	34009ffe <knl_searchFreeArea+0x92>
34009fd6:	68fb      	ldr	r3, [r7, #12]
34009fd8:	e011      	b.n	34009ffe <knl_searchFreeArea+0x92>
	} else {
		/* Search from smaller size. */
		while ( (q = q->next) != &imacb->freeque ) {
			if ( FreeSize(q) >= blksz ) {
34009fda:	68fb      	ldr	r3, [r7, #12]
34009fdc:	3308      	adds	r3, #8
34009fde:	685b      	ldr	r3, [r3, #4]
34009fe0:	461a      	mov	r2, r3
34009fe2:	683b      	ldr	r3, [r7, #0]
34009fe4:	4293      	cmp	r3, r2
34009fe6:	dd08      	ble.n	34009ffa <knl_searchFreeArea+0x8e>
		while ( (q = q->next) != &imacb->freeque ) {
34009fe8:	68fb      	ldr	r3, [r7, #12]
34009fea:	681b      	ldr	r3, [r3, #0]
34009fec:	60fb      	str	r3, [r7, #12]
34009fee:	687b      	ldr	r3, [r7, #4]
34009ff0:	330c      	adds	r3, #12
34009ff2:	68fa      	ldr	r2, [r7, #12]
34009ff4:	429a      	cmp	r2, r3
34009ff6:	d1f0      	bne.n	34009fda <knl_searchFreeArea+0x6e>
34009ff8:	e000      	b.n	34009ffc <knl_searchFreeArea+0x90>
				break;
34009ffa:	bf00      	nop
			}
		}
		return q;
34009ffc:	68fb      	ldr	r3, [r7, #12]
	}
}
34009ffe:	4618      	mov	r0, r3
3400a000:	3714      	adds	r7, #20
3400a002:	46bd      	mov	sp, r7
3400a004:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a008:	4770      	bx	lr

3400a00a <knl_appendFreeArea>:
 *	|   +-----------------------+	    +-----------------------+
 *	|   | AreaQue		    |	    | AreaQue		    |
 *	v   +-----------------------+	    +-----------------------+
 */
EXPORT void knl_appendFreeArea( IMACB *imacb, QUEUE *aq )
{
3400a00a:	b580      	push	{r7, lr}
3400a00c:	b084      	sub	sp, #16
3400a00e:	af00      	add	r7, sp, #0
3400a010:	6078      	str	r0, [r7, #4]
3400a012:	6039      	str	r1, [r7, #0]
	QUEUE	*fq;
	W	size = AreaSize(aq);
3400a014:	683b      	ldr	r3, [r7, #0]
3400a016:	681a      	ldr	r2, [r3, #0]
3400a018:	683b      	ldr	r3, [r7, #0]
3400a01a:	3308      	adds	r3, #8
3400a01c:	1ad3      	subs	r3, r2, r3
3400a01e:	60fb      	str	r3, [r7, #12]
	/* Registration position search */
	/*  Search the free area whose size is equal to 'blksz',
	 *  or larger than 'blksz' but closest.
	 *  If it does not exist, return '&imacb->freeque'.
	 */
	fq = knl_searchFreeArea(imacb, size);
3400a020:	68f9      	ldr	r1, [r7, #12]
3400a022:	6878      	ldr	r0, [r7, #4]
3400a024:	f7ff ffa2 	bl	34009f6c <knl_searchFreeArea>
3400a028:	60b8      	str	r0, [r7, #8]

	/* Register */
	clrAreaFlag(aq, AREA_USE);
3400a02a:	683b      	ldr	r3, [r7, #0]
3400a02c:	685b      	ldr	r3, [r3, #4]
3400a02e:	f023 0301 	bic.w	r3, r3, #1
3400a032:	461a      	mov	r2, r3
3400a034:	683b      	ldr	r3, [r7, #0]
3400a036:	605a      	str	r2, [r3, #4]
	if ( fq != &imacb->freeque && FreeSize(fq) == size ) {
3400a038:	687b      	ldr	r3, [r7, #4]
3400a03a:	330c      	adds	r3, #12
3400a03c:	68ba      	ldr	r2, [r7, #8]
3400a03e:	429a      	cmp	r2, r3
3400a040:	d027      	beq.n	3400a092 <knl_appendFreeArea+0x88>
3400a042:	68bb      	ldr	r3, [r7, #8]
3400a044:	3308      	adds	r3, #8
3400a046:	685b      	ldr	r3, [r3, #4]
3400a048:	461a      	mov	r2, r3
3400a04a:	68fb      	ldr	r3, [r7, #12]
3400a04c:	4293      	cmp	r3, r2
3400a04e:	d120      	bne.n	3400a092 <knl_appendFreeArea+0x88>
		/* FreeQue Same size */
		(aq + 2)->next = (fq + 1)->next;
3400a050:	68bb      	ldr	r3, [r7, #8]
3400a052:	f103 0208 	add.w	r2, r3, #8
3400a056:	683b      	ldr	r3, [r7, #0]
3400a058:	3310      	adds	r3, #16
3400a05a:	6812      	ldr	r2, [r2, #0]
3400a05c:	601a      	str	r2, [r3, #0]
		(fq + 1)->next = aq + 2;
3400a05e:	68bb      	ldr	r3, [r7, #8]
3400a060:	3308      	adds	r3, #8
3400a062:	683a      	ldr	r2, [r7, #0]
3400a064:	3210      	adds	r2, #16
3400a066:	601a      	str	r2, [r3, #0]
		(aq + 2)->prev = fq + 1;
3400a068:	683b      	ldr	r3, [r7, #0]
3400a06a:	3310      	adds	r3, #16
3400a06c:	68ba      	ldr	r2, [r7, #8]
3400a06e:	3208      	adds	r2, #8
3400a070:	605a      	str	r2, [r3, #4]
		if( (aq + 2)->next != NULL ) {
3400a072:	683b      	ldr	r3, [r7, #0]
3400a074:	3310      	adds	r3, #16
3400a076:	681b      	ldr	r3, [r3, #0]
3400a078:	2b00      	cmp	r3, #0
3400a07a:	d005      	beq.n	3400a088 <knl_appendFreeArea+0x7e>
			(aq + 2)->next->prev = aq + 2;
3400a07c:	683b      	ldr	r3, [r7, #0]
3400a07e:	3310      	adds	r3, #16
3400a080:	681b      	ldr	r3, [r3, #0]
3400a082:	683a      	ldr	r2, [r7, #0]
3400a084:	3210      	adds	r2, #16
3400a086:	605a      	str	r2, [r3, #4]
		}
		(aq + 1)->next = NULL;
3400a088:	683b      	ldr	r3, [r7, #0]
3400a08a:	3308      	adds	r3, #8
3400a08c:	2200      	movs	r2, #0
3400a08e:	601a      	str	r2, [r3, #0]
3400a090:	e00e      	b.n	3400a0b0 <knl_appendFreeArea+0xa6>
	} else {
		/* FreeQue Size order */
		QueInsert(aq + 1, fq);
3400a092:	683b      	ldr	r3, [r7, #0]
3400a094:	3308      	adds	r3, #8
3400a096:	68b9      	ldr	r1, [r7, #8]
3400a098:	4618      	mov	r0, r3
3400a09a:	f7ff ff35 	bl	34009f08 <QueInsert>
		(aq + 2)->next = NULL;
3400a09e:	683b      	ldr	r3, [r7, #0]
3400a0a0:	3310      	adds	r3, #16
3400a0a2:	2200      	movs	r2, #0
3400a0a4:	601a      	str	r2, [r3, #0]
		(aq + 2)->prev = (QUEUE*)size;
3400a0a6:	683b      	ldr	r3, [r7, #0]
3400a0a8:	3310      	adds	r3, #16
3400a0aa:	68fa      	ldr	r2, [r7, #12]
3400a0ac:	605a      	str	r2, [r3, #4]
	}
}
3400a0ae:	bf00      	nop
3400a0b0:	bf00      	nop
3400a0b2:	3710      	adds	r7, #16
3400a0b4:	46bd      	mov	sp, r7
3400a0b6:	bd80      	pop	{r7, pc}

3400a0b8 <knl_removeFreeQue>:

/*
 * Delete from FreeQue
 */
EXPORT void knl_removeFreeQue( QUEUE *fq )
{
3400a0b8:	b580      	push	{r7, lr}
3400a0ba:	b082      	sub	sp, #8
3400a0bc:	af00      	add	r7, sp, #0
3400a0be:	6078      	str	r0, [r7, #4]
	if ( fq->next == NULL ) {	/* FreeQue Same size */
3400a0c0:	687b      	ldr	r3, [r7, #4]
3400a0c2:	681b      	ldr	r3, [r3, #0]
3400a0c4:	2b00      	cmp	r3, #0
3400a0c6:	d115      	bne.n	3400a0f4 <knl_removeFreeQue+0x3c>
		(fq + 1)->prev->next = (fq + 1)->next;
3400a0c8:	687b      	ldr	r3, [r7, #4]
3400a0ca:	f103 0208 	add.w	r2, r3, #8
3400a0ce:	687b      	ldr	r3, [r7, #4]
3400a0d0:	3308      	adds	r3, #8
3400a0d2:	685b      	ldr	r3, [r3, #4]
3400a0d4:	6812      	ldr	r2, [r2, #0]
3400a0d6:	601a      	str	r2, [r3, #0]
		if ( (fq + 1)->next != NULL ) {
3400a0d8:	687b      	ldr	r3, [r7, #4]
3400a0da:	3308      	adds	r3, #8
3400a0dc:	681b      	ldr	r3, [r3, #0]
3400a0de:	2b00      	cmp	r3, #0
3400a0e0:	d020      	beq.n	3400a124 <knl_removeFreeQue+0x6c>
			(fq + 1)->next->prev = (fq + 1)->prev;
3400a0e2:	687b      	ldr	r3, [r7, #4]
3400a0e4:	f103 0208 	add.w	r2, r3, #8
3400a0e8:	687b      	ldr	r3, [r7, #4]
3400a0ea:	3308      	adds	r3, #8
3400a0ec:	681b      	ldr	r3, [r3, #0]
3400a0ee:	6852      	ldr	r2, [r2, #4]
3400a0f0:	605a      	str	r2, [r3, #4]
			QueInsert((fq + 1)->next - 1, fq);
			(fq + 1)->next->prev = (fq + 1)->prev;
		}
		QueRemove(fq);
	}
}
3400a0f2:	e017      	b.n	3400a124 <knl_removeFreeQue+0x6c>
		if ( (fq + 1)->next != NULL ) {		/* having FreeQue Same size */
3400a0f4:	687b      	ldr	r3, [r7, #4]
3400a0f6:	3308      	adds	r3, #8
3400a0f8:	681b      	ldr	r3, [r3, #0]
3400a0fa:	2b00      	cmp	r3, #0
3400a0fc:	d00f      	beq.n	3400a11e <knl_removeFreeQue+0x66>
			QueInsert((fq + 1)->next - 1, fq);
3400a0fe:	687b      	ldr	r3, [r7, #4]
3400a100:	3308      	adds	r3, #8
3400a102:	681b      	ldr	r3, [r3, #0]
3400a104:	3b08      	subs	r3, #8
3400a106:	6879      	ldr	r1, [r7, #4]
3400a108:	4618      	mov	r0, r3
3400a10a:	f7ff fefd 	bl	34009f08 <QueInsert>
			(fq + 1)->next->prev = (fq + 1)->prev;
3400a10e:	687b      	ldr	r3, [r7, #4]
3400a110:	f103 0208 	add.w	r2, r3, #8
3400a114:	687b      	ldr	r3, [r7, #4]
3400a116:	3308      	adds	r3, #8
3400a118:	681b      	ldr	r3, [r3, #0]
3400a11a:	6852      	ldr	r2, [r2, #4]
3400a11c:	605a      	str	r2, [r3, #4]
		QueRemove(fq);
3400a11e:	6878      	ldr	r0, [r7, #4]
3400a120:	f7ff ff0b 	bl	34009f3a <QueRemove>
}
3400a124:	bf00      	nop
3400a126:	3708      	adds	r7, #8
3400a128:	46bd      	mov	sp, r7
3400a12a:	bd80      	pop	{r7, pc}

3400a12c <knl_insertAreaQue>:
/*
 * Register area
 *	Insert 'ent' just after 'que.'
 */
EXPORT void knl_insertAreaQue( QUEUE *que, QUEUE *ent )
{
3400a12c:	b480      	push	{r7}
3400a12e:	b083      	sub	sp, #12
3400a130:	af00      	add	r7, sp, #0
3400a132:	6078      	str	r0, [r7, #4]
3400a134:	6039      	str	r1, [r7, #0]
	ent->prev = que;
3400a136:	683b      	ldr	r3, [r7, #0]
3400a138:	687a      	ldr	r2, [r7, #4]
3400a13a:	605a      	str	r2, [r3, #4]
	ent->next = que->next;
3400a13c:	687b      	ldr	r3, [r7, #4]
3400a13e:	681a      	ldr	r2, [r3, #0]
3400a140:	683b      	ldr	r3, [r7, #0]
3400a142:	601a      	str	r2, [r3, #0]
	Assign(que->next->prev, ent);
3400a144:	687b      	ldr	r3, [r7, #4]
3400a146:	681b      	ldr	r3, [r3, #0]
3400a148:	685b      	ldr	r3, [r3, #4]
3400a14a:	f003 0201 	and.w	r2, r3, #1
3400a14e:	683b      	ldr	r3, [r7, #0]
3400a150:	431a      	orrs	r2, r3
3400a152:	687b      	ldr	r3, [r7, #4]
3400a154:	681b      	ldr	r3, [r3, #0]
3400a156:	605a      	str	r2, [r3, #4]
	que->next = ent;
3400a158:	687b      	ldr	r3, [r7, #4]
3400a15a:	683a      	ldr	r2, [r7, #0]
3400a15c:	601a      	str	r2, [r3, #0]
}
3400a15e:	bf00      	nop
3400a160:	370c      	adds	r7, #12
3400a162:	46bd      	mov	sp, r7
3400a164:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a168:	4770      	bx	lr

3400a16a <knl_removeAreaQue>:

/*
 * Delete area
 */
EXPORT void knl_removeAreaQue( QUEUE *aq )
{
3400a16a:	b480      	push	{r7}
3400a16c:	b083      	sub	sp, #12
3400a16e:	af00      	add	r7, sp, #0
3400a170:	6078      	str	r0, [r7, #4]
	Mask(aq->prev)->next = aq->next;
3400a172:	687b      	ldr	r3, [r7, #4]
3400a174:	685b      	ldr	r3, [r3, #4]
3400a176:	f023 0301 	bic.w	r3, r3, #1
3400a17a:	461a      	mov	r2, r3
3400a17c:	687b      	ldr	r3, [r7, #4]
3400a17e:	681b      	ldr	r3, [r3, #0]
3400a180:	6013      	str	r3, [r2, #0]
	Assign(aq->next->prev, Mask(aq->prev));
3400a182:	687b      	ldr	r3, [r7, #4]
3400a184:	681b      	ldr	r3, [r3, #0]
3400a186:	685b      	ldr	r3, [r3, #4]
3400a188:	f003 0201 	and.w	r2, r3, #1
3400a18c:	687b      	ldr	r3, [r7, #4]
3400a18e:	685b      	ldr	r3, [r3, #4]
3400a190:	f023 0301 	bic.w	r3, r3, #1
3400a194:	431a      	orrs	r2, r3
3400a196:	687b      	ldr	r3, [r7, #4]
3400a198:	681b      	ldr	r3, [r3, #0]
3400a19a:	605a      	str	r2, [r3, #4]
}
3400a19c:	bf00      	nop
3400a19e:	370c      	adds	r7, #12
3400a1a0:	46bd      	mov	sp, r7
3400a1a2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a1a6:	4770      	bx	lr

3400a1a8 <knl_Imalloc>:

/*
 * Memory allocate
 */
EXPORT void* knl_Imalloc( SZ size )
{
3400a1a8:	b580      	push	{r7, lr}
3400a1aa:	b086      	sub	sp, #24
3400a1ac:	af00      	add	r7, sp, #0
3400a1ae:	6078      	str	r0, [r7, #4]
	QUEUE	*q, *aq, *aq2;
	UINT	imask;

	/* If it is smaller than the minimum fragment size,
	   allocate the minimum size to it. */
	if( size <= 0 ) {
3400a1b0:	687b      	ldr	r3, [r7, #4]
3400a1b2:	2b00      	cmp	r3, #0
3400a1b4:	dc01      	bgt.n	3400a1ba <knl_Imalloc+0x12>
		return (void *)NULL;
3400a1b6:	2300      	movs	r3, #0
3400a1b8:	e045      	b.n	3400a246 <knl_Imalloc+0x9e>
	} else 	if ( size < MIN_FRAGMENT ) {
3400a1ba:	687b      	ldr	r3, [r7, #4]
3400a1bc:	2b0f      	cmp	r3, #15
3400a1be:	d802      	bhi.n	3400a1c6 <knl_Imalloc+0x1e>
		size = MIN_FRAGMENT;
3400a1c0:	2310      	movs	r3, #16
3400a1c2:	607b      	str	r3, [r7, #4]
3400a1c4:	e004      	b.n	3400a1d0 <knl_Imalloc+0x28>
	} else {
		size = ROUND(size);
3400a1c6:	687b      	ldr	r3, [r7, #4]
3400a1c8:	3307      	adds	r3, #7
3400a1ca:	f023 0307 	bic.w	r3, r3, #7
3400a1ce:	607b      	str	r3, [r7, #4]
	}

	DI(imask);  /* Exclusive control by interrupt disable */
3400a1d0:	f003 fbd9 	bl	3400d986 <disint>
3400a1d4:	6138      	str	r0, [r7, #16]

	/* Search FreeQue */
	q = knl_searchFreeArea(knl_imacb, size);
3400a1d6:	4b1e      	ldr	r3, [pc, #120]	@ (3400a250 <knl_Imalloc+0xa8>)
3400a1d8:	681b      	ldr	r3, [r3, #0]
3400a1da:	6879      	ldr	r1, [r7, #4]
3400a1dc:	4618      	mov	r0, r3
3400a1de:	f7ff fec5 	bl	34009f6c <knl_searchFreeArea>
3400a1e2:	6178      	str	r0, [r7, #20]
	if ( q == &(knl_imacb->freeque) ) {
3400a1e4:	4b1a      	ldr	r3, [pc, #104]	@ (3400a250 <knl_Imalloc+0xa8>)
3400a1e6:	681b      	ldr	r3, [r3, #0]
3400a1e8:	330c      	adds	r3, #12
3400a1ea:	697a      	ldr	r2, [r7, #20]
3400a1ec:	429a      	cmp	r2, r3
3400a1ee:	d102      	bne.n	3400a1f6 <knl_Imalloc+0x4e>
		q = NULL; /* Insufficient memory */
3400a1f0:	2300      	movs	r3, #0
3400a1f2:	617b      	str	r3, [r7, #20]
		goto err_ret;
3400a1f4:	e023      	b.n	3400a23e <knl_Imalloc+0x96>
	}

	/* There is free area: Split from FreeQue once */
	knl_removeFreeQue(q);
3400a1f6:	6978      	ldr	r0, [r7, #20]
3400a1f8:	f7ff ff5e 	bl	3400a0b8 <knl_removeFreeQue>

	aq = q - 1;
3400a1fc:	697b      	ldr	r3, [r7, #20]
3400a1fe:	3b08      	subs	r3, #8
3400a200:	60fb      	str	r3, [r7, #12]

	/* If there are fragments smaller than the minimum fragment size,
	   allocate them also */
	if ( FreeSize(q) - size >= MIN_FRAGMENT + sizeof(QUEUE) ) {
3400a202:	697b      	ldr	r3, [r7, #20]
3400a204:	3308      	adds	r3, #8
3400a206:	685b      	ldr	r3, [r3, #4]
3400a208:	461a      	mov	r2, r3
3400a20a:	687b      	ldr	r3, [r7, #4]
3400a20c:	1ad3      	subs	r3, r2, r3
3400a20e:	2b17      	cmp	r3, #23
3400a210:	d90e      	bls.n	3400a230 <knl_Imalloc+0x88>

		/* Divide area into 2 */
		aq2 = (QUEUE*)((VB*)(aq + 1) + size);
3400a212:	687b      	ldr	r3, [r7, #4]
3400a214:	3308      	adds	r3, #8
3400a216:	68fa      	ldr	r2, [r7, #12]
3400a218:	4413      	add	r3, r2
3400a21a:	60bb      	str	r3, [r7, #8]
		knl_insertAreaQue(aq, aq2);
3400a21c:	68b9      	ldr	r1, [r7, #8]
3400a21e:	68f8      	ldr	r0, [r7, #12]
3400a220:	f7ff ff84 	bl	3400a12c <knl_insertAreaQue>

		/* Register remaining area to FreeQue */
		knl_appendFreeArea(knl_imacb, aq2);
3400a224:	4b0a      	ldr	r3, [pc, #40]	@ (3400a250 <knl_Imalloc+0xa8>)
3400a226:	681b      	ldr	r3, [r3, #0]
3400a228:	68b9      	ldr	r1, [r7, #8]
3400a22a:	4618      	mov	r0, r3
3400a22c:	f7ff feed 	bl	3400a00a <knl_appendFreeArea>
	}
	setAreaFlag(aq, AREA_USE);
3400a230:	68fb      	ldr	r3, [r7, #12]
3400a232:	685b      	ldr	r3, [r3, #4]
3400a234:	f043 0301 	orr.w	r3, r3, #1
3400a238:	461a      	mov	r2, r3
3400a23a:	68fb      	ldr	r3, [r7, #12]
3400a23c:	605a      	str	r2, [r3, #4]

err_ret:
	EI(imask);
3400a23e:	6938      	ldr	r0, [r7, #16]
3400a240:	f003 fb85 	bl	3400d94e <set_basepri>

	return (void *)q;
3400a244:	697b      	ldr	r3, [r7, #20]
}
3400a246:	4618      	mov	r0, r3
3400a248:	3718      	adds	r7, #24
3400a24a:	46bd      	mov	sp, r7
3400a24c:	bd80      	pop	{r7, pc}
3400a24e:	bf00      	nop
3400a250:	34010328 	.word	0x34010328

3400a254 <knl_Ifree>:

/*
 * Free memory
 */
EXPORT void  knl_Ifree( void *ptr )
{
3400a254:	b580      	push	{r7, lr}
3400a256:	b084      	sub	sp, #16
3400a258:	af00      	add	r7, sp, #0
3400a25a:	6078      	str	r0, [r7, #4]
	QUEUE	*aq;
	UINT	imask;

	DI(imask);  /* Exclusive control by interrupt disable */
3400a25c:	f003 fb93 	bl	3400d986 <disint>
3400a260:	60b8      	str	r0, [r7, #8]

	aq = (QUEUE*)ptr - 1;
3400a262:	687b      	ldr	r3, [r7, #4]
3400a264:	3b08      	subs	r3, #8
3400a266:	60fb      	str	r3, [r7, #12]
	clrAreaFlag(aq, AREA_USE);
3400a268:	68fb      	ldr	r3, [r7, #12]
3400a26a:	685b      	ldr	r3, [r3, #4]
3400a26c:	f023 0301 	bic.w	r3, r3, #1
3400a270:	461a      	mov	r2, r3
3400a272:	68fb      	ldr	r3, [r7, #12]
3400a274:	605a      	str	r2, [r3, #4]

	if ( !chkAreaFlag(aq->next, AREA_USE) ) {
3400a276:	68fb      	ldr	r3, [r7, #12]
3400a278:	681b      	ldr	r3, [r3, #0]
3400a27a:	685b      	ldr	r3, [r3, #4]
3400a27c:	f003 0301 	and.w	r3, r3, #1
3400a280:	2b00      	cmp	r3, #0
3400a282:	d10a      	bne.n	3400a29a <knl_Ifree+0x46>
		/* Merge with free area in after location */
		knl_removeFreeQue(aq->next + 1);
3400a284:	68fb      	ldr	r3, [r7, #12]
3400a286:	681b      	ldr	r3, [r3, #0]
3400a288:	3308      	adds	r3, #8
3400a28a:	4618      	mov	r0, r3
3400a28c:	f7ff ff14 	bl	3400a0b8 <knl_removeFreeQue>
		knl_removeAreaQue(aq->next);
3400a290:	68fb      	ldr	r3, [r7, #12]
3400a292:	681b      	ldr	r3, [r3, #0]
3400a294:	4618      	mov	r0, r3
3400a296:	f7ff ff68 	bl	3400a16a <knl_removeAreaQue>
	}

	if ( !chkAreaFlag(aq->prev, AREA_USE) ) {
3400a29a:	68fb      	ldr	r3, [r7, #12]
3400a29c:	685b      	ldr	r3, [r3, #4]
3400a29e:	685b      	ldr	r3, [r3, #4]
3400a2a0:	f003 0301 	and.w	r3, r3, #1
3400a2a4:	2b00      	cmp	r3, #0
3400a2a6:	d10c      	bne.n	3400a2c2 <knl_Ifree+0x6e>
		/* Merge with free area in front location */
		aq = aq->prev;
3400a2a8:	68fb      	ldr	r3, [r7, #12]
3400a2aa:	685b      	ldr	r3, [r3, #4]
3400a2ac:	60fb      	str	r3, [r7, #12]
		knl_removeFreeQue(aq + 1);
3400a2ae:	68fb      	ldr	r3, [r7, #12]
3400a2b0:	3308      	adds	r3, #8
3400a2b2:	4618      	mov	r0, r3
3400a2b4:	f7ff ff00 	bl	3400a0b8 <knl_removeFreeQue>
		knl_removeAreaQue(aq->next);
3400a2b8:	68fb      	ldr	r3, [r7, #12]
3400a2ba:	681b      	ldr	r3, [r3, #0]
3400a2bc:	4618      	mov	r0, r3
3400a2be:	f7ff ff54 	bl	3400a16a <knl_removeAreaQue>
	}

	knl_appendFreeArea(knl_imacb, aq);
3400a2c2:	4b06      	ldr	r3, [pc, #24]	@ (3400a2dc <knl_Ifree+0x88>)
3400a2c4:	681b      	ldr	r3, [r3, #0]
3400a2c6:	68f9      	ldr	r1, [r7, #12]
3400a2c8:	4618      	mov	r0, r3
3400a2ca:	f7ff fe9e 	bl	3400a00a <knl_appendFreeArea>

	EI(imask);
3400a2ce:	68b8      	ldr	r0, [r7, #8]
3400a2d0:	f003 fb3d 	bl	3400d94e <set_basepri>
}
3400a2d4:	bf00      	nop
3400a2d6:	3710      	adds	r7, #16
3400a2d8:	46bd      	mov	sp, r7
3400a2da:	bd80      	pop	{r7, pc}
3400a2dc:	34010328 	.word	0x34010328

3400a2e0 <initIMACB>:

/*
 * IMACB Initialization 
 */
LOCAL void initIMACB( void )
{
3400a2e0:	b580      	push	{r7, lr}
3400a2e2:	af00      	add	r7, sp, #0
	QueInit(&(knl_imacb->areaque));
3400a2e4:	4b06      	ldr	r3, [pc, #24]	@ (3400a300 <initIMACB+0x20>)
3400a2e6:	681b      	ldr	r3, [r3, #0]
3400a2e8:	3304      	adds	r3, #4
3400a2ea:	4618      	mov	r0, r3
3400a2ec:	f7ff fdfc 	bl	34009ee8 <QueInit>
	QueInit(&(knl_imacb->freeque));
3400a2f0:	4b03      	ldr	r3, [pc, #12]	@ (3400a300 <initIMACB+0x20>)
3400a2f2:	681b      	ldr	r3, [r3, #0]
3400a2f4:	330c      	adds	r3, #12
3400a2f6:	4618      	mov	r0, r3
3400a2f8:	f7ff fdf6 	bl	34009ee8 <QueInit>
}
3400a2fc:	bf00      	nop
3400a2fe:	bd80      	pop	{r7, pc}
3400a300:	34010328 	.word	0x34010328

3400a304 <knl_init_Imalloc>:

/*
 * Imalloc initial setting 
 */
EXPORT ER knl_init_Imalloc( void )
{
3400a304:	b580      	push	{r7, lr}
3400a306:	b082      	sub	sp, #8
3400a308:	af00      	add	r7, sp, #0
	QUEUE	*top, *end;

	/* Align top with 4 byte unit alignment for IMACB */
	knl_lowmem_top = (void *)(((UW)knl_lowmem_top + 3) & ~0x00000003UL);
3400a30a:	4b2e      	ldr	r3, [pc, #184]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a30c:	681b      	ldr	r3, [r3, #0]
3400a30e:	3303      	adds	r3, #3
3400a310:	f023 0303 	bic.w	r3, r3, #3
3400a314:	461a      	mov	r2, r3
3400a316:	4b2b      	ldr	r3, [pc, #172]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a318:	601a      	str	r2, [r3, #0]
	knl_imacb = (IMACB*)knl_lowmem_top;
3400a31a:	4b2a      	ldr	r3, [pc, #168]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a31c:	681b      	ldr	r3, [r3, #0]
3400a31e:	4a2a      	ldr	r2, [pc, #168]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a320:	6013      	str	r3, [r2, #0]
	knl_lowmem_top = (void *)((UW)knl_lowmem_top + sizeof(IMACB));
3400a322:	4b28      	ldr	r3, [pc, #160]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a324:	681b      	ldr	r3, [r3, #0]
3400a326:	3314      	adds	r3, #20
3400a328:	461a      	mov	r2, r3
3400a32a:	4b26      	ldr	r3, [pc, #152]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a32c:	601a      	str	r2, [r3, #0]

	/* Align top with 8 byte unit alignment */
	knl_lowmem_top = (void *)(((UW)knl_lowmem_top + 7) & ~0x00000007UL);
3400a32e:	4b25      	ldr	r3, [pc, #148]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a330:	681b      	ldr	r3, [r3, #0]
3400a332:	3307      	adds	r3, #7
3400a334:	f023 0307 	bic.w	r3, r3, #7
3400a338:	461a      	mov	r2, r3
3400a33a:	4b22      	ldr	r3, [pc, #136]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a33c:	601a      	str	r2, [r3, #0]
	top = (QUEUE*)knl_lowmem_top;
3400a33e:	4b21      	ldr	r3, [pc, #132]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a340:	681b      	ldr	r3, [r3, #0]
3400a342:	607b      	str	r3, [r7, #4]
	knl_imacb->memsz = (W)((UW)knl_lowmem_limit - (UW)knl_lowmem_top - sizeof(QUEUE)*2);
3400a344:	4b21      	ldr	r3, [pc, #132]	@ (3400a3cc <knl_init_Imalloc+0xc8>)
3400a346:	681b      	ldr	r3, [r3, #0]
3400a348:	461a      	mov	r2, r3
3400a34a:	4b1e      	ldr	r3, [pc, #120]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a34c:	681b      	ldr	r3, [r3, #0]
3400a34e:	1ad3      	subs	r3, r2, r3
3400a350:	f1a3 0210 	sub.w	r2, r3, #16
3400a354:	4b1c      	ldr	r3, [pc, #112]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a356:	681b      	ldr	r3, [r3, #0]
3400a358:	601a      	str	r2, [r3, #0]

	knl_lowmem_top = knl_lowmem_limit;  /* Update memory free space */
3400a35a:	4b1c      	ldr	r3, [pc, #112]	@ (3400a3cc <knl_init_Imalloc+0xc8>)
3400a35c:	681b      	ldr	r3, [r3, #0]
3400a35e:	4a19      	ldr	r2, [pc, #100]	@ (3400a3c4 <knl_init_Imalloc+0xc0>)
3400a360:	6013      	str	r3, [r2, #0]

	initIMACB();
3400a362:	f7ff ffbd 	bl	3400a2e0 <initIMACB>

	/* Register on AreaQue */
	end = (QUEUE*)((VB*)top + knl_imacb->memsz) + 1;
3400a366:	4b18      	ldr	r3, [pc, #96]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a368:	681b      	ldr	r3, [r3, #0]
3400a36a:	681b      	ldr	r3, [r3, #0]
3400a36c:	3308      	adds	r3, #8
3400a36e:	687a      	ldr	r2, [r7, #4]
3400a370:	4413      	add	r3, r2
3400a372:	603b      	str	r3, [r7, #0]
	knl_insertAreaQue(&knl_imacb->areaque, end);
3400a374:	4b14      	ldr	r3, [pc, #80]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a376:	681b      	ldr	r3, [r3, #0]
3400a378:	3304      	adds	r3, #4
3400a37a:	6839      	ldr	r1, [r7, #0]
3400a37c:	4618      	mov	r0, r3
3400a37e:	f7ff fed5 	bl	3400a12c <knl_insertAreaQue>
	knl_insertAreaQue(&knl_imacb->areaque, top);
3400a382:	4b11      	ldr	r3, [pc, #68]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a384:	681b      	ldr	r3, [r3, #0]
3400a386:	3304      	adds	r3, #4
3400a388:	6879      	ldr	r1, [r7, #4]
3400a38a:	4618      	mov	r0, r3
3400a38c:	f7ff fece 	bl	3400a12c <knl_insertAreaQue>
	setAreaFlag(end, AREA_USE);
3400a390:	683b      	ldr	r3, [r7, #0]
3400a392:	685b      	ldr	r3, [r3, #4]
3400a394:	f043 0301 	orr.w	r3, r3, #1
3400a398:	461a      	mov	r2, r3
3400a39a:	683b      	ldr	r3, [r7, #0]
3400a39c:	605a      	str	r2, [r3, #4]
	setAreaFlag(&knl_imacb->areaque, AREA_USE);
3400a39e:	4b0a      	ldr	r3, [pc, #40]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a3a0:	681b      	ldr	r3, [r3, #0]
3400a3a2:	689b      	ldr	r3, [r3, #8]
3400a3a4:	f043 0201 	orr.w	r2, r3, #1
3400a3a8:	4b07      	ldr	r3, [pc, #28]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a3aa:	681b      	ldr	r3, [r3, #0]
3400a3ac:	609a      	str	r2, [r3, #8]

	knl_appendFreeArea(knl_imacb, top);
3400a3ae:	4b06      	ldr	r3, [pc, #24]	@ (3400a3c8 <knl_init_Imalloc+0xc4>)
3400a3b0:	681b      	ldr	r3, [r3, #0]
3400a3b2:	6879      	ldr	r1, [r7, #4]
3400a3b4:	4618      	mov	r0, r3
3400a3b6:	f7ff fe28 	bl	3400a00a <knl_appendFreeArea>

	return E_OK;
3400a3ba:	2300      	movs	r3, #0
}
3400a3bc:	4618      	mov	r0, r3
3400a3be:	3708      	adds	r7, #8
3400a3c0:	46bd      	mov	sp, r7
3400a3c2:	bd80      	pop	{r7, pc}
3400a3c4:	3400f6bc 	.word	0x3400f6bc
3400a3c8:	34010328 	.word	0x34010328
3400a3cc:	3400f6c0 	.word	0x3400f6c0

3400a3d0 <QueInit>:
{
3400a3d0:	b480      	push	{r7}
3400a3d2:	b083      	sub	sp, #12
3400a3d4:	af00      	add	r7, sp, #0
3400a3d6:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400a3d8:	687b      	ldr	r3, [r7, #4]
3400a3da:	687a      	ldr	r2, [r7, #4]
3400a3dc:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400a3de:	687b      	ldr	r3, [r7, #4]
3400a3e0:	687a      	ldr	r2, [r7, #4]
3400a3e2:	605a      	str	r2, [r3, #4]
}
3400a3e4:	bf00      	nop
3400a3e6:	370c      	adds	r7, #12
3400a3e8:	46bd      	mov	sp, r7
3400a3ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a3ee:	4770      	bx	lr

3400a3f0 <QueInsert>:
{
3400a3f0:	b480      	push	{r7}
3400a3f2:	b083      	sub	sp, #12
3400a3f4:	af00      	add	r7, sp, #0
3400a3f6:	6078      	str	r0, [r7, #4]
3400a3f8:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400a3fa:	683b      	ldr	r3, [r7, #0]
3400a3fc:	685a      	ldr	r2, [r3, #4]
3400a3fe:	687b      	ldr	r3, [r7, #4]
3400a400:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400a402:	687b      	ldr	r3, [r7, #4]
3400a404:	683a      	ldr	r2, [r7, #0]
3400a406:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400a408:	683b      	ldr	r3, [r7, #0]
3400a40a:	685b      	ldr	r3, [r3, #4]
3400a40c:	687a      	ldr	r2, [r7, #4]
3400a40e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400a410:	683b      	ldr	r3, [r7, #0]
3400a412:	687a      	ldr	r2, [r7, #4]
3400a414:	605a      	str	r2, [r3, #4]
}
3400a416:	bf00      	nop
3400a418:	370c      	adds	r7, #12
3400a41a:	46bd      	mov	sp, r7
3400a41c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a420:	4770      	bx	lr

3400a422 <knl_InitOBJLOCK>:
typedef struct objlock {
	QUEUE		wtskq;		/* Wait task queue */
} OBJLOCK;

Inline void knl_InitOBJLOCK( OBJLOCK *loc )
{
3400a422:	b480      	push	{r7}
3400a424:	b083      	sub	sp, #12
3400a426:	af00      	add	r7, sp, #0
3400a428:	6078      	str	r0, [r7, #4]
	loc->wtskq.next = NULL;
3400a42a:	687b      	ldr	r3, [r7, #4]
3400a42c:	2200      	movs	r2, #0
3400a42e:	601a      	str	r2, [r3, #0]
}
3400a430:	bf00      	nop
3400a432:	370c      	adds	r7, #12
3400a434:	46bd      	mov	sp, r7
3400a436:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a43a:	4770      	bx	lr

3400a43c <knl_fix_memorypool_initialize>:

/*
 * Initialization of fixed size memory pool control block
 */
EXPORT ER knl_fix_memorypool_initialize( void )
{
3400a43c:	b580      	push	{r7, lr}
3400a43e:	b082      	sub	sp, #8
3400a440:	af00      	add	r7, sp, #0
	if ( NUM_MPFID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mpfcb);
3400a442:	4810      	ldr	r0, [pc, #64]	@ (3400a484 <knl_fix_memorypool_initialize+0x48>)
3400a444:	f7ff ffc4 	bl	3400a3d0 <QueInit>
	end = knl_mpfcb_table + NUM_MPFID;
3400a448:	4b0f      	ldr	r3, [pc, #60]	@ (3400a488 <knl_fix_memorypool_initialize+0x4c>)
3400a44a:	603b      	str	r3, [r7, #0]
	for ( mpfcb = knl_mpfcb_table; mpfcb < end; mpfcb++ ) {
3400a44c:	4b0f      	ldr	r3, [pc, #60]	@ (3400a48c <knl_fix_memorypool_initialize+0x50>)
3400a44e:	607b      	str	r3, [r7, #4]
3400a450:	e00f      	b.n	3400a472 <knl_fix_memorypool_initialize+0x36>
		mpfcb->mpfid = 0;
3400a452:	687b      	ldr	r3, [r7, #4]
3400a454:	2200      	movs	r2, #0
3400a456:	609a      	str	r2, [r3, #8]
		knl_InitOBJLOCK(&mpfcb->lock);
3400a458:	687b      	ldr	r3, [r7, #4]
3400a45a:	3330      	adds	r3, #48	@ 0x30
3400a45c:	4618      	mov	r0, r3
3400a45e:	f7ff ffe0 	bl	3400a422 <knl_InitOBJLOCK>
		QueInsert(&mpfcb->wait_queue, &knl_free_mpfcb);
3400a462:	687b      	ldr	r3, [r7, #4]
3400a464:	4907      	ldr	r1, [pc, #28]	@ (3400a484 <knl_fix_memorypool_initialize+0x48>)
3400a466:	4618      	mov	r0, r3
3400a468:	f7ff ffc2 	bl	3400a3f0 <QueInsert>
	for ( mpfcb = knl_mpfcb_table; mpfcb < end; mpfcb++ ) {
3400a46c:	687b      	ldr	r3, [r7, #4]
3400a46e:	3338      	adds	r3, #56	@ 0x38
3400a470:	607b      	str	r3, [r7, #4]
3400a472:	687a      	ldr	r2, [r7, #4]
3400a474:	683b      	ldr	r3, [r7, #0]
3400a476:	429a      	cmp	r2, r3
3400a478:	d3eb      	bcc.n	3400a452 <knl_fix_memorypool_initialize+0x16>
	}

	return E_OK;
3400a47a:	2300      	movs	r3, #0
}
3400a47c:	4618      	mov	r0, r3
3400a47e:	3708      	adds	r7, #8
3400a480:	46bd      	mov	sp, r7
3400a482:	bd80      	pop	{r7, pc}
3400a484:	340104ec 	.word	0x340104ec
3400a488:	340104ec 	.word	0x340104ec
3400a48c:	3401032c 	.word	0x3401032c

3400a490 <QueInit>:
{
3400a490:	b480      	push	{r7}
3400a492:	b083      	sub	sp, #12
3400a494:	af00      	add	r7, sp, #0
3400a496:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400a498:	687b      	ldr	r3, [r7, #4]
3400a49a:	687a      	ldr	r2, [r7, #4]
3400a49c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400a49e:	687b      	ldr	r3, [r7, #4]
3400a4a0:	687a      	ldr	r2, [r7, #4]
3400a4a2:	605a      	str	r2, [r3, #4]
}
3400a4a4:	bf00      	nop
3400a4a6:	370c      	adds	r7, #12
3400a4a8:	46bd      	mov	sp, r7
3400a4aa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a4ae:	4770      	bx	lr

3400a4b0 <QueInsert>:
{
3400a4b0:	b480      	push	{r7}
3400a4b2:	b083      	sub	sp, #12
3400a4b4:	af00      	add	r7, sp, #0
3400a4b6:	6078      	str	r0, [r7, #4]
3400a4b8:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400a4ba:	683b      	ldr	r3, [r7, #0]
3400a4bc:	685a      	ldr	r2, [r3, #4]
3400a4be:	687b      	ldr	r3, [r7, #4]
3400a4c0:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400a4c2:	687b      	ldr	r3, [r7, #4]
3400a4c4:	683a      	ldr	r2, [r7, #0]
3400a4c6:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400a4c8:	683b      	ldr	r3, [r7, #0]
3400a4ca:	685b      	ldr	r3, [r3, #4]
3400a4cc:	687a      	ldr	r2, [r7, #4]
3400a4ce:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400a4d0:	683b      	ldr	r3, [r7, #0]
3400a4d2:	687a      	ldr	r2, [r7, #4]
3400a4d4:	605a      	str	r2, [r3, #4]
}
3400a4d6:	bf00      	nop
3400a4d8:	370c      	adds	r7, #12
3400a4da:	46bd      	mov	sp, r7
3400a4dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a4e0:	4770      	bx	lr
	...

3400a4e4 <knl_memorypool_initialize>:

/*
 * Initialization of variable size memory pool control block
 */
EXPORT ER knl_memorypool_initialize( void )
{
3400a4e4:	b580      	push	{r7, lr}
3400a4e6:	b082      	sub	sp, #8
3400a4e8:	af00      	add	r7, sp, #0
	if ( NUM_MPLID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mplcb);
3400a4ea:	480e      	ldr	r0, [pc, #56]	@ (3400a524 <knl_memorypool_initialize+0x40>)
3400a4ec:	f7ff ffd0 	bl	3400a490 <QueInit>
	end = knl_mplcb_table + NUM_MPLID;
3400a4f0:	4b0d      	ldr	r3, [pc, #52]	@ (3400a528 <knl_memorypool_initialize+0x44>)
3400a4f2:	603b      	str	r3, [r7, #0]
	for ( mplcb = knl_mplcb_table; mplcb < end; mplcb++ ) {
3400a4f4:	4b0d      	ldr	r3, [pc, #52]	@ (3400a52c <knl_memorypool_initialize+0x48>)
3400a4f6:	607b      	str	r3, [r7, #4]
3400a4f8:	e00a      	b.n	3400a510 <knl_memorypool_initialize+0x2c>
		mplcb->mplid = 0;
3400a4fa:	687b      	ldr	r3, [r7, #4]
3400a4fc:	2200      	movs	r2, #0
3400a4fe:	609a      	str	r2, [r3, #8]
		QueInsert(&mplcb->wait_queue, &knl_free_mplcb);
3400a500:	687b      	ldr	r3, [r7, #4]
3400a502:	4908      	ldr	r1, [pc, #32]	@ (3400a524 <knl_memorypool_initialize+0x40>)
3400a504:	4618      	mov	r0, r3
3400a506:	f7ff ffd3 	bl	3400a4b0 <QueInsert>
	for ( mplcb = knl_mplcb_table; mplcb < end; mplcb++ ) {
3400a50a:	687b      	ldr	r3, [r7, #4]
3400a50c:	3334      	adds	r3, #52	@ 0x34
3400a50e:	607b      	str	r3, [r7, #4]
3400a510:	687a      	ldr	r2, [r7, #4]
3400a512:	683b      	ldr	r3, [r7, #0]
3400a514:	429a      	cmp	r2, r3
3400a516:	d3f0      	bcc.n	3400a4fa <knl_memorypool_initialize+0x16>
	}

	return E_OK;
3400a518:	2300      	movs	r3, #0
}
3400a51a:	4618      	mov	r0, r3
3400a51c:	3708      	adds	r7, #8
3400a51e:	46bd      	mov	sp, r7
3400a520:	bd80      	pop	{r7, pc}
3400a522:	bf00      	nop
3400a524:	340105c4 	.word	0x340105c4
3400a528:	340105c4 	.word	0x340105c4
3400a52c:	340104f4 	.word	0x340104f4

3400a530 <QueInit>:
{
3400a530:	b480      	push	{r7}
3400a532:	b083      	sub	sp, #12
3400a534:	af00      	add	r7, sp, #0
3400a536:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400a538:	687b      	ldr	r3, [r7, #4]
3400a53a:	687a      	ldr	r2, [r7, #4]
3400a53c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400a53e:	687b      	ldr	r3, [r7, #4]
3400a540:	687a      	ldr	r2, [r7, #4]
3400a542:	605a      	str	r2, [r3, #4]
}
3400a544:	bf00      	nop
3400a546:	370c      	adds	r7, #12
3400a548:	46bd      	mov	sp, r7
3400a54a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a54e:	4770      	bx	lr

3400a550 <QueInsert>:
{
3400a550:	b480      	push	{r7}
3400a552:	b083      	sub	sp, #12
3400a554:	af00      	add	r7, sp, #0
3400a556:	6078      	str	r0, [r7, #4]
3400a558:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400a55a:	683b      	ldr	r3, [r7, #0]
3400a55c:	685a      	ldr	r2, [r3, #4]
3400a55e:	687b      	ldr	r3, [r7, #4]
3400a560:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400a562:	687b      	ldr	r3, [r7, #4]
3400a564:	683a      	ldr	r2, [r7, #0]
3400a566:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400a568:	683b      	ldr	r3, [r7, #0]
3400a56a:	685b      	ldr	r3, [r3, #4]
3400a56c:	687a      	ldr	r2, [r7, #4]
3400a56e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400a570:	683b      	ldr	r3, [r7, #0]
3400a572:	687a      	ldr	r2, [r7, #4]
3400a574:	605a      	str	r2, [r3, #4]
}
3400a576:	bf00      	nop
3400a578:	370c      	adds	r7, #12
3400a57a:	46bd      	mov	sp, r7
3400a57c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a580:	4770      	bx	lr
	...

3400a584 <knl_messagebuffer_initialize>:

/*
 * Initialization of message buffer control block 
 */
EXPORT ER knl_messagebuffer_initialize( void )
{
3400a584:	b580      	push	{r7, lr}
3400a586:	b082      	sub	sp, #8
3400a588:	af00      	add	r7, sp, #0
	if ( NUM_MBFID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mbfcb);
3400a58a:	480e      	ldr	r0, [pc, #56]	@ (3400a5c4 <knl_messagebuffer_initialize+0x40>)
3400a58c:	f7ff ffd0 	bl	3400a530 <QueInit>
	end = knl_mbfcb_table + NUM_MBFID;
3400a590:	4b0d      	ldr	r3, [pc, #52]	@ (3400a5c8 <knl_messagebuffer_initialize+0x44>)
3400a592:	603b      	str	r3, [r7, #0]
	for ( mbfcb = knl_mbfcb_table; mbfcb < end; mbfcb++ ) {
3400a594:	4b0d      	ldr	r3, [pc, #52]	@ (3400a5cc <knl_messagebuffer_initialize+0x48>)
3400a596:	607b      	str	r3, [r7, #4]
3400a598:	e00a      	b.n	3400a5b0 <knl_messagebuffer_initialize+0x2c>
		mbfcb->mbfid = 0;
3400a59a:	687b      	ldr	r3, [r7, #4]
3400a59c:	2200      	movs	r2, #0
3400a59e:	609a      	str	r2, [r3, #8]
		QueInsert(&mbfcb->send_queue, &knl_free_mbfcb);
3400a5a0:	687b      	ldr	r3, [r7, #4]
3400a5a2:	4908      	ldr	r1, [pc, #32]	@ (3400a5c4 <knl_messagebuffer_initialize+0x40>)
3400a5a4:	4618      	mov	r0, r3
3400a5a6:	f7ff ffd3 	bl	3400a550 <QueInsert>
	for ( mbfcb = knl_mbfcb_table; mbfcb < end; mbfcb++ ) {
3400a5aa:	687b      	ldr	r3, [r7, #4]
3400a5ac:	3334      	adds	r3, #52	@ 0x34
3400a5ae:	607b      	str	r3, [r7, #4]
3400a5b0:	687a      	ldr	r2, [r7, #4]
3400a5b2:	683b      	ldr	r3, [r7, #0]
3400a5b4:	429a      	cmp	r2, r3
3400a5b6:	d3f0      	bcc.n	3400a59a <knl_messagebuffer_initialize+0x16>
	}

	return E_OK;
3400a5b8:	2300      	movs	r3, #0
}
3400a5ba:	4618      	mov	r0, r3
3400a5bc:	3708      	adds	r7, #8
3400a5be:	46bd      	mov	sp, r7
3400a5c0:	bd80      	pop	{r7, pc}
3400a5c2:	bf00      	nop
3400a5c4:	3401076c 	.word	0x3401076c
3400a5c8:	3401076c 	.word	0x3401076c
3400a5cc:	340105cc 	.word	0x340105cc

3400a5d0 <QueInit>:
{
3400a5d0:	b480      	push	{r7}
3400a5d2:	b083      	sub	sp, #12
3400a5d4:	af00      	add	r7, sp, #0
3400a5d6:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400a5d8:	687b      	ldr	r3, [r7, #4]
3400a5da:	687a      	ldr	r2, [r7, #4]
3400a5dc:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400a5de:	687b      	ldr	r3, [r7, #4]
3400a5e0:	687a      	ldr	r2, [r7, #4]
3400a5e2:	605a      	str	r2, [r3, #4]
}
3400a5e4:	bf00      	nop
3400a5e6:	370c      	adds	r7, #12
3400a5e8:	46bd      	mov	sp, r7
3400a5ea:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a5ee:	4770      	bx	lr

3400a5f0 <QueInsert>:
{
3400a5f0:	b480      	push	{r7}
3400a5f2:	b083      	sub	sp, #12
3400a5f4:	af00      	add	r7, sp, #0
3400a5f6:	6078      	str	r0, [r7, #4]
3400a5f8:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400a5fa:	683b      	ldr	r3, [r7, #0]
3400a5fc:	685a      	ldr	r2, [r3, #4]
3400a5fe:	687b      	ldr	r3, [r7, #4]
3400a600:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400a602:	687b      	ldr	r3, [r7, #4]
3400a604:	683a      	ldr	r2, [r7, #0]
3400a606:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400a608:	683b      	ldr	r3, [r7, #0]
3400a60a:	685b      	ldr	r3, [r3, #4]
3400a60c:	687a      	ldr	r2, [r7, #4]
3400a60e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400a610:	683b      	ldr	r3, [r7, #0]
3400a612:	687a      	ldr	r2, [r7, #4]
3400a614:	605a      	str	r2, [r3, #4]
}
3400a616:	bf00      	nop
3400a618:	370c      	adds	r7, #12
3400a61a:	46bd      	mov	sp, r7
3400a61c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a620:	4770      	bx	lr
	...

3400a624 <knl_mutex_initialize>:

/*
 * Initialization of mutex control block 
 */
EXPORT ER knl_mutex_initialize(void)
{
3400a624:	b580      	push	{r7, lr}
3400a626:	b082      	sub	sp, #8
3400a628:	af00      	add	r7, sp, #0
	if ( NUM_MTXID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mtxcb);
3400a62a:	480e      	ldr	r0, [pc, #56]	@ (3400a664 <knl_mutex_initialize+0x40>)
3400a62c:	f7ff ffd0 	bl	3400a5d0 <QueInit>
	end = knl_mtxcb_table + NUM_MTXID;
3400a630:	4b0d      	ldr	r3, [pc, #52]	@ (3400a668 <knl_mutex_initialize+0x44>)
3400a632:	603b      	str	r3, [r7, #0]
	for( mtxcb = knl_mtxcb_table; mtxcb < end; mtxcb++ ) {
3400a634:	4b0d      	ldr	r3, [pc, #52]	@ (3400a66c <knl_mutex_initialize+0x48>)
3400a636:	607b      	str	r3, [r7, #4]
3400a638:	e00a      	b.n	3400a650 <knl_mutex_initialize+0x2c>
		mtxcb->mtxid = 0;
3400a63a:	687b      	ldr	r3, [r7, #4]
3400a63c:	2200      	movs	r2, #0
3400a63e:	609a      	str	r2, [r3, #8]
		QueInsert(&mtxcb->wait_queue, &knl_free_mtxcb);
3400a640:	687b      	ldr	r3, [r7, #4]
3400a642:	4908      	ldr	r1, [pc, #32]	@ (3400a664 <knl_mutex_initialize+0x40>)
3400a644:	4618      	mov	r0, r3
3400a646:	f7ff ffd3 	bl	3400a5f0 <QueInsert>
	for( mtxcb = knl_mtxcb_table; mtxcb < end; mtxcb++ ) {
3400a64a:	687b      	ldr	r3, [r7, #4]
3400a64c:	3320      	adds	r3, #32
3400a64e:	607b      	str	r3, [r7, #4]
3400a650:	687a      	ldr	r2, [r7, #4]
3400a652:	683b      	ldr	r3, [r7, #0]
3400a654:	429a      	cmp	r2, r3
3400a656:	d3f0      	bcc.n	3400a63a <knl_mutex_initialize+0x16>
	}

	return E_OK;
3400a658:	2300      	movs	r3, #0
}
3400a65a:	4618      	mov	r0, r3
3400a65c:	3708      	adds	r7, #8
3400a65e:	46bd      	mov	sp, r7
3400a660:	bd80      	pop	{r7, pc}
3400a662:	bf00      	nop
3400a664:	340107f4 	.word	0x340107f4
3400a668:	340107f4 	.word	0x340107f4
3400a66c:	34010774 	.word	0x34010774

3400a670 <QueInit>:
{
3400a670:	b480      	push	{r7}
3400a672:	b083      	sub	sp, #12
3400a674:	af00      	add	r7, sp, #0
3400a676:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400a678:	687b      	ldr	r3, [r7, #4]
3400a67a:	687a      	ldr	r2, [r7, #4]
3400a67c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400a67e:	687b      	ldr	r3, [r7, #4]
3400a680:	687a      	ldr	r2, [r7, #4]
3400a682:	605a      	str	r2, [r3, #4]
}
3400a684:	bf00      	nop
3400a686:	370c      	adds	r7, #12
3400a688:	46bd      	mov	sp, r7
3400a68a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a68e:	4770      	bx	lr

3400a690 <QueInsert>:
{
3400a690:	b480      	push	{r7}
3400a692:	b083      	sub	sp, #12
3400a694:	af00      	add	r7, sp, #0
3400a696:	6078      	str	r0, [r7, #4]
3400a698:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400a69a:	683b      	ldr	r3, [r7, #0]
3400a69c:	685a      	ldr	r2, [r3, #4]
3400a69e:	687b      	ldr	r3, [r7, #4]
3400a6a0:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400a6a2:	687b      	ldr	r3, [r7, #4]
3400a6a4:	683a      	ldr	r2, [r7, #0]
3400a6a6:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400a6a8:	683b      	ldr	r3, [r7, #0]
3400a6aa:	685b      	ldr	r3, [r3, #4]
3400a6ac:	687a      	ldr	r2, [r7, #4]
3400a6ae:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400a6b0:	683b      	ldr	r3, [r7, #0]
3400a6b2:	687a      	ldr	r2, [r7, #4]
3400a6b4:	605a      	str	r2, [r3, #4]
}
3400a6b6:	bf00      	nop
3400a6b8:	370c      	adds	r7, #12
3400a6ba:	46bd      	mov	sp, r7
3400a6bc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a6c0:	4770      	bx	lr

3400a6c2 <QueRemoveNext>:
{
3400a6c2:	b480      	push	{r7}
3400a6c4:	b085      	sub	sp, #20
3400a6c6:	af00      	add	r7, sp, #0
3400a6c8:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400a6ca:	687b      	ldr	r3, [r7, #4]
3400a6cc:	681b      	ldr	r3, [r3, #0]
3400a6ce:	687a      	ldr	r2, [r7, #4]
3400a6d0:	429a      	cmp	r2, r3
3400a6d2:	d101      	bne.n	3400a6d8 <QueRemoveNext+0x16>
		return NULL;
3400a6d4:	2300      	movs	r3, #0
3400a6d6:	e00b      	b.n	3400a6f0 <QueRemoveNext+0x2e>
	entry = que->next;
3400a6d8:	687b      	ldr	r3, [r7, #4]
3400a6da:	681b      	ldr	r3, [r3, #0]
3400a6dc:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400a6de:	68fb      	ldr	r3, [r7, #12]
3400a6e0:	681a      	ldr	r2, [r3, #0]
3400a6e2:	687b      	ldr	r3, [r7, #4]
3400a6e4:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400a6e6:	68fb      	ldr	r3, [r7, #12]
3400a6e8:	681b      	ldr	r3, [r3, #0]
3400a6ea:	687a      	ldr	r2, [r7, #4]
3400a6ec:	605a      	str	r2, [r3, #4]
	return entry;
3400a6ee:	68fb      	ldr	r3, [r7, #12]
}
3400a6f0:	4618      	mov	r0, r3
3400a6f2:	3714      	adds	r7, #20
3400a6f4:	46bd      	mov	sp, r7
3400a6f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a6fa:	4770      	bx	lr

3400a6fc <knl_isTaskIndependent>:
{
3400a6fc:	b480      	push	{r7}
3400a6fe:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400a700:	4b05      	ldr	r3, [pc, #20]	@ (3400a718 <knl_isTaskIndependent+0x1c>)
3400a702:	681b      	ldr	r3, [r3, #0]
3400a704:	2b00      	cmp	r3, #0
3400a706:	bfcc      	ite	gt
3400a708:	2301      	movgt	r3, #1
3400a70a:	2300      	movle	r3, #0
3400a70c:	b2db      	uxtb	r3, r3
}
3400a70e:	4618      	mov	r0, r3
3400a710:	46bd      	mov	sp, r7
3400a712:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a716:	4770      	bx	lr
3400a718:	3400f6b0 	.word	0x3400f6b0

3400a71c <knl_semaphore_initialize>:

/* 
 * Initialization of semaphore control block 
 */
EXPORT ER knl_semaphore_initialize( void )
{
3400a71c:	b580      	push	{r7, lr}
3400a71e:	b082      	sub	sp, #8
3400a720:	af00      	add	r7, sp, #0
	if ( NUM_SEMID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_semcb);
3400a722:	480e      	ldr	r0, [pc, #56]	@ (3400a75c <knl_semaphore_initialize+0x40>)
3400a724:	f7ff ffa4 	bl	3400a670 <QueInit>
	end = knl_semcb_table + NUM_SEMID;
3400a728:	4b0d      	ldr	r3, [pc, #52]	@ (3400a760 <knl_semaphore_initialize+0x44>)
3400a72a:	603b      	str	r3, [r7, #0]
	for ( semcb = knl_semcb_table; semcb < end; semcb++ ) {
3400a72c:	4b0d      	ldr	r3, [pc, #52]	@ (3400a764 <knl_semaphore_initialize+0x48>)
3400a72e:	607b      	str	r3, [r7, #4]
3400a730:	e00a      	b.n	3400a748 <knl_semaphore_initialize+0x2c>
		semcb->semid = 0;
3400a732:	687b      	ldr	r3, [r7, #4]
3400a734:	2200      	movs	r2, #0
3400a736:	609a      	str	r2, [r3, #8]
		QueInsert(&semcb->wait_queue, &knl_free_semcb);
3400a738:	687b      	ldr	r3, [r7, #4]
3400a73a:	4908      	ldr	r1, [pc, #32]	@ (3400a75c <knl_semaphore_initialize+0x40>)
3400a73c:	4618      	mov	r0, r3
3400a73e:	f7ff ffa7 	bl	3400a690 <QueInsert>
	for ( semcb = knl_semcb_table; semcb < end; semcb++ ) {
3400a742:	687b      	ldr	r3, [r7, #4]
3400a744:	331c      	adds	r3, #28
3400a746:	607b      	str	r3, [r7, #4]
3400a748:	687a      	ldr	r2, [r7, #4]
3400a74a:	683b      	ldr	r3, [r7, #0]
3400a74c:	429a      	cmp	r2, r3
3400a74e:	d3f0      	bcc.n	3400a732 <knl_semaphore_initialize+0x16>
	}

	return E_OK;
3400a750:	2300      	movs	r3, #0
}
3400a752:	4618      	mov	r0, r3
3400a754:	3708      	adds	r7, #8
3400a756:	46bd      	mov	sp, r7
3400a758:	bd80      	pop	{r7, pc}
3400a75a:	bf00      	nop
3400a75c:	340109bc 	.word	0x340109bc
3400a760:	340109bc 	.word	0x340109bc
3400a764:	340107fc 	.word	0x340107fc

3400a768 <tk_cre_sem>:

/*
 * Create semaphore
 */
SYSCALL ID tk_cre_sem( CONST T_CSEM *pk_csem )
{
3400a768:	b580      	push	{r7, lr}
3400a76a:	b088      	sub	sp, #32
3400a76c:	af00      	add	r7, sp, #0
3400a76e:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_SEMATR = {
3400a770:	2303      	movs	r3, #3
3400a772:	61bb      	str	r3, [r7, #24]
#endif
	SEMCB	*semcb;
	ID	semid;
	ER	ercd;

	CHECK_RSATR(pk_csem->sematr, VALID_SEMATR);
3400a774:	687b      	ldr	r3, [r7, #4]
3400a776:	685a      	ldr	r2, [r3, #4]
3400a778:	69bb      	ldr	r3, [r7, #24]
3400a77a:	43db      	mvns	r3, r3
3400a77c:	4013      	ands	r3, r2
3400a77e:	2b00      	cmp	r3, #0
3400a780:	d002      	beq.n	3400a788 <tk_cre_sem+0x20>
3400a782:	f06f 030a 	mvn.w	r3, #10
3400a786:	e059      	b.n	3400a83c <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->isemcnt >= 0);
3400a788:	687b      	ldr	r3, [r7, #4]
3400a78a:	689b      	ldr	r3, [r3, #8]
3400a78c:	2b00      	cmp	r3, #0
3400a78e:	da02      	bge.n	3400a796 <tk_cre_sem+0x2e>
3400a790:	f06f 0310 	mvn.w	r3, #16
3400a794:	e052      	b.n	3400a83c <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->maxsem > 0);
3400a796:	687b      	ldr	r3, [r7, #4]
3400a798:	68db      	ldr	r3, [r3, #12]
3400a79a:	2b00      	cmp	r3, #0
3400a79c:	dc02      	bgt.n	3400a7a4 <tk_cre_sem+0x3c>
3400a79e:	f06f 0310 	mvn.w	r3, #16
3400a7a2:	e04b      	b.n	3400a83c <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->maxsem >= pk_csem->isemcnt);
3400a7a4:	687b      	ldr	r3, [r7, #4]
3400a7a6:	68da      	ldr	r2, [r3, #12]
3400a7a8:	687b      	ldr	r3, [r7, #4]
3400a7aa:	689b      	ldr	r3, [r3, #8]
3400a7ac:	429a      	cmp	r2, r3
3400a7ae:	da02      	bge.n	3400a7b6 <tk_cre_sem+0x4e>
3400a7b0:	f06f 0310 	mvn.w	r3, #16
3400a7b4:	e042      	b.n	3400a83c <tk_cre_sem+0xd4>

	BEGIN_CRITICAL_SECTION;
3400a7b6:	f003 f8e6 	bl	3400d986 <disint>
3400a7ba:	6178      	str	r0, [r7, #20]
	/* Get control block from FreeQue */
	semcb = (SEMCB*)QueRemoveNext(&knl_free_semcb);
3400a7bc:	4821      	ldr	r0, [pc, #132]	@ (3400a844 <tk_cre_sem+0xdc>)
3400a7be:	f7ff ff80 	bl	3400a6c2 <QueRemoveNext>
3400a7c2:	6138      	str	r0, [r7, #16]
	if ( semcb == NULL ) {
3400a7c4:	693b      	ldr	r3, [r7, #16]
3400a7c6:	2b00      	cmp	r3, #0
3400a7c8:	d103      	bne.n	3400a7d2 <tk_cre_sem+0x6a>
		ercd = E_LIMIT;
3400a7ca:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400a7ce:	61fb      	str	r3, [r7, #28]
3400a7d0:	e021      	b.n	3400a816 <tk_cre_sem+0xae>
	} else {
		semid = ID_SEM(semcb - knl_semcb_table);
3400a7d2:	693b      	ldr	r3, [r7, #16]
3400a7d4:	4a1c      	ldr	r2, [pc, #112]	@ (3400a848 <tk_cre_sem+0xe0>)
3400a7d6:	1a9b      	subs	r3, r3, r2
3400a7d8:	109b      	asrs	r3, r3, #2
3400a7da:	4a1c      	ldr	r2, [pc, #112]	@ (3400a84c <tk_cre_sem+0xe4>)
3400a7dc:	fb02 f303 	mul.w	r3, r2, r3
3400a7e0:	3301      	adds	r3, #1
3400a7e2:	60fb      	str	r3, [r7, #12]

		/* Initialize control block */
		QueInit(&semcb->wait_queue);
3400a7e4:	693b      	ldr	r3, [r7, #16]
3400a7e6:	4618      	mov	r0, r3
3400a7e8:	f7ff ff42 	bl	3400a670 <QueInit>
		semcb->semid = semid;
3400a7ec:	693b      	ldr	r3, [r7, #16]
3400a7ee:	68fa      	ldr	r2, [r7, #12]
3400a7f0:	609a      	str	r2, [r3, #8]
		semcb->exinf = pk_csem->exinf;
3400a7f2:	687b      	ldr	r3, [r7, #4]
3400a7f4:	681a      	ldr	r2, [r3, #0]
3400a7f6:	693b      	ldr	r3, [r7, #16]
3400a7f8:	60da      	str	r2, [r3, #12]
		semcb->sematr = pk_csem->sematr;
3400a7fa:	687b      	ldr	r3, [r7, #4]
3400a7fc:	685a      	ldr	r2, [r3, #4]
3400a7fe:	693b      	ldr	r3, [r7, #16]
3400a800:	611a      	str	r2, [r3, #16]
		semcb->semcnt = pk_csem->isemcnt;
3400a802:	687b      	ldr	r3, [r7, #4]
3400a804:	689a      	ldr	r2, [r3, #8]
3400a806:	693b      	ldr	r3, [r7, #16]
3400a808:	615a      	str	r2, [r3, #20]
		semcb->maxsem = pk_csem->maxsem;
3400a80a:	687b      	ldr	r3, [r7, #4]
3400a80c:	68da      	ldr	r2, [r3, #12]
3400a80e:	693b      	ldr	r3, [r7, #16]
3400a810:	619a      	str	r2, [r3, #24]
		if ( (pk_csem->sematr & TA_DSNAME) != 0 ) {
			knl_strncpy((char*)semcb->name, (char*)pk_csem->dsname,
				OBJECT_NAME_LENGTH);
		}
#endif
		ercd = semid;
3400a812:	68fb      	ldr	r3, [r7, #12]
3400a814:	61fb      	str	r3, [r7, #28]
	}
	END_CRITICAL_SECTION;
3400a816:	697b      	ldr	r3, [r7, #20]
3400a818:	2b00      	cmp	r3, #0
3400a81a:	d10b      	bne.n	3400a834 <tk_cre_sem+0xcc>
3400a81c:	4b0c      	ldr	r3, [pc, #48]	@ (3400a850 <tk_cre_sem+0xe8>)
3400a81e:	681a      	ldr	r2, [r3, #0]
3400a820:	4b0c      	ldr	r3, [pc, #48]	@ (3400a854 <tk_cre_sem+0xec>)
3400a822:	681b      	ldr	r3, [r3, #0]
3400a824:	429a      	cmp	r2, r3
3400a826:	d005      	beq.n	3400a834 <tk_cre_sem+0xcc>
3400a828:	4b0b      	ldr	r3, [pc, #44]	@ (3400a858 <tk_cre_sem+0xf0>)
3400a82a:	681b      	ldr	r3, [r3, #0]
3400a82c:	2b00      	cmp	r3, #0
3400a82e:	d101      	bne.n	3400a834 <tk_cre_sem+0xcc>
3400a830:	f002 f96a 	bl	3400cb08 <knl_dispatch>
3400a834:	6978      	ldr	r0, [r7, #20]
3400a836:	f003 f88a 	bl	3400d94e <set_basepri>

	return ercd;
3400a83a:	69fb      	ldr	r3, [r7, #28]
}
3400a83c:	4618      	mov	r0, r3
3400a83e:	3720      	adds	r7, #32
3400a840:	46bd      	mov	sp, r7
3400a842:	bd80      	pop	{r7, pc}
3400a844:	340109bc 	.word	0x340109bc
3400a848:	340107fc 	.word	0x340107fc
3400a84c:	b6db6db7 	.word	0xb6db6db7
3400a850:	340109c8 	.word	0x340109c8
3400a854:	340109cc 	.word	0x340109cc
3400a858:	340109c4 	.word	0x340109c4

3400a85c <tk_del_sem>:
#ifdef USE_FUNC_TK_DEL_SEM
/*
 * Delete semaphore
 */
SYSCALL ER tk_del_sem( ID semid )
{
3400a85c:	b580      	push	{r7, lr}
3400a85e:	b086      	sub	sp, #24
3400a860:	af00      	add	r7, sp, #0
3400a862:	6078      	str	r0, [r7, #4]
	SEMCB	*semcb;
	ER	ercd = E_OK;
3400a864:	2300      	movs	r3, #0
3400a866:	617b      	str	r3, [r7, #20]

	CHECK_SEMID(semid);
3400a868:	687b      	ldr	r3, [r7, #4]
3400a86a:	2b00      	cmp	r3, #0
3400a86c:	dd02      	ble.n	3400a874 <tk_del_sem+0x18>
3400a86e:	687b      	ldr	r3, [r7, #4]
3400a870:	2b10      	cmp	r3, #16
3400a872:	dd02      	ble.n	3400a87a <tk_del_sem+0x1e>
3400a874:	f06f 0311 	mvn.w	r3, #17
3400a878:	e032      	b.n	3400a8e0 <tk_del_sem+0x84>

	semcb = get_semcb(semid);
3400a87a:	687b      	ldr	r3, [r7, #4]
3400a87c:	1e5a      	subs	r2, r3, #1
3400a87e:	4613      	mov	r3, r2
3400a880:	00db      	lsls	r3, r3, #3
3400a882:	1a9b      	subs	r3, r3, r2
3400a884:	009b      	lsls	r3, r3, #2
3400a886:	4a18      	ldr	r2, [pc, #96]	@ (3400a8e8 <tk_del_sem+0x8c>)
3400a888:	4413      	add	r3, r2
3400a88a:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400a88c:	f003 f87b 	bl	3400d986 <disint>
3400a890:	60f8      	str	r0, [r7, #12]
	if ( semcb->semid == 0 ) {
3400a892:	693b      	ldr	r3, [r7, #16]
3400a894:	689b      	ldr	r3, [r3, #8]
3400a896:	2b00      	cmp	r3, #0
3400a898:	d103      	bne.n	3400a8a2 <tk_del_sem+0x46>
		ercd = E_NOEXS;
3400a89a:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400a89e:	617b      	str	r3, [r7, #20]
3400a8a0:	e00b      	b.n	3400a8ba <tk_del_sem+0x5e>
	} else {
		/* Release wait state of task (E_DLT) */
		knl_wait_delete(&semcb->wait_queue);
3400a8a2:	693b      	ldr	r3, [r7, #16]
3400a8a4:	4618      	mov	r0, r3
3400a8a6:	f001 f9f5 	bl	3400bc94 <knl_wait_delete>

		/* Return to FreeQue */
		QueInsert(&semcb->wait_queue, &knl_free_semcb);
3400a8aa:	693b      	ldr	r3, [r7, #16]
3400a8ac:	490f      	ldr	r1, [pc, #60]	@ (3400a8ec <tk_del_sem+0x90>)
3400a8ae:	4618      	mov	r0, r3
3400a8b0:	f7ff feee 	bl	3400a690 <QueInsert>
		semcb->semid = 0;
3400a8b4:	693b      	ldr	r3, [r7, #16]
3400a8b6:	2200      	movs	r2, #0
3400a8b8:	609a      	str	r2, [r3, #8]
	}
	END_CRITICAL_SECTION;
3400a8ba:	68fb      	ldr	r3, [r7, #12]
3400a8bc:	2b00      	cmp	r3, #0
3400a8be:	d10b      	bne.n	3400a8d8 <tk_del_sem+0x7c>
3400a8c0:	4b0b      	ldr	r3, [pc, #44]	@ (3400a8f0 <tk_del_sem+0x94>)
3400a8c2:	681a      	ldr	r2, [r3, #0]
3400a8c4:	4b0b      	ldr	r3, [pc, #44]	@ (3400a8f4 <tk_del_sem+0x98>)
3400a8c6:	681b      	ldr	r3, [r3, #0]
3400a8c8:	429a      	cmp	r2, r3
3400a8ca:	d005      	beq.n	3400a8d8 <tk_del_sem+0x7c>
3400a8cc:	4b0a      	ldr	r3, [pc, #40]	@ (3400a8f8 <tk_del_sem+0x9c>)
3400a8ce:	681b      	ldr	r3, [r3, #0]
3400a8d0:	2b00      	cmp	r3, #0
3400a8d2:	d101      	bne.n	3400a8d8 <tk_del_sem+0x7c>
3400a8d4:	f002 f918 	bl	3400cb08 <knl_dispatch>
3400a8d8:	68f8      	ldr	r0, [r7, #12]
3400a8da:	f003 f838 	bl	3400d94e <set_basepri>

	return ercd;
3400a8de:	697b      	ldr	r3, [r7, #20]
}
3400a8e0:	4618      	mov	r0, r3
3400a8e2:	3718      	adds	r7, #24
3400a8e4:	46bd      	mov	sp, r7
3400a8e6:	bd80      	pop	{r7, pc}
3400a8e8:	340107fc 	.word	0x340107fc
3400a8ec:	340109bc 	.word	0x340109bc
3400a8f0:	340109c8 	.word	0x340109c8
3400a8f4:	340109cc 	.word	0x340109cc
3400a8f8:	340109c4 	.word	0x340109c4

3400a8fc <tk_sig_sem>:

/*
 * Signal semaphore
 */
SYSCALL ER tk_sig_sem( ID semid, INT cnt )
{
3400a8fc:	b580      	push	{r7, lr}
3400a8fe:	b088      	sub	sp, #32
3400a900:	af00      	add	r7, sp, #0
3400a902:	6078      	str	r0, [r7, #4]
3400a904:	6039      	str	r1, [r7, #0]
	SEMCB	*semcb;
	TCB	*tcb;
	QUEUE	*queue;
	ER	ercd = E_OK;
3400a906:	2300      	movs	r3, #0
3400a908:	61bb      	str	r3, [r7, #24]
    
	CHECK_SEMID(semid);
3400a90a:	687b      	ldr	r3, [r7, #4]
3400a90c:	2b00      	cmp	r3, #0
3400a90e:	dd02      	ble.n	3400a916 <tk_sig_sem+0x1a>
3400a910:	687b      	ldr	r3, [r7, #4]
3400a912:	2b10      	cmp	r3, #16
3400a914:	dd02      	ble.n	3400a91c <tk_sig_sem+0x20>
3400a916:	f06f 0311 	mvn.w	r3, #17
3400a91a:	e06a      	b.n	3400a9f2 <tk_sig_sem+0xf6>
	CHECK_PAR(cnt > 0);
3400a91c:	683b      	ldr	r3, [r7, #0]
3400a91e:	2b00      	cmp	r3, #0
3400a920:	dc02      	bgt.n	3400a928 <tk_sig_sem+0x2c>
3400a922:	f06f 0310 	mvn.w	r3, #16
3400a926:	e064      	b.n	3400a9f2 <tk_sig_sem+0xf6>

	semcb = get_semcb(semid);
3400a928:	687b      	ldr	r3, [r7, #4]
3400a92a:	1e5a      	subs	r2, r3, #1
3400a92c:	4613      	mov	r3, r2
3400a92e:	00db      	lsls	r3, r3, #3
3400a930:	1a9b      	subs	r3, r3, r2
3400a932:	009b      	lsls	r3, r3, #2
3400a934:	4a31      	ldr	r2, [pc, #196]	@ (3400a9fc <tk_sig_sem+0x100>)
3400a936:	4413      	add	r3, r2
3400a938:	617b      	str	r3, [r7, #20]

	BEGIN_CRITICAL_SECTION;
3400a93a:	f003 f824 	bl	3400d986 <disint>
3400a93e:	6138      	str	r0, [r7, #16]
	if ( semcb->semid == 0 ) {
3400a940:	697b      	ldr	r3, [r7, #20]
3400a942:	689b      	ldr	r3, [r3, #8]
3400a944:	2b00      	cmp	r3, #0
3400a946:	d103      	bne.n	3400a950 <tk_sig_sem+0x54>
		ercd = E_NOEXS;
3400a948:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400a94c:	61bb      	str	r3, [r7, #24]
		goto error_exit;
3400a94e:	e03d      	b.n	3400a9cc <tk_sig_sem+0xd0>
	}
	if ( cnt > (semcb->maxsem - semcb->semcnt) ) {
3400a950:	697b      	ldr	r3, [r7, #20]
3400a952:	699a      	ldr	r2, [r3, #24]
3400a954:	697b      	ldr	r3, [r7, #20]
3400a956:	695b      	ldr	r3, [r3, #20]
3400a958:	1ad3      	subs	r3, r2, r3
3400a95a:	683a      	ldr	r2, [r7, #0]
3400a95c:	429a      	cmp	r2, r3
3400a95e:	dd03      	ble.n	3400a968 <tk_sig_sem+0x6c>
		ercd = E_QOVR;
3400a960:	f06f 032a 	mvn.w	r3, #42	@ 0x2a
3400a964:	61bb      	str	r3, [r7, #24]
		goto error_exit;
3400a966:	e031      	b.n	3400a9cc <tk_sig_sem+0xd0>
	}

	/* Return semaphore counts */
	semcb->semcnt += cnt;
3400a968:	697b      	ldr	r3, [r7, #20]
3400a96a:	695a      	ldr	r2, [r3, #20]
3400a96c:	683b      	ldr	r3, [r7, #0]
3400a96e:	441a      	add	r2, r3
3400a970:	697b      	ldr	r3, [r7, #20]
3400a972:	615a      	str	r2, [r3, #20]

	/* Search task that frees wait */
	queue = semcb->wait_queue.next;
3400a974:	697b      	ldr	r3, [r7, #20]
3400a976:	681b      	ldr	r3, [r3, #0]
3400a978:	61fb      	str	r3, [r7, #28]
	while ( queue != &semcb->wait_queue ) {
3400a97a:	e021      	b.n	3400a9c0 <tk_sig_sem+0xc4>
		tcb = (TCB*)queue;
3400a97c:	69fb      	ldr	r3, [r7, #28]
3400a97e:	60fb      	str	r3, [r7, #12]
		queue = queue->next;
3400a980:	69fb      	ldr	r3, [r7, #28]
3400a982:	681b      	ldr	r3, [r3, #0]
3400a984:	61fb      	str	r3, [r7, #28]

		/* Meet condition for Releasing wait? */
		if ( semcb->semcnt < tcb->winfo.sem.cnt ) {
3400a986:	697b      	ldr	r3, [r7, #20]
3400a988:	695a      	ldr	r2, [r3, #20]
3400a98a:	68fb      	ldr	r3, [r7, #12]
3400a98c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400a98e:	429a      	cmp	r2, r3
3400a990:	da06      	bge.n	3400a9a0 <tk_sig_sem+0xa4>
			if ( (semcb->sematr & TA_CNT) == 0 ) {
3400a992:	697b      	ldr	r3, [r7, #20]
3400a994:	691b      	ldr	r3, [r3, #16]
3400a996:	f003 0302 	and.w	r3, r3, #2
3400a99a:	2b00      	cmp	r3, #0
3400a99c:	d10f      	bne.n	3400a9be <tk_sig_sem+0xc2>
				break;
3400a99e:	e015      	b.n	3400a9cc <tk_sig_sem+0xd0>
			}
			continue;
		}

		/* Release wait */
		knl_wait_release_ok(tcb);
3400a9a0:	68f8      	ldr	r0, [r7, #12]
3400a9a2:	f001 f8ea 	bl	3400bb7a <knl_wait_release_ok>

		semcb->semcnt -= tcb->winfo.sem.cnt;
3400a9a6:	697b      	ldr	r3, [r7, #20]
3400a9a8:	695a      	ldr	r2, [r3, #20]
3400a9aa:	68fb      	ldr	r3, [r7, #12]
3400a9ac:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400a9ae:	1ad2      	subs	r2, r2, r3
3400a9b0:	697b      	ldr	r3, [r7, #20]
3400a9b2:	615a      	str	r2, [r3, #20]
		if ( semcb->semcnt <= 0 ) {
3400a9b4:	697b      	ldr	r3, [r7, #20]
3400a9b6:	695b      	ldr	r3, [r3, #20]
3400a9b8:	2b00      	cmp	r3, #0
3400a9ba:	dd06      	ble.n	3400a9ca <tk_sig_sem+0xce>
3400a9bc:	e000      	b.n	3400a9c0 <tk_sig_sem+0xc4>
			continue;
3400a9be:	bf00      	nop
	while ( queue != &semcb->wait_queue ) {
3400a9c0:	697b      	ldr	r3, [r7, #20]
3400a9c2:	69fa      	ldr	r2, [r7, #28]
3400a9c4:	429a      	cmp	r2, r3
3400a9c6:	d1d9      	bne.n	3400a97c <tk_sig_sem+0x80>
			break;
		}
	}

    error_exit:
3400a9c8:	e000      	b.n	3400a9cc <tk_sig_sem+0xd0>
			break;
3400a9ca:	bf00      	nop
	END_CRITICAL_SECTION;
3400a9cc:	693b      	ldr	r3, [r7, #16]
3400a9ce:	2b00      	cmp	r3, #0
3400a9d0:	d10b      	bne.n	3400a9ea <tk_sig_sem+0xee>
3400a9d2:	4b0b      	ldr	r3, [pc, #44]	@ (3400aa00 <tk_sig_sem+0x104>)
3400a9d4:	681a      	ldr	r2, [r3, #0]
3400a9d6:	4b0b      	ldr	r3, [pc, #44]	@ (3400aa04 <tk_sig_sem+0x108>)
3400a9d8:	681b      	ldr	r3, [r3, #0]
3400a9da:	429a      	cmp	r2, r3
3400a9dc:	d005      	beq.n	3400a9ea <tk_sig_sem+0xee>
3400a9de:	4b0a      	ldr	r3, [pc, #40]	@ (3400aa08 <tk_sig_sem+0x10c>)
3400a9e0:	681b      	ldr	r3, [r3, #0]
3400a9e2:	2b00      	cmp	r3, #0
3400a9e4:	d101      	bne.n	3400a9ea <tk_sig_sem+0xee>
3400a9e6:	f002 f88f 	bl	3400cb08 <knl_dispatch>
3400a9ea:	6938      	ldr	r0, [r7, #16]
3400a9ec:	f002 ffaf 	bl	3400d94e <set_basepri>

	return ercd;
3400a9f0:	69bb      	ldr	r3, [r7, #24]
}
3400a9f2:	4618      	mov	r0, r3
3400a9f4:	3720      	adds	r7, #32
3400a9f6:	46bd      	mov	sp, r7
3400a9f8:	bd80      	pop	{r7, pc}
3400a9fa:	bf00      	nop
3400a9fc:	340107fc 	.word	0x340107fc
3400aa00:	340109c8 	.word	0x340109c8
3400aa04:	340109cc 	.word	0x340109cc
3400aa08:	340109c4 	.word	0x340109c4

3400aa0c <sem_chg_pri>:

/*
 * Processing if the priority of wait task changes
 */
LOCAL void sem_chg_pri( TCB *tcb, INT oldpri )
{
3400aa0c:	b580      	push	{r7, lr}
3400aa0e:	b086      	sub	sp, #24
3400aa10:	af00      	add	r7, sp, #0
3400aa12:	6078      	str	r0, [r7, #4]
3400aa14:	6039      	str	r1, [r7, #0]
	SEMCB	*semcb;
	QUEUE	*queue;
	TCB	*top;

	semcb = get_semcb(tcb->wid);
3400aa16:	687b      	ldr	r3, [r7, #4]
3400aa18:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400aa1a:	1e5a      	subs	r2, r3, #1
3400aa1c:	4613      	mov	r3, r2
3400aa1e:	00db      	lsls	r3, r3, #3
3400aa20:	1a9b      	subs	r3, r3, r2
3400aa22:	009b      	lsls	r3, r3, #2
3400aa24:	4a19      	ldr	r2, [pc, #100]	@ (3400aa8c <sem_chg_pri+0x80>)
3400aa26:	4413      	add	r3, r2
3400aa28:	613b      	str	r3, [r7, #16]
	if ( oldpri >= 0 ) {
3400aa2a:	683b      	ldr	r3, [r7, #0]
3400aa2c:	2b00      	cmp	r3, #0
3400aa2e:	db03      	blt.n	3400aa38 <sem_chg_pri+0x2c>
		/* Reorder wait line */
		knl_gcb_change_priority((GCB*)semcb, tcb);
3400aa30:	6879      	ldr	r1, [r7, #4]
3400aa32:	6938      	ldr	r0, [r7, #16]
3400aa34:	f001 f980 	bl	3400bd38 <knl_gcb_change_priority>
	}

	if ( (semcb->sematr & TA_CNT) != 0 ) {
3400aa38:	693b      	ldr	r3, [r7, #16]
3400aa3a:	691b      	ldr	r3, [r3, #16]
3400aa3c:	f003 0302 	and.w	r3, r3, #2
3400aa40:	2b00      	cmp	r3, #0
3400aa42:	d11d      	bne.n	3400aa80 <sem_chg_pri+0x74>
		return;
	}

	/* From the head task in a wait queue, allocate semaphore counts
	   and release wait state as much as possible */
	queue = semcb->wait_queue.next;
3400aa44:	693b      	ldr	r3, [r7, #16]
3400aa46:	681b      	ldr	r3, [r3, #0]
3400aa48:	617b      	str	r3, [r7, #20]
	while ( queue != &semcb->wait_queue ) {
3400aa4a:	e014      	b.n	3400aa76 <sem_chg_pri+0x6a>
		top = (TCB*)queue;
3400aa4c:	697b      	ldr	r3, [r7, #20]
3400aa4e:	60fb      	str	r3, [r7, #12]
		queue = queue->next;
3400aa50:	697b      	ldr	r3, [r7, #20]
3400aa52:	681b      	ldr	r3, [r3, #0]
3400aa54:	617b      	str	r3, [r7, #20]

		/* Meet condition for releasing wait? */
		if ( semcb->semcnt < top->winfo.sem.cnt ) {
3400aa56:	693b      	ldr	r3, [r7, #16]
3400aa58:	695a      	ldr	r2, [r3, #20]
3400aa5a:	68fb      	ldr	r3, [r7, #12]
3400aa5c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400aa5e:	429a      	cmp	r2, r3
3400aa60:	db10      	blt.n	3400aa84 <sem_chg_pri+0x78>
			break;
		}

		/* Release wait */
		knl_wait_release_ok(top);
3400aa62:	68f8      	ldr	r0, [r7, #12]
3400aa64:	f001 f889 	bl	3400bb7a <knl_wait_release_ok>

		semcb->semcnt -= top->winfo.sem.cnt;
3400aa68:	693b      	ldr	r3, [r7, #16]
3400aa6a:	695a      	ldr	r2, [r3, #20]
3400aa6c:	68fb      	ldr	r3, [r7, #12]
3400aa6e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400aa70:	1ad2      	subs	r2, r2, r3
3400aa72:	693b      	ldr	r3, [r7, #16]
3400aa74:	615a      	str	r2, [r3, #20]
	while ( queue != &semcb->wait_queue ) {
3400aa76:	693b      	ldr	r3, [r7, #16]
3400aa78:	697a      	ldr	r2, [r7, #20]
3400aa7a:	429a      	cmp	r2, r3
3400aa7c:	d1e6      	bne.n	3400aa4c <sem_chg_pri+0x40>
3400aa7e:	e002      	b.n	3400aa86 <sem_chg_pri+0x7a>
		return;
3400aa80:	bf00      	nop
3400aa82:	e000      	b.n	3400aa86 <sem_chg_pri+0x7a>
			break;
3400aa84:	bf00      	nop
	}
}
3400aa86:	3718      	adds	r7, #24
3400aa88:	46bd      	mov	sp, r7
3400aa8a:	bd80      	pop	{r7, pc}
3400aa8c:	340107fc 	.word	0x340107fc

3400aa90 <sem_rel_wai>:

/*
 * Processing if the wait task is freed
 */
LOCAL void sem_rel_wai( TCB *tcb )
{
3400aa90:	b580      	push	{r7, lr}
3400aa92:	b082      	sub	sp, #8
3400aa94:	af00      	add	r7, sp, #0
3400aa96:	6078      	str	r0, [r7, #4]
	sem_chg_pri(tcb, -1);
3400aa98:	f04f 31ff 	mov.w	r1, #4294967295
3400aa9c:	6878      	ldr	r0, [r7, #4]
3400aa9e:	f7ff ffb5 	bl	3400aa0c <sem_chg_pri>
}
3400aaa2:	bf00      	nop
3400aaa4:	3708      	adds	r7, #8
3400aaa6:	46bd      	mov	sp, r7
3400aaa8:	bd80      	pop	{r7, pc}
	...

3400aaac <tk_wai_sem>:

/*
 * Wait on semaphore
 */
SYSCALL ER tk_wai_sem( ID semid, INT cnt, TMO tmout )
{
3400aaac:	b580      	push	{r7, lr}
3400aaae:	b088      	sub	sp, #32
3400aab0:	af00      	add	r7, sp, #0
3400aab2:	60f8      	str	r0, [r7, #12]
3400aab4:	60b9      	str	r1, [r7, #8]
3400aab6:	607a      	str	r2, [r7, #4]
	SEMCB	*semcb;
	ER	ercd = E_OK;
3400aab8:	2300      	movs	r3, #0
3400aaba:	617b      	str	r3, [r7, #20]

	CHECK_SEMID(semid);
3400aabc:	68fb      	ldr	r3, [r7, #12]
3400aabe:	2b00      	cmp	r3, #0
3400aac0:	dd02      	ble.n	3400aac8 <tk_wai_sem+0x1c>
3400aac2:	68fb      	ldr	r3, [r7, #12]
3400aac4:	2b10      	cmp	r3, #16
3400aac6:	dd02      	ble.n	3400aace <tk_wai_sem+0x22>
3400aac8:	f06f 0311 	mvn.w	r3, #17
3400aacc:	e087      	b.n	3400abde <tk_wai_sem+0x132>
	CHECK_PAR(cnt > 0);
3400aace:	68bb      	ldr	r3, [r7, #8]
3400aad0:	2b00      	cmp	r3, #0
3400aad2:	dc02      	bgt.n	3400aada <tk_wai_sem+0x2e>
3400aad4:	f06f 0310 	mvn.w	r3, #16
3400aad8:	e081      	b.n	3400abde <tk_wai_sem+0x132>
	CHECK_TMOUT(tmout);
3400aada:	687b      	ldr	r3, [r7, #4]
3400aadc:	f1b3 3fff 	cmp.w	r3, #4294967295
3400aae0:	da02      	bge.n	3400aae8 <tk_wai_sem+0x3c>
3400aae2:	f06f 0310 	mvn.w	r3, #16
3400aae6:	e07a      	b.n	3400abde <tk_wai_sem+0x132>
	CHECK_DISPATCH();
3400aae8:	4b3f      	ldr	r3, [pc, #252]	@ (3400abe8 <tk_wai_sem+0x13c>)
3400aaea:	681b      	ldr	r3, [r3, #0]
3400aaec:	2b00      	cmp	r3, #0
3400aaee:	d10d      	bne.n	3400ab0c <tk_wai_sem+0x60>
3400aaf0:	f7ff fe04 	bl	3400a6fc <knl_isTaskIndependent>
3400aaf4:	4603      	mov	r3, r0
3400aaf6:	2b00      	cmp	r3, #0
3400aaf8:	d108      	bne.n	3400ab0c <tk_wai_sem+0x60>
3400aafa:	4b3c      	ldr	r3, [pc, #240]	@ (3400abec <tk_wai_sem+0x140>)
3400aafc:	681b      	ldr	r3, [r3, #0]
3400aafe:	2b00      	cmp	r3, #0
3400ab00:	d004      	beq.n	3400ab0c <tk_wai_sem+0x60>
3400ab02:	f002 ff33 	bl	3400d96c <get_basepri>
3400ab06:	4603      	mov	r3, r0
3400ab08:	2b00      	cmp	r3, #0
3400ab0a:	d002      	beq.n	3400ab12 <tk_wai_sem+0x66>
3400ab0c:	f06f 0318 	mvn.w	r3, #24
3400ab10:	e065      	b.n	3400abde <tk_wai_sem+0x132>

	semcb = get_semcb(semid);
3400ab12:	68fb      	ldr	r3, [r7, #12]
3400ab14:	1e5a      	subs	r2, r3, #1
3400ab16:	4613      	mov	r3, r2
3400ab18:	00db      	lsls	r3, r3, #3
3400ab1a:	1a9b      	subs	r3, r3, r2
3400ab1c:	009b      	lsls	r3, r3, #2
3400ab1e:	4a34      	ldr	r2, [pc, #208]	@ (3400abf0 <tk_wai_sem+0x144>)
3400ab20:	4413      	add	r3, r2
3400ab22:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
3400ab24:	f002 ff2f 	bl	3400d986 <disint>
3400ab28:	61b8      	str	r0, [r7, #24]
	if ( semcb->semid == 0 ) {
3400ab2a:	69fb      	ldr	r3, [r7, #28]
3400ab2c:	689b      	ldr	r3, [r3, #8]
3400ab2e:	2b00      	cmp	r3, #0
3400ab30:	d103      	bne.n	3400ab3a <tk_wai_sem+0x8e>
		ercd = E_NOEXS;
3400ab32:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400ab36:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400ab38:	e03e      	b.n	3400abb8 <tk_wai_sem+0x10c>
	}
#if CHK_PAR
	if ( cnt > semcb->maxsem ) {
3400ab3a:	69fb      	ldr	r3, [r7, #28]
3400ab3c:	699b      	ldr	r3, [r3, #24]
3400ab3e:	68ba      	ldr	r2, [r7, #8]
3400ab40:	429a      	cmp	r2, r3
3400ab42:	dd03      	ble.n	3400ab4c <tk_wai_sem+0xa0>
		ercd = E_PAR;
3400ab44:	f06f 0310 	mvn.w	r3, #16
3400ab48:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400ab4a:	e035      	b.n	3400abb8 <tk_wai_sem+0x10c>
	}
#endif

	if ( ((semcb->sematr & TA_CNT) != 0
3400ab4c:	69fb      	ldr	r3, [r7, #28]
3400ab4e:	691b      	ldr	r3, [r3, #16]
3400ab50:	f003 0302 	and.w	r3, r3, #2
3400ab54:	2b00      	cmp	r3, #0
3400ab56:	d10a      	bne.n	3400ab6e <tk_wai_sem+0xc2>
	      || knl_gcb_top_of_wait_queue((GCB*)semcb, knl_ctxtsk) == knl_ctxtsk)
3400ab58:	4b24      	ldr	r3, [pc, #144]	@ (3400abec <tk_wai_sem+0x140>)
3400ab5a:	681b      	ldr	r3, [r3, #0]
3400ab5c:	4619      	mov	r1, r3
3400ab5e:	69f8      	ldr	r0, [r7, #28]
3400ab60:	f001 f8fc 	bl	3400bd5c <knl_gcb_top_of_wait_queue>
3400ab64:	4602      	mov	r2, r0
3400ab66:	4b21      	ldr	r3, [pc, #132]	@ (3400abec <tk_wai_sem+0x140>)
3400ab68:	681b      	ldr	r3, [r3, #0]
3400ab6a:	429a      	cmp	r2, r3
3400ab6c:	d10b      	bne.n	3400ab86 <tk_wai_sem+0xda>
	  && semcb->semcnt >= cnt ) {
3400ab6e:	69fb      	ldr	r3, [r7, #28]
3400ab70:	695b      	ldr	r3, [r3, #20]
3400ab72:	68ba      	ldr	r2, [r7, #8]
3400ab74:	429a      	cmp	r2, r3
3400ab76:	dc06      	bgt.n	3400ab86 <tk_wai_sem+0xda>
		/* Get semaphore count */
		semcb->semcnt -= cnt;
3400ab78:	69fb      	ldr	r3, [r7, #28]
3400ab7a:	695a      	ldr	r2, [r3, #20]
3400ab7c:	68bb      	ldr	r3, [r7, #8]
3400ab7e:	1ad2      	subs	r2, r2, r3
3400ab80:	69fb      	ldr	r3, [r7, #28]
3400ab82:	615a      	str	r2, [r3, #20]
3400ab84:	e018      	b.n	3400abb8 <tk_wai_sem+0x10c>

	} else {
		/* Ready for wait */
		knl_ctxtsk->wspec = ( (semcb->sematr & TA_TPRI) != 0 )?
3400ab86:	69fb      	ldr	r3, [r7, #28]
3400ab88:	691b      	ldr	r3, [r3, #16]
3400ab8a:	f003 0301 	and.w	r3, r3, #1
					&knl_wspec_sem_tpri: &knl_wspec_sem_tfifo;
3400ab8e:	2b00      	cmp	r3, #0
3400ab90:	d001      	beq.n	3400ab96 <tk_wai_sem+0xea>
3400ab92:	4a18      	ldr	r2, [pc, #96]	@ (3400abf4 <tk_wai_sem+0x148>)
3400ab94:	e000      	b.n	3400ab98 <tk_wai_sem+0xec>
3400ab96:	4a18      	ldr	r2, [pc, #96]	@ (3400abf8 <tk_wai_sem+0x14c>)
		knl_ctxtsk->wspec = ( (semcb->sematr & TA_TPRI) != 0 )?
3400ab98:	4b14      	ldr	r3, [pc, #80]	@ (3400abec <tk_wai_sem+0x140>)
3400ab9a:	681b      	ldr	r3, [r3, #0]
3400ab9c:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wercd = &ercd;
3400ab9e:	4b13      	ldr	r3, [pc, #76]	@ (3400abec <tk_wai_sem+0x140>)
3400aba0:	681b      	ldr	r3, [r3, #0]
3400aba2:	f107 0214 	add.w	r2, r7, #20
3400aba6:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_ctxtsk->winfo.sem.cnt = cnt;
3400aba8:	4b10      	ldr	r3, [pc, #64]	@ (3400abec <tk_wai_sem+0x140>)
3400abaa:	681b      	ldr	r3, [r3, #0]
3400abac:	68ba      	ldr	r2, [r7, #8]
3400abae:	641a      	str	r2, [r3, #64]	@ 0x40
		knl_gcb_make_wait((GCB*)semcb, tmout);
3400abb0:	6879      	ldr	r1, [r7, #4]
3400abb2:	69f8      	ldr	r0, [r7, #28]
3400abb4:	f001 f88a 	bl	3400bccc <knl_gcb_make_wait>
	}

    error_exit:
	END_CRITICAL_SECTION;
3400abb8:	69bb      	ldr	r3, [r7, #24]
3400abba:	2b00      	cmp	r3, #0
3400abbc:	d10b      	bne.n	3400abd6 <tk_wai_sem+0x12a>
3400abbe:	4b0b      	ldr	r3, [pc, #44]	@ (3400abec <tk_wai_sem+0x140>)
3400abc0:	681a      	ldr	r2, [r3, #0]
3400abc2:	4b0e      	ldr	r3, [pc, #56]	@ (3400abfc <tk_wai_sem+0x150>)
3400abc4:	681b      	ldr	r3, [r3, #0]
3400abc6:	429a      	cmp	r2, r3
3400abc8:	d005      	beq.n	3400abd6 <tk_wai_sem+0x12a>
3400abca:	4b07      	ldr	r3, [pc, #28]	@ (3400abe8 <tk_wai_sem+0x13c>)
3400abcc:	681b      	ldr	r3, [r3, #0]
3400abce:	2b00      	cmp	r3, #0
3400abd0:	d101      	bne.n	3400abd6 <tk_wai_sem+0x12a>
3400abd2:	f001 ff99 	bl	3400cb08 <knl_dispatch>
3400abd6:	69b8      	ldr	r0, [r7, #24]
3400abd8:	f002 feb9 	bl	3400d94e <set_basepri>

	return ercd;
3400abdc:	697b      	ldr	r3, [r7, #20]
}
3400abde:	4618      	mov	r0, r3
3400abe0:	3720      	adds	r7, #32
3400abe2:	46bd      	mov	sp, r7
3400abe4:	bd80      	pop	{r7, pc}
3400abe6:	bf00      	nop
3400abe8:	340109c4 	.word	0x340109c4
3400abec:	340109c8 	.word	0x340109c8
3400abf0:	340107fc 	.word	0x340107fc
3400abf4:	3400e048 	.word	0x3400e048
3400abf8:	3400e03c 	.word	0x3400e03c
3400abfc:	340109cc 	.word	0x340109cc

3400ac00 <QueInit>:
{
3400ac00:	b480      	push	{r7}
3400ac02:	b083      	sub	sp, #12
3400ac04:	af00      	add	r7, sp, #0
3400ac06:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400ac08:	687b      	ldr	r3, [r7, #4]
3400ac0a:	687a      	ldr	r2, [r7, #4]
3400ac0c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400ac0e:	687b      	ldr	r3, [r7, #4]
3400ac10:	687a      	ldr	r2, [r7, #4]
3400ac12:	605a      	str	r2, [r3, #4]
}
3400ac14:	bf00      	nop
3400ac16:	370c      	adds	r7, #12
3400ac18:	46bd      	mov	sp, r7
3400ac1a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ac1e:	4770      	bx	lr

3400ac20 <isQueEmpty>:
{
3400ac20:	b480      	push	{r7}
3400ac22:	b083      	sub	sp, #12
3400ac24:	af00      	add	r7, sp, #0
3400ac26:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400ac28:	687b      	ldr	r3, [r7, #4]
3400ac2a:	681b      	ldr	r3, [r3, #0]
3400ac2c:	687a      	ldr	r2, [r7, #4]
3400ac2e:	429a      	cmp	r2, r3
3400ac30:	bf0c      	ite	eq
3400ac32:	2301      	moveq	r3, #1
3400ac34:	2300      	movne	r3, #0
3400ac36:	b2db      	uxtb	r3, r3
}
3400ac38:	4618      	mov	r0, r3
3400ac3a:	370c      	adds	r7, #12
3400ac3c:	46bd      	mov	sp, r7
3400ac3e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ac42:	4770      	bx	lr

3400ac44 <QueInsert>:
{
3400ac44:	b480      	push	{r7}
3400ac46:	b083      	sub	sp, #12
3400ac48:	af00      	add	r7, sp, #0
3400ac4a:	6078      	str	r0, [r7, #4]
3400ac4c:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400ac4e:	683b      	ldr	r3, [r7, #0]
3400ac50:	685a      	ldr	r2, [r3, #4]
3400ac52:	687b      	ldr	r3, [r7, #4]
3400ac54:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400ac56:	687b      	ldr	r3, [r7, #4]
3400ac58:	683a      	ldr	r2, [r7, #0]
3400ac5a:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400ac5c:	683b      	ldr	r3, [r7, #0]
3400ac5e:	685b      	ldr	r3, [r3, #4]
3400ac60:	687a      	ldr	r2, [r7, #4]
3400ac62:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400ac64:	683b      	ldr	r3, [r7, #0]
3400ac66:	687a      	ldr	r2, [r7, #4]
3400ac68:	605a      	str	r2, [r3, #4]
}
3400ac6a:	bf00      	nop
3400ac6c:	370c      	adds	r7, #12
3400ac6e:	46bd      	mov	sp, r7
3400ac70:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ac74:	4770      	bx	lr

3400ac76 <QueRemove>:
{
3400ac76:	b480      	push	{r7}
3400ac78:	b083      	sub	sp, #12
3400ac7a:	af00      	add	r7, sp, #0
3400ac7c:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400ac7e:	687b      	ldr	r3, [r7, #4]
3400ac80:	681b      	ldr	r3, [r3, #0]
3400ac82:	687a      	ldr	r2, [r7, #4]
3400ac84:	429a      	cmp	r2, r3
3400ac86:	d009      	beq.n	3400ac9c <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400ac88:	687b      	ldr	r3, [r7, #4]
3400ac8a:	685b      	ldr	r3, [r3, #4]
3400ac8c:	687a      	ldr	r2, [r7, #4]
3400ac8e:	6812      	ldr	r2, [r2, #0]
3400ac90:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400ac92:	687b      	ldr	r3, [r7, #4]
3400ac94:	681b      	ldr	r3, [r3, #0]
3400ac96:	687a      	ldr	r2, [r7, #4]
3400ac98:	6852      	ldr	r2, [r2, #4]
3400ac9a:	605a      	str	r2, [r3, #4]
}
3400ac9c:	bf00      	nop
3400ac9e:	370c      	adds	r7, #12
3400aca0:	46bd      	mov	sp, r7
3400aca2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400aca6:	4770      	bx	lr

3400aca8 <knl_ready_queue_calc_top_priority>:

IMPORT RDYQUE	knl_ready_queue;

#if NUM_TSKPRI <= INT_BITWIDTH
Inline INT knl_ready_queue_calc_top_priority( UINT bitmap, INT pos )
{
3400aca8:	b480      	push	{r7}
3400acaa:	b083      	sub	sp, #12
3400acac:	af00      	add	r7, sp, #0
3400acae:	6078      	str	r0, [r7, #4]
3400acb0:	6039      	str	r1, [r7, #0]
	for ( ; pos < NUM_TSKPRI; pos++ ) {
3400acb2:	e00b      	b.n	3400accc <knl_ready_queue_calc_top_priority+0x24>
		if ( bitmap & (1U << pos) ) {
3400acb4:	2201      	movs	r2, #1
3400acb6:	683b      	ldr	r3, [r7, #0]
3400acb8:	409a      	lsls	r2, r3
3400acba:	687b      	ldr	r3, [r7, #4]
3400acbc:	4013      	ands	r3, r2
3400acbe:	2b00      	cmp	r3, #0
3400acc0:	d001      	beq.n	3400acc6 <knl_ready_queue_calc_top_priority+0x1e>
			return pos;
3400acc2:	683b      	ldr	r3, [r7, #0]
3400acc4:	e006      	b.n	3400acd4 <knl_ready_queue_calc_top_priority+0x2c>
	for ( ; pos < NUM_TSKPRI; pos++ ) {
3400acc6:	683b      	ldr	r3, [r7, #0]
3400acc8:	3301      	adds	r3, #1
3400acca:	603b      	str	r3, [r7, #0]
3400accc:	683b      	ldr	r3, [r7, #0]
3400acce:	2b1f      	cmp	r3, #31
3400acd0:	ddf0      	ble.n	3400acb4 <knl_ready_queue_calc_top_priority+0xc>
		}
	}
	return NUM_TSKPRI;
3400acd2:	2320      	movs	r3, #32
}
3400acd4:	4618      	mov	r0, r3
3400acd6:	370c      	adds	r7, #12
3400acd8:	46bd      	mov	sp, r7
3400acda:	f85d 7b04 	ldr.w	r7, [sp], #4
3400acde:	4770      	bx	lr

3400ace0 <knl_ready_queue_initialize>:

/*
 * Ready queue initialization
 */
Inline void knl_ready_queue_initialize( RDYQUE *rq )
{
3400ace0:	b580      	push	{r7, lr}
3400ace2:	b084      	sub	sp, #16
3400ace4:	af00      	add	r7, sp, #0
3400ace6:	6078      	str	r0, [r7, #4]
	INT	i;

	rq->top_priority = NUM_TSKPRI;
3400ace8:	687b      	ldr	r3, [r7, #4]
3400acea:	2220      	movs	r2, #32
3400acec:	601a      	str	r2, [r3, #0]
	for ( i = 0; i < NUM_TSKPRI; i++ ) {
3400acee:	2300      	movs	r3, #0
3400acf0:	60fb      	str	r3, [r7, #12]
3400acf2:	e00a      	b.n	3400ad0a <knl_ready_queue_initialize+0x2a>
		QueInit(&rq->tskque[i]);
3400acf4:	68fb      	ldr	r3, [r7, #12]
3400acf6:	00db      	lsls	r3, r3, #3
3400acf8:	687a      	ldr	r2, [r7, #4]
3400acfa:	4413      	add	r3, r2
3400acfc:	3304      	adds	r3, #4
3400acfe:	4618      	mov	r0, r3
3400ad00:	f7ff ff7e 	bl	3400ac00 <QueInit>
	for ( i = 0; i < NUM_TSKPRI; i++ ) {
3400ad04:	68fb      	ldr	r3, [r7, #12]
3400ad06:	3301      	adds	r3, #1
3400ad08:	60fb      	str	r3, [r7, #12]
3400ad0a:	68fb      	ldr	r3, [r7, #12]
3400ad0c:	2b1f      	cmp	r3, #31
3400ad0e:	ddf1      	ble.n	3400acf4 <knl_ready_queue_initialize+0x14>
	}
	rq->null = NULL;
3400ad10:	687b      	ldr	r3, [r7, #4]
3400ad12:	2200      	movs	r2, #0
3400ad14:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
	rq->klocktsk = NULL;
3400ad18:	687b      	ldr	r3, [r7, #4]
3400ad1a:	2200      	movs	r2, #0
3400ad1c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	knl_memset(rq->bitmap, 0, sizeof(rq->bitmap));
3400ad20:	687b      	ldr	r3, [r7, #4]
3400ad22:	f503 7384 	add.w	r3, r3, #264	@ 0x108
3400ad26:	2204      	movs	r2, #4
3400ad28:	2100      	movs	r1, #0
3400ad2a:	4618      	mov	r0, r3
3400ad2c:	f001 f83e 	bl	3400bdac <knl_memset>
}
3400ad30:	bf00      	nop
3400ad32:	3710      	adds	r7, #16
3400ad34:	46bd      	mov	sp, r7
3400ad36:	bd80      	pop	{r7, pc}

3400ad38 <knl_ready_queue_top>:

/*
 * Return the highest priority task in ready queue
 */
Inline TCB* knl_ready_queue_top( RDYQUE *rq )
{
3400ad38:	b480      	push	{r7}
3400ad3a:	b083      	sub	sp, #12
3400ad3c:	af00      	add	r7, sp, #0
3400ad3e:	6078      	str	r0, [r7, #4]
	/* If there is a task at kernel lock, that is the highest priority task */
	if ( rq->klocktsk != NULL ) {
3400ad40:	687b      	ldr	r3, [r7, #4]
3400ad42:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400ad46:	2b00      	cmp	r3, #0
3400ad48:	d003      	beq.n	3400ad52 <knl_ready_queue_top+0x1a>
		return rq->klocktsk;
3400ad4a:	687b      	ldr	r3, [r7, #4]
3400ad4c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400ad50:	e005      	b.n	3400ad5e <knl_ready_queue_top+0x26>
	}

	return (TCB*)rq->tskque[rq->top_priority].next;
3400ad52:	687b      	ldr	r3, [r7, #4]
3400ad54:	681b      	ldr	r3, [r3, #0]
3400ad56:	687a      	ldr	r2, [r7, #4]
3400ad58:	00db      	lsls	r3, r3, #3
3400ad5a:	4413      	add	r3, r2
3400ad5c:	685b      	ldr	r3, [r3, #4]
}
3400ad5e:	4618      	mov	r0, r3
3400ad60:	370c      	adds	r7, #12
3400ad62:	46bd      	mov	sp, r7
3400ad64:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ad68:	4770      	bx	lr

3400ad6a <knl_ready_queue_insert>:
 *	indicated with 'tcb'. Set the applicable bit in the bitmap area and 
 *	update 'top_priority' if necessary. When updating 'top_priority,' 
 *	return TRUE, otherwise FALSE.
 */
Inline BOOL knl_ready_queue_insert( RDYQUE *rq, TCB *tcb )
{
3400ad6a:	b580      	push	{r7, lr}
3400ad6c:	b084      	sub	sp, #16
3400ad6e:	af00      	add	r7, sp, #0
3400ad70:	6078      	str	r0, [r7, #4]
3400ad72:	6039      	str	r1, [r7, #0]
	INT	priority = tcb->priority;
3400ad74:	683b      	ldr	r3, [r7, #0]
3400ad76:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400ad7a:	60fb      	str	r3, [r7, #12]

	QueInsert(&tcb->tskque, &rq->tskque[priority]);
3400ad7c:	6838      	ldr	r0, [r7, #0]
3400ad7e:	68fb      	ldr	r3, [r7, #12]
3400ad80:	00db      	lsls	r3, r3, #3
3400ad82:	687a      	ldr	r2, [r7, #4]
3400ad84:	4413      	add	r3, r2
3400ad86:	3304      	adds	r3, #4
3400ad88:	4619      	mov	r1, r3
3400ad8a:	f7ff ff5b 	bl	3400ac44 <QueInsert>
#if NUM_TSKPRI <= INT_BITWIDTH
	rq->bitmap[0] |= (1U << priority);
3400ad8e:	687b      	ldr	r3, [r7, #4]
3400ad90:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400ad94:	2101      	movs	r1, #1
3400ad96:	68fb      	ldr	r3, [r7, #12]
3400ad98:	fa01 f303 	lsl.w	r3, r1, r3
3400ad9c:	431a      	orrs	r2, r3
3400ad9e:	687b      	ldr	r3, [r7, #4]
3400ada0:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#else
	knl_bitset(rq->bitmap, priority);
#endif

	if ( tcb->klocked ) {
3400ada4:	683b      	ldr	r3, [r7, #0]
3400ada6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
3400adaa:	f003 0302 	and.w	r3, r3, #2
3400adae:	b2db      	uxtb	r3, r3
3400adb0:	2b00      	cmp	r3, #0
3400adb2:	d003      	beq.n	3400adbc <knl_ready_queue_insert+0x52>
		rq->klocktsk = tcb;
3400adb4:	687b      	ldr	r3, [r7, #4]
3400adb6:	683a      	ldr	r2, [r7, #0]
3400adb8:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	}

	if ( priority < rq->top_priority ) {
3400adbc:	687b      	ldr	r3, [r7, #4]
3400adbe:	681b      	ldr	r3, [r3, #0]
3400adc0:	68fa      	ldr	r2, [r7, #12]
3400adc2:	429a      	cmp	r2, r3
3400adc4:	da04      	bge.n	3400add0 <knl_ready_queue_insert+0x66>
		rq->top_priority = priority;
3400adc6:	687b      	ldr	r3, [r7, #4]
3400adc8:	68fa      	ldr	r2, [r7, #12]
3400adca:	601a      	str	r2, [r3, #0]
		return TRUE;
3400adcc:	2301      	movs	r3, #1
3400adce:	e000      	b.n	3400add2 <knl_ready_queue_insert+0x68>
	}
	return FALSE;
3400add0:	2300      	movs	r3, #0
}
3400add2:	4618      	mov	r0, r3
3400add4:	3710      	adds	r7, #16
3400add6:	46bd      	mov	sp, r7
3400add8:	bd80      	pop	{r7, pc}

3400adda <knl_ready_queue_delete>:
 *	In addition, update 'top_priority' if the deleted task had the highest 
 *	priority. In such case, use the bitmap area to search the second
 *	highest priority task.
 */
Inline void knl_ready_queue_delete( RDYQUE *rq, TCB *tcb )
{
3400adda:	b580      	push	{r7, lr}
3400addc:	b084      	sub	sp, #16
3400adde:	af00      	add	r7, sp, #0
3400ade0:	6078      	str	r0, [r7, #4]
3400ade2:	6039      	str	r1, [r7, #0]
	INT	priority = tcb->priority;
3400ade4:	683b      	ldr	r3, [r7, #0]
3400ade6:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400adea:	60fb      	str	r3, [r7, #12]
#if NUM_TSKPRI > INT_BITWIDTH
	INT	i;
#endif

	if ( rq->klocktsk == tcb ) {
3400adec:	687b      	ldr	r3, [r7, #4]
3400adee:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400adf2:	683a      	ldr	r2, [r7, #0]
3400adf4:	429a      	cmp	r2, r3
3400adf6:	d103      	bne.n	3400ae00 <knl_ready_queue_delete+0x26>
		rq->klocktsk = NULL;
3400adf8:	687b      	ldr	r3, [r7, #4]
3400adfa:	2200      	movs	r2, #0
3400adfc:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	}

	QueRemove(&tcb->tskque);
3400ae00:	683b      	ldr	r3, [r7, #0]
3400ae02:	4618      	mov	r0, r3
3400ae04:	f7ff ff37 	bl	3400ac76 <QueRemove>
	if ( tcb->klockwait ) {
3400ae08:	683b      	ldr	r3, [r7, #0]
3400ae0a:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
3400ae0e:	f003 0301 	and.w	r3, r3, #1
3400ae12:	b2db      	uxtb	r3, r3
3400ae14:	2b00      	cmp	r3, #0
3400ae16:	d007      	beq.n	3400ae28 <knl_ready_queue_delete+0x4e>
		/* Delete from kernel lock wait queue */
		tcb->klockwait = FALSE;
3400ae18:	683a      	ldr	r2, [r7, #0]
3400ae1a:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400ae1e:	f023 0301 	bic.w	r3, r3, #1
3400ae22:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
		return;
3400ae26:	e029      	b.n	3400ae7c <knl_ready_queue_delete+0xa2>
	}
	if ( !isQueEmpty(&rq->tskque[priority]) ) {
3400ae28:	68fb      	ldr	r3, [r7, #12]
3400ae2a:	00db      	lsls	r3, r3, #3
3400ae2c:	687a      	ldr	r2, [r7, #4]
3400ae2e:	4413      	add	r3, r2
3400ae30:	3304      	adds	r3, #4
3400ae32:	4618      	mov	r0, r3
3400ae34:	f7ff fef4 	bl	3400ac20 <isQueEmpty>
3400ae38:	4603      	mov	r3, r0
3400ae3a:	2b00      	cmp	r3, #0
3400ae3c:	d01b      	beq.n	3400ae76 <knl_ready_queue_delete+0x9c>
		return;
	}

#if NUM_TSKPRI <= INT_BITWIDTH
	rq->bitmap[0] &= ~(1U << priority);
3400ae3e:	687b      	ldr	r3, [r7, #4]
3400ae40:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400ae44:	2101      	movs	r1, #1
3400ae46:	68fb      	ldr	r3, [r7, #12]
3400ae48:	fa01 f303 	lsl.w	r3, r1, r3
3400ae4c:	43db      	mvns	r3, r3
3400ae4e:	401a      	ands	r2, r3
3400ae50:	687b      	ldr	r3, [r7, #4]
3400ae52:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#else
	knl_bitclr(rq->bitmap, priority);
#endif
	if ( priority != rq->top_priority ) {
3400ae56:	687b      	ldr	r3, [r7, #4]
3400ae58:	681b      	ldr	r3, [r3, #0]
3400ae5a:	68fa      	ldr	r2, [r7, #12]
3400ae5c:	429a      	cmp	r2, r3
3400ae5e:	d10c      	bne.n	3400ae7a <knl_ready_queue_delete+0xa0>
		return;
	}

#if NUM_TSKPRI <= INT_BITWIDTH
	rq->top_priority = knl_ready_queue_calc_top_priority(rq->bitmap[0], priority);
3400ae60:	687b      	ldr	r3, [r7, #4]
3400ae62:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400ae66:	68f9      	ldr	r1, [r7, #12]
3400ae68:	4618      	mov	r0, r3
3400ae6a:	f7ff ff1d 	bl	3400aca8 <knl_ready_queue_calc_top_priority>
3400ae6e:	4602      	mov	r2, r0
3400ae70:	687b      	ldr	r3, [r7, #4]
3400ae72:	601a      	str	r2, [r3, #0]
3400ae74:	e002      	b.n	3400ae7c <knl_ready_queue_delete+0xa2>
		return;
3400ae76:	bf00      	nop
3400ae78:	e000      	b.n	3400ae7c <knl_ready_queue_delete+0xa2>
		return;
3400ae7a:	bf00      	nop
		rq->top_priority = priority + i;
	} else {
		rq->top_priority = NUM_TSKPRI;
	}
#endif
}
3400ae7c:	3710      	adds	r7, #16
3400ae7e:	46bd      	mov	sp, r7
3400ae80:	bd80      	pop	{r7, pc}

3400ae82 <knl_setup_context>:
/*
 * Create stack frame for task startup
 *	Call from 'make_dormant()'
 */
Inline void knl_setup_context( TCB *tcb )
{
3400ae82:	b480      	push	{r7}
3400ae84:	b085      	sub	sp, #20
3400ae86:	af00      	add	r7, sp, #0
3400ae88:	6078      	str	r0, [r7, #4]
	SStackFrame	*ssp;

	ssp = tcb->isstack;
3400ae8a:	687b      	ldr	r3, [r7, #4]
3400ae8c:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400ae8e:	60fb      	str	r3, [r7, #12]
	ssp--;
3400ae90:	68fb      	ldr	r3, [r7, #12]
3400ae92:	3b44      	subs	r3, #68	@ 0x44
3400ae94:	60fb      	str	r3, [r7, #12]

	/* CPU context initialization */
	ssp->exp_ret	= EXCRTN_CODE;
3400ae96:	68fb      	ldr	r3, [r7, #12]
3400ae98:	f06f 0206 	mvn.w	r2, #6
3400ae9c:	601a      	str	r2, [r3, #0]
	ssp->lr		= 0;
3400ae9e:	68fb      	ldr	r3, [r7, #12]
3400aea0:	2200      	movs	r2, #0
3400aea2:	639a      	str	r2, [r3, #56]	@ 0x38
	ssp->xpsr	= 0x01000000;		/* Initial SR */
3400aea4:	68fb      	ldr	r3, [r7, #12]
3400aea6:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400aeaa:	641a      	str	r2, [r3, #64]	@ 0x40
	ssp->pc = (void*)((UW)tcb->task & ~0x00000001UL);	/* Task startup address */
3400aeac:	687b      	ldr	r3, [r7, #4]
3400aeae:	695b      	ldr	r3, [r3, #20]
3400aeb0:	f023 0301 	bic.w	r3, r3, #1
3400aeb4:	461a      	mov	r2, r3
3400aeb6:	68fb      	ldr	r3, [r7, #12]
3400aeb8:	63da      	str	r2, [r3, #60]	@ 0x3c

	tcb->tskctxb.ssp = ssp;		/* System stack pointer */
3400aeba:	687b      	ldr	r3, [r7, #4]
3400aebc:	68fa      	ldr	r2, [r7, #12]
3400aebe:	619a      	str	r2, [r3, #24]
	tcb->tskctxb.spsa = tcb->isstack - tcb->sstksz;
	tcb->tskctxb.spea = tcb->isstack + sizeof(UW) - 1;
#endif

#if USE_FPU && ALWAYS_FPU_ATR
	tcb->tskatr |= TA_FPU;		/* Always set the TA_FPU attribute on all tasks */
3400aec0:	687b      	ldr	r3, [r7, #4]
3400aec2:	691b      	ldr	r3, [r3, #16]
3400aec4:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
3400aec8:	687b      	ldr	r3, [r7, #4]
3400aeca:	611a      	str	r2, [r3, #16]
#endif
}
3400aecc:	bf00      	nop
3400aece:	3714      	adds	r7, #20
3400aed0:	46bd      	mov	sp, r7
3400aed2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400aed6:	4770      	bx	lr

3400aed8 <knl_task_initialize>:

/*
 * TCB Initialization
 */
EXPORT ER knl_task_initialize( void )
{
3400aed8:	b580      	push	{r7, lr}
3400aeda:	b084      	sub	sp, #16
3400aedc:	af00      	add	r7, sp, #0
	if ( NUM_TSKID < 1 ) {
		return E_SYS;
	}

	/* Initialize task execution control information */
	knl_ctxtsk = knl_schedtsk = NULL;
3400aede:	4b19      	ldr	r3, [pc, #100]	@ (3400af44 <knl_task_initialize+0x6c>)
3400aee0:	2200      	movs	r2, #0
3400aee2:	601a      	str	r2, [r3, #0]
3400aee4:	4b17      	ldr	r3, [pc, #92]	@ (3400af44 <knl_task_initialize+0x6c>)
3400aee6:	681b      	ldr	r3, [r3, #0]
3400aee8:	4a17      	ldr	r2, [pc, #92]	@ (3400af48 <knl_task_initialize+0x70>)
3400aeea:	6013      	str	r3, [r2, #0]
	knl_ready_queue_initialize(&knl_ready_queue);
3400aeec:	4817      	ldr	r0, [pc, #92]	@ (3400af4c <knl_task_initialize+0x74>)
3400aeee:	f7ff fef7 	bl	3400ace0 <knl_ready_queue_initialize>
	knl_dispatch_disabled = DDS_ENABLE;
3400aef2:	4b17      	ldr	r3, [pc, #92]	@ (3400af50 <knl_task_initialize+0x78>)
3400aef4:	2200      	movs	r2, #0
3400aef6:	601a      	str	r2, [r3, #0]

	/* Register all TCBs onto FreeQue */
	QueInit(&knl_free_tcb);
3400aef8:	4816      	ldr	r0, [pc, #88]	@ (3400af54 <knl_task_initialize+0x7c>)
3400aefa:	f7ff fe81 	bl	3400ac00 <QueInit>
	for ( tcb = knl_tcb_table, i = 0; i < NUM_TSKID; tcb++, i++ ) {
3400aefe:	4b16      	ldr	r3, [pc, #88]	@ (3400af58 <knl_task_initialize+0x80>)
3400af00:	60bb      	str	r3, [r7, #8]
3400af02:	2300      	movs	r3, #0
3400af04:	60fb      	str	r3, [r7, #12]
3400af06:	e014      	b.n	3400af32 <knl_task_initialize+0x5a>
		tskid = ID_TSK(i);
3400af08:	68fb      	ldr	r3, [r7, #12]
3400af0a:	3301      	adds	r3, #1
3400af0c:	607b      	str	r3, [r7, #4]
		tcb->tskid = tskid;
3400af0e:	68bb      	ldr	r3, [r7, #8]
3400af10:	687a      	ldr	r2, [r7, #4]
3400af12:	609a      	str	r2, [r3, #8]
		tcb->state = TS_NONEXIST;
3400af14:	68bb      	ldr	r3, [r7, #8]
3400af16:	2200      	movs	r2, #0
3400af18:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
#if USE_LEGACY_API && USE_RENDEZVOUS
		tcb->wrdvno = tskid;
#endif

		QueInsert(&tcb->tskque, &knl_free_tcb);
3400af1c:	68bb      	ldr	r3, [r7, #8]
3400af1e:	490d      	ldr	r1, [pc, #52]	@ (3400af54 <knl_task_initialize+0x7c>)
3400af20:	4618      	mov	r0, r3
3400af22:	f7ff fe8f 	bl	3400ac44 <QueInsert>
	for ( tcb = knl_tcb_table, i = 0; i < NUM_TSKID; tcb++, i++ ) {
3400af26:	68bb      	ldr	r3, [r7, #8]
3400af28:	3368      	adds	r3, #104	@ 0x68
3400af2a:	60bb      	str	r3, [r7, #8]
3400af2c:	68fb      	ldr	r3, [r7, #12]
3400af2e:	3301      	adds	r3, #1
3400af30:	60fb      	str	r3, [r7, #12]
3400af32:	68fb      	ldr	r3, [r7, #12]
3400af34:	2b1f      	cmp	r3, #31
3400af36:	dde7      	ble.n	3400af08 <knl_task_initialize+0x30>
	}

	return E_OK;
3400af38:	2300      	movs	r3, #0
}
3400af3a:	4618      	mov	r0, r3
3400af3c:	3710      	adds	r7, #16
3400af3e:	46bd      	mov	sp, r7
3400af40:	bd80      	pop	{r7, pc}
3400af42:	bf00      	nop
3400af44:	340109cc 	.word	0x340109cc
3400af48:	340109c8 	.word	0x340109c8
3400af4c:	340109d0 	.word	0x340109d0
3400af50:	340109c4 	.word	0x340109c4
3400af54:	340117e0 	.word	0x340117e0
3400af58:	34010ae0 	.word	0x34010ae0

3400af5c <knl_make_dormant>:

/*
 * Prepare task execution.
 */
EXPORT void knl_make_dormant( TCB *tcb )
{
3400af5c:	b580      	push	{r7, lr}
3400af5e:	b082      	sub	sp, #8
3400af60:	af00      	add	r7, sp, #0
3400af62:	6078      	str	r0, [r7, #4]
	/* Initialize variables which should be reset at DORMANT state */
	tcb->state	= TS_DORMANT;
3400af64:	687b      	ldr	r3, [r7, #4]
3400af66:	2208      	movs	r2, #8
3400af68:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
	tcb->priority	= tcb->bpriority = tcb->ipriority;
3400af6c:	687b      	ldr	r3, [r7, #4]
3400af6e:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
3400af72:	687b      	ldr	r3, [r7, #4]
3400af74:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
3400af78:	687b      	ldr	r3, [r7, #4]
3400af7a:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
3400af7e:	687b      	ldr	r3, [r7, #4]
3400af80:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
	tcb->sysmode	= tcb->isysmode;
3400af84:	687b      	ldr	r3, [r7, #4]
3400af86:	f993 3020 	ldrsb.w	r3, [r3, #32]
3400af8a:	461a      	mov	r2, r3
3400af8c:	687b      	ldr	r3, [r7, #4]
3400af8e:	845a      	strh	r2, [r3, #34]	@ 0x22
	tcb->wupcnt	= 0;
3400af90:	687b      	ldr	r3, [r7, #4]
3400af92:	2200      	movs	r2, #0
3400af94:	635a      	str	r2, [r3, #52]	@ 0x34
	tcb->suscnt	= 0;
3400af96:	687b      	ldr	r3, [r7, #4]
3400af98:	2200      	movs	r2, #0
3400af9a:	639a      	str	r2, [r3, #56]	@ 0x38

	tcb->klockwait	= FALSE;
3400af9c:	687a      	ldr	r2, [r7, #4]
3400af9e:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400afa2:	f023 0301 	bic.w	r3, r3, #1
3400afa6:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
	tcb->klocked	= FALSE;
3400afaa:	687a      	ldr	r2, [r7, #4]
3400afac:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400afb0:	f023 0302 	bic.w	r3, r3, #2
3400afb4:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
#if USE_DBGSPT && defined(USE_FUNC_TD_INF_TSK)
	tcb->stime	= 0;
	tcb->utime	= 0;
#endif

	tcb->wercd = NULL;
3400afb8:	687b      	ldr	r3, [r7, #4]
3400afba:	2200      	movs	r2, #0
3400afbc:	63da      	str	r2, [r3, #60]	@ 0x3c

#if USE_MUTEX == 1
	tcb->mtxlist	= NULL;
3400afbe:	687b      	ldr	r3, [r7, #4]
3400afc0:	2200      	movs	r2, #0
3400afc2:	665a      	str	r2, [r3, #100]	@ 0x64
#endif

	/* Set context to start task */
	knl_setup_context(tcb);
3400afc4:	6878      	ldr	r0, [r7, #4]
3400afc6:	f7ff ff5c 	bl	3400ae82 <knl_setup_context>
}
3400afca:	bf00      	nop
3400afcc:	3708      	adds	r7, #8
3400afce:	46bd      	mov	sp, r7
3400afd0:	bd80      	pop	{r7, pc}
	...

3400afd4 <knl_make_ready>:
 * Set task to READY state.
 *	Update the task state and insert in the ready queue. If necessary, 
 *	update 'knl_schedtsk' and request to start task dispatcher. 
 */
EXPORT void knl_make_ready( TCB *tcb )
{
3400afd4:	b580      	push	{r7, lr}
3400afd6:	b082      	sub	sp, #8
3400afd8:	af00      	add	r7, sp, #0
3400afda:	6078      	str	r0, [r7, #4]
	tcb->state = TS_READY;
3400afdc:	687b      	ldr	r3, [r7, #4]
3400afde:	2201      	movs	r2, #1
3400afe0:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
	if ( knl_ready_queue_insert(&knl_ready_queue, tcb) ) {
3400afe4:	6879      	ldr	r1, [r7, #4]
3400afe6:	4806      	ldr	r0, [pc, #24]	@ (3400b000 <knl_make_ready+0x2c>)
3400afe8:	f7ff febf 	bl	3400ad6a <knl_ready_queue_insert>
3400afec:	4603      	mov	r3, r0
3400afee:	2b00      	cmp	r3, #0
3400aff0:	d002      	beq.n	3400aff8 <knl_make_ready+0x24>
		knl_schedtsk = tcb;
3400aff2:	4a04      	ldr	r2, [pc, #16]	@ (3400b004 <knl_make_ready+0x30>)
3400aff4:	687b      	ldr	r3, [r7, #4]
3400aff6:	6013      	str	r3, [r2, #0]
	}
}
3400aff8:	bf00      	nop
3400affa:	3708      	adds	r7, #8
3400affc:	46bd      	mov	sp, r7
3400affe:	bd80      	pop	{r7, pc}
3400b000:	340109d0 	.word	0x340109d0
3400b004:	340109cc 	.word	0x340109cc

3400b008 <knl_make_non_ready>:
 *	If the deleted task is 'knl_schedtsk', set 'knl_schedtsk' to the
 *	highest priority task in the ready queue. 
 *	'tcb' task must be READY.
 */
EXPORT void knl_make_non_ready( TCB *tcb )
{
3400b008:	b580      	push	{r7, lr}
3400b00a:	b082      	sub	sp, #8
3400b00c:	af00      	add	r7, sp, #0
3400b00e:	6078      	str	r0, [r7, #4]
	knl_ready_queue_delete(&knl_ready_queue, tcb);
3400b010:	6879      	ldr	r1, [r7, #4]
3400b012:	4809      	ldr	r0, [pc, #36]	@ (3400b038 <knl_make_non_ready+0x30>)
3400b014:	f7ff fee1 	bl	3400adda <knl_ready_queue_delete>
	if ( knl_schedtsk == tcb ) {
3400b018:	4b08      	ldr	r3, [pc, #32]	@ (3400b03c <knl_make_non_ready+0x34>)
3400b01a:	681b      	ldr	r3, [r3, #0]
3400b01c:	687a      	ldr	r2, [r7, #4]
3400b01e:	429a      	cmp	r2, r3
3400b020:	d105      	bne.n	3400b02e <knl_make_non_ready+0x26>
		knl_schedtsk = knl_ready_queue_top(&knl_ready_queue);
3400b022:	4805      	ldr	r0, [pc, #20]	@ (3400b038 <knl_make_non_ready+0x30>)
3400b024:	f7ff fe88 	bl	3400ad38 <knl_ready_queue_top>
3400b028:	4603      	mov	r3, r0
3400b02a:	4a04      	ldr	r2, [pc, #16]	@ (3400b03c <knl_make_non_ready+0x34>)
3400b02c:	6013      	str	r3, [r2, #0]
	}
}
3400b02e:	bf00      	nop
3400b030:	3708      	adds	r7, #8
3400b032:	46bd      	mov	sp, r7
3400b034:	bd80      	pop	{r7, pc}
3400b036:	bf00      	nop
3400b038:	340109d0 	.word	0x340109d0
3400b03c:	340109cc 	.word	0x340109cc

3400b040 <QueRemoveNext>:
{
3400b040:	b480      	push	{r7}
3400b042:	b085      	sub	sp, #20
3400b044:	af00      	add	r7, sp, #0
3400b046:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400b048:	687b      	ldr	r3, [r7, #4]
3400b04a:	681b      	ldr	r3, [r3, #0]
3400b04c:	687a      	ldr	r2, [r7, #4]
3400b04e:	429a      	cmp	r2, r3
3400b050:	d101      	bne.n	3400b056 <QueRemoveNext+0x16>
		return NULL;
3400b052:	2300      	movs	r3, #0
3400b054:	e00b      	b.n	3400b06e <QueRemoveNext+0x2e>
	entry = que->next;
3400b056:	687b      	ldr	r3, [r7, #4]
3400b058:	681b      	ldr	r3, [r3, #0]
3400b05a:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400b05c:	68fb      	ldr	r3, [r7, #12]
3400b05e:	681a      	ldr	r2, [r3, #0]
3400b060:	687b      	ldr	r3, [r7, #4]
3400b062:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400b064:	68fb      	ldr	r3, [r7, #12]
3400b066:	681b      	ldr	r3, [r3, #0]
3400b068:	687a      	ldr	r2, [r7, #4]
3400b06a:	605a      	str	r2, [r3, #4]
	return entry;
3400b06c:	68fb      	ldr	r3, [r7, #12]
}
3400b06e:	4618      	mov	r0, r3
3400b070:	3714      	adds	r7, #20
3400b072:	46bd      	mov	sp, r7
3400b074:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b078:	4770      	bx	lr
	...

3400b07c <knl_isTaskIndependent>:
{
3400b07c:	b480      	push	{r7}
3400b07e:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400b080:	4b05      	ldr	r3, [pc, #20]	@ (3400b098 <knl_isTaskIndependent+0x1c>)
3400b082:	681b      	ldr	r3, [r3, #0]
3400b084:	2b00      	cmp	r3, #0
3400b086:	bfcc      	ite	gt
3400b088:	2301      	movgt	r3, #1
3400b08a:	2300      	movle	r3, #0
3400b08c:	b2db      	uxtb	r3, r3
}
3400b08e:	4618      	mov	r0, r3
3400b090:	46bd      	mov	sp, r7
3400b092:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b096:	4770      	bx	lr
3400b098:	3400f6b0 	.word	0x3400f6b0

3400b09c <knl_setup_stacd>:
/*
 * Set task startup code
 *	Called by 'tk_sta_tsk()' processing.
 */
Inline void knl_setup_stacd( TCB *tcb, INT stacd )
{
3400b09c:	b480      	push	{r7}
3400b09e:	b085      	sub	sp, #20
3400b0a0:	af00      	add	r7, sp, #0
3400b0a2:	6078      	str	r0, [r7, #4]
3400b0a4:	6039      	str	r1, [r7, #0]
	SStackFrame	*ssp;
	
	ssp = tcb->tskctxb.ssp;
3400b0a6:	687b      	ldr	r3, [r7, #4]
3400b0a8:	699b      	ldr	r3, [r3, #24]
3400b0aa:	60fb      	str	r3, [r7, #12]

	ssp->r[0] = stacd;
3400b0ac:	683a      	ldr	r2, [r7, #0]
3400b0ae:	68fb      	ldr	r3, [r7, #12]
3400b0b0:	625a      	str	r2, [r3, #36]	@ 0x24
	ssp->r[1] = (VW)tcb->exinf;
3400b0b2:	687b      	ldr	r3, [r7, #4]
3400b0b4:	68db      	ldr	r3, [r3, #12]
3400b0b6:	461a      	mov	r2, r3
3400b0b8:	68fb      	ldr	r3, [r7, #12]
3400b0ba:	629a      	str	r2, [r3, #40]	@ 0x28
}
3400b0bc:	bf00      	nop
3400b0be:	3714      	adds	r7, #20
3400b0c0:	46bd      	mov	sp, r7
3400b0c2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b0c6:	4770      	bx	lr

3400b0c8 <tk_cre_tsk>:

/*
 * Create task
 */
SYSCALL ID tk_cre_tsk( CONST T_CTSK *pk_ctsk )
{
3400b0c8:	b580      	push	{r7, lr}
3400b0ca:	b088      	sub	sp, #32
3400b0cc:	af00      	add	r7, sp, #0
3400b0ce:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_TSKATR = {	/* Valid value of task attribute */
3400b0d0:	f241 3321 	movw	r3, #4897	@ 0x1321
3400b0d4:	613b      	str	r3, [r7, #16]
	TCB	*tcb;
	W	sstksz;
	void	*stack;
	ER	ercd;

	CHECK_RSATR(pk_ctsk->tskatr, VALID_TSKATR);
3400b0d6:	687b      	ldr	r3, [r7, #4]
3400b0d8:	685a      	ldr	r2, [r3, #4]
3400b0da:	693b      	ldr	r3, [r7, #16]
3400b0dc:	43db      	mvns	r3, r3
3400b0de:	4013      	ands	r3, r2
3400b0e0:	2b00      	cmp	r3, #0
3400b0e2:	d002      	beq.n	3400b0ea <tk_cre_tsk+0x22>
3400b0e4:	f06f 030a 	mvn.w	r3, #10
3400b0e8:	e090      	b.n	3400b20c <tk_cre_tsk+0x144>
#if !USE_IMALLOC
	/* TA_USERBUF must be specified if configured in no Imalloc */
	CHECK_PAR((pk_ctsk->tskatr & TA_USERBUF) != 0);
#endif
	CHECK_PAR(pk_ctsk->stksz >= 0);
3400b0ea:	687b      	ldr	r3, [r7, #4]
3400b0ec:	691b      	ldr	r3, [r3, #16]
3400b0ee:	2b00      	cmp	r3, #0
3400b0f0:	da02      	bge.n	3400b0f8 <tk_cre_tsk+0x30>
3400b0f2:	f06f 0310 	mvn.w	r3, #16
3400b0f6:	e089      	b.n	3400b20c <tk_cre_tsk+0x144>
	CHECK_PRI(pk_ctsk->itskpri);
3400b0f8:	687b      	ldr	r3, [r7, #4]
3400b0fa:	68db      	ldr	r3, [r3, #12]
3400b0fc:	2b00      	cmp	r3, #0
3400b0fe:	dd03      	ble.n	3400b108 <tk_cre_tsk+0x40>
3400b100:	687b      	ldr	r3, [r7, #4]
3400b102:	68db      	ldr	r3, [r3, #12]
3400b104:	2b20      	cmp	r3, #32
3400b106:	dd02      	ble.n	3400b10e <tk_cre_tsk+0x46>
3400b108:	f06f 0310 	mvn.w	r3, #16
3400b10c:	e07e      	b.n	3400b20c <tk_cre_tsk+0x144>

	if ( (pk_ctsk->tskatr & TA_USERBUF) != 0 ) {
3400b10e:	687b      	ldr	r3, [r7, #4]
3400b110:	685b      	ldr	r3, [r3, #4]
3400b112:	f003 0320 	and.w	r3, r3, #32
3400b116:	2b00      	cmp	r3, #0
3400b118:	d00c      	beq.n	3400b134 <tk_cre_tsk+0x6c>
		/* Use user buffer */
		sstksz = pk_ctsk->stksz;
3400b11a:	687b      	ldr	r3, [r7, #4]
3400b11c:	691b      	ldr	r3, [r3, #16]
3400b11e:	61fb      	str	r3, [r7, #28]
		CHECK_PAR(sstksz >= MIN_SYS_STACK_SIZE);
3400b120:	69fb      	ldr	r3, [r7, #28]
3400b122:	2b7f      	cmp	r3, #127	@ 0x7f
3400b124:	dc02      	bgt.n	3400b12c <tk_cre_tsk+0x64>
3400b126:	f06f 0310 	mvn.w	r3, #16
3400b12a:	e06f      	b.n	3400b20c <tk_cre_tsk+0x144>
		stack = pk_ctsk->bufptr;
3400b12c:	687b      	ldr	r3, [r7, #4]
3400b12e:	695b      	ldr	r3, [r3, #20]
3400b130:	61bb      	str	r3, [r7, #24]
3400b132:	e015      	b.n	3400b160 <tk_cre_tsk+0x98>
	} else {
#if USE_IMALLOC
		/* Allocate system stack area */
		sstksz = pk_ctsk->stksz + DEFAULT_SYS_STKSZ;
3400b134:	687b      	ldr	r3, [r7, #4]
3400b136:	691b      	ldr	r3, [r3, #16]
3400b138:	3380      	adds	r3, #128	@ 0x80
3400b13a:	61fb      	str	r3, [r7, #28]
		sstksz  = (sstksz  + 7) / 8 * 8;	/* Align to a multiple of 8 */
3400b13c:	69fb      	ldr	r3, [r7, #28]
3400b13e:	3307      	adds	r3, #7
3400b140:	2b00      	cmp	r3, #0
3400b142:	da00      	bge.n	3400b146 <tk_cre_tsk+0x7e>
3400b144:	3307      	adds	r3, #7
3400b146:	10db      	asrs	r3, r3, #3
3400b148:	00db      	lsls	r3, r3, #3
3400b14a:	61fb      	str	r3, [r7, #28]
		stack = knl_Imalloc((UW)sstksz);
3400b14c:	69f8      	ldr	r0, [r7, #28]
3400b14e:	f7ff f82b 	bl	3400a1a8 <knl_Imalloc>
3400b152:	61b8      	str	r0, [r7, #24]
		if ( stack == NULL ) {
3400b154:	69bb      	ldr	r3, [r7, #24]
3400b156:	2b00      	cmp	r3, #0
3400b158:	d102      	bne.n	3400b160 <tk_cre_tsk+0x98>
			return E_NOMEM;
3400b15a:	f06f 0320 	mvn.w	r3, #32
3400b15e:	e055      	b.n	3400b20c <tk_cre_tsk+0x144>
		}
#endif
	}

	BEGIN_CRITICAL_SECTION;
3400b160:	f002 fc11 	bl	3400d986 <disint>
3400b164:	60f8      	str	r0, [r7, #12]
	/* Get control block from FreeQue */
	tcb = (TCB*)QueRemoveNext(&knl_free_tcb);
3400b166:	482b      	ldr	r0, [pc, #172]	@ (3400b214 <tk_cre_tsk+0x14c>)
3400b168:	f7ff ff6a 	bl	3400b040 <QueRemoveNext>
3400b16c:	60b8      	str	r0, [r7, #8]
	if ( tcb == NULL ) {
3400b16e:	68bb      	ldr	r3, [r7, #8]
3400b170:	2b00      	cmp	r3, #0
3400b172:	d103      	bne.n	3400b17c <tk_cre_tsk+0xb4>
		ercd = E_LIMIT;
3400b174:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400b178:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400b17a:	e028      	b.n	3400b1ce <tk_cre_tsk+0x106>
	}

	/* Initialize control block */
	tcb->exinf     = pk_ctsk->exinf;
3400b17c:	687b      	ldr	r3, [r7, #4]
3400b17e:	681a      	ldr	r2, [r3, #0]
3400b180:	68bb      	ldr	r3, [r7, #8]
3400b182:	60da      	str	r2, [r3, #12]
	tcb->tskatr    = pk_ctsk->tskatr;
3400b184:	687b      	ldr	r3, [r7, #4]
3400b186:	685a      	ldr	r2, [r3, #4]
3400b188:	68bb      	ldr	r3, [r7, #8]
3400b18a:	611a      	str	r2, [r3, #16]
	tcb->task      = pk_ctsk->task;
3400b18c:	687b      	ldr	r3, [r7, #4]
3400b18e:	689a      	ldr	r2, [r3, #8]
3400b190:	68bb      	ldr	r3, [r7, #8]
3400b192:	615a      	str	r2, [r3, #20]
	tcb->ipriority = (UB)int_priority(pk_ctsk->itskpri);
3400b194:	687b      	ldr	r3, [r7, #4]
3400b196:	68db      	ldr	r3, [r3, #12]
3400b198:	b2db      	uxtb	r3, r3
3400b19a:	3b01      	subs	r3, #1
3400b19c:	b2da      	uxtb	r2, r3
3400b19e:	68bb      	ldr	r3, [r7, #8]
3400b1a0:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
	tcb->sstksz    = sstksz;
3400b1a4:	68bb      	ldr	r3, [r7, #8]
3400b1a6:	69fa      	ldr	r2, [r7, #28]
3400b1a8:	61da      	str	r2, [r3, #28]
		knl_strncpy((char*)tcb->name, (char*)pk_ctsk->dsname, OBJECT_NAME_LENGTH);
	}
#endif

	/* Set stack pointer */
	tcb->isstack = (VB*)stack + sstksz;
3400b1aa:	69fb      	ldr	r3, [r7, #28]
3400b1ac:	69ba      	ldr	r2, [r7, #24]
3400b1ae:	441a      	add	r2, r3
3400b1b0:	68bb      	ldr	r3, [r7, #8]
3400b1b2:	661a      	str	r2, [r3, #96]	@ 0x60

	/* Set initial value of task operation mode */
	tcb->isysmode = 1;
3400b1b4:	68bb      	ldr	r3, [r7, #8]
3400b1b6:	2201      	movs	r2, #1
3400b1b8:	f883 2020 	strb.w	r2, [r3, #32]
	tcb->sysmode  = 1;
3400b1bc:	68bb      	ldr	r3, [r7, #8]
3400b1be:	2201      	movs	r2, #1
3400b1c0:	845a      	strh	r2, [r3, #34]	@ 0x22

	/* make it to DORMANT state */
	knl_make_dormant(tcb);
3400b1c2:	68b8      	ldr	r0, [r7, #8]
3400b1c4:	f7ff feca 	bl	3400af5c <knl_make_dormant>

	ercd = tcb->tskid;
3400b1c8:	68bb      	ldr	r3, [r7, #8]
3400b1ca:	689b      	ldr	r3, [r3, #8]
3400b1cc:	617b      	str	r3, [r7, #20]

    error_exit:
	END_CRITICAL_SECTION;
3400b1ce:	68fb      	ldr	r3, [r7, #12]
3400b1d0:	2b00      	cmp	r3, #0
3400b1d2:	d10b      	bne.n	3400b1ec <tk_cre_tsk+0x124>
3400b1d4:	4b10      	ldr	r3, [pc, #64]	@ (3400b218 <tk_cre_tsk+0x150>)
3400b1d6:	681a      	ldr	r2, [r3, #0]
3400b1d8:	4b10      	ldr	r3, [pc, #64]	@ (3400b21c <tk_cre_tsk+0x154>)
3400b1da:	681b      	ldr	r3, [r3, #0]
3400b1dc:	429a      	cmp	r2, r3
3400b1de:	d005      	beq.n	3400b1ec <tk_cre_tsk+0x124>
3400b1e0:	4b0f      	ldr	r3, [pc, #60]	@ (3400b220 <tk_cre_tsk+0x158>)
3400b1e2:	681b      	ldr	r3, [r3, #0]
3400b1e4:	2b00      	cmp	r3, #0
3400b1e6:	d101      	bne.n	3400b1ec <tk_cre_tsk+0x124>
3400b1e8:	f001 fc8e 	bl	3400cb08 <knl_dispatch>
3400b1ec:	68f8      	ldr	r0, [r7, #12]
3400b1ee:	f002 fbae 	bl	3400d94e <set_basepri>

#if USE_IMALLOC
	if ( (ercd < E_OK) && ((pk_ctsk->tskatr & TA_USERBUF) == 0) ) {
3400b1f2:	697b      	ldr	r3, [r7, #20]
3400b1f4:	2b00      	cmp	r3, #0
3400b1f6:	da08      	bge.n	3400b20a <tk_cre_tsk+0x142>
3400b1f8:	687b      	ldr	r3, [r7, #4]
3400b1fa:	685b      	ldr	r3, [r3, #4]
3400b1fc:	f003 0320 	and.w	r3, r3, #32
3400b200:	2b00      	cmp	r3, #0
3400b202:	d102      	bne.n	3400b20a <tk_cre_tsk+0x142>
		knl_Ifree(stack);
3400b204:	69b8      	ldr	r0, [r7, #24]
3400b206:	f7ff f825 	bl	3400a254 <knl_Ifree>
	}
#endif

	return ercd;
3400b20a:	697b      	ldr	r3, [r7, #20]
}
3400b20c:	4618      	mov	r0, r3
3400b20e:	3720      	adds	r7, #32
3400b210:	46bd      	mov	sp, r7
3400b212:	bd80      	pop	{r7, pc}
3400b214:	340117e0 	.word	0x340117e0
3400b218:	340109c8 	.word	0x340109c8
3400b21c:	340109cc 	.word	0x340109cc
3400b220:	340109c4 	.word	0x340109c4

3400b224 <tk_sta_tsk>:

/*
 * Start task
 */
SYSCALL ER tk_sta_tsk( ID tskid, INT stacd )
{
3400b224:	b580      	push	{r7, lr}
3400b226:	b086      	sub	sp, #24
3400b228:	af00      	add	r7, sp, #0
3400b22a:	6078      	str	r0, [r7, #4]
3400b22c:	6039      	str	r1, [r7, #0]
	TCB	*tcb;
	TSTAT	state;
	ER	ercd = E_OK;
3400b22e:	2300      	movs	r3, #0
3400b230:	617b      	str	r3, [r7, #20]

	CHECK_TSKID(tskid);
3400b232:	f7ff ff23 	bl	3400b07c <knl_isTaskIndependent>
3400b236:	4603      	mov	r3, r0
3400b238:	2b00      	cmp	r3, #0
3400b23a:	d109      	bne.n	3400b250 <tk_sta_tsk+0x2c>
3400b23c:	4b2f      	ldr	r3, [pc, #188]	@ (3400b2fc <tk_sta_tsk+0xd8>)
3400b23e:	681b      	ldr	r3, [r3, #0]
3400b240:	2b00      	cmp	r3, #0
3400b242:	d005      	beq.n	3400b250 <tk_sta_tsk+0x2c>
3400b244:	687b      	ldr	r3, [r7, #4]
3400b246:	2b00      	cmp	r3, #0
3400b248:	d102      	bne.n	3400b250 <tk_sta_tsk+0x2c>
3400b24a:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400b24e:	e050      	b.n	3400b2f2 <tk_sta_tsk+0xce>
3400b250:	687b      	ldr	r3, [r7, #4]
3400b252:	2b00      	cmp	r3, #0
3400b254:	dd02      	ble.n	3400b25c <tk_sta_tsk+0x38>
3400b256:	687b      	ldr	r3, [r7, #4]
3400b258:	2b20      	cmp	r3, #32
3400b25a:	dd02      	ble.n	3400b262 <tk_sta_tsk+0x3e>
3400b25c:	f06f 0311 	mvn.w	r3, #17
3400b260:	e047      	b.n	3400b2f2 <tk_sta_tsk+0xce>
	CHECK_NONSELF(tskid);
3400b262:	f7ff ff0b 	bl	3400b07c <knl_isTaskIndependent>
3400b266:	4603      	mov	r3, r0
3400b268:	2b00      	cmp	r3, #0
3400b26a:	d10c      	bne.n	3400b286 <tk_sta_tsk+0x62>
3400b26c:	4b23      	ldr	r3, [pc, #140]	@ (3400b2fc <tk_sta_tsk+0xd8>)
3400b26e:	681b      	ldr	r3, [r3, #0]
3400b270:	2b00      	cmp	r3, #0
3400b272:	d008      	beq.n	3400b286 <tk_sta_tsk+0x62>
3400b274:	4b21      	ldr	r3, [pc, #132]	@ (3400b2fc <tk_sta_tsk+0xd8>)
3400b276:	681b      	ldr	r3, [r3, #0]
3400b278:	689b      	ldr	r3, [r3, #8]
3400b27a:	687a      	ldr	r2, [r7, #4]
3400b27c:	429a      	cmp	r2, r3
3400b27e:	d102      	bne.n	3400b286 <tk_sta_tsk+0x62>
3400b280:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400b284:	e035      	b.n	3400b2f2 <tk_sta_tsk+0xce>

	tcb = get_tcb(tskid);
3400b286:	687b      	ldr	r3, [r7, #4]
3400b288:	3b01      	subs	r3, #1
3400b28a:	2268      	movs	r2, #104	@ 0x68
3400b28c:	fb02 f303 	mul.w	r3, r2, r3
3400b290:	4a1b      	ldr	r2, [pc, #108]	@ (3400b300 <tk_sta_tsk+0xdc>)
3400b292:	4413      	add	r3, r2
3400b294:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400b296:	f002 fb76 	bl	3400d986 <disint>
3400b29a:	60f8      	str	r0, [r7, #12]
	state = (TSTAT)tcb->state;
3400b29c:	693b      	ldr	r3, [r7, #16]
3400b29e:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400b2a2:	72fb      	strb	r3, [r7, #11]
	if ( state != TS_DORMANT ) {
3400b2a4:	7afb      	ldrb	r3, [r7, #11]
3400b2a6:	2b08      	cmp	r3, #8
3400b2a8:	d009      	beq.n	3400b2be <tk_sta_tsk+0x9a>
		ercd = ( state == TS_NONEXIST )? E_NOEXS: E_OBJ;
3400b2aa:	7afb      	ldrb	r3, [r7, #11]
3400b2ac:	2b00      	cmp	r3, #0
3400b2ae:	d102      	bne.n	3400b2b6 <tk_sta_tsk+0x92>
3400b2b0:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400b2b4:	e001      	b.n	3400b2ba <tk_sta_tsk+0x96>
3400b2b6:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400b2ba:	617b      	str	r3, [r7, #20]
3400b2bc:	e006      	b.n	3400b2cc <tk_sta_tsk+0xa8>
	} else {
		knl_setup_stacd(tcb, stacd);
3400b2be:	6839      	ldr	r1, [r7, #0]
3400b2c0:	6938      	ldr	r0, [r7, #16]
3400b2c2:	f7ff feeb 	bl	3400b09c <knl_setup_stacd>
		knl_make_ready(tcb);
3400b2c6:	6938      	ldr	r0, [r7, #16]
3400b2c8:	f7ff fe84 	bl	3400afd4 <knl_make_ready>
	}
	END_CRITICAL_SECTION;
3400b2cc:	68fb      	ldr	r3, [r7, #12]
3400b2ce:	2b00      	cmp	r3, #0
3400b2d0:	d10b      	bne.n	3400b2ea <tk_sta_tsk+0xc6>
3400b2d2:	4b0a      	ldr	r3, [pc, #40]	@ (3400b2fc <tk_sta_tsk+0xd8>)
3400b2d4:	681a      	ldr	r2, [r3, #0]
3400b2d6:	4b0b      	ldr	r3, [pc, #44]	@ (3400b304 <tk_sta_tsk+0xe0>)
3400b2d8:	681b      	ldr	r3, [r3, #0]
3400b2da:	429a      	cmp	r2, r3
3400b2dc:	d005      	beq.n	3400b2ea <tk_sta_tsk+0xc6>
3400b2de:	4b0a      	ldr	r3, [pc, #40]	@ (3400b308 <tk_sta_tsk+0xe4>)
3400b2e0:	681b      	ldr	r3, [r3, #0]
3400b2e2:	2b00      	cmp	r3, #0
3400b2e4:	d101      	bne.n	3400b2ea <tk_sta_tsk+0xc6>
3400b2e6:	f001 fc0f 	bl	3400cb08 <knl_dispatch>
3400b2ea:	68f8      	ldr	r0, [r7, #12]
3400b2ec:	f002 fb2f 	bl	3400d94e <set_basepri>

	return ercd;
3400b2f0:	697b      	ldr	r3, [r7, #20]
}
3400b2f2:	4618      	mov	r0, r3
3400b2f4:	3718      	adds	r7, #24
3400b2f6:	46bd      	mov	sp, r7
3400b2f8:	bd80      	pop	{r7, pc}
3400b2fa:	bf00      	nop
3400b2fc:	340109c8 	.word	0x340109c8
3400b300:	34010ae0 	.word	0x34010ae0
3400b304:	340109cc 	.word	0x340109cc
3400b308:	340109c4 	.word	0x340109c4

3400b30c <tk_get_tid>:
#ifdef USE_FUNC_TK_GET_TID
/*
 * Refer task ID at execution
 */
SYSCALL ID tk_get_tid( void )
{
3400b30c:	b480      	push	{r7}
3400b30e:	af00      	add	r7, sp, #0
	return ( knl_ctxtsk == NULL )? 0: knl_ctxtsk->tskid;
3400b310:	4b06      	ldr	r3, [pc, #24]	@ (3400b32c <tk_get_tid+0x20>)
3400b312:	681b      	ldr	r3, [r3, #0]
3400b314:	2b00      	cmp	r3, #0
3400b316:	d003      	beq.n	3400b320 <tk_get_tid+0x14>
3400b318:	4b04      	ldr	r3, [pc, #16]	@ (3400b32c <tk_get_tid+0x20>)
3400b31a:	681b      	ldr	r3, [r3, #0]
3400b31c:	689b      	ldr	r3, [r3, #8]
3400b31e:	e000      	b.n	3400b322 <tk_get_tid+0x16>
3400b320:	2300      	movs	r3, #0
}
3400b322:	4618      	mov	r0, r3
3400b324:	46bd      	mov	sp, r7
3400b326:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b32a:	4770      	bx	lr
3400b32c:	340109c8 	.word	0x340109c8

3400b330 <QueInit>:
{
3400b330:	b480      	push	{r7}
3400b332:	b083      	sub	sp, #12
3400b334:	af00      	add	r7, sp, #0
3400b336:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400b338:	687b      	ldr	r3, [r7, #4]
3400b33a:	687a      	ldr	r2, [r7, #4]
3400b33c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400b33e:	687b      	ldr	r3, [r7, #4]
3400b340:	687a      	ldr	r2, [r7, #4]
3400b342:	605a      	str	r2, [r3, #4]
}
3400b344:	bf00      	nop
3400b346:	370c      	adds	r7, #12
3400b348:	46bd      	mov	sp, r7
3400b34a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b34e:	4770      	bx	lr

3400b350 <knl_isTaskIndependent>:
{
3400b350:	b480      	push	{r7}
3400b352:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400b354:	4b05      	ldr	r3, [pc, #20]	@ (3400b36c <knl_isTaskIndependent+0x1c>)
3400b356:	681b      	ldr	r3, [r3, #0]
3400b358:	2b00      	cmp	r3, #0
3400b35a:	bfcc      	ite	gt
3400b35c:	2301      	movgt	r3, #1
3400b35e:	2300      	movle	r3, #0
3400b360:	b2db      	uxtb	r3, r3
}
3400b362:	4618      	mov	r0, r3
3400b364:	46bd      	mov	sp, r7
3400b366:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b36a:	4770      	bx	lr
3400b36c:	3400f6b0 	.word	0x3400f6b0

3400b370 <tk_slp_tsk>:
#ifdef USE_FUNC_TK_SLP_TSK
/*
 * Move its own task state to wait state
 */
SYSCALL ER tk_slp_tsk( TMO tmout )
{
3400b370:	b580      	push	{r7, lr}
3400b372:	b084      	sub	sp, #16
3400b374:	af00      	add	r7, sp, #0
3400b376:	6078      	str	r0, [r7, #4]
	ER	ercd = E_OK;
3400b378:	2300      	movs	r3, #0
3400b37a:	60bb      	str	r3, [r7, #8]

	CHECK_TMOUT(tmout);
3400b37c:	687b      	ldr	r3, [r7, #4]
3400b37e:	f1b3 3fff 	cmp.w	r3, #4294967295
3400b382:	da02      	bge.n	3400b38a <tk_slp_tsk+0x1a>
3400b384:	f06f 0310 	mvn.w	r3, #16
3400b388:	e051      	b.n	3400b42e <tk_slp_tsk+0xbe>
	CHECK_DISPATCH();
3400b38a:	4b2b      	ldr	r3, [pc, #172]	@ (3400b438 <tk_slp_tsk+0xc8>)
3400b38c:	681b      	ldr	r3, [r3, #0]
3400b38e:	2b00      	cmp	r3, #0
3400b390:	d10d      	bne.n	3400b3ae <tk_slp_tsk+0x3e>
3400b392:	f7ff ffdd 	bl	3400b350 <knl_isTaskIndependent>
3400b396:	4603      	mov	r3, r0
3400b398:	2b00      	cmp	r3, #0
3400b39a:	d108      	bne.n	3400b3ae <tk_slp_tsk+0x3e>
3400b39c:	4b27      	ldr	r3, [pc, #156]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b39e:	681b      	ldr	r3, [r3, #0]
3400b3a0:	2b00      	cmp	r3, #0
3400b3a2:	d004      	beq.n	3400b3ae <tk_slp_tsk+0x3e>
3400b3a4:	f002 fae2 	bl	3400d96c <get_basepri>
3400b3a8:	4603      	mov	r3, r0
3400b3aa:	2b00      	cmp	r3, #0
3400b3ac:	d002      	beq.n	3400b3b4 <tk_slp_tsk+0x44>
3400b3ae:	f06f 0318 	mvn.w	r3, #24
3400b3b2:	e03c      	b.n	3400b42e <tk_slp_tsk+0xbe>

	BEGIN_CRITICAL_SECTION;
3400b3b4:	f002 fae7 	bl	3400d986 <disint>
3400b3b8:	60f8      	str	r0, [r7, #12]

	if ( knl_ctxtsk->wupcnt > 0 ) {
3400b3ba:	4b20      	ldr	r3, [pc, #128]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b3bc:	681b      	ldr	r3, [r3, #0]
3400b3be:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400b3c0:	2b00      	cmp	r3, #0
3400b3c2:	dd05      	ble.n	3400b3d0 <tk_slp_tsk+0x60>
		knl_ctxtsk->wupcnt--;
3400b3c4:	4b1d      	ldr	r3, [pc, #116]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b3c6:	681b      	ldr	r3, [r3, #0]
3400b3c8:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3400b3ca:	3a01      	subs	r2, #1
3400b3cc:	635a      	str	r2, [r3, #52]	@ 0x34
3400b3ce:	e01b      	b.n	3400b408 <tk_slp_tsk+0x98>
	} else {
		ercd = E_TMOUT;
3400b3d0:	f06f 0331 	mvn.w	r3, #49	@ 0x31
3400b3d4:	60bb      	str	r3, [r7, #8]
		if ( tmout != TMO_POL ) {
3400b3d6:	687b      	ldr	r3, [r7, #4]
3400b3d8:	2b00      	cmp	r3, #0
3400b3da:	d015      	beq.n	3400b408 <tk_slp_tsk+0x98>
			knl_ctxtsk->wspec = &knl_wspec_slp;
3400b3dc:	4b17      	ldr	r3, [pc, #92]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b3de:	681b      	ldr	r3, [r3, #0]
3400b3e0:	4a17      	ldr	r2, [pc, #92]	@ (3400b440 <tk_slp_tsk+0xd0>)
3400b3e2:	62da      	str	r2, [r3, #44]	@ 0x2c
			knl_ctxtsk->wid = 0;
3400b3e4:	4b15      	ldr	r3, [pc, #84]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b3e6:	681b      	ldr	r3, [r3, #0]
3400b3e8:	2200      	movs	r2, #0
3400b3ea:	631a      	str	r2, [r3, #48]	@ 0x30
			knl_ctxtsk->wercd = &ercd;
3400b3ec:	4b13      	ldr	r3, [pc, #76]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b3ee:	681b      	ldr	r3, [r3, #0]
3400b3f0:	f107 0208 	add.w	r2, r7, #8
3400b3f4:	63da      	str	r2, [r3, #60]	@ 0x3c
			knl_make_wait(tmout, TA_NULL);
3400b3f6:	2100      	movs	r1, #0
3400b3f8:	6878      	ldr	r0, [r7, #4]
3400b3fa:	f000 fbe7 	bl	3400bbcc <knl_make_wait>
			QueInit(&knl_ctxtsk->tskque);
3400b3fe:	4b0f      	ldr	r3, [pc, #60]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b400:	681b      	ldr	r3, [r3, #0]
3400b402:	4618      	mov	r0, r3
3400b404:	f7ff ff94 	bl	3400b330 <QueInit>
		}
	}

	END_CRITICAL_SECTION;
3400b408:	68fb      	ldr	r3, [r7, #12]
3400b40a:	2b00      	cmp	r3, #0
3400b40c:	d10b      	bne.n	3400b426 <tk_slp_tsk+0xb6>
3400b40e:	4b0b      	ldr	r3, [pc, #44]	@ (3400b43c <tk_slp_tsk+0xcc>)
3400b410:	681a      	ldr	r2, [r3, #0]
3400b412:	4b0c      	ldr	r3, [pc, #48]	@ (3400b444 <tk_slp_tsk+0xd4>)
3400b414:	681b      	ldr	r3, [r3, #0]
3400b416:	429a      	cmp	r2, r3
3400b418:	d005      	beq.n	3400b426 <tk_slp_tsk+0xb6>
3400b41a:	4b07      	ldr	r3, [pc, #28]	@ (3400b438 <tk_slp_tsk+0xc8>)
3400b41c:	681b      	ldr	r3, [r3, #0]
3400b41e:	2b00      	cmp	r3, #0
3400b420:	d101      	bne.n	3400b426 <tk_slp_tsk+0xb6>
3400b422:	f001 fb71 	bl	3400cb08 <knl_dispatch>
3400b426:	68f8      	ldr	r0, [r7, #12]
3400b428:	f002 fa91 	bl	3400d94e <set_basepri>

	return ercd;
3400b42c:	68bb      	ldr	r3, [r7, #8]
}
3400b42e:	4618      	mov	r0, r3
3400b430:	3710      	adds	r7, #16
3400b432:	46bd      	mov	sp, r7
3400b434:	bd80      	pop	{r7, pc}
3400b436:	bf00      	nop
3400b438:	340109c4 	.word	0x340109c4
3400b43c:	340109c8 	.word	0x340109c8
3400b440:	3400e054 	.word	0x3400e054
3400b444:	340109cc 	.word	0x340109cc

3400b448 <tk_dly_tsk>:

/*
 * Task delay
 */
SYSCALL ER tk_dly_tsk( RELTIM dlytim )
{
3400b448:	b580      	push	{r7, lr}
3400b44a:	b084      	sub	sp, #16
3400b44c:	af00      	add	r7, sp, #0
3400b44e:	6078      	str	r0, [r7, #4]
	ER	ercd = E_OK;
3400b450:	2300      	movs	r3, #0
3400b452:	60bb      	str	r3, [r7, #8]

	CHECK_RELTIM(dlytim);
3400b454:	687b      	ldr	r3, [r7, #4]
3400b456:	2b00      	cmp	r3, #0
3400b458:	da02      	bge.n	3400b460 <tk_dly_tsk+0x18>
3400b45a:	f06f 0310 	mvn.w	r3, #16
3400b45e:	e043      	b.n	3400b4e8 <tk_dly_tsk+0xa0>

	CHECK_DISPATCH();
3400b460:	4b23      	ldr	r3, [pc, #140]	@ (3400b4f0 <tk_dly_tsk+0xa8>)
3400b462:	681b      	ldr	r3, [r3, #0]
3400b464:	2b00      	cmp	r3, #0
3400b466:	d10d      	bne.n	3400b484 <tk_dly_tsk+0x3c>
3400b468:	f7ff ff72 	bl	3400b350 <knl_isTaskIndependent>
3400b46c:	4603      	mov	r3, r0
3400b46e:	2b00      	cmp	r3, #0
3400b470:	d108      	bne.n	3400b484 <tk_dly_tsk+0x3c>
3400b472:	4b20      	ldr	r3, [pc, #128]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b474:	681b      	ldr	r3, [r3, #0]
3400b476:	2b00      	cmp	r3, #0
3400b478:	d004      	beq.n	3400b484 <tk_dly_tsk+0x3c>
3400b47a:	f002 fa77 	bl	3400d96c <get_basepri>
3400b47e:	4603      	mov	r3, r0
3400b480:	2b00      	cmp	r3, #0
3400b482:	d002      	beq.n	3400b48a <tk_dly_tsk+0x42>
3400b484:	f06f 0318 	mvn.w	r3, #24
3400b488:	e02e      	b.n	3400b4e8 <tk_dly_tsk+0xa0>

	if ( dlytim > 0 ) {
3400b48a:	687b      	ldr	r3, [r7, #4]
3400b48c:	2b00      	cmp	r3, #0
3400b48e:	d02a      	beq.n	3400b4e6 <tk_dly_tsk+0x9e>
		BEGIN_CRITICAL_SECTION;
3400b490:	f002 fa79 	bl	3400d986 <disint>
3400b494:	60f8      	str	r0, [r7, #12]
		knl_ctxtsk->wspec = &knl_wspec_dly;
3400b496:	4b17      	ldr	r3, [pc, #92]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b498:	681b      	ldr	r3, [r3, #0]
3400b49a:	4a17      	ldr	r2, [pc, #92]	@ (3400b4f8 <tk_dly_tsk+0xb0>)
3400b49c:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wid = 0;
3400b49e:	4b15      	ldr	r3, [pc, #84]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b4a0:	681b      	ldr	r3, [r3, #0]
3400b4a2:	2200      	movs	r2, #0
3400b4a4:	631a      	str	r2, [r3, #48]	@ 0x30
		knl_ctxtsk->wercd = &ercd;
3400b4a6:	4b13      	ldr	r3, [pc, #76]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b4a8:	681b      	ldr	r3, [r3, #0]
3400b4aa:	f107 0208 	add.w	r2, r7, #8
3400b4ae:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_make_wait_reltim(dlytim, TA_NULL);
3400b4b0:	2100      	movs	r1, #0
3400b4b2:	6878      	ldr	r0, [r7, #4]
3400b4b4:	f000 fbbc 	bl	3400bc30 <knl_make_wait_reltim>
		QueInit(&knl_ctxtsk->tskque);
3400b4b8:	4b0e      	ldr	r3, [pc, #56]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b4ba:	681b      	ldr	r3, [r3, #0]
3400b4bc:	4618      	mov	r0, r3
3400b4be:	f7ff ff37 	bl	3400b330 <QueInit>
		END_CRITICAL_SECTION;
3400b4c2:	68fb      	ldr	r3, [r7, #12]
3400b4c4:	2b00      	cmp	r3, #0
3400b4c6:	d10b      	bne.n	3400b4e0 <tk_dly_tsk+0x98>
3400b4c8:	4b0a      	ldr	r3, [pc, #40]	@ (3400b4f4 <tk_dly_tsk+0xac>)
3400b4ca:	681a      	ldr	r2, [r3, #0]
3400b4cc:	4b0b      	ldr	r3, [pc, #44]	@ (3400b4fc <tk_dly_tsk+0xb4>)
3400b4ce:	681b      	ldr	r3, [r3, #0]
3400b4d0:	429a      	cmp	r2, r3
3400b4d2:	d005      	beq.n	3400b4e0 <tk_dly_tsk+0x98>
3400b4d4:	4b06      	ldr	r3, [pc, #24]	@ (3400b4f0 <tk_dly_tsk+0xa8>)
3400b4d6:	681b      	ldr	r3, [r3, #0]
3400b4d8:	2b00      	cmp	r3, #0
3400b4da:	d101      	bne.n	3400b4e0 <tk_dly_tsk+0x98>
3400b4dc:	f001 fb14 	bl	3400cb08 <knl_dispatch>
3400b4e0:	68f8      	ldr	r0, [r7, #12]
3400b4e2:	f002 fa34 	bl	3400d94e <set_basepri>
	}

	return ercd;
3400b4e6:	68bb      	ldr	r3, [r7, #8]
}
3400b4e8:	4618      	mov	r0, r3
3400b4ea:	3710      	adds	r7, #16
3400b4ec:	46bd      	mov	sp, r7
3400b4ee:	bd80      	pop	{r7, pc}
3400b4f0:	340109c4 	.word	0x340109c4
3400b4f4:	340109c8 	.word	0x340109c8
3400b4f8:	3400e060 	.word	0x3400e060
3400b4fc:	340109cc 	.word	0x340109cc

3400b500 <QueInit>:
{
3400b500:	b480      	push	{r7}
3400b502:	b083      	sub	sp, #12
3400b504:	af00      	add	r7, sp, #0
3400b506:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400b508:	687b      	ldr	r3, [r7, #4]
3400b50a:	687a      	ldr	r2, [r7, #4]
3400b50c:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400b50e:	687b      	ldr	r3, [r7, #4]
3400b510:	687a      	ldr	r2, [r7, #4]
3400b512:	605a      	str	r2, [r3, #4]
}
3400b514:	bf00      	nop
3400b516:	370c      	adds	r7, #12
3400b518:	46bd      	mov	sp, r7
3400b51a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b51e:	4770      	bx	lr

3400b520 <QueInsert>:
{
3400b520:	b480      	push	{r7}
3400b522:	b083      	sub	sp, #12
3400b524:	af00      	add	r7, sp, #0
3400b526:	6078      	str	r0, [r7, #4]
3400b528:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400b52a:	683b      	ldr	r3, [r7, #0]
3400b52c:	685a      	ldr	r2, [r3, #4]
3400b52e:	687b      	ldr	r3, [r7, #4]
3400b530:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400b532:	687b      	ldr	r3, [r7, #4]
3400b534:	683a      	ldr	r2, [r7, #0]
3400b536:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400b538:	683b      	ldr	r3, [r7, #0]
3400b53a:	685b      	ldr	r3, [r3, #4]
3400b53c:	687a      	ldr	r2, [r7, #4]
3400b53e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400b540:	683b      	ldr	r3, [r7, #0]
3400b542:	687a      	ldr	r2, [r7, #4]
3400b544:	605a      	str	r2, [r3, #4]
}
3400b546:	bf00      	nop
3400b548:	370c      	adds	r7, #12
3400b54a:	46bd      	mov	sp, r7
3400b54c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b550:	4770      	bx	lr
	...

3400b554 <knl_cyclichandler_initialize>:

/*
 * Initialization of cyclic handler control block
 */
EXPORT ER knl_cyclichandler_initialize( void )
{
3400b554:	b580      	push	{r7, lr}
3400b556:	b082      	sub	sp, #8
3400b558:	af00      	add	r7, sp, #0
	if ( NUM_CYCID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_cyccb);
3400b55a:	480d      	ldr	r0, [pc, #52]	@ (3400b590 <knl_cyclichandler_initialize+0x3c>)
3400b55c:	f7ff ffd0 	bl	3400b500 <QueInit>
	end = knl_cyccb_table + NUM_CYCID;
3400b560:	4b0c      	ldr	r3, [pc, #48]	@ (3400b594 <knl_cyclichandler_initialize+0x40>)
3400b562:	603b      	str	r3, [r7, #0]
	for ( cyccb = knl_cyccb_table; cyccb < end; cyccb++ ) {
3400b564:	4b0c      	ldr	r3, [pc, #48]	@ (3400b598 <knl_cyclichandler_initialize+0x44>)
3400b566:	607b      	str	r3, [r7, #4]
3400b568:	e009      	b.n	3400b57e <knl_cyclichandler_initialize+0x2a>
		cyccb->cychdr = NULL; /* Unregistered handler */
3400b56a:	687b      	ldr	r3, [r7, #4]
3400b56c:	2200      	movs	r2, #0
3400b56e:	609a      	str	r2, [r3, #8]
		QueInsert((QUEUE*)cyccb, &knl_free_cyccb);
3400b570:	4907      	ldr	r1, [pc, #28]	@ (3400b590 <knl_cyclichandler_initialize+0x3c>)
3400b572:	6878      	ldr	r0, [r7, #4]
3400b574:	f7ff ffd4 	bl	3400b520 <QueInsert>
	for ( cyccb = knl_cyccb_table; cyccb < end; cyccb++ ) {
3400b578:	687b      	ldr	r3, [r7, #4]
3400b57a:	3328      	adds	r3, #40	@ 0x28
3400b57c:	607b      	str	r3, [r7, #4]
3400b57e:	687a      	ldr	r2, [r7, #4]
3400b580:	683b      	ldr	r3, [r7, #0]
3400b582:	429a      	cmp	r2, r3
3400b584:	d3f1      	bcc.n	3400b56a <knl_cyclichandler_initialize+0x16>
	}

	return E_OK;
3400b586:	2300      	movs	r3, #0
}
3400b588:	4618      	mov	r0, r3
3400b58a:	3708      	adds	r7, #8
3400b58c:	46bd      	mov	sp, r7
3400b58e:	bd80      	pop	{r7, pc}
3400b590:	34011888 	.word	0x34011888
3400b594:	34011888 	.word	0x34011888
3400b598:	340117e8 	.word	0x340117e8

3400b59c <knl_alarmhandler_initialize>:

/*
 * Initialization of alarm handler control block 
 */
EXPORT ER knl_alarmhandler_initialize( void )
{
3400b59c:	b580      	push	{r7, lr}
3400b59e:	b082      	sub	sp, #8
3400b5a0:	af00      	add	r7, sp, #0
	if ( NUM_ALMID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_almcb);
3400b5a2:	480d      	ldr	r0, [pc, #52]	@ (3400b5d8 <knl_alarmhandler_initialize+0x3c>)
3400b5a4:	f7ff ffac 	bl	3400b500 <QueInit>
	end = knl_almcb_table + NUM_ALMID;
3400b5a8:	4b0c      	ldr	r3, [pc, #48]	@ (3400b5dc <knl_alarmhandler_initialize+0x40>)
3400b5aa:	603b      	str	r3, [r7, #0]
	for ( almcb = knl_almcb_table; almcb < end; almcb++ ) {
3400b5ac:	4b0c      	ldr	r3, [pc, #48]	@ (3400b5e0 <knl_alarmhandler_initialize+0x44>)
3400b5ae:	607b      	str	r3, [r7, #4]
3400b5b0:	e009      	b.n	3400b5c6 <knl_alarmhandler_initialize+0x2a>
		almcb->almhdr = NULL; /* Unregistered handler */
3400b5b2:	687b      	ldr	r3, [r7, #4]
3400b5b4:	2200      	movs	r2, #0
3400b5b6:	609a      	str	r2, [r3, #8]
		QueInsert((QUEUE*)almcb, &knl_free_almcb);
3400b5b8:	4907      	ldr	r1, [pc, #28]	@ (3400b5d8 <knl_alarmhandler_initialize+0x3c>)
3400b5ba:	6878      	ldr	r0, [r7, #4]
3400b5bc:	f7ff ffb0 	bl	3400b520 <QueInsert>
	for ( almcb = knl_almcb_table; almcb < end; almcb++ ) {
3400b5c0:	687b      	ldr	r3, [r7, #4]
3400b5c2:	3324      	adds	r3, #36	@ 0x24
3400b5c4:	607b      	str	r3, [r7, #4]
3400b5c6:	687a      	ldr	r2, [r7, #4]
3400b5c8:	683b      	ldr	r3, [r7, #0]
3400b5ca:	429a      	cmp	r2, r3
3400b5cc:	d3f1      	bcc.n	3400b5b2 <knl_alarmhandler_initialize+0x16>
	}

	return E_OK;
3400b5ce:	2300      	movs	r3, #0
}
3400b5d0:	4618      	mov	r0, r3
3400b5d2:	3708      	adds	r7, #8
3400b5d4:	46bd      	mov	sp, r7
3400b5d6:	bd80      	pop	{r7, pc}
3400b5d8:	340119b0 	.word	0x340119b0
3400b5dc:	340119b0 	.word	0x340119b0
3400b5e0:	34011890 	.word	0x34011890

3400b5e4 <out_w>:
{
3400b5e4:	b480      	push	{r7}
3400b5e6:	b083      	sub	sp, #12
3400b5e8:	af00      	add	r7, sp, #0
3400b5ea:	6078      	str	r0, [r7, #4]
3400b5ec:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400b5ee:	687b      	ldr	r3, [r7, #4]
3400b5f0:	683a      	ldr	r2, [r7, #0]
3400b5f2:	601a      	str	r2, [r3, #0]
}
3400b5f4:	bf00      	nop
3400b5f6:	370c      	adds	r7, #12
3400b5f8:	46bd      	mov	sp, r7
3400b5fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b5fe:	4770      	bx	lr

3400b600 <in_w>:
{
3400b600:	b480      	push	{r7}
3400b602:	b083      	sub	sp, #12
3400b604:	af00      	add	r7, sp, #0
3400b606:	6078      	str	r0, [r7, #4]
	return *(_UW*)port;
3400b608:	687b      	ldr	r3, [r7, #4]
3400b60a:	681b      	ldr	r3, [r3, #0]
}
3400b60c:	4618      	mov	r0, r3
3400b60e:	370c      	adds	r7, #12
3400b610:	46bd      	mov	sp, r7
3400b612:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b616:	4770      	bx	lr

3400b618 <QueInit>:
{
3400b618:	b480      	push	{r7}
3400b61a:	b083      	sub	sp, #12
3400b61c:	af00      	add	r7, sp, #0
3400b61e:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400b620:	687b      	ldr	r3, [r7, #4]
3400b622:	687a      	ldr	r2, [r7, #4]
3400b624:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400b626:	687b      	ldr	r3, [r7, #4]
3400b628:	687a      	ldr	r2, [r7, #4]
3400b62a:	605a      	str	r2, [r3, #4]
}
3400b62c:	bf00      	nop
3400b62e:	370c      	adds	r7, #12
3400b630:	46bd      	mov	sp, r7
3400b632:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b636:	4770      	bx	lr

3400b638 <isQueEmpty>:
{
3400b638:	b480      	push	{r7}
3400b63a:	b083      	sub	sp, #12
3400b63c:	af00      	add	r7, sp, #0
3400b63e:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400b640:	687b      	ldr	r3, [r7, #4]
3400b642:	681b      	ldr	r3, [r3, #0]
3400b644:	687a      	ldr	r2, [r7, #4]
3400b646:	429a      	cmp	r2, r3
3400b648:	bf0c      	ite	eq
3400b64a:	2301      	moveq	r3, #1
3400b64c:	2300      	movne	r3, #0
3400b64e:	b2db      	uxtb	r3, r3
}
3400b650:	4618      	mov	r0, r3
3400b652:	370c      	adds	r7, #12
3400b654:	46bd      	mov	sp, r7
3400b656:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b65a:	4770      	bx	lr

3400b65c <QueInsert>:
{
3400b65c:	b480      	push	{r7}
3400b65e:	b083      	sub	sp, #12
3400b660:	af00      	add	r7, sp, #0
3400b662:	6078      	str	r0, [r7, #4]
3400b664:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400b666:	683b      	ldr	r3, [r7, #0]
3400b668:	685a      	ldr	r2, [r3, #4]
3400b66a:	687b      	ldr	r3, [r7, #4]
3400b66c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400b66e:	687b      	ldr	r3, [r7, #4]
3400b670:	683a      	ldr	r2, [r7, #0]
3400b672:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400b674:	683b      	ldr	r3, [r7, #0]
3400b676:	685b      	ldr	r3, [r3, #4]
3400b678:	687a      	ldr	r2, [r7, #4]
3400b67a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400b67c:	683b      	ldr	r3, [r7, #0]
3400b67e:	687a      	ldr	r2, [r7, #4]
3400b680:	605a      	str	r2, [r3, #4]
}
3400b682:	bf00      	nop
3400b684:	370c      	adds	r7, #12
3400b686:	46bd      	mov	sp, r7
3400b688:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b68c:	4770      	bx	lr

3400b68e <QueRemove>:
{
3400b68e:	b480      	push	{r7}
3400b690:	b083      	sub	sp, #12
3400b692:	af00      	add	r7, sp, #0
3400b694:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400b696:	687b      	ldr	r3, [r7, #4]
3400b698:	681b      	ldr	r3, [r3, #0]
3400b69a:	687a      	ldr	r2, [r7, #4]
3400b69c:	429a      	cmp	r2, r3
3400b69e:	d009      	beq.n	3400b6b4 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400b6a0:	687b      	ldr	r3, [r7, #4]
3400b6a2:	685b      	ldr	r3, [r3, #4]
3400b6a4:	687a      	ldr	r2, [r7, #4]
3400b6a6:	6812      	ldr	r2, [r2, #0]
3400b6a8:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400b6aa:	687b      	ldr	r3, [r7, #4]
3400b6ac:	681b      	ldr	r3, [r3, #0]
3400b6ae:	687a      	ldr	r2, [r7, #4]
3400b6b0:	6852      	ldr	r2, [r2, #4]
3400b6b2:	605a      	str	r2, [r3, #4]
}
3400b6b4:	bf00      	nop
3400b6b6:	370c      	adds	r7, #12
3400b6b8:	46bd      	mov	sp, r7
3400b6ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b6be:	4770      	bx	lr

3400b6c0 <knl_abstim_reached>:
typedef	UW	ABSTIM;

#define ABSTIM_DIFF_MIN  (0x7FFFFFFF)

Inline BOOL knl_abstim_reached( ABSTIM curtim, ABSTIM evttim )
{
3400b6c0:	b480      	push	{r7}
3400b6c2:	b083      	sub	sp, #12
3400b6c4:	af00      	add	r7, sp, #0
3400b6c6:	6078      	str	r0, [r7, #4]
3400b6c8:	6039      	str	r1, [r7, #0]
	return (ABSTIM)(curtim - evttim) <= (ABSTIM)ABSTIM_DIFF_MIN;
3400b6ca:	687a      	ldr	r2, [r7, #4]
3400b6cc:	683b      	ldr	r3, [r7, #0]
3400b6ce:	1ad3      	subs	r3, r2, r3
3400b6d0:	43db      	mvns	r3, r3
3400b6d2:	0fdb      	lsrs	r3, r3, #31
3400b6d4:	b2db      	uxtb	r3, r3
}
3400b6d6:	4618      	mov	r0, r3
3400b6d8:	370c      	adds	r7, #12
3400b6da:	46bd      	mov	sp, r7
3400b6dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b6e0:	4770      	bx	lr
	...

3400b6e4 <knl_start_hw_timer>:
/*
 * Timer start processing
 *	Initialize the timer and start the periodical timer interrupt.
 */
Inline void knl_start_hw_timer( void )
{
3400b6e4:	b580      	push	{r7, lr}
3400b6e6:	b082      	sub	sp, #8
3400b6e8:	af00      	add	r7, sp, #0
	UINT	n, imask;

	DI(imask);
3400b6ea:	f002 f94c 	bl	3400d986 <disint>
3400b6ee:	6078      	str	r0, [r7, #4]

	/* Set System timer CLK source to Core, Systick exception enable */
	out_w(SYST_CSR, 0x00000006);
3400b6f0:	2106      	movs	r1, #6
3400b6f2:	4811      	ldr	r0, [pc, #68]	@ (3400b738 <knl_start_hw_timer+0x54>)
3400b6f4:	f7ff ff76 	bl	3400b5e4 <out_w>

	/* Set counter: TMCLK(MHz) */
	n = (UINT)(TIMER_PERIOD * TMCLK_KHz - 1);
3400b6f8:	4b10      	ldr	r3, [pc, #64]	@ (3400b73c <knl_start_hw_timer+0x58>)
3400b6fa:	681b      	ldr	r3, [r3, #0]
3400b6fc:	4a10      	ldr	r2, [pc, #64]	@ (3400b740 <knl_start_hw_timer+0x5c>)
3400b6fe:	fba2 2303 	umull	r2, r3, r2, r3
3400b702:	099a      	lsrs	r2, r3, #6
3400b704:	4613      	mov	r3, r2
3400b706:	009b      	lsls	r3, r3, #2
3400b708:	4413      	add	r3, r2
3400b70a:	005b      	lsls	r3, r3, #1
3400b70c:	3b01      	subs	r3, #1
3400b70e:	603b      	str	r3, [r7, #0]
	out_w(SYST_RVR, n);
3400b710:	6839      	ldr	r1, [r7, #0]
3400b712:	480c      	ldr	r0, [pc, #48]	@ (3400b744 <knl_start_hw_timer+0x60>)
3400b714:	f7ff ff66 	bl	3400b5e4 <out_w>
	out_w(SYST_CVR, 0);
3400b718:	2100      	movs	r1, #0
3400b71a:	480b      	ldr	r0, [pc, #44]	@ (3400b748 <knl_start_hw_timer+0x64>)
3400b71c:	f7ff ff62 	bl	3400b5e4 <out_w>

	/* Start timer count */
	out_w(SYST_CSR, 0x00000007);
3400b720:	2107      	movs	r1, #7
3400b722:	4805      	ldr	r0, [pc, #20]	@ (3400b738 <knl_start_hw_timer+0x54>)
3400b724:	f7ff ff5e 	bl	3400b5e4 <out_w>

	EI(imask);
3400b728:	6878      	ldr	r0, [r7, #4]
3400b72a:	f002 f910 	bl	3400d94e <set_basepri>
}
3400b72e:	bf00      	nop
3400b730:	3708      	adds	r7, #8
3400b732:	46bd      	mov	sp, r7
3400b734:	bd80      	pop	{r7, pc}
3400b736:	bf00      	nop
3400b738:	e000e010 	.word	0xe000e010
3400b73c:	3400f6b4 	.word	0x3400f6b4
3400b740:	10624dd3 	.word	0x10624dd3
3400b744:	e000e014 	.word	0xe000e014
3400b748:	e000e018 	.word	0xe000e018

3400b74c <knl_clear_hw_timer_interrupt>:
 *	'end_of_hw_timer_interrupt()' is called at the end of the timer
 *	interrupt handler.
 *	Use either or both according to hardware.
 */
Inline void knl_clear_hw_timer_interrupt( void )
{
3400b74c:	b580      	push	{r7, lr}
3400b74e:	af00      	add	r7, sp, #0
	(void)in_w(SYST_CSR);			/* Clear COUNTFLAG */
3400b750:	4804      	ldr	r0, [pc, #16]	@ (3400b764 <knl_clear_hw_timer_interrupt+0x18>)
3400b752:	f7ff ff55 	bl	3400b600 <in_w>
	out_w(SCB_ICSR, ICSR_PENDSTCLR);
3400b756:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
3400b75a:	4803      	ldr	r0, [pc, #12]	@ (3400b768 <knl_clear_hw_timer_interrupt+0x1c>)
3400b75c:	f7ff ff42 	bl	3400b5e4 <out_w>
}
3400b760:	bf00      	nop
3400b762:	bd80      	pop	{r7, pc}
3400b764:	e000e010 	.word	0xe000e010
3400b768:	e000ed04 	.word	0xe000ed04

3400b76c <knl_end_of_hw_timer_interrupt>:

Inline void knl_end_of_hw_timer_interrupt( void )
{
3400b76c:	b480      	push	{r7}
3400b76e:	af00      	add	r7, sp, #0
	/* No processing */
}
3400b770:	bf00      	nop
3400b772:	46bd      	mov	sp, r7
3400b774:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b778:	4770      	bx	lr
	...

3400b77c <knl_terminate_hw_timer>:
 * Timer stop processing
 *	Stop the timer operation.
 *	Called when system stops.
 */
Inline void knl_terminate_hw_timer( void )
{
3400b77c:	b580      	push	{r7, lr}
3400b77e:	af00      	add	r7, sp, #0
	/* Timer interrupt disable */
	out_w(SYST_CSR, 0x00000000);
3400b780:	2100      	movs	r1, #0
3400b782:	4802      	ldr	r0, [pc, #8]	@ (3400b78c <knl_terminate_hw_timer+0x10>)
3400b784:	f7ff ff2e 	bl	3400b5e4 <out_w>
}
3400b788:	bf00      	nop
3400b78a:	bd80      	pop	{r7, pc}
3400b78c:	e000e010 	.word	0xe000e010

3400b790 <knl_timer_startup>:

/*
 * Start system timer
 */
EXPORT ER knl_timer_startup( void )
{
3400b790:	b580      	push	{r7, lr}
3400b792:	af00      	add	r7, sp, #0
	knl_current_time = knl_real_time_ofs = uitoll(0);
3400b794:	490a      	ldr	r1, [pc, #40]	@ (3400b7c0 <knl_timer_startup+0x30>)
3400b796:	f04f 0200 	mov.w	r2, #0
3400b79a:	f04f 0300 	mov.w	r3, #0
3400b79e:	e9c1 2300 	strd	r2, r3, [r1]
3400b7a2:	4b07      	ldr	r3, [pc, #28]	@ (3400b7c0 <knl_timer_startup+0x30>)
3400b7a4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b7a8:	4906      	ldr	r1, [pc, #24]	@ (3400b7c4 <knl_timer_startup+0x34>)
3400b7aa:	e9c1 2300 	strd	r2, r3, [r1]
	QueInit(&knl_timer_queue);
3400b7ae:	4806      	ldr	r0, [pc, #24]	@ (3400b7c8 <knl_timer_startup+0x38>)
3400b7b0:	f7ff ff32 	bl	3400b618 <QueInit>

	/* Start timer interrupt */
	knl_start_hw_timer();
3400b7b4:	f7ff ff96 	bl	3400b6e4 <knl_start_hw_timer>

	return E_OK;
3400b7b8:	2300      	movs	r3, #0
}
3400b7ba:	4618      	mov	r0, r3
3400b7bc:	bd80      	pop	{r7, pc}
3400b7be:	bf00      	nop
3400b7c0:	340119c0 	.word	0x340119c0
3400b7c4:	340119b8 	.word	0x340119b8
3400b7c8:	340119c8 	.word	0x340119c8

3400b7cc <knl_timer_shutdown>:
#if USE_SHUTDOWN
/*
 * Stop system timer
 */
EXPORT void knl_timer_shutdown( void )
{
3400b7cc:	b580      	push	{r7, lr}
3400b7ce:	af00      	add	r7, sp, #0
	knl_terminate_hw_timer();
3400b7d0:	f7ff ffd4 	bl	3400b77c <knl_terminate_hw_timer>
}
3400b7d4:	bf00      	nop
3400b7d6:	bd80      	pop	{r7, pc}

3400b7d8 <knl_enqueue_tmeb>:

/*
 * Insert timer event to timer event queue
 */
LOCAL void knl_enqueue_tmeb( TMEB *event )
{
3400b7d8:	b580      	push	{r7, lr}
3400b7da:	b084      	sub	sp, #16
3400b7dc:	af00      	add	r7, sp, #0
3400b7de:	6078      	str	r0, [r7, #4]
	QUEUE	*q;
	ABSTIM	ofs = lltoul(knl_current_time) - ABSTIM_DIFF_MIN;
3400b7e0:	4b13      	ldr	r3, [pc, #76]	@ (3400b830 <knl_enqueue_tmeb+0x58>)
3400b7e2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b7e6:	4613      	mov	r3, r2
3400b7e8:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
3400b7ec:	3301      	adds	r3, #1
3400b7ee:	60bb      	str	r3, [r7, #8]

	for ( q = knl_timer_queue.next; q != &knl_timer_queue; q = q->next ) {
3400b7f0:	4b10      	ldr	r3, [pc, #64]	@ (3400b834 <knl_enqueue_tmeb+0x5c>)
3400b7f2:	681b      	ldr	r3, [r3, #0]
3400b7f4:	60fb      	str	r3, [r7, #12]
3400b7f6:	e00c      	b.n	3400b812 <knl_enqueue_tmeb+0x3a>
		if ( (ABSTIM)(event->time - ofs) < (ABSTIM)((((TMEB*)q)->time) - ofs) ) {
3400b7f8:	687b      	ldr	r3, [r7, #4]
3400b7fa:	689a      	ldr	r2, [r3, #8]
3400b7fc:	68bb      	ldr	r3, [r7, #8]
3400b7fe:	1ad2      	subs	r2, r2, r3
3400b800:	68fb      	ldr	r3, [r7, #12]
3400b802:	6899      	ldr	r1, [r3, #8]
3400b804:	68bb      	ldr	r3, [r7, #8]
3400b806:	1acb      	subs	r3, r1, r3
3400b808:	429a      	cmp	r2, r3
3400b80a:	d307      	bcc.n	3400b81c <knl_enqueue_tmeb+0x44>
	for ( q = knl_timer_queue.next; q != &knl_timer_queue; q = q->next ) {
3400b80c:	68fb      	ldr	r3, [r7, #12]
3400b80e:	681b      	ldr	r3, [r3, #0]
3400b810:	60fb      	str	r3, [r7, #12]
3400b812:	68fb      	ldr	r3, [r7, #12]
3400b814:	4a07      	ldr	r2, [pc, #28]	@ (3400b834 <knl_enqueue_tmeb+0x5c>)
3400b816:	4293      	cmp	r3, r2
3400b818:	d1ee      	bne.n	3400b7f8 <knl_enqueue_tmeb+0x20>
3400b81a:	e000      	b.n	3400b81e <knl_enqueue_tmeb+0x46>
			break;
3400b81c:	bf00      	nop
		}
	}
	QueInsert(&event->queue, q);
3400b81e:	687b      	ldr	r3, [r7, #4]
3400b820:	68f9      	ldr	r1, [r7, #12]
3400b822:	4618      	mov	r0, r3
3400b824:	f7ff ff1a 	bl	3400b65c <QueInsert>
}
3400b828:	bf00      	nop
3400b82a:	3710      	adds	r7, #16
3400b82c:	46bd      	mov	sp, r7
3400b82e:	bd80      	pop	{r7, pc}
3400b830:	340119b8 	.word	0x340119b8
3400b834:	340119c8 	.word	0x340119c8

3400b838 <knl_timer_insert>:
 *	typedef	W		TMO;
 *	typedef UW		RELTIM;
 *	#define TMO_FEVR	(-1)
 */
EXPORT void knl_timer_insert( TMEB *event, TMO tmout, CBACK callback, void *arg )
{
3400b838:	b580      	push	{r7, lr}
3400b83a:	b084      	sub	sp, #16
3400b83c:	af00      	add	r7, sp, #0
3400b83e:	60f8      	str	r0, [r7, #12]
3400b840:	60b9      	str	r1, [r7, #8]
3400b842:	607a      	str	r2, [r7, #4]
3400b844:	603b      	str	r3, [r7, #0]
	event->callback = callback;
3400b846:	68fb      	ldr	r3, [r7, #12]
3400b848:	687a      	ldr	r2, [r7, #4]
3400b84a:	60da      	str	r2, [r3, #12]
	event->arg = arg;
3400b84c:	68fb      	ldr	r3, [r7, #12]
3400b84e:	683a      	ldr	r2, [r7, #0]
3400b850:	611a      	str	r2, [r3, #16]

	if ( tmout == TMO_FEVR ) {
3400b852:	68bb      	ldr	r3, [r7, #8]
3400b854:	f1b3 3fff 	cmp.w	r3, #4294967295
3400b858:	d104      	bne.n	3400b864 <knl_timer_insert+0x2c>
		QueInit(&event->queue);
3400b85a:	68fb      	ldr	r3, [r7, #12]
3400b85c:	4618      	mov	r0, r3
3400b85e:	f7ff fedb 	bl	3400b618 <QueInit>
		/* To guarantee longer wait time specified by 'tmout',
		   add TIMER_PERIOD on wait time */
		event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
		knl_enqueue_tmeb(event);
	}
}
3400b862:	e00b      	b.n	3400b87c <knl_timer_insert+0x44>
		event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
3400b864:	4b07      	ldr	r3, [pc, #28]	@ (3400b884 <knl_timer_insert+0x4c>)
3400b866:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b86a:	68bb      	ldr	r3, [r7, #8]
3400b86c:	4413      	add	r3, r2
3400b86e:	f103 020a 	add.w	r2, r3, #10
3400b872:	68fb      	ldr	r3, [r7, #12]
3400b874:	609a      	str	r2, [r3, #8]
		knl_enqueue_tmeb(event);
3400b876:	68f8      	ldr	r0, [r7, #12]
3400b878:	f7ff ffae 	bl	3400b7d8 <knl_enqueue_tmeb>
}
3400b87c:	bf00      	nop
3400b87e:	3710      	adds	r7, #16
3400b880:	46bd      	mov	sp, r7
3400b882:	bd80      	pop	{r7, pc}
3400b884:	340119b8 	.word	0x340119b8

3400b888 <knl_timer_insert_reltim>:

EXPORT void knl_timer_insert_reltim( TMEB *event, RELTIM tmout, CBACK callback, void *arg )
{
3400b888:	b580      	push	{r7, lr}
3400b88a:	b084      	sub	sp, #16
3400b88c:	af00      	add	r7, sp, #0
3400b88e:	60f8      	str	r0, [r7, #12]
3400b890:	60b9      	str	r1, [r7, #8]
3400b892:	607a      	str	r2, [r7, #4]
3400b894:	603b      	str	r3, [r7, #0]
	event->callback = callback;
3400b896:	68fb      	ldr	r3, [r7, #12]
3400b898:	687a      	ldr	r2, [r7, #4]
3400b89a:	60da      	str	r2, [r3, #12]
	event->arg = arg;
3400b89c:	68fb      	ldr	r3, [r7, #12]
3400b89e:	683a      	ldr	r2, [r7, #0]
3400b8a0:	611a      	str	r2, [r3, #16]

	/* To guarantee longer wait time specified by 'tmout',
	   add TIMER_PERIOD on wait time */
	event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
3400b8a2:	4b08      	ldr	r3, [pc, #32]	@ (3400b8c4 <knl_timer_insert_reltim+0x3c>)
3400b8a4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b8a8:	68bb      	ldr	r3, [r7, #8]
3400b8aa:	4413      	add	r3, r2
3400b8ac:	f103 020a 	add.w	r2, r3, #10
3400b8b0:	68fb      	ldr	r3, [r7, #12]
3400b8b2:	609a      	str	r2, [r3, #8]
	knl_enqueue_tmeb(event);
3400b8b4:	68f8      	ldr	r0, [r7, #12]
3400b8b6:	f7ff ff8f 	bl	3400b7d8 <knl_enqueue_tmeb>
}
3400b8ba:	bf00      	nop
3400b8bc:	3710      	adds	r7, #16
3400b8be:	46bd      	mov	sp, r7
3400b8c0:	bd80      	pop	{r7, pc}
3400b8c2:	bf00      	nop
3400b8c4:	340119b8 	.word	0x340119b8

3400b8c8 <knl_timer_handler>:
 *	interval by hardware timer. Update the software clock and start the 
 *	timer event upon arriving at start time.
 */

EXPORT void knl_timer_handler( void )
{
3400b8c8:	b5b0      	push	{r4, r5, r7, lr}
3400b8ca:	b084      	sub	sp, #16
3400b8cc:	af00      	add	r7, sp, #0
	TMEB	*event;
	ABSTIM	cur;

	knl_clear_hw_timer_interrupt();		/* Clear timer interrupt */
3400b8ce:	f7ff ff3d 	bl	3400b74c <knl_clear_hw_timer_interrupt>

	BEGIN_CRITICAL_SECTION;
3400b8d2:	f002 f858 	bl	3400d986 <disint>
3400b8d6:	60f8      	str	r0, [r7, #12]
	knl_current_time = ll_add(knl_current_time, uitoll(TIMER_PERIOD));
3400b8d8:	4b24      	ldr	r3, [pc, #144]	@ (3400b96c <knl_timer_handler+0xa4>)
3400b8da:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b8de:	f112 040a 	adds.w	r4, r2, #10
3400b8e2:	f143 0500 	adc.w	r5, r3, #0
3400b8e6:	4b21      	ldr	r3, [pc, #132]	@ (3400b96c <knl_timer_handler+0xa4>)
3400b8e8:	e9c3 4500 	strd	r4, r5, [r3]
	cur = lltoul(knl_current_time);
3400b8ec:	4b1f      	ldr	r3, [pc, #124]	@ (3400b96c <knl_timer_handler+0xa4>)
3400b8ee:	e9d3 2300 	ldrd	r2, r3, [r3]
3400b8f2:	4613      	mov	r3, r2
3400b8f4:	60bb      	str	r3, [r7, #8]
		}
	}
#endif

	/* Execute event that passed occurring time. */
	while ( !isQueEmpty(&knl_timer_queue) ) {
3400b8f6:	e019      	b.n	3400b92c <knl_timer_handler+0x64>
		event = (TMEB*)knl_timer_queue.next;
3400b8f8:	4b1d      	ldr	r3, [pc, #116]	@ (3400b970 <knl_timer_handler+0xa8>)
3400b8fa:	681b      	ldr	r3, [r3, #0]
3400b8fc:	607b      	str	r3, [r7, #4]

		if ( !knl_abstim_reached(cur, event->time) ) {
3400b8fe:	687b      	ldr	r3, [r7, #4]
3400b900:	689b      	ldr	r3, [r3, #8]
3400b902:	4619      	mov	r1, r3
3400b904:	68b8      	ldr	r0, [r7, #8]
3400b906:	f7ff fedb 	bl	3400b6c0 <knl_abstim_reached>
3400b90a:	4603      	mov	r3, r0
3400b90c:	2b00      	cmp	r3, #0
3400b90e:	d014      	beq.n	3400b93a <knl_timer_handler+0x72>
			break;
		}

		QueRemove(&event->queue);
3400b910:	687b      	ldr	r3, [r7, #4]
3400b912:	4618      	mov	r0, r3
3400b914:	f7ff febb 	bl	3400b68e <QueRemove>
		if ( event->callback != NULL ) {
3400b918:	687b      	ldr	r3, [r7, #4]
3400b91a:	68db      	ldr	r3, [r3, #12]
3400b91c:	2b00      	cmp	r3, #0
3400b91e:	d005      	beq.n	3400b92c <knl_timer_handler+0x64>
			(*event->callback)(event->arg);
3400b920:	687b      	ldr	r3, [r7, #4]
3400b922:	68db      	ldr	r3, [r3, #12]
3400b924:	687a      	ldr	r2, [r7, #4]
3400b926:	6912      	ldr	r2, [r2, #16]
3400b928:	4610      	mov	r0, r2
3400b92a:	4798      	blx	r3
	while ( !isQueEmpty(&knl_timer_queue) ) {
3400b92c:	4810      	ldr	r0, [pc, #64]	@ (3400b970 <knl_timer_handler+0xa8>)
3400b92e:	f7ff fe83 	bl	3400b638 <isQueEmpty>
3400b932:	4603      	mov	r3, r0
3400b934:	2b00      	cmp	r3, #0
3400b936:	d0df      	beq.n	3400b8f8 <knl_timer_handler+0x30>
3400b938:	e000      	b.n	3400b93c <knl_timer_handler+0x74>
			break;
3400b93a:	bf00      	nop
		}
	}

	END_CRITICAL_SECTION;
3400b93c:	68fb      	ldr	r3, [r7, #12]
3400b93e:	2b00      	cmp	r3, #0
3400b940:	d10b      	bne.n	3400b95a <knl_timer_handler+0x92>
3400b942:	4b0c      	ldr	r3, [pc, #48]	@ (3400b974 <knl_timer_handler+0xac>)
3400b944:	681a      	ldr	r2, [r3, #0]
3400b946:	4b0c      	ldr	r3, [pc, #48]	@ (3400b978 <knl_timer_handler+0xb0>)
3400b948:	681b      	ldr	r3, [r3, #0]
3400b94a:	429a      	cmp	r2, r3
3400b94c:	d005      	beq.n	3400b95a <knl_timer_handler+0x92>
3400b94e:	4b0b      	ldr	r3, [pc, #44]	@ (3400b97c <knl_timer_handler+0xb4>)
3400b950:	681b      	ldr	r3, [r3, #0]
3400b952:	2b00      	cmp	r3, #0
3400b954:	d101      	bne.n	3400b95a <knl_timer_handler+0x92>
3400b956:	f001 f8d7 	bl	3400cb08 <knl_dispatch>
3400b95a:	68f8      	ldr	r0, [r7, #12]
3400b95c:	f001 fff7 	bl	3400d94e <set_basepri>

	knl_end_of_hw_timer_interrupt();		/* Clear timer interrupt */
3400b960:	f7ff ff04 	bl	3400b76c <knl_end_of_hw_timer_interrupt>
}
3400b964:	bf00      	nop
3400b966:	3710      	adds	r7, #16
3400b968:	46bd      	mov	sp, r7
3400b96a:	bdb0      	pop	{r4, r5, r7, pc}
3400b96c:	340119b8 	.word	0x340119b8
3400b970:	340119c8 	.word	0x340119c8
3400b974:	340109c8 	.word	0x340109c8
3400b978:	340109cc 	.word	0x340109cc
3400b97c:	340109c4 	.word	0x340109c4

3400b980 <knl_init_object>:

/*
 * Each kernel-object initialization
 */
EXPORT ER knl_init_object( void)
{	
3400b980:	b580      	push	{r7, lr}
3400b982:	b082      	sub	sp, #8
3400b984:	af00      	add	r7, sp, #0
	ER	ercd;

	ercd = knl_task_initialize();
3400b986:	f7ff faa7 	bl	3400aed8 <knl_task_initialize>
3400b98a:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b98c:	687b      	ldr	r3, [r7, #4]
3400b98e:	2b00      	cmp	r3, #0
3400b990:	da01      	bge.n	3400b996 <knl_init_object+0x16>
3400b992:	687b      	ldr	r3, [r7, #4]
3400b994:	e048      	b.n	3400ba28 <knl_init_object+0xa8>

#if USE_SEMAPHORE
	ercd = knl_semaphore_initialize();
3400b996:	f7fe fec1 	bl	3400a71c <knl_semaphore_initialize>
3400b99a:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b99c:	687b      	ldr	r3, [r7, #4]
3400b99e:	2b00      	cmp	r3, #0
3400b9a0:	da01      	bge.n	3400b9a6 <knl_init_object+0x26>
3400b9a2:	687b      	ldr	r3, [r7, #4]
3400b9a4:	e040      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_EVENTFLAG
	ercd = knl_eventflag_initialize();
3400b9a6:	f7fd ffc7 	bl	34009938 <knl_eventflag_initialize>
3400b9aa:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9ac:	687b      	ldr	r3, [r7, #4]
3400b9ae:	2b00      	cmp	r3, #0
3400b9b0:	da01      	bge.n	3400b9b6 <knl_init_object+0x36>
3400b9b2:	687b      	ldr	r3, [r7, #4]
3400b9b4:	e038      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_MAILBOX
	ercd = knl_mailbox_initialize();
3400b9b6:	f7fe fa71 	bl	34009e9c <knl_mailbox_initialize>
3400b9ba:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9bc:	687b      	ldr	r3, [r7, #4]
3400b9be:	2b00      	cmp	r3, #0
3400b9c0:	da01      	bge.n	3400b9c6 <knl_init_object+0x46>
3400b9c2:	687b      	ldr	r3, [r7, #4]
3400b9c4:	e030      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_MESSAGEBUFFER
	ercd = knl_messagebuffer_initialize();
3400b9c6:	f7fe fddd 	bl	3400a584 <knl_messagebuffer_initialize>
3400b9ca:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9cc:	687b      	ldr	r3, [r7, #4]
3400b9ce:	2b00      	cmp	r3, #0
3400b9d0:	da01      	bge.n	3400b9d6 <knl_init_object+0x56>
3400b9d2:	687b      	ldr	r3, [r7, #4]
3400b9d4:	e028      	b.n	3400ba28 <knl_init_object+0xa8>
#if USE_LEGACY_API && USE_RENDEZVOUS
	ercd = knl_rendezvous_initialize();
	if(ercd < E_OK) return ercd;
#endif
#if USE_MUTEX
	ercd = knl_mutex_initialize();
3400b9d6:	f7fe fe25 	bl	3400a624 <knl_mutex_initialize>
3400b9da:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9dc:	687b      	ldr	r3, [r7, #4]
3400b9de:	2b00      	cmp	r3, #0
3400b9e0:	da01      	bge.n	3400b9e6 <knl_init_object+0x66>
3400b9e2:	687b      	ldr	r3, [r7, #4]
3400b9e4:	e020      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_MEMORYPOOL
	ercd = knl_memorypool_initialize();
3400b9e6:	f7fe fd7d 	bl	3400a4e4 <knl_memorypool_initialize>
3400b9ea:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9ec:	687b      	ldr	r3, [r7, #4]
3400b9ee:	2b00      	cmp	r3, #0
3400b9f0:	da01      	bge.n	3400b9f6 <knl_init_object+0x76>
3400b9f2:	687b      	ldr	r3, [r7, #4]
3400b9f4:	e018      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_FIX_MEMORYPOOL
	ercd = knl_fix_memorypool_initialize();
3400b9f6:	f7fe fd21 	bl	3400a43c <knl_fix_memorypool_initialize>
3400b9fa:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400b9fc:	687b      	ldr	r3, [r7, #4]
3400b9fe:	2b00      	cmp	r3, #0
3400ba00:	da01      	bge.n	3400ba06 <knl_init_object+0x86>
3400ba02:	687b      	ldr	r3, [r7, #4]
3400ba04:	e010      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_CYCLICHANDLER
	ercd = knl_cyclichandler_initialize();
3400ba06:	f7ff fda5 	bl	3400b554 <knl_cyclichandler_initialize>
3400ba0a:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400ba0c:	687b      	ldr	r3, [r7, #4]
3400ba0e:	2b00      	cmp	r3, #0
3400ba10:	da01      	bge.n	3400ba16 <knl_init_object+0x96>
3400ba12:	687b      	ldr	r3, [r7, #4]
3400ba14:	e008      	b.n	3400ba28 <knl_init_object+0xa8>
#endif
#if USE_ALARMHANDLER
	ercd = knl_alarmhandler_initialize();
3400ba16:	f7ff fdc1 	bl	3400b59c <knl_alarmhandler_initialize>
3400ba1a:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400ba1c:	687b      	ldr	r3, [r7, #4]
3400ba1e:	2b00      	cmp	r3, #0
3400ba20:	da01      	bge.n	3400ba26 <knl_init_object+0xa6>
3400ba22:	687b      	ldr	r3, [r7, #4]
3400ba24:	e000      	b.n	3400ba28 <knl_init_object+0xa8>
#endif

	return E_OK;
3400ba26:	2300      	movs	r3, #0
}
3400ba28:	4618      	mov	r0, r3
3400ba2a:	3708      	adds	r7, #8
3400ba2c:	46bd      	mov	sp, r7
3400ba2e:	bd80      	pop	{r7, pc}

3400ba30 <isQueEmpty>:
{
3400ba30:	b480      	push	{r7}
3400ba32:	b083      	sub	sp, #12
3400ba34:	af00      	add	r7, sp, #0
3400ba36:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400ba38:	687b      	ldr	r3, [r7, #4]
3400ba3a:	681b      	ldr	r3, [r3, #0]
3400ba3c:	687a      	ldr	r2, [r7, #4]
3400ba3e:	429a      	cmp	r2, r3
3400ba40:	bf0c      	ite	eq
3400ba42:	2301      	moveq	r3, #1
3400ba44:	2300      	movne	r3, #0
3400ba46:	b2db      	uxtb	r3, r3
}
3400ba48:	4618      	mov	r0, r3
3400ba4a:	370c      	adds	r7, #12
3400ba4c:	46bd      	mov	sp, r7
3400ba4e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ba52:	4770      	bx	lr

3400ba54 <QueInsert>:
{
3400ba54:	b480      	push	{r7}
3400ba56:	b083      	sub	sp, #12
3400ba58:	af00      	add	r7, sp, #0
3400ba5a:	6078      	str	r0, [r7, #4]
3400ba5c:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400ba5e:	683b      	ldr	r3, [r7, #0]
3400ba60:	685a      	ldr	r2, [r3, #4]
3400ba62:	687b      	ldr	r3, [r7, #4]
3400ba64:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400ba66:	687b      	ldr	r3, [r7, #4]
3400ba68:	683a      	ldr	r2, [r7, #0]
3400ba6a:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400ba6c:	683b      	ldr	r3, [r7, #0]
3400ba6e:	685b      	ldr	r3, [r3, #4]
3400ba70:	687a      	ldr	r2, [r7, #4]
3400ba72:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400ba74:	683b      	ldr	r3, [r7, #0]
3400ba76:	687a      	ldr	r2, [r7, #4]
3400ba78:	605a      	str	r2, [r3, #4]
}
3400ba7a:	bf00      	nop
3400ba7c:	370c      	adds	r7, #12
3400ba7e:	46bd      	mov	sp, r7
3400ba80:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ba84:	4770      	bx	lr

3400ba86 <QueRemove>:
{
3400ba86:	b480      	push	{r7}
3400ba88:	b083      	sub	sp, #12
3400ba8a:	af00      	add	r7, sp, #0
3400ba8c:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400ba8e:	687b      	ldr	r3, [r7, #4]
3400ba90:	681b      	ldr	r3, [r3, #0]
3400ba92:	687a      	ldr	r2, [r7, #4]
3400ba94:	429a      	cmp	r2, r3
3400ba96:	d009      	beq.n	3400baac <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400ba98:	687b      	ldr	r3, [r7, #4]
3400ba9a:	685b      	ldr	r3, [r3, #4]
3400ba9c:	687a      	ldr	r2, [r7, #4]
3400ba9e:	6812      	ldr	r2, [r2, #0]
3400baa0:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400baa2:	687b      	ldr	r3, [r7, #4]
3400baa4:	681b      	ldr	r3, [r3, #0]
3400baa6:	687a      	ldr	r2, [r7, #4]
3400baa8:	6852      	ldr	r2, [r2, #4]
3400baaa:	605a      	str	r2, [r3, #4]
}
3400baac:	bf00      	nop
3400baae:	370c      	adds	r7, #12
3400bab0:	46bd      	mov	sp, r7
3400bab2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bab6:	4770      	bx	lr

3400bab8 <knl_timer_delete>:

/*
 * Delete from time-event queue
 */
Inline void knl_timer_delete( TMEB *event )
{
3400bab8:	b580      	push	{r7, lr}
3400baba:	b082      	sub	sp, #8
3400babc:	af00      	add	r7, sp, #0
3400babe:	6078      	str	r0, [r7, #4]
	QueRemove(&event->queue);
3400bac0:	687b      	ldr	r3, [r7, #4]
3400bac2:	4618      	mov	r0, r3
3400bac4:	f7ff ffdf 	bl	3400ba86 <QueRemove>
}
3400bac8:	bf00      	nop
3400baca:	3708      	adds	r7, #8
3400bacc:	46bd      	mov	sp, r7
3400bace:	bd80      	pop	{r7, pc}

3400bad0 <knl_queue_insert_tpri>:

/*
 * Connect the task to the prioritized wait queue.
 */
Inline void knl_queue_insert_tpri( TCB *tcb, QUEUE *queue )
{
3400bad0:	b580      	push	{r7, lr}
3400bad2:	b088      	sub	sp, #32
3400bad4:	af00      	add	r7, sp, #0
3400bad6:	6078      	str	r0, [r7, #4]
3400bad8:	6039      	str	r1, [r7, #0]
	QUEUE *q;
	QUEUE *start, *end;
	UB val;
	W offset;

	start = end = queue;
3400bada:	683b      	ldr	r3, [r7, #0]
3400badc:	61bb      	str	r3, [r7, #24]
3400bade:	69bb      	ldr	r3, [r7, #24]
3400bae0:	617b      	str	r3, [r7, #20]
	val = tcb->priority;
3400bae2:	687b      	ldr	r3, [r7, #4]
3400bae4:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400bae8:	74fb      	strb	r3, [r7, #19]
	offset = offsetof(TCB, priority);
3400baea:	2326      	movs	r3, #38	@ 0x26
3400baec:	60fb      	str	r3, [r7, #12]

	for ( q = start->next; q != end; q = q->next ) {
3400baee:	697b      	ldr	r3, [r7, #20]
3400baf0:	681b      	ldr	r3, [r3, #0]
3400baf2:	61fb      	str	r3, [r7, #28]
3400baf4:	e009      	b.n	3400bb0a <knl_queue_insert_tpri+0x3a>
		if ( *(UB*)((VB*)q + offset) > val ) {
3400baf6:	68fb      	ldr	r3, [r7, #12]
3400baf8:	69fa      	ldr	r2, [r7, #28]
3400bafa:	4413      	add	r3, r2
3400bafc:	781b      	ldrb	r3, [r3, #0]
3400bafe:	7cfa      	ldrb	r2, [r7, #19]
3400bb00:	429a      	cmp	r2, r3
3400bb02:	d307      	bcc.n	3400bb14 <knl_queue_insert_tpri+0x44>
	for ( q = start->next; q != end; q = q->next ) {
3400bb04:	69fb      	ldr	r3, [r7, #28]
3400bb06:	681b      	ldr	r3, [r3, #0]
3400bb08:	61fb      	str	r3, [r7, #28]
3400bb0a:	69fa      	ldr	r2, [r7, #28]
3400bb0c:	69bb      	ldr	r3, [r7, #24]
3400bb0e:	429a      	cmp	r2, r3
3400bb10:	d1f1      	bne.n	3400baf6 <knl_queue_insert_tpri+0x26>
3400bb12:	e000      	b.n	3400bb16 <knl_queue_insert_tpri+0x46>
			break;
3400bb14:	bf00      	nop
		}
	}

	QueInsert(&tcb->tskque, q);
3400bb16:	687b      	ldr	r3, [r7, #4]
3400bb18:	69f9      	ldr	r1, [r7, #28]
3400bb1a:	4618      	mov	r0, r3
3400bb1c:	f7ff ff9a 	bl	3400ba54 <QueInsert>
}
3400bb20:	bf00      	nop
3400bb22:	3720      	adds	r7, #32
3400bb24:	46bd      	mov	sp, r7
3400bb26:	bd80      	pop	{r7, pc}

3400bb28 <knl_make_non_wait>:
 * Update the task state to release wait. When it becomes ready state,
 * connect to the ready queue.
 * Call when the task is in the wait state (including double wait).
 */
Inline void knl_make_non_wait( TCB *tcb )
{
3400bb28:	b580      	push	{r7, lr}
3400bb2a:	b082      	sub	sp, #8
3400bb2c:	af00      	add	r7, sp, #0
3400bb2e:	6078      	str	r0, [r7, #4]
	if ( tcb->state == TS_WAIT ) {
3400bb30:	687b      	ldr	r3, [r7, #4]
3400bb32:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400bb36:	2b02      	cmp	r3, #2
3400bb38:	d103      	bne.n	3400bb42 <knl_make_non_wait+0x1a>
		knl_make_ready(tcb);
3400bb3a:	6878      	ldr	r0, [r7, #4]
3400bb3c:	f7ff fa4a 	bl	3400afd4 <knl_make_ready>
	} else {
		tcb->state = TS_SUSPEND;
	}
}
3400bb40:	e003      	b.n	3400bb4a <knl_make_non_wait+0x22>
		tcb->state = TS_SUSPEND;
3400bb42:	687b      	ldr	r3, [r7, #4]
3400bb44:	2204      	movs	r2, #4
3400bb46:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
}
3400bb4a:	bf00      	nop
3400bb4c:	3708      	adds	r7, #8
3400bb4e:	46bd      	mov	sp, r7
3400bb50:	bd80      	pop	{r7, pc}

3400bb52 <knl_wait_release>:

/*
 * Release wait state of the task.
 */
Inline void knl_wait_release( TCB *tcb )
{
3400bb52:	b580      	push	{r7, lr}
3400bb54:	b082      	sub	sp, #8
3400bb56:	af00      	add	r7, sp, #0
3400bb58:	6078      	str	r0, [r7, #4]
	knl_timer_delete(&tcb->wtmeb);
3400bb5a:	687b      	ldr	r3, [r7, #4]
3400bb5c:	334c      	adds	r3, #76	@ 0x4c
3400bb5e:	4618      	mov	r0, r3
3400bb60:	f7ff ffaa 	bl	3400bab8 <knl_timer_delete>
	QueRemove(&tcb->tskque);
3400bb64:	687b      	ldr	r3, [r7, #4]
3400bb66:	4618      	mov	r0, r3
3400bb68:	f7ff ff8d 	bl	3400ba86 <QueRemove>
	knl_make_non_wait(tcb);
3400bb6c:	6878      	ldr	r0, [r7, #4]
3400bb6e:	f7ff ffdb 	bl	3400bb28 <knl_make_non_wait>
}
3400bb72:	bf00      	nop
3400bb74:	3708      	adds	r7, #8
3400bb76:	46bd      	mov	sp, r7
3400bb78:	bd80      	pop	{r7, pc}

3400bb7a <knl_wait_release_ok>:

#include "kernel.h"
#include "wait.h"

EXPORT void knl_wait_release_ok( TCB *tcb )
{
3400bb7a:	b580      	push	{r7, lr}
3400bb7c:	b082      	sub	sp, #8
3400bb7e:	af00      	add	r7, sp, #0
3400bb80:	6078      	str	r0, [r7, #4]
	knl_wait_release(tcb);
3400bb82:	6878      	ldr	r0, [r7, #4]
3400bb84:	f7ff ffe5 	bl	3400bb52 <knl_wait_release>
	*tcb->wercd = E_OK;
3400bb88:	687b      	ldr	r3, [r7, #4]
3400bb8a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bb8c:	2200      	movs	r2, #0
3400bb8e:	601a      	str	r2, [r3, #0]
}
3400bb90:	bf00      	nop
3400bb92:	3708      	adds	r7, #8
3400bb94:	46bd      	mov	sp, r7
3400bb96:	bd80      	pop	{r7, pc}

3400bb98 <knl_wait_release_tmout>:
	}
	*tcb->wercd = ercd;
}

EXPORT void knl_wait_release_tmout( TCB *tcb )
{
3400bb98:	b580      	push	{r7, lr}
3400bb9a:	b082      	sub	sp, #8
3400bb9c:	af00      	add	r7, sp, #0
3400bb9e:	6078      	str	r0, [r7, #4]
	QueRemove(&tcb->tskque);
3400bba0:	687b      	ldr	r3, [r7, #4]
3400bba2:	4618      	mov	r0, r3
3400bba4:	f7ff ff6f 	bl	3400ba86 <QueRemove>
	knl_make_non_wait(tcb);
3400bba8:	6878      	ldr	r0, [r7, #4]
3400bbaa:	f7ff ffbd 	bl	3400bb28 <knl_make_non_wait>
	if ( tcb->wspec->rel_wai_hook != NULL ) {
3400bbae:	687b      	ldr	r3, [r7, #4]
3400bbb0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400bbb2:	689b      	ldr	r3, [r3, #8]
3400bbb4:	2b00      	cmp	r3, #0
3400bbb6:	d004      	beq.n	3400bbc2 <knl_wait_release_tmout+0x2a>
		(*tcb->wspec->rel_wai_hook)(tcb);
3400bbb8:	687b      	ldr	r3, [r7, #4]
3400bbba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400bbbc:	689b      	ldr	r3, [r3, #8]
3400bbbe:	6878      	ldr	r0, [r7, #4]
3400bbc0:	4798      	blx	r3
	}
}
3400bbc2:	bf00      	nop
3400bbc4:	3708      	adds	r7, #8
3400bbc6:	46bd      	mov	sp, r7
3400bbc8:	bd80      	pop	{r7, pc}
	...

3400bbcc <knl_make_wait>:
 *	typedef	W		TMO;
 *	typedef UW		RELTIM;
 *	#define TMO_FEVR	(-1)
 */
EXPORT void knl_make_wait( TMO tmout, ATR atr )
{
3400bbcc:	b580      	push	{r7, lr}
3400bbce:	b082      	sub	sp, #8
3400bbd0:	af00      	add	r7, sp, #0
3400bbd2:	6078      	str	r0, [r7, #4]
3400bbd4:	6039      	str	r1, [r7, #0]
	switch ( knl_ctxtsk->state ) {
3400bbd6:	4b14      	ldr	r3, [pc, #80]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bbd8:	681b      	ldr	r3, [r3, #0]
3400bbda:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400bbde:	2b01      	cmp	r3, #1
3400bbe0:	d002      	beq.n	3400bbe8 <knl_make_wait+0x1c>
3400bbe2:	2b04      	cmp	r3, #4
3400bbe4:	d00b      	beq.n	3400bbfe <knl_make_wait+0x32>
3400bbe6:	e010      	b.n	3400bc0a <knl_make_wait+0x3e>
	  case TS_READY:
		knl_make_non_ready(knl_ctxtsk);
3400bbe8:	4b0f      	ldr	r3, [pc, #60]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bbea:	681b      	ldr	r3, [r3, #0]
3400bbec:	4618      	mov	r0, r3
3400bbee:	f7ff fa0b 	bl	3400b008 <knl_make_non_ready>
		knl_ctxtsk->state = TS_WAIT;
3400bbf2:	4b0d      	ldr	r3, [pc, #52]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bbf4:	681b      	ldr	r3, [r3, #0]
3400bbf6:	2202      	movs	r2, #2
3400bbf8:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400bbfc:	e005      	b.n	3400bc0a <knl_make_wait+0x3e>
	  case TS_SUSPEND:
		knl_ctxtsk->state = TS_WAITSUS;
3400bbfe:	4b0a      	ldr	r3, [pc, #40]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bc00:	681b      	ldr	r3, [r3, #0]
3400bc02:	2206      	movs	r2, #6
3400bc04:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400bc08:	bf00      	nop
	}
	knl_timer_insert(&knl_ctxtsk->wtmeb, tmout, (CBACK)knl_wait_release_tmout, knl_ctxtsk);
3400bc0a:	4b07      	ldr	r3, [pc, #28]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bc0c:	681b      	ldr	r3, [r3, #0]
3400bc0e:	f103 004c 	add.w	r0, r3, #76	@ 0x4c
3400bc12:	4b05      	ldr	r3, [pc, #20]	@ (3400bc28 <knl_make_wait+0x5c>)
3400bc14:	681b      	ldr	r3, [r3, #0]
3400bc16:	4a05      	ldr	r2, [pc, #20]	@ (3400bc2c <knl_make_wait+0x60>)
3400bc18:	6879      	ldr	r1, [r7, #4]
3400bc1a:	f7ff fe0d 	bl	3400b838 <knl_timer_insert>
}
3400bc1e:	bf00      	nop
3400bc20:	3708      	adds	r7, #8
3400bc22:	46bd      	mov	sp, r7
3400bc24:	bd80      	pop	{r7, pc}
3400bc26:	bf00      	nop
3400bc28:	340109c8 	.word	0x340109c8
3400bc2c:	3400bb99 	.word	0x3400bb99

3400bc30 <knl_make_wait_reltim>:

EXPORT void knl_make_wait_reltim( RELTIM tmout, ATR atr )
{
3400bc30:	b580      	push	{r7, lr}
3400bc32:	b082      	sub	sp, #8
3400bc34:	af00      	add	r7, sp, #0
3400bc36:	6078      	str	r0, [r7, #4]
3400bc38:	6039      	str	r1, [r7, #0]
	switch ( knl_ctxtsk->state ) {
3400bc3a:	4b14      	ldr	r3, [pc, #80]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc3c:	681b      	ldr	r3, [r3, #0]
3400bc3e:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400bc42:	2b01      	cmp	r3, #1
3400bc44:	d002      	beq.n	3400bc4c <knl_make_wait_reltim+0x1c>
3400bc46:	2b04      	cmp	r3, #4
3400bc48:	d00b      	beq.n	3400bc62 <knl_make_wait_reltim+0x32>
3400bc4a:	e010      	b.n	3400bc6e <knl_make_wait_reltim+0x3e>
	  case TS_READY:
		knl_make_non_ready(knl_ctxtsk);
3400bc4c:	4b0f      	ldr	r3, [pc, #60]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc4e:	681b      	ldr	r3, [r3, #0]
3400bc50:	4618      	mov	r0, r3
3400bc52:	f7ff f9d9 	bl	3400b008 <knl_make_non_ready>
		knl_ctxtsk->state = TS_WAIT;
3400bc56:	4b0d      	ldr	r3, [pc, #52]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc58:	681b      	ldr	r3, [r3, #0]
3400bc5a:	2202      	movs	r2, #2
3400bc5c:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400bc60:	e005      	b.n	3400bc6e <knl_make_wait_reltim+0x3e>
	  case TS_SUSPEND:
		knl_ctxtsk->state = TS_WAITSUS;
3400bc62:	4b0a      	ldr	r3, [pc, #40]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc64:	681b      	ldr	r3, [r3, #0]
3400bc66:	2206      	movs	r2, #6
3400bc68:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400bc6c:	bf00      	nop
	}
	knl_timer_insert_reltim(&knl_ctxtsk->wtmeb, tmout, (CBACK)knl_wait_release_tmout, knl_ctxtsk);
3400bc6e:	4b07      	ldr	r3, [pc, #28]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc70:	681b      	ldr	r3, [r3, #0]
3400bc72:	f103 004c 	add.w	r0, r3, #76	@ 0x4c
3400bc76:	4b05      	ldr	r3, [pc, #20]	@ (3400bc8c <knl_make_wait_reltim+0x5c>)
3400bc78:	681b      	ldr	r3, [r3, #0]
3400bc7a:	4a05      	ldr	r2, [pc, #20]	@ (3400bc90 <knl_make_wait_reltim+0x60>)
3400bc7c:	6879      	ldr	r1, [r7, #4]
3400bc7e:	f7ff fe03 	bl	3400b888 <knl_timer_insert_reltim>
}
3400bc82:	bf00      	nop
3400bc84:	3708      	adds	r7, #8
3400bc86:	46bd      	mov	sp, r7
3400bc88:	bd80      	pop	{r7, pc}
3400bc8a:	bf00      	nop
3400bc8c:	340109c8 	.word	0x340109c8
3400bc90:	3400bb99 	.word	0x3400bb99

3400bc94 <knl_wait_delete>:
/*
 * Release all tasks connected to the wait queue, and define it
 * as E_DLT error.
 */
EXPORT void knl_wait_delete( QUEUE *wait_queue )
{
3400bc94:	b580      	push	{r7, lr}
3400bc96:	b084      	sub	sp, #16
3400bc98:	af00      	add	r7, sp, #0
3400bc9a:	6078      	str	r0, [r7, #4]
	TCB	*tcb;

	while ( !isQueEmpty(wait_queue) ) {
3400bc9c:	e00a      	b.n	3400bcb4 <knl_wait_delete+0x20>
		tcb = (TCB*)wait_queue->next;
3400bc9e:	687b      	ldr	r3, [r7, #4]
3400bca0:	681b      	ldr	r3, [r3, #0]
3400bca2:	60fb      	str	r3, [r7, #12]
		knl_wait_release(tcb);
3400bca4:	68f8      	ldr	r0, [r7, #12]
3400bca6:	f7ff ff54 	bl	3400bb52 <knl_wait_release>
		*tcb->wercd = E_DLT;
3400bcaa:	68fb      	ldr	r3, [r7, #12]
3400bcac:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bcae:	f06f 0232 	mvn.w	r2, #50	@ 0x32
3400bcb2:	601a      	str	r2, [r3, #0]
	while ( !isQueEmpty(wait_queue) ) {
3400bcb4:	6878      	ldr	r0, [r7, #4]
3400bcb6:	f7ff febb 	bl	3400ba30 <isQueEmpty>
3400bcba:	4603      	mov	r3, r0
3400bcbc:	2b00      	cmp	r3, #0
3400bcbe:	d0ee      	beq.n	3400bc9e <knl_wait_delete+0xa>
	}
}
3400bcc0:	bf00      	nop
3400bcc2:	bf00      	nop
3400bcc4:	3710      	adds	r7, #16
3400bcc6:	46bd      	mov	sp, r7
3400bcc8:	bd80      	pop	{r7, pc}
	...

3400bccc <knl_gcb_make_wait>:
/*
 * Change the active task state to wait state and connect to the timer wait 
 * queue and the object wait queue. Also set 'wid' in 'knl_ctxtsk'.
 */
EXPORT void knl_gcb_make_wait( GCB *gcb, TMO tmout )
{
3400bccc:	b580      	push	{r7, lr}
3400bcce:	b082      	sub	sp, #8
3400bcd0:	af00      	add	r7, sp, #0
3400bcd2:	6078      	str	r0, [r7, #4]
3400bcd4:	6039      	str	r1, [r7, #0]
	*knl_ctxtsk->wercd = E_TMOUT;
3400bcd6:	4b17      	ldr	r3, [pc, #92]	@ (3400bd34 <knl_gcb_make_wait+0x68>)
3400bcd8:	681b      	ldr	r3, [r3, #0]
3400bcda:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400bcdc:	f06f 0231 	mvn.w	r2, #49	@ 0x31
3400bce0:	601a      	str	r2, [r3, #0]
	if ( tmout != TMO_POL ) {
3400bce2:	683b      	ldr	r3, [r7, #0]
3400bce4:	2b00      	cmp	r3, #0
3400bce6:	d020      	beq.n	3400bd2a <knl_gcb_make_wait+0x5e>
		knl_ctxtsk->wid = gcb->objid;
3400bce8:	4b12      	ldr	r3, [pc, #72]	@ (3400bd34 <knl_gcb_make_wait+0x68>)
3400bcea:	681b      	ldr	r3, [r3, #0]
3400bcec:	687a      	ldr	r2, [r7, #4]
3400bcee:	6892      	ldr	r2, [r2, #8]
3400bcf0:	631a      	str	r2, [r3, #48]	@ 0x30
		knl_make_wait(tmout, gcb->objatr);
3400bcf2:	687b      	ldr	r3, [r7, #4]
3400bcf4:	691b      	ldr	r3, [r3, #16]
3400bcf6:	4619      	mov	r1, r3
3400bcf8:	6838      	ldr	r0, [r7, #0]
3400bcfa:	f7ff ff67 	bl	3400bbcc <knl_make_wait>
		if ( (gcb->objatr & TA_TPRI) != 0 ) {
3400bcfe:	687b      	ldr	r3, [r7, #4]
3400bd00:	691b      	ldr	r3, [r3, #16]
3400bd02:	f003 0301 	and.w	r3, r3, #1
3400bd06:	2b00      	cmp	r3, #0
3400bd08:	d007      	beq.n	3400bd1a <knl_gcb_make_wait+0x4e>
			knl_queue_insert_tpri(knl_ctxtsk, &gcb->wait_queue);
3400bd0a:	4b0a      	ldr	r3, [pc, #40]	@ (3400bd34 <knl_gcb_make_wait+0x68>)
3400bd0c:	681b      	ldr	r3, [r3, #0]
3400bd0e:	687a      	ldr	r2, [r7, #4]
3400bd10:	4611      	mov	r1, r2
3400bd12:	4618      	mov	r0, r3
3400bd14:	f7ff fedc 	bl	3400bad0 <knl_queue_insert_tpri>
		} else {
			QueInsert(&knl_ctxtsk->tskque, &gcb->wait_queue);
		}
	}
}
3400bd18:	e007      	b.n	3400bd2a <knl_gcb_make_wait+0x5e>
			QueInsert(&knl_ctxtsk->tskque, &gcb->wait_queue);
3400bd1a:	4b06      	ldr	r3, [pc, #24]	@ (3400bd34 <knl_gcb_make_wait+0x68>)
3400bd1c:	681b      	ldr	r3, [r3, #0]
3400bd1e:	461a      	mov	r2, r3
3400bd20:	687b      	ldr	r3, [r7, #4]
3400bd22:	4619      	mov	r1, r3
3400bd24:	4610      	mov	r0, r2
3400bd26:	f7ff fe95 	bl	3400ba54 <QueInsert>
}
3400bd2a:	bf00      	nop
3400bd2c:	3708      	adds	r7, #8
3400bd2e:	46bd      	mov	sp, r7
3400bd30:	bd80      	pop	{r7, pc}
3400bd32:	bf00      	nop
3400bd34:	340109c8 	.word	0x340109c8

3400bd38 <knl_gcb_change_priority>:
 * When the task priority changes, adjust the task position at the wait queue.
 * It is called only if the object attribute TA_TPRI is specified.
 *
 */
EXPORT void knl_gcb_change_priority( GCB *gcb, TCB *tcb )
{
3400bd38:	b580      	push	{r7, lr}
3400bd3a:	b082      	sub	sp, #8
3400bd3c:	af00      	add	r7, sp, #0
3400bd3e:	6078      	str	r0, [r7, #4]
3400bd40:	6039      	str	r1, [r7, #0]
	QueRemove(&tcb->tskque);
3400bd42:	683b      	ldr	r3, [r7, #0]
3400bd44:	4618      	mov	r0, r3
3400bd46:	f7ff fe9e 	bl	3400ba86 <QueRemove>
	knl_queue_insert_tpri(tcb, &gcb->wait_queue);
3400bd4a:	687b      	ldr	r3, [r7, #4]
3400bd4c:	4619      	mov	r1, r3
3400bd4e:	6838      	ldr	r0, [r7, #0]
3400bd50:	f7ff febe 	bl	3400bad0 <knl_queue_insert_tpri>
}
3400bd54:	bf00      	nop
3400bd56:	3708      	adds	r7, #8
3400bd58:	46bd      	mov	sp, r7
3400bd5a:	bd80      	pop	{r7, pc}

3400bd5c <knl_gcb_top_of_wait_queue>:
 * Search the first task of wait queue include "tcb" with target.
 * (Not insert "tcb" into wait queue.)
 *
 */
EXPORT TCB* knl_gcb_top_of_wait_queue( GCB *gcb, TCB *tcb )
{
3400bd5c:	b580      	push	{r7, lr}
3400bd5e:	b084      	sub	sp, #16
3400bd60:	af00      	add	r7, sp, #0
3400bd62:	6078      	str	r0, [r7, #4]
3400bd64:	6039      	str	r1, [r7, #0]
	TCB	*q;

	if ( isQueEmpty(&gcb->wait_queue) ) {
3400bd66:	687b      	ldr	r3, [r7, #4]
3400bd68:	4618      	mov	r0, r3
3400bd6a:	f7ff fe61 	bl	3400ba30 <isQueEmpty>
3400bd6e:	4603      	mov	r3, r0
3400bd70:	2b00      	cmp	r3, #0
3400bd72:	d001      	beq.n	3400bd78 <knl_gcb_top_of_wait_queue+0x1c>
		return tcb;
3400bd74:	683b      	ldr	r3, [r7, #0]
3400bd76:	e015      	b.n	3400bda4 <knl_gcb_top_of_wait_queue+0x48>
	}

	q = (TCB*)gcb->wait_queue.next;
3400bd78:	687b      	ldr	r3, [r7, #4]
3400bd7a:	681b      	ldr	r3, [r3, #0]
3400bd7c:	60fb      	str	r3, [r7, #12]
	if ( (gcb->objatr & TA_TPRI) == 0 ) {
3400bd7e:	687b      	ldr	r3, [r7, #4]
3400bd80:	691b      	ldr	r3, [r3, #16]
3400bd82:	f003 0301 	and.w	r3, r3, #1
3400bd86:	2b00      	cmp	r3, #0
3400bd88:	d101      	bne.n	3400bd8e <knl_gcb_top_of_wait_queue+0x32>
		return q;
3400bd8a:	68fb      	ldr	r3, [r7, #12]
3400bd8c:	e00a      	b.n	3400bda4 <knl_gcb_top_of_wait_queue+0x48>
	}

	return ( tcb->priority < q->priority )? tcb: q;
3400bd8e:	683b      	ldr	r3, [r7, #0]
3400bd90:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
3400bd94:	68fb      	ldr	r3, [r7, #12]
3400bd96:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400bd9a:	429a      	cmp	r2, r3
3400bd9c:	d201      	bcs.n	3400bda2 <knl_gcb_top_of_wait_queue+0x46>
3400bd9e:	683b      	ldr	r3, [r7, #0]
3400bda0:	e000      	b.n	3400bda4 <knl_gcb_top_of_wait_queue+0x48>
3400bda2:	68fb      	ldr	r3, [r7, #12]
}
3400bda4:	4618      	mov	r0, r3
3400bda6:	3710      	adds	r7, #16
3400bda8:	46bd      	mov	sp, r7
3400bdaa:	bd80      	pop	{r7, pc}

3400bdac <knl_memset>:
#include "kernel.h"

/*** binary operation ***/
/* memset : fill memory area */
void* knl_memset( void *s, int c, SZ n )
{
3400bdac:	b4f0      	push	{r4, r5, r6, r7}
3400bdae:	b084      	sub	sp, #16
3400bdb0:	af00      	add	r7, sp, #0
3400bdb2:	60f8      	str	r0, [r7, #12]
3400bdb4:	60b9      	str	r1, [r7, #8]
3400bdb6:	607a      	str	r2, [r7, #4]
	register unsigned char *cp, cval;
	register unsigned long *lp, lval;

	cp = (unsigned char *)s;
3400bdb8:	68fc      	ldr	r4, [r7, #12]
	cval = (unsigned char)c;
3400bdba:	68bb      	ldr	r3, [r7, #8]
3400bdbc:	b2dd      	uxtb	r5, r3
	
	if (n < 8) {
3400bdbe:	687b      	ldr	r3, [r7, #4]
3400bdc0:	2b07      	cmp	r3, #7
3400bdc2:	dc12      	bgt.n	3400bdea <knl_memset+0x3e>
		while (n-- > 0) {
3400bdc4:	e003      	b.n	3400bdce <knl_memset+0x22>
			*cp++ = cval;
3400bdc6:	4623      	mov	r3, r4
3400bdc8:	1c5c      	adds	r4, r3, #1
3400bdca:	462a      	mov	r2, r5
3400bdcc:	701a      	strb	r2, [r3, #0]
		while (n-- > 0) {
3400bdce:	687b      	ldr	r3, [r7, #4]
3400bdd0:	1e5a      	subs	r2, r3, #1
3400bdd2:	607a      	str	r2, [r7, #4]
3400bdd4:	2b00      	cmp	r3, #0
3400bdd6:	dcf6      	bgt.n	3400bdc6 <knl_memset+0x1a>
		}
		return s;
3400bdd8:	68fb      	ldr	r3, [r7, #12]
3400bdda:	e02e      	b.n	3400be3a <knl_memset+0x8e>
	}

	while ((long)cp % 4) {
		--n;
3400bddc:	687b      	ldr	r3, [r7, #4]
3400bdde:	3b01      	subs	r3, #1
3400bde0:	607b      	str	r3, [r7, #4]
		*cp++ = cval;
3400bde2:	4623      	mov	r3, r4
3400bde4:	1c5c      	adds	r4, r3, #1
3400bde6:	462a      	mov	r2, r5
3400bde8:	701a      	strb	r2, [r3, #0]
	while ((long)cp % 4) {
3400bdea:	4623      	mov	r3, r4
3400bdec:	f003 0303 	and.w	r3, r3, #3
3400bdf0:	2b00      	cmp	r3, #0
3400bdf2:	d1f3      	bne.n	3400bddc <knl_memset+0x30>
	}

	lp = (unsigned long *)cp;
3400bdf4:	4626      	mov	r6, r4
	lval = (unsigned long)cval |
3400bdf6:	462a      	mov	r2, r5
3400bdf8:	4613      	mov	r3, r2
3400bdfa:	021b      	lsls	r3, r3, #8
3400bdfc:	441a      	add	r2, r3
		(unsigned long)cval << 8 |
		(unsigned long)cval << 16 |
3400bdfe:	462b      	mov	r3, r5
3400be00:	041b      	lsls	r3, r3, #16
		(unsigned long)cval << 8 |
3400be02:	431a      	orrs	r2, r3
		(unsigned long)cval << 24;
3400be04:	462b      	mov	r3, r5
3400be06:	061b      	lsls	r3, r3, #24
	lval = (unsigned long)cval |
3400be08:	ea42 0403 	orr.w	r4, r2, r3

	while (n >= 4) {
3400be0c:	e005      	b.n	3400be1a <knl_memset+0x6e>
		*lp++ = lval;
3400be0e:	4633      	mov	r3, r6
3400be10:	1d1e      	adds	r6, r3, #4
3400be12:	601c      	str	r4, [r3, #0]
		n -= 4;
3400be14:	687b      	ldr	r3, [r7, #4]
3400be16:	3b04      	subs	r3, #4
3400be18:	607b      	str	r3, [r7, #4]
	while (n >= 4) {
3400be1a:	687b      	ldr	r3, [r7, #4]
3400be1c:	2b03      	cmp	r3, #3
3400be1e:	dcf6      	bgt.n	3400be0e <knl_memset+0x62>
	}

	cp = (unsigned char *)lp;
3400be20:	4634      	mov	r4, r6
	while (n) {
3400be22:	e006      	b.n	3400be32 <knl_memset+0x86>
		*cp++ = cval;
3400be24:	4623      	mov	r3, r4
3400be26:	1c5c      	adds	r4, r3, #1
3400be28:	462a      	mov	r2, r5
3400be2a:	701a      	strb	r2, [r3, #0]
		--n;
3400be2c:	687b      	ldr	r3, [r7, #4]
3400be2e:	3b01      	subs	r3, #1
3400be30:	607b      	str	r3, [r7, #4]
	while (n) {
3400be32:	687b      	ldr	r3, [r7, #4]
3400be34:	2b00      	cmp	r3, #0
3400be36:	d1f5      	bne.n	3400be24 <knl_memset+0x78>
	}

	return s;
3400be38:	68fb      	ldr	r3, [r7, #12]
}
3400be3a:	4618      	mov	r0, r3
3400be3c:	3710      	adds	r7, #16
3400be3e:	46bd      	mov	sp, r7
3400be40:	bcf0      	pop	{r4, r5, r6, r7}
3400be42:	4770      	bx	lr

3400be44 <knl_strlen>:
	return dst;
}

/* strlen : get text string length */
SZ knl_strlen( const char *s )
{
3400be44:	b490      	push	{r4, r7}
3400be46:	b082      	sub	sp, #8
3400be48:	af00      	add	r7, sp, #0
3400be4a:	6078      	str	r0, [r7, #4]
	register char *cp;

	cp = (char *)s;
3400be4c:	687c      	ldr	r4, [r7, #4]
	while (*cp) {
3400be4e:	e000      	b.n	3400be52 <knl_strlen+0xe>
		++cp;
3400be50:	3401      	adds	r4, #1
	while (*cp) {
3400be52:	7823      	ldrb	r3, [r4, #0]
3400be54:	2b00      	cmp	r3, #0
3400be56:	d1fb      	bne.n	3400be50 <knl_strlen+0xc>
	}
	return (SZ)(cp - s);
3400be58:	687b      	ldr	r3, [r7, #4]
3400be5a:	1ae3      	subs	r3, r4, r3
}
3400be5c:	4618      	mov	r0, r3
3400be5e:	3708      	adds	r7, #8
3400be60:	46bd      	mov	sp, r7
3400be62:	bc90      	pop	{r4, r7}
3400be64:	4770      	bx	lr

3400be66 <knl_strcpy>:

/* strcpy : copy text string */
char* knl_strcpy( char *dst, const char *src )
{
3400be66:	b490      	push	{r4, r7}
3400be68:	b082      	sub	sp, #8
3400be6a:	af00      	add	r7, sp, #0
3400be6c:	6078      	str	r0, [r7, #4]
3400be6e:	6039      	str	r1, [r7, #0]
	register char *cp;

	cp = dst;
3400be70:	687c      	ldr	r4, [r7, #4]
	do {
		*cp++ = *src;
3400be72:	4623      	mov	r3, r4
3400be74:	1c5c      	adds	r4, r3, #1
3400be76:	683a      	ldr	r2, [r7, #0]
3400be78:	7812      	ldrb	r2, [r2, #0]
3400be7a:	701a      	strb	r2, [r3, #0]
	} while (*src++);
3400be7c:	683b      	ldr	r3, [r7, #0]
3400be7e:	1c5a      	adds	r2, r3, #1
3400be80:	603a      	str	r2, [r7, #0]
3400be82:	781b      	ldrb	r3, [r3, #0]
3400be84:	2b00      	cmp	r3, #0
3400be86:	d1f4      	bne.n	3400be72 <knl_strcpy+0xc>

	return dst;
3400be88:	687b      	ldr	r3, [r7, #4]
}
3400be8a:	4618      	mov	r0, r3
3400be8c:	3708      	adds	r7, #8
3400be8e:	46bd      	mov	sp, r7
3400be90:	bc90      	pop	{r4, r7}
3400be92:	4770      	bx	lr

3400be94 <knl_strncpy>:

char* knl_strncpy( char *dst, const char *src, SZ n )
{
3400be94:	b490      	push	{r4, r7}
3400be96:	b084      	sub	sp, #16
3400be98:	af00      	add	r7, sp, #0
3400be9a:	60f8      	str	r0, [r7, #12]
3400be9c:	60b9      	str	r1, [r7, #8]
3400be9e:	607a      	str	r2, [r7, #4]
	register char *cp;

	cp = dst;
3400bea0:	68fc      	ldr	r4, [r7, #12]
	do {
		if (n-- <= 0) {
3400bea2:	687b      	ldr	r3, [r7, #4]
3400bea4:	1e5a      	subs	r2, r3, #1
3400bea6:	607a      	str	r2, [r7, #4]
3400bea8:	2b00      	cmp	r3, #0
3400beaa:	dc01      	bgt.n	3400beb0 <knl_strncpy+0x1c>
			return dst;
3400beac:	68fb      	ldr	r3, [r7, #12]
3400beae:	e015      	b.n	3400bedc <knl_strncpy+0x48>
		}
		*cp++ = *src;
3400beb0:	4623      	mov	r3, r4
3400beb2:	1c5c      	adds	r4, r3, #1
3400beb4:	68ba      	ldr	r2, [r7, #8]
3400beb6:	7812      	ldrb	r2, [r2, #0]
3400beb8:	701a      	strb	r2, [r3, #0]
	} while (*src++);
3400beba:	68bb      	ldr	r3, [r7, #8]
3400bebc:	1c5a      	adds	r2, r3, #1
3400bebe:	60ba      	str	r2, [r7, #8]
3400bec0:	781b      	ldrb	r3, [r3, #0]
3400bec2:	2b00      	cmp	r3, #0
3400bec4:	d1ed      	bne.n	3400bea2 <knl_strncpy+0xe>

	while (n-- > 0) {
3400bec6:	e003      	b.n	3400bed0 <knl_strncpy+0x3c>
		*cp++ = 0;
3400bec8:	4623      	mov	r3, r4
3400beca:	1c5c      	adds	r4, r3, #1
3400becc:	2200      	movs	r2, #0
3400bece:	701a      	strb	r2, [r3, #0]
	while (n-- > 0) {
3400bed0:	687b      	ldr	r3, [r7, #4]
3400bed2:	1e5a      	subs	r2, r3, #1
3400bed4:	607a      	str	r2, [r7, #4]
3400bed6:	2b00      	cmp	r3, #0
3400bed8:	dcf6      	bgt.n	3400bec8 <knl_strncpy+0x34>
	}

	return dst;
3400beda:	68fb      	ldr	r3, [r7, #12]
}
3400bedc:	4618      	mov	r0, r3
3400bede:	3710      	adds	r7, #16
3400bee0:	46bd      	mov	sp, r7
3400bee2:	bc90      	pop	{r4, r7}
3400bee4:	4770      	bx	lr

3400bee6 <knl_strcmp>:

/* strcmp : perform text string comparison */
int knl_strcmp( const char *s1, const char *s2 )
{
3400bee6:	b490      	push	{r4, r7}
3400bee8:	b082      	sub	sp, #8
3400beea:	af00      	add	r7, sp, #0
3400beec:	6078      	str	r0, [r7, #4]
3400beee:	6039      	str	r1, [r7, #0]
	register int result;

	while (*s1) {
3400bef0:	e00d      	b.n	3400bf0e <knl_strcmp+0x28>
		result = (unsigned char)*s1++ - (unsigned char)*s2++;
3400bef2:	687b      	ldr	r3, [r7, #4]
3400bef4:	1c5a      	adds	r2, r3, #1
3400bef6:	607a      	str	r2, [r7, #4]
3400bef8:	781b      	ldrb	r3, [r3, #0]
3400befa:	4619      	mov	r1, r3
3400befc:	683b      	ldr	r3, [r7, #0]
3400befe:	1c5a      	adds	r2, r3, #1
3400bf00:	603a      	str	r2, [r7, #0]
3400bf02:	781b      	ldrb	r3, [r3, #0]
3400bf04:	1acc      	subs	r4, r1, r3
		if (result) {
3400bf06:	2c00      	cmp	r4, #0
3400bf08:	d001      	beq.n	3400bf0e <knl_strcmp+0x28>
			return result;
3400bf0a:	4623      	mov	r3, r4
3400bf0c:	e009      	b.n	3400bf22 <knl_strcmp+0x3c>
	while (*s1) {
3400bf0e:	687b      	ldr	r3, [r7, #4]
3400bf10:	781b      	ldrb	r3, [r3, #0]
3400bf12:	2b00      	cmp	r3, #0
3400bf14:	d1ed      	bne.n	3400bef2 <knl_strcmp+0xc>
		}
	}

	return (unsigned char)*s1 - (unsigned char)*s2;
3400bf16:	687b      	ldr	r3, [r7, #4]
3400bf18:	781b      	ldrb	r3, [r3, #0]
3400bf1a:	461a      	mov	r2, r3
3400bf1c:	683b      	ldr	r3, [r7, #0]
3400bf1e:	781b      	ldrb	r3, [r3, #0]
3400bf20:	1ad3      	subs	r3, r2, r3
}
3400bf22:	4618      	mov	r0, r3
3400bf24:	3708      	adds	r7, #8
3400bf26:	46bd      	mov	sp, r7
3400bf28:	bc90      	pop	{r4, r7}
3400bf2a:	4770      	bx	lr

3400bf2c <Inc>:
 *	Increment/Decrement and evaluation of the associated result must
 *	be executed exclusively.
 */

Inline INT Inc( FastLock *lock )
{
3400bf2c:	b580      	push	{r7, lr}
3400bf2e:	b084      	sub	sp, #16
3400bf30:	af00      	add	r7, sp, #0
3400bf32:	6078      	str	r0, [r7, #4]
	UINT	imask;
	INT	c;
	DI(imask);
3400bf34:	f001 fd27 	bl	3400d986 <disint>
3400bf38:	60f8      	str	r0, [r7, #12]
	c = ++lock->cnt;
3400bf3a:	687b      	ldr	r3, [r7, #4]
3400bf3c:	681b      	ldr	r3, [r3, #0]
3400bf3e:	1c5a      	adds	r2, r3, #1
3400bf40:	687b      	ldr	r3, [r7, #4]
3400bf42:	601a      	str	r2, [r3, #0]
3400bf44:	687b      	ldr	r3, [r7, #4]
3400bf46:	681b      	ldr	r3, [r3, #0]
3400bf48:	60bb      	str	r3, [r7, #8]
	EI(imask);
3400bf4a:	68f8      	ldr	r0, [r7, #12]
3400bf4c:	f001 fcff 	bl	3400d94e <set_basepri>
	return c;
3400bf50:	68bb      	ldr	r3, [r7, #8]
}
3400bf52:	4618      	mov	r0, r3
3400bf54:	3710      	adds	r7, #16
3400bf56:	46bd      	mov	sp, r7
3400bf58:	bd80      	pop	{r7, pc}

3400bf5a <Dec>:
Inline INT Dec( FastLock *lock )
{
3400bf5a:	b580      	push	{r7, lr}
3400bf5c:	b084      	sub	sp, #16
3400bf5e:	af00      	add	r7, sp, #0
3400bf60:	6078      	str	r0, [r7, #4]
	UINT	imask;
	INT	c;
	DI(imask);
3400bf62:	f001 fd10 	bl	3400d986 <disint>
3400bf66:	60f8      	str	r0, [r7, #12]
	c = lock->cnt--;
3400bf68:	687b      	ldr	r3, [r7, #4]
3400bf6a:	681b      	ldr	r3, [r3, #0]
3400bf6c:	1e59      	subs	r1, r3, #1
3400bf6e:	687a      	ldr	r2, [r7, #4]
3400bf70:	6011      	str	r1, [r2, #0]
3400bf72:	60bb      	str	r3, [r7, #8]
	EI(imask);
3400bf74:	68f8      	ldr	r0, [r7, #12]
3400bf76:	f001 fcea 	bl	3400d94e <set_basepri>
	return c;
3400bf7a:	68bb      	ldr	r3, [r7, #8]
}
3400bf7c:	4618      	mov	r0, r3
3400bf7e:	3710      	adds	r7, #16
3400bf80:	46bd      	mov	sp, r7
3400bf82:	bd80      	pop	{r7, pc}

3400bf84 <Lock>:

/*
 * Lock 
 */
EXPORT void Lock( FastLock *lock )
{
3400bf84:	b580      	push	{r7, lr}
3400bf86:	b082      	sub	sp, #8
3400bf88:	af00      	add	r7, sp, #0
3400bf8a:	6078      	str	r0, [r7, #4]
	if ( Inc(lock) > 0 ) {
3400bf8c:	6878      	ldr	r0, [r7, #4]
3400bf8e:	f7ff ffcd 	bl	3400bf2c <Inc>
3400bf92:	4603      	mov	r3, r0
3400bf94:	2b00      	cmp	r3, #0
3400bf96:	dd07      	ble.n	3400bfa8 <Lock+0x24>
		tk_wai_sem(lock->id, 1, TMO_FEVR);
3400bf98:	687b      	ldr	r3, [r7, #4]
3400bf9a:	685b      	ldr	r3, [r3, #4]
3400bf9c:	f04f 32ff 	mov.w	r2, #4294967295
3400bfa0:	2101      	movs	r1, #1
3400bfa2:	4618      	mov	r0, r3
3400bfa4:	f7fe fd82 	bl	3400aaac <tk_wai_sem>
	}
}
3400bfa8:	bf00      	nop
3400bfaa:	3708      	adds	r7, #8
3400bfac:	46bd      	mov	sp, r7
3400bfae:	bd80      	pop	{r7, pc}

3400bfb0 <Unlock>:

/*
 * Lock release
 */
EXPORT void Unlock( FastLock *lock )
{
3400bfb0:	b580      	push	{r7, lr}
3400bfb2:	b082      	sub	sp, #8
3400bfb4:	af00      	add	r7, sp, #0
3400bfb6:	6078      	str	r0, [r7, #4]
	if ( Dec(lock) > 0 ) {
3400bfb8:	6878      	ldr	r0, [r7, #4]
3400bfba:	f7ff ffce 	bl	3400bf5a <Dec>
3400bfbe:	4603      	mov	r3, r0
3400bfc0:	2b00      	cmp	r3, #0
3400bfc2:	dd05      	ble.n	3400bfd0 <Unlock+0x20>
		tk_sig_sem(lock->id, 1);
3400bfc4:	687b      	ldr	r3, [r7, #4]
3400bfc6:	685b      	ldr	r3, [r3, #4]
3400bfc8:	2101      	movs	r1, #1
3400bfca:	4618      	mov	r0, r3
3400bfcc:	f7fe fc96 	bl	3400a8fc <tk_sig_sem>
	}
}
3400bfd0:	bf00      	nop
3400bfd2:	3708      	adds	r7, #8
3400bfd4:	46bd      	mov	sp, r7
3400bfd6:	bd80      	pop	{r7, pc}

3400bfd8 <CreateLock>:

/*
 * Create high-speed lock 
 */
EXPORT ER CreateLock( FastLock *lock, CONST UB *name )
{
3400bfd8:	b580      	push	{r7, lr}
3400bfda:	b08a      	sub	sp, #40	@ 0x28
3400bfdc:	af00      	add	r7, sp, #0
3400bfde:	6078      	str	r0, [r7, #4]
3400bfe0:	6039      	str	r1, [r7, #0]
	T_CSEM	csem;
	ER	ercd;

	csem.sematr  = TA_TPRI;
3400bfe2:	2301      	movs	r3, #1
3400bfe4:	60fb      	str	r3, [r7, #12]
	csem.isemcnt = 0;
3400bfe6:	2300      	movs	r3, #0
3400bfe8:	613b      	str	r3, [r7, #16]
	csem.maxsem  = 1;
3400bfea:	2301      	movs	r3, #1
3400bfec:	617b      	str	r3, [r7, #20]
	SetOBJNAME(csem.exinf, "FLOC");
3400bfee:	f107 0308 	add.w	r3, r7, #8
3400bff2:	627b      	str	r3, [r7, #36]	@ 0x24
3400bff4:	4b16      	ldr	r3, [pc, #88]	@ (3400c050 <CreateLock+0x78>)
3400bff6:	623b      	str	r3, [r7, #32]
3400bff8:	2300      	movs	r3, #0
3400bffa:	61fb      	str	r3, [r7, #28]
3400bffc:	e00a      	b.n	3400c014 <CreateLock+0x3c>
3400bffe:	6a3a      	ldr	r2, [r7, #32]
3400c000:	1c53      	adds	r3, r2, #1
3400c002:	623b      	str	r3, [r7, #32]
3400c004:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400c006:	1c59      	adds	r1, r3, #1
3400c008:	6279      	str	r1, [r7, #36]	@ 0x24
3400c00a:	7812      	ldrb	r2, [r2, #0]
3400c00c:	701a      	strb	r2, [r3, #0]
3400c00e:	69fb      	ldr	r3, [r7, #28]
3400c010:	3301      	adds	r3, #1
3400c012:	61fb      	str	r3, [r7, #28]
3400c014:	69fb      	ldr	r3, [r7, #28]
3400c016:	2b03      	cmp	r3, #3
3400c018:	ddf1      	ble.n	3400bffe <CreateLock+0x26>

	ercd = tk_cre_sem(&csem);
3400c01a:	f107 0308 	add.w	r3, r7, #8
3400c01e:	4618      	mov	r0, r3
3400c020:	f7fe fba2 	bl	3400a768 <tk_cre_sem>
3400c024:	61b8      	str	r0, [r7, #24]
	if ( ercd < E_OK ) {
3400c026:	69bb      	ldr	r3, [r7, #24]
3400c028:	2b00      	cmp	r3, #0
3400c02a:	da01      	bge.n	3400c030 <CreateLock+0x58>
		return ercd;
3400c02c:	69bb      	ldr	r3, [r7, #24]
3400c02e:	e00a      	b.n	3400c046 <CreateLock+0x6e>
	}

	lock->id = ercd;
3400c030:	687b      	ldr	r3, [r7, #4]
3400c032:	69ba      	ldr	r2, [r7, #24]
3400c034:	605a      	str	r2, [r3, #4]
	lock->cnt = -1;
3400c036:	687b      	ldr	r3, [r7, #4]
3400c038:	f04f 32ff 	mov.w	r2, #4294967295
3400c03c:	601a      	str	r2, [r3, #0]
	lock->name = name;
3400c03e:	687b      	ldr	r3, [r7, #4]
3400c040:	683a      	ldr	r2, [r7, #0]
3400c042:	609a      	str	r2, [r3, #8]
  
	return E_OK;
3400c044:	2300      	movs	r3, #0
}
3400c046:	4618      	mov	r0, r3
3400c048:	3728      	adds	r7, #40	@ 0x28
3400c04a:	46bd      	mov	sp, r7
3400c04c:	bd80      	pop	{r7, pc}
3400c04e:	bf00      	nop
3400c050:	3400de44 	.word	0x3400de44

3400c054 <DeleteLock>:

/*
 * Delete high-speed lock
 */
EXPORT void DeleteLock( FastLock *lock )
{
3400c054:	b580      	push	{r7, lr}
3400c056:	b082      	sub	sp, #8
3400c058:	af00      	add	r7, sp, #0
3400c05a:	6078      	str	r0, [r7, #4]
	if ( lock->id > 0 ) {
3400c05c:	687b      	ldr	r3, [r7, #4]
3400c05e:	685b      	ldr	r3, [r3, #4]
3400c060:	2b00      	cmp	r3, #0
3400c062:	dd04      	ble.n	3400c06e <DeleteLock+0x1a>
		tk_del_sem(lock->id);
3400c064:	687b      	ldr	r3, [r7, #4]
3400c066:	685b      	ldr	r3, [r3, #4]
3400c068:	4618      	mov	r0, r3
3400c06a:	f7fe fbf7 	bl	3400a85c <tk_del_sem>
	}
	lock->id = 0;
3400c06e:	687b      	ldr	r3, [r7, #4]
3400c070:	2200      	movs	r2, #0
3400c072:	605a      	str	r2, [r3, #4]
}
3400c074:	bf00      	nop
3400c076:	3708      	adds	r7, #8
3400c078:	46bd      	mov	sp, r7
3400c07a:	bd80      	pop	{r7, pc}

3400c07c <INC>:
 *
 *	The above must be operated exclusively.
 */

Inline void INC( INT *val )
{
3400c07c:	b580      	push	{r7, lr}
3400c07e:	b084      	sub	sp, #16
3400c080:	af00      	add	r7, sp, #0
3400c082:	6078      	str	r0, [r7, #4]
	UINT	imask;

	DI(imask);
3400c084:	f001 fc7f 	bl	3400d986 <disint>
3400c088:	60f8      	str	r0, [r7, #12]
	(*val)++;
3400c08a:	687b      	ldr	r3, [r7, #4]
3400c08c:	681b      	ldr	r3, [r3, #0]
3400c08e:	1c5a      	adds	r2, r3, #1
3400c090:	687b      	ldr	r3, [r7, #4]
3400c092:	601a      	str	r2, [r3, #0]
	EI(imask);
3400c094:	68f8      	ldr	r0, [r7, #12]
3400c096:	f001 fc5a 	bl	3400d94e <set_basepri>
}
3400c09a:	bf00      	nop
3400c09c:	3710      	adds	r7, #16
3400c09e:	46bd      	mov	sp, r7
3400c0a0:	bd80      	pop	{r7, pc}

3400c0a2 <DEC>:

Inline void DEC( INT *val )
{
3400c0a2:	b580      	push	{r7, lr}
3400c0a4:	b084      	sub	sp, #16
3400c0a6:	af00      	add	r7, sp, #0
3400c0a8:	6078      	str	r0, [r7, #4]
	UINT	imask;

	DI(imask);
3400c0aa:	f001 fc6c 	bl	3400d986 <disint>
3400c0ae:	60f8      	str	r0, [r7, #12]
	(*val)--;
3400c0b0:	687b      	ldr	r3, [r7, #4]
3400c0b2:	681b      	ldr	r3, [r3, #0]
3400c0b4:	1e5a      	subs	r2, r3, #1
3400c0b6:	687b      	ldr	r3, [r7, #4]
3400c0b8:	601a      	str	r2, [r3, #0]
	EI(imask);
3400c0ba:	68f8      	ldr	r0, [r7, #12]
3400c0bc:	f001 fc47 	bl	3400d94e <set_basepri>
}
3400c0c0:	bf00      	nop
3400c0c2:	3710      	adds	r7, #16
3400c0c4:	46bd      	mov	sp, r7
3400c0c6:	bd80      	pop	{r7, pc}

3400c0c8 <BTS>:

Inline BOOL BTS( UINT *val, INT no )
{
3400c0c8:	b580      	push	{r7, lr}
3400c0ca:	b086      	sub	sp, #24
3400c0cc:	af00      	add	r7, sp, #0
3400c0ce:	6078      	str	r0, [r7, #4]
3400c0d0:	6039      	str	r1, [r7, #0]
	UINT	imask;
	UINT	b;
	UINT	bm = (UINT)(1 << no);
3400c0d2:	2201      	movs	r2, #1
3400c0d4:	683b      	ldr	r3, [r7, #0]
3400c0d6:	fa02 f303 	lsl.w	r3, r2, r3
3400c0da:	617b      	str	r3, [r7, #20]

	DI(imask);
3400c0dc:	f001 fc53 	bl	3400d986 <disint>
3400c0e0:	6138      	str	r0, [r7, #16]
	b = *val & bm;
3400c0e2:	687b      	ldr	r3, [r7, #4]
3400c0e4:	681b      	ldr	r3, [r3, #0]
3400c0e6:	697a      	ldr	r2, [r7, #20]
3400c0e8:	4013      	ands	r3, r2
3400c0ea:	60fb      	str	r3, [r7, #12]
	*val |= bm;
3400c0ec:	687b      	ldr	r3, [r7, #4]
3400c0ee:	681a      	ldr	r2, [r3, #0]
3400c0f0:	697b      	ldr	r3, [r7, #20]
3400c0f2:	431a      	orrs	r2, r3
3400c0f4:	687b      	ldr	r3, [r7, #4]
3400c0f6:	601a      	str	r2, [r3, #0]
	EI(imask);
3400c0f8:	6938      	ldr	r0, [r7, #16]
3400c0fa:	f001 fc28 	bl	3400d94e <set_basepri>
	return (BOOL)b;
3400c0fe:	68fb      	ldr	r3, [r7, #12]
}
3400c100:	4618      	mov	r0, r3
3400c102:	3718      	adds	r7, #24
3400c104:	46bd      	mov	sp, r7
3400c106:	bd80      	pop	{r7, pc}

3400c108 <BR>:

Inline void BR( UINT *val, INT no )
{
3400c108:	b580      	push	{r7, lr}
3400c10a:	b084      	sub	sp, #16
3400c10c:	af00      	add	r7, sp, #0
3400c10e:	6078      	str	r0, [r7, #4]
3400c110:	6039      	str	r1, [r7, #0]
	UINT	imask;

	DI(imask);
3400c112:	f001 fc38 	bl	3400d986 <disint>
3400c116:	60f8      	str	r0, [r7, #12]
	*val &= ~(UINT)(1 << no);
3400c118:	687b      	ldr	r3, [r7, #4]
3400c11a:	681a      	ldr	r2, [r3, #0]
3400c11c:	2101      	movs	r1, #1
3400c11e:	683b      	ldr	r3, [r7, #0]
3400c120:	fa01 f303 	lsl.w	r3, r1, r3
3400c124:	43db      	mvns	r3, r3
3400c126:	401a      	ands	r2, r3
3400c128:	687b      	ldr	r3, [r7, #4]
3400c12a:	601a      	str	r2, [r3, #0]
	EI(imask);
3400c12c:	68f8      	ldr	r0, [r7, #12]
3400c12e:	f001 fc0e 	bl	3400d94e <set_basepri>
}
3400c132:	bf00      	nop
3400c134:	3710      	adds	r7, #16
3400c136:	46bd      	mov	sp, r7
3400c138:	bd80      	pop	{r7, pc}

3400c13a <MLockTmo>:
/*
 * Lock with wait time designation 
 *	no	lock number 0 - 31 
 */
EXPORT ER MLockTmo( FastMLock *lock, INT no, TMO tmo )
{
3400c13a:	b580      	push	{r7, lr}
3400c13c:	b08a      	sub	sp, #40	@ 0x28
3400c13e:	af02      	add	r7, sp, #8
3400c140:	60f8      	str	r0, [r7, #12]
3400c142:	60b9      	str	r1, [r7, #8]
3400c144:	607a      	str	r2, [r7, #4]
	UINT	ptn = (UINT)(1 << no);
3400c146:	2201      	movs	r2, #1
3400c148:	68bb      	ldr	r3, [r7, #8]
3400c14a:	fa02 f303 	lsl.w	r3, r2, r3
3400c14e:	61bb      	str	r3, [r7, #24]
	UINT	flg;
	ER	ercd;

	INC(&lock->wai);
3400c150:	68fb      	ldr	r3, [r7, #12]
3400c152:	3304      	adds	r3, #4
3400c154:	4618      	mov	r0, r3
3400c156:	f7ff ff91 	bl	3400c07c <INC>
	for ( ;; ) {
		if ( !BTS(&lock->flg, no) ) {
3400c15a:	68fb      	ldr	r3, [r7, #12]
3400c15c:	68b9      	ldr	r1, [r7, #8]
3400c15e:	4618      	mov	r0, r3
3400c160:	f7ff ffb2 	bl	3400c0c8 <BTS>
3400c164:	4603      	mov	r3, r0
3400c166:	2b00      	cmp	r3, #0
3400c168:	d102      	bne.n	3400c170 <MLockTmo+0x36>
			ercd = E_OK;
3400c16a:	2300      	movs	r3, #0
3400c16c:	61fb      	str	r3, [r7, #28]
			break;
3400c16e:	e010      	b.n	3400c192 <MLockTmo+0x58>
		}

		ercd = tk_wai_flg(lock->id, ptn, TWF_ORW|TWF_BITCLR, &flg, tmo);
3400c170:	68fb      	ldr	r3, [r7, #12]
3400c172:	6898      	ldr	r0, [r3, #8]
3400c174:	f107 0214 	add.w	r2, r7, #20
3400c178:	687b      	ldr	r3, [r7, #4]
3400c17a:	9300      	str	r3, [sp, #0]
3400c17c:	4613      	mov	r3, r2
3400c17e:	2221      	movs	r2, #33	@ 0x21
3400c180:	69b9      	ldr	r1, [r7, #24]
3400c182:	f7fd fd9b 	bl	34009cbc <tk_wai_flg>
3400c186:	61f8      	str	r0, [r7, #28]
		if ( ercd < E_OK ) {
3400c188:	69fb      	ldr	r3, [r7, #28]
3400c18a:	2b00      	cmp	r3, #0
3400c18c:	db00      	blt.n	3400c190 <MLockTmo+0x56>
		if ( !BTS(&lock->flg, no) ) {
3400c18e:	e7e4      	b.n	3400c15a <MLockTmo+0x20>
			break;
3400c190:	bf00      	nop
		}
	}
	DEC(&lock->wai);
3400c192:	68fb      	ldr	r3, [r7, #12]
3400c194:	3304      	adds	r3, #4
3400c196:	4618      	mov	r0, r3
3400c198:	f7ff ff83 	bl	3400c0a2 <DEC>

	return ercd;
3400c19c:	69fb      	ldr	r3, [r7, #28]
}
3400c19e:	4618      	mov	r0, r3
3400c1a0:	3720      	adds	r7, #32
3400c1a2:	46bd      	mov	sp, r7
3400c1a4:	bd80      	pop	{r7, pc}

3400c1a6 <MLock>:
/*
 * Lock 
 *	no	Lock number 0 - 31 
 */
EXPORT ER MLock( FastMLock *lock, INT no )
{
3400c1a6:	b580      	push	{r7, lr}
3400c1a8:	b082      	sub	sp, #8
3400c1aa:	af00      	add	r7, sp, #0
3400c1ac:	6078      	str	r0, [r7, #4]
3400c1ae:	6039      	str	r1, [r7, #0]
	return MLockTmo(lock, no, TMO_FEVR);
3400c1b0:	f04f 32ff 	mov.w	r2, #4294967295
3400c1b4:	6839      	ldr	r1, [r7, #0]
3400c1b6:	6878      	ldr	r0, [r7, #4]
3400c1b8:	f7ff ffbf 	bl	3400c13a <MLockTmo>
3400c1bc:	4603      	mov	r3, r0
}
3400c1be:	4618      	mov	r0, r3
3400c1c0:	3708      	adds	r7, #8
3400c1c2:	46bd      	mov	sp, r7
3400c1c4:	bd80      	pop	{r7, pc}

3400c1c6 <MUnlock>:
/*
 * Lock release 
 *	no	Lock number 0 - 31 
 */
EXPORT ER MUnlock( FastMLock *lock, INT no )
{
3400c1c6:	b580      	push	{r7, lr}
3400c1c8:	b084      	sub	sp, #16
3400c1ca:	af00      	add	r7, sp, #0
3400c1cc:	6078      	str	r0, [r7, #4]
3400c1ce:	6039      	str	r1, [r7, #0]
	UINT	ptn = (UINT)(1 << no);
3400c1d0:	2201      	movs	r2, #1
3400c1d2:	683b      	ldr	r3, [r7, #0]
3400c1d4:	fa02 f303 	lsl.w	r3, r2, r3
3400c1d8:	60fb      	str	r3, [r7, #12]
	ER	ercd;

	BR(&lock->flg, no);
3400c1da:	687b      	ldr	r3, [r7, #4]
3400c1dc:	6839      	ldr	r1, [r7, #0]
3400c1de:	4618      	mov	r0, r3
3400c1e0:	f7ff ff92 	bl	3400c108 <BR>
	ercd = ( lock->wai == 0 )? E_OK: tk_set_flg(lock->id, ptn);
3400c1e4:	687b      	ldr	r3, [r7, #4]
3400c1e6:	685b      	ldr	r3, [r3, #4]
3400c1e8:	2b00      	cmp	r3, #0
3400c1ea:	d007      	beq.n	3400c1fc <MUnlock+0x36>
3400c1ec:	687b      	ldr	r3, [r7, #4]
3400c1ee:	689b      	ldr	r3, [r3, #8]
3400c1f0:	68f9      	ldr	r1, [r7, #12]
3400c1f2:	4618      	mov	r0, r3
3400c1f4:	f7fd fc76 	bl	34009ae4 <tk_set_flg>
3400c1f8:	4603      	mov	r3, r0
3400c1fa:	e000      	b.n	3400c1fe <MUnlock+0x38>
3400c1fc:	2300      	movs	r3, #0
3400c1fe:	60bb      	str	r3, [r7, #8]

	return ercd;
3400c200:	68bb      	ldr	r3, [r7, #8]
}
3400c202:	4618      	mov	r0, r3
3400c204:	3710      	adds	r7, #16
3400c206:	46bd      	mov	sp, r7
3400c208:	bd80      	pop	{r7, pc}
	...

3400c20c <CreateMLock>:

/*
 * Create multi-lock 
 */
EXPORT ER CreateMLock( FastMLock *lock, CONST UB *name )
{
3400c20c:	b580      	push	{r7, lr}
3400c20e:	b08a      	sub	sp, #40	@ 0x28
3400c210:	af00      	add	r7, sp, #0
3400c212:	6078      	str	r0, [r7, #4]
3400c214:	6039      	str	r1, [r7, #0]
	T_CFLG	cflg;
	ER	ercd;

	cflg.flgatr  = TA_TPRI | TA_WMUL;
3400c216:	2309      	movs	r3, #9
3400c218:	613b      	str	r3, [r7, #16]
	cflg.iflgptn = 0;
3400c21a:	2300      	movs	r3, #0
3400c21c:	617b      	str	r3, [r7, #20]
	SetOBJNAME(cflg.exinf, "MLOC");
3400c21e:	f107 030c 	add.w	r3, r7, #12
3400c222:	627b      	str	r3, [r7, #36]	@ 0x24
3400c224:	4b17      	ldr	r3, [pc, #92]	@ (3400c284 <CreateMLock+0x78>)
3400c226:	623b      	str	r3, [r7, #32]
3400c228:	2300      	movs	r3, #0
3400c22a:	61fb      	str	r3, [r7, #28]
3400c22c:	e00a      	b.n	3400c244 <CreateMLock+0x38>
3400c22e:	6a3a      	ldr	r2, [r7, #32]
3400c230:	1c53      	adds	r3, r2, #1
3400c232:	623b      	str	r3, [r7, #32]
3400c234:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400c236:	1c59      	adds	r1, r3, #1
3400c238:	6279      	str	r1, [r7, #36]	@ 0x24
3400c23a:	7812      	ldrb	r2, [r2, #0]
3400c23c:	701a      	strb	r2, [r3, #0]
3400c23e:	69fb      	ldr	r3, [r7, #28]
3400c240:	3301      	adds	r3, #1
3400c242:	61fb      	str	r3, [r7, #28]
3400c244:	69fb      	ldr	r3, [r7, #28]
3400c246:	2b03      	cmp	r3, #3
3400c248:	ddf1      	ble.n	3400c22e <CreateMLock+0x22>

	lock->id = ercd = tk_cre_flg(&cflg);
3400c24a:	f107 030c 	add.w	r3, r7, #12
3400c24e:	4618      	mov	r0, r3
3400c250:	f7fd fb98 	bl	34009984 <tk_cre_flg>
3400c254:	61b8      	str	r0, [r7, #24]
3400c256:	687b      	ldr	r3, [r7, #4]
3400c258:	69ba      	ldr	r2, [r7, #24]
3400c25a:	609a      	str	r2, [r3, #8]
	if ( ercd < E_OK ) {
3400c25c:	69bb      	ldr	r3, [r7, #24]
3400c25e:	2b00      	cmp	r3, #0
3400c260:	da01      	bge.n	3400c266 <CreateMLock+0x5a>
		return ercd;
3400c262:	69bb      	ldr	r3, [r7, #24]
3400c264:	e009      	b.n	3400c27a <CreateMLock+0x6e>
	}

	lock->wai = 0;
3400c266:	687b      	ldr	r3, [r7, #4]
3400c268:	2200      	movs	r2, #0
3400c26a:	605a      	str	r2, [r3, #4]
	lock->flg = 0;
3400c26c:	687b      	ldr	r3, [r7, #4]
3400c26e:	2200      	movs	r2, #0
3400c270:	601a      	str	r2, [r3, #0]
	lock->name = name;
3400c272:	687b      	ldr	r3, [r7, #4]
3400c274:	683a      	ldr	r2, [r7, #0]
3400c276:	60da      	str	r2, [r3, #12]

	return E_OK;
3400c278:	2300      	movs	r3, #0
}
3400c27a:	4618      	mov	r0, r3
3400c27c:	3728      	adds	r7, #40	@ 0x28
3400c27e:	46bd      	mov	sp, r7
3400c280:	bd80      	pop	{r7, pc}
3400c282:	bf00      	nop
3400c284:	3400de4c 	.word	0x3400de4c

3400c288 <DeleteMLock>:

/*
 * Delete multi-lock 
 */
EXPORT ER DeleteMLock( FastMLock *lock )
{
3400c288:	b580      	push	{r7, lr}
3400c28a:	b084      	sub	sp, #16
3400c28c:	af00      	add	r7, sp, #0
3400c28e:	6078      	str	r0, [r7, #4]
	ER	ercd;

	if ( lock->id <= 0 ) {
3400c290:	687b      	ldr	r3, [r7, #4]
3400c292:	689b      	ldr	r3, [r3, #8]
3400c294:	2b00      	cmp	r3, #0
3400c296:	dc02      	bgt.n	3400c29e <DeleteMLock+0x16>
		return E_PAR;
3400c298:	f06f 0310 	mvn.w	r3, #16
3400c29c:	e00e      	b.n	3400c2bc <DeleteMLock+0x34>
	}

	ercd = tk_del_flg(lock->id);
3400c29e:	687b      	ldr	r3, [r7, #4]
3400c2a0:	689b      	ldr	r3, [r3, #8]
3400c2a2:	4618      	mov	r0, r3
3400c2a4:	f7fd fbce 	bl	34009a44 <tk_del_flg>
3400c2a8:	60f8      	str	r0, [r7, #12]
	if ( ercd < E_OK ) {
3400c2aa:	68fb      	ldr	r3, [r7, #12]
3400c2ac:	2b00      	cmp	r3, #0
3400c2ae:	da01      	bge.n	3400c2b4 <DeleteMLock+0x2c>
		return ercd;
3400c2b0:	68fb      	ldr	r3, [r7, #12]
3400c2b2:	e003      	b.n	3400c2bc <DeleteMLock+0x34>
	}

	lock->id = 0;
3400c2b4:	687b      	ldr	r3, [r7, #4]
3400c2b6:	2200      	movs	r2, #0
3400c2b8:	609a      	str	r2, [r3, #8]

	return E_OK;
3400c2ba:	2300      	movs	r3, #0
}
3400c2bc:	4618      	mov	r0, r3
3400c2be:	3710      	adds	r7, #16
3400c2c0:	46bd      	mov	sp, r7
3400c2c2:	bd80      	pop	{r7, pc}

3400c2c4 <Kmalloc>:
/* --------------------------------------------------------------------- */
/*
 * Memory allocation API definition
 */
EXPORT void* Kmalloc( size_t size )
{
3400c2c4:	b580      	push	{r7, lr}
3400c2c6:	b082      	sub	sp, #8
3400c2c8:	af00      	add	r7, sp, #0
3400c2ca:	6078      	str	r0, [r7, #4]
	return knl_Imalloc(size);
3400c2cc:	687b      	ldr	r3, [r7, #4]
3400c2ce:	4618      	mov	r0, r3
3400c2d0:	f7fd ff6a 	bl	3400a1a8 <knl_Imalloc>
3400c2d4:	4603      	mov	r3, r0
}
3400c2d6:	4618      	mov	r0, r3
3400c2d8:	3708      	adds	r7, #8
3400c2da:	46bd      	mov	sp, r7
3400c2dc:	bd80      	pop	{r7, pc}

3400c2de <Kfree>:
{
	return knl_Irealloc(ptr, size);
}

EXPORT void Kfree( void *ptr )
{
3400c2de:	b580      	push	{r7, lr}
3400c2e0:	b082      	sub	sp, #8
3400c2e2:	af00      	add	r7, sp, #0
3400c2e4:	6078      	str	r0, [r7, #4]
	knl_Ifree(ptr);
3400c2e6:	6878      	ldr	r0, [r7, #4]
3400c2e8:	f7fd ffb4 	bl	3400a254 <knl_Ifree>
}
3400c2ec:	bf00      	nop
3400c2ee:	3708      	adds	r7, #8
3400c2f0:	46bd      	mov	sp, r7
3400c2f2:	bd80      	pop	{r7, pc}

3400c2f4 <libtm_init>:
/*
 * libtm_init() - libtm Initialize
 * supported only on wait != 0 (polling not supported)
 */
EXPORT void libtm_init(void)
{
3400c2f4:	b580      	push	{r7, lr}
3400c2f6:	af00      	add	r7, sp, #0
	tm_com_init();
3400c2f8:	f001 fb86 	bl	3400da08 <tm_com_init>
}
3400c2fc:	bf00      	nop
3400c2fe:	bd80      	pop	{r7, pc}

3400c300 <tm_putchar>:
/*
 * tm_putchar()
 * Ctrl-C is not supported
 */
EXPORT INT tm_putchar( INT c )
{
3400c300:	b580      	push	{r7, lr}
3400c302:	b084      	sub	sp, #16
3400c304:	af00      	add	r7, sp, #0
3400c306:	6078      	str	r0, [r7, #4]
	static const char CR = CHR_CR;
	UB buf = (UB)c;
3400c308:	687b      	ldr	r3, [r7, #4]
3400c30a:	b2db      	uxtb	r3, r3
3400c30c:	72fb      	strb	r3, [r7, #11]
	INT imask;

	DI(imask);
3400c30e:	f001 fb3a 	bl	3400d986 <disint>
3400c312:	4603      	mov	r3, r0
3400c314:	60fb      	str	r3, [r7, #12]
	if (buf == CHR_LF) {
3400c316:	7afb      	ldrb	r3, [r7, #11]
3400c318:	2b0a      	cmp	r3, #10
3400c31a:	d103      	bne.n	3400c324 <tm_putchar+0x24>
		tm_snd_dat((const UB*)&CR, 1);
3400c31c:	2101      	movs	r1, #1
3400c31e:	4809      	ldr	r0, [pc, #36]	@ (3400c344 <tm_putchar+0x44>)
3400c320:	f001 fb44 	bl	3400d9ac <tm_snd_dat>
	}
	tm_snd_dat(&buf, 1);
3400c324:	f107 030b 	add.w	r3, r7, #11
3400c328:	2101      	movs	r1, #1
3400c32a:	4618      	mov	r0, r3
3400c32c:	f001 fb3e 	bl	3400d9ac <tm_snd_dat>
	EI(imask);
3400c330:	68fb      	ldr	r3, [r7, #12]
3400c332:	4618      	mov	r0, r3
3400c334:	f001 fb0b 	bl	3400d94e <set_basepri>

	return 0;
3400c338:	2300      	movs	r3, #0
}
3400c33a:	4618      	mov	r0, r3
3400c33c:	3710      	adds	r7, #16
3400c33e:	46bd      	mov	sp, r7
3400c340:	bd80      	pop	{r7, pc}
3400c342:	bf00      	nop
3400c344:	3400e06c 	.word	0x3400e06c

3400c348 <tm_putstring>:
/*
 * tm_putstring() - Put String
 * Ctrl-C is not supported
 */
EXPORT INT tm_putstring( const UB *buff )
{
3400c348:	b580      	push	{r7, lr}
3400c34a:	b084      	sub	sp, #16
3400c34c:	af00      	add	r7, sp, #0
3400c34e:	6078      	str	r0, [r7, #4]
	const UB* p = buff;
3400c350:	687b      	ldr	r3, [r7, #4]
3400c352:	60fb      	str	r3, [r7, #12]
	INT imask;

	DI(imask);
3400c354:	f001 fb17 	bl	3400d986 <disint>
3400c358:	4603      	mov	r3, r0
3400c35a:	60bb      	str	r3, [r7, #8]
	while ( *p != (UB)'\0' ) {
3400c35c:	e006      	b.n	3400c36c <tm_putstring+0x24>
		tm_putchar(*p++);
3400c35e:	68fb      	ldr	r3, [r7, #12]
3400c360:	1c5a      	adds	r2, r3, #1
3400c362:	60fa      	str	r2, [r7, #12]
3400c364:	781b      	ldrb	r3, [r3, #0]
3400c366:	4618      	mov	r0, r3
3400c368:	f7ff ffca 	bl	3400c300 <tm_putchar>
	while ( *p != (UB)'\0' ) {
3400c36c:	68fb      	ldr	r3, [r7, #12]
3400c36e:	781b      	ldrb	r3, [r3, #0]
3400c370:	2b00      	cmp	r3, #0
3400c372:	d1f4      	bne.n	3400c35e <tm_putstring+0x16>
	}
	EI(imask);
3400c374:	68bb      	ldr	r3, [r7, #8]
3400c376:	4618      	mov	r0, r3
3400c378:	f001 fae9 	bl	3400d94e <set_basepri>

	return 0;
3400c37c:	2300      	movs	r3, #0
}
3400c37e:	4618      	mov	r0, r3
3400c380:	3710      	adds	r7, #16
3400c382:	46bd      	mov	sp, r7
3400c384:	bd80      	pop	{r7, pc}
	...

3400c388 <outint>:

/*
 *	Output integer value
 */
LOCAL	UB	*outint( UB *ep, UW val, UB base )
{
3400c388:	b480      	push	{r7}
3400c38a:	b087      	sub	sp, #28
3400c38c:	af00      	add	r7, sp, #0
3400c38e:	60f8      	str	r0, [r7, #12]
3400c390:	60b9      	str	r1, [r7, #8]
3400c392:	4613      	mov	r3, r2
3400c394:	71fb      	strb	r3, [r7, #7]
LOCAL const UB  digits[32] = "0123456789abcdef0123456789ABCDEF";
	UB	caps;

	caps = (base & 0x40) >> 2;		/* 'a' or 'A' */
3400c396:	79fb      	ldrb	r3, [r7, #7]
3400c398:	109b      	asrs	r3, r3, #2
3400c39a:	b2db      	uxtb	r3, r3
3400c39c:	f003 0310 	and.w	r3, r3, #16
3400c3a0:	75fb      	strb	r3, [r7, #23]
	for (base &= 0x3F; val >= base; val /= base) {
3400c3a2:	79fb      	ldrb	r3, [r7, #7]
3400c3a4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3400c3a8:	71fb      	strb	r3, [r7, #7]
3400c3aa:	e014      	b.n	3400c3d6 <outint+0x4e>
		*--ep = digits[(val % base) + caps];
3400c3ac:	79fa      	ldrb	r2, [r7, #7]
3400c3ae:	68bb      	ldr	r3, [r7, #8]
3400c3b0:	fbb3 f1f2 	udiv	r1, r3, r2
3400c3b4:	fb01 f202 	mul.w	r2, r1, r2
3400c3b8:	1a9a      	subs	r2, r3, r2
3400c3ba:	7dfb      	ldrb	r3, [r7, #23]
3400c3bc:	4413      	add	r3, r2
3400c3be:	68fa      	ldr	r2, [r7, #12]
3400c3c0:	3a01      	subs	r2, #1
3400c3c2:	60fa      	str	r2, [r7, #12]
3400c3c4:	4a0e      	ldr	r2, [pc, #56]	@ (3400c400 <outint+0x78>)
3400c3c6:	5cd2      	ldrb	r2, [r2, r3]
3400c3c8:	68fb      	ldr	r3, [r7, #12]
3400c3ca:	701a      	strb	r2, [r3, #0]
	for (base &= 0x3F; val >= base; val /= base) {
3400c3cc:	79fb      	ldrb	r3, [r7, #7]
3400c3ce:	68ba      	ldr	r2, [r7, #8]
3400c3d0:	fbb2 f3f3 	udiv	r3, r2, r3
3400c3d4:	60bb      	str	r3, [r7, #8]
3400c3d6:	79fb      	ldrb	r3, [r7, #7]
3400c3d8:	68ba      	ldr	r2, [r7, #8]
3400c3da:	429a      	cmp	r2, r3
3400c3dc:	d2e6      	bcs.n	3400c3ac <outint+0x24>
	}
	*--ep = digits[val + caps];
3400c3de:	7dfa      	ldrb	r2, [r7, #23]
3400c3e0:	68bb      	ldr	r3, [r7, #8]
3400c3e2:	4413      	add	r3, r2
3400c3e4:	68fa      	ldr	r2, [r7, #12]
3400c3e6:	3a01      	subs	r2, #1
3400c3e8:	60fa      	str	r2, [r7, #12]
3400c3ea:	4a05      	ldr	r2, [pc, #20]	@ (3400c400 <outint+0x78>)
3400c3ec:	5cd2      	ldrb	r2, [r2, r3]
3400c3ee:	68fb      	ldr	r3, [r7, #12]
3400c3f0:	701a      	strb	r2, [r3, #0]
	return ep;				/* buffer top pointer */
3400c3f2:	68fb      	ldr	r3, [r7, #12]
}
3400c3f4:	4618      	mov	r0, r3
3400c3f6:	371c      	adds	r7, #28
3400c3f8:	46bd      	mov	sp, r7
3400c3fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c3fe:	4770      	bx	lr
3400c400:	3400e070 	.word	0x3400e070

3400c404 <tm_vsprintf>:

/*
 *	Output with format (limited version)
 */
LOCAL	void	tm_vsprintf( OutFn ostr, OutPar *par, const UB *fmt, va_list ap )
{
3400c404:	b580      	push	{r7, lr}
3400c406:	b090      	sub	sp, #64	@ 0x40
3400c408:	af00      	add	r7, sp, #0
3400c40a:	60f8      	str	r0, [r7, #12]
3400c40c:	60b9      	str	r1, [r7, #8]
3400c40e:	607a      	str	r2, [r7, #4]
3400c410:	603b      	str	r3, [r7, #0]
#define	F_PLUS		0x02
#define	F_SPACE		0x04
#define	F_PREFIX	0x08
#define	F_ZERO		0x10

	for (fms = NULL; (c = *fmt++) != '\0'; ) {
3400c412:	2300      	movs	r3, #0
3400c414:	633b      	str	r3, [r7, #48]	@ 0x30
3400c416:	e2f1      	b.n	3400c9fc <tm_vsprintf+0x5f8>

		if (c != '%') {	/* Fixed string */
3400c418:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c41c:	2b25      	cmp	r3, #37	@ 0x25
3400c41e:	d007      	beq.n	3400c430 <tm_vsprintf+0x2c>
			if (fms == NULL) fms = (UB*)fmt - 1;
3400c420:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c422:	2b00      	cmp	r3, #0
3400c424:	f040 82e9 	bne.w	3400c9fa <tm_vsprintf+0x5f6>
3400c428:	687b      	ldr	r3, [r7, #4]
3400c42a:	3b01      	subs	r3, #1
3400c42c:	633b      	str	r3, [r7, #48]	@ 0x30
			continue;
3400c42e:	e2e4      	b.n	3400c9fa <tm_vsprintf+0x5f6>
		}

		/* Output fix string */
		if (fms != NULL) {
3400c430:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c432:	2b00      	cmp	r3, #0
3400c434:	d009      	beq.n	3400c44a <tm_vsprintf+0x46>
			(*ostr)(fms, fmt - fms - 1, par);
3400c436:	687a      	ldr	r2, [r7, #4]
3400c438:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c43a:	1ad3      	subs	r3, r2, r3
3400c43c:	1e59      	subs	r1, r3, #1
3400c43e:	68fb      	ldr	r3, [r7, #12]
3400c440:	68ba      	ldr	r2, [r7, #8]
3400c442:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3400c444:	4798      	blx	r3
			fms = NULL;
3400c446:	2300      	movs	r3, #0
3400c448:	633b      	str	r3, [r7, #48]	@ 0x30
		}

		/* Get flags */
		for (flg = 0; ; ) {
3400c44a:	2300      	movs	r3, #0
3400c44c:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
			switch (c = *fmt++) {
3400c450:	687b      	ldr	r3, [r7, #4]
3400c452:	1c5a      	adds	r2, r3, #1
3400c454:	607a      	str	r2, [r7, #4]
3400c456:	781b      	ldrb	r3, [r3, #0]
3400c458:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400c45c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c460:	3b20      	subs	r3, #32
3400c462:	2b10      	cmp	r3, #16
3400c464:	d848      	bhi.n	3400c4f8 <tm_vsprintf+0xf4>
3400c466:	a201      	add	r2, pc, #4	@ (adr r2, 3400c46c <tm_vsprintf+0x68>)
3400c468:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400c46c:	3400c4cd 	.word	0x3400c4cd
3400c470:	3400c4f9 	.word	0x3400c4f9
3400c474:	3400c4f9 	.word	0x3400c4f9
3400c478:	3400c4db 	.word	0x3400c4db
3400c47c:	3400c4f9 	.word	0x3400c4f9
3400c480:	3400c4f9 	.word	0x3400c4f9
3400c484:	3400c4f9 	.word	0x3400c4f9
3400c488:	3400c4f9 	.word	0x3400c4f9
3400c48c:	3400c4f9 	.word	0x3400c4f9
3400c490:	3400c4f9 	.word	0x3400c4f9
3400c494:	3400c4f9 	.word	0x3400c4f9
3400c498:	3400c4bf 	.word	0x3400c4bf
3400c49c:	3400c4f9 	.word	0x3400c4f9
3400c4a0:	3400c4b1 	.word	0x3400c4b1
3400c4a4:	3400c4f9 	.word	0x3400c4f9
3400c4a8:	3400c4f9 	.word	0x3400c4f9
3400c4ac:	3400c4e9 	.word	0x3400c4e9
			case '-': flg |= F_LEFT;	continue;
3400c4b0:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c4b4:	f043 0301 	orr.w	r3, r3, #1
3400c4b8:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400c4bc:	e01b      	b.n	3400c4f6 <tm_vsprintf+0xf2>
			case '+': flg |= F_PLUS;	continue;
3400c4be:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c4c2:	f043 0302 	orr.w	r3, r3, #2
3400c4c6:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400c4ca:	e014      	b.n	3400c4f6 <tm_vsprintf+0xf2>
			case ' ': flg |= F_SPACE;	continue;
3400c4cc:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c4d0:	f043 0304 	orr.w	r3, r3, #4
3400c4d4:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400c4d8:	e00d      	b.n	3400c4f6 <tm_vsprintf+0xf2>
			case '#': flg |= F_PREFIX;	continue;
3400c4da:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c4de:	f043 0308 	orr.w	r3, r3, #8
3400c4e2:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400c4e6:	e006      	b.n	3400c4f6 <tm_vsprintf+0xf2>
			case '0': flg |= F_ZERO;	continue;
3400c4e8:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c4ec:	f043 0310 	orr.w	r3, r3, #16
3400c4f0:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400c4f4:	bf00      	nop
			switch (c = *fmt++) {
3400c4f6:	e7ab      	b.n	3400c450 <tm_vsprintf+0x4c>
			}
			break;
3400c4f8:	bf00      	nop
		}

		/* Get field width */
		if (c == '*') {
3400c4fa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c4fe:	2b2a      	cmp	r3, #42	@ 0x2a
3400c500:	d119      	bne.n	3400c536 <tm_vsprintf+0x132>
			wid = va_arg(ap, INT);
3400c502:	683b      	ldr	r3, [r7, #0]
3400c504:	1d1a      	adds	r2, r3, #4
3400c506:	603a      	str	r2, [r7, #0]
3400c508:	681b      	ldr	r3, [r3, #0]
3400c50a:	877b      	strh	r3, [r7, #58]	@ 0x3a
			if (wid < 0) {
3400c50c:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400c510:	2b00      	cmp	r3, #0
3400c512:	da09      	bge.n	3400c528 <tm_vsprintf+0x124>
				wid = -wid;
3400c514:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c516:	425b      	negs	r3, r3
3400c518:	b29b      	uxth	r3, r3
3400c51a:	877b      	strh	r3, [r7, #58]	@ 0x3a
				flg |= F_LEFT;
3400c51c:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c520:	f043 0301 	orr.w	r3, r3, #1
3400c524:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
			}
			c = *fmt++;
3400c528:	687b      	ldr	r3, [r7, #4]
3400c52a:	1c5a      	adds	r2, r3, #1
3400c52c:	607a      	str	r2, [r7, #4]
3400c52e:	781b      	ldrb	r3, [r3, #0]
3400c530:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400c534:	e01e      	b.n	3400c574 <tm_vsprintf+0x170>
		} else {
			for (wid = 0; c >= '0' && c <= '9'; c = *fmt++)
3400c536:	2300      	movs	r3, #0
3400c538:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400c53a:	e013      	b.n	3400c564 <tm_vsprintf+0x160>
				wid = wid * 10 + c - '0';
3400c53c:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c53e:	461a      	mov	r2, r3
3400c540:	0092      	lsls	r2, r2, #2
3400c542:	4413      	add	r3, r2
3400c544:	005b      	lsls	r3, r3, #1
3400c546:	b29a      	uxth	r2, r3
3400c548:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c54c:	b29b      	uxth	r3, r3
3400c54e:	4413      	add	r3, r2
3400c550:	b29b      	uxth	r3, r3
3400c552:	3b30      	subs	r3, #48	@ 0x30
3400c554:	b29b      	uxth	r3, r3
3400c556:	877b      	strh	r3, [r7, #58]	@ 0x3a
			for (wid = 0; c >= '0' && c <= '9'; c = *fmt++)
3400c558:	687b      	ldr	r3, [r7, #4]
3400c55a:	1c5a      	adds	r2, r3, #1
3400c55c:	607a      	str	r2, [r7, #4]
3400c55e:	781b      	ldrb	r3, [r3, #0]
3400c560:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400c564:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c568:	2b2f      	cmp	r3, #47	@ 0x2f
3400c56a:	d903      	bls.n	3400c574 <tm_vsprintf+0x170>
3400c56c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c570:	2b39      	cmp	r3, #57	@ 0x39
3400c572:	d9e3      	bls.n	3400c53c <tm_vsprintf+0x138>
		}

		/* Get precision */
		prec = -1;
3400c574:	f64f 73ff 	movw	r3, #65535	@ 0xffff
3400c578:	873b      	strh	r3, [r7, #56]	@ 0x38
		if (c == '.') {
3400c57a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c57e:	2b2e      	cmp	r3, #46	@ 0x2e
3400c580:	d140      	bne.n	3400c604 <tm_vsprintf+0x200>
			c = *fmt++;
3400c582:	687b      	ldr	r3, [r7, #4]
3400c584:	1c5a      	adds	r2, r3, #1
3400c586:	607a      	str	r2, [r7, #4]
3400c588:	781b      	ldrb	r3, [r3, #0]
3400c58a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (c == '*') {
3400c58e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c592:	2b2a      	cmp	r3, #42	@ 0x2a
3400c594:	d111      	bne.n	3400c5ba <tm_vsprintf+0x1b6>
				prec = va_arg(ap, INT);
3400c596:	683b      	ldr	r3, [r7, #0]
3400c598:	1d1a      	adds	r2, r3, #4
3400c59a:	603a      	str	r2, [r7, #0]
3400c59c:	681b      	ldr	r3, [r3, #0]
3400c59e:	873b      	strh	r3, [r7, #56]	@ 0x38
				if (prec < 0) prec = 0;
3400c5a0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400c5a4:	2b00      	cmp	r3, #0
3400c5a6:	da01      	bge.n	3400c5ac <tm_vsprintf+0x1a8>
3400c5a8:	2300      	movs	r3, #0
3400c5aa:	873b      	strh	r3, [r7, #56]	@ 0x38
				c = *fmt++;
3400c5ac:	687b      	ldr	r3, [r7, #4]
3400c5ae:	1c5a      	adds	r2, r3, #1
3400c5b0:	607a      	str	r2, [r7, #4]
3400c5b2:	781b      	ldrb	r3, [r3, #0]
3400c5b4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400c5b8:	e01e      	b.n	3400c5f8 <tm_vsprintf+0x1f4>
			} else {
				for (prec = 0;c >= '0' && c <= '9';c = *fmt++)
3400c5ba:	2300      	movs	r3, #0
3400c5bc:	873b      	strh	r3, [r7, #56]	@ 0x38
3400c5be:	e013      	b.n	3400c5e8 <tm_vsprintf+0x1e4>
					prec = prec * 10 + c - '0';
3400c5c0:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400c5c2:	461a      	mov	r2, r3
3400c5c4:	0092      	lsls	r2, r2, #2
3400c5c6:	4413      	add	r3, r2
3400c5c8:	005b      	lsls	r3, r3, #1
3400c5ca:	b29a      	uxth	r2, r3
3400c5cc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c5d0:	b29b      	uxth	r3, r3
3400c5d2:	4413      	add	r3, r2
3400c5d4:	b29b      	uxth	r3, r3
3400c5d6:	3b30      	subs	r3, #48	@ 0x30
3400c5d8:	b29b      	uxth	r3, r3
3400c5da:	873b      	strh	r3, [r7, #56]	@ 0x38
				for (prec = 0;c >= '0' && c <= '9';c = *fmt++)
3400c5dc:	687b      	ldr	r3, [r7, #4]
3400c5de:	1c5a      	adds	r2, r3, #1
3400c5e0:	607a      	str	r2, [r7, #4]
3400c5e2:	781b      	ldrb	r3, [r3, #0]
3400c5e4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400c5e8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c5ec:	2b2f      	cmp	r3, #47	@ 0x2f
3400c5ee:	d903      	bls.n	3400c5f8 <tm_vsprintf+0x1f4>
3400c5f0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c5f4:	2b39      	cmp	r3, #57	@ 0x39
3400c5f6:	d9e3      	bls.n	3400c5c0 <tm_vsprintf+0x1bc>
			}
			flg &= ~F_ZERO;		/* No ZERO padding */
3400c5f8:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c5fc:	f023 0310 	bic.w	r3, r3, #16
3400c600:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
		}

		/* Get qualifier */
		qual = 0;
3400c604:	2300      	movs	r3, #0
3400c606:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
		if (c == 'h' || c == 'l') {
3400c60a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c60e:	2b68      	cmp	r3, #104	@ 0x68
3400c610:	d003      	beq.n	3400c61a <tm_vsprintf+0x216>
3400c612:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c616:	2b6c      	cmp	r3, #108	@ 0x6c
3400c618:	d109      	bne.n	3400c62e <tm_vsprintf+0x22a>
			qual = c;
3400c61a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c61e:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
			c = *fmt++;
3400c622:	687b      	ldr	r3, [r7, #4]
3400c624:	1c5a      	adds	r2, r3, #1
3400c626:	607a      	str	r2, [r7, #4]
3400c628:	781b      	ldrb	r3, [r3, #0]
3400c62a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		}

		/* Format items */
		base = 10;
3400c62e:	230a      	movs	r3, #10
3400c630:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
		sign = 0;
3400c634:	2300      	movs	r3, #0
3400c636:	74fb      	strb	r3, [r7, #19]
		cbe = &cbuf[MAX_DIGITS];	/* buffer end pointer */
3400c638:	f107 0314 	add.w	r3, r7, #20
3400c63c:	330e      	adds	r3, #14
3400c63e:	62bb      	str	r3, [r7, #40]	@ 0x28

		switch (c) {
3400c640:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c644:	2b78      	cmp	r3, #120	@ 0x78
3400c646:	f300 814d 	bgt.w	3400c8e4 <tm_vsprintf+0x4e0>
3400c64a:	2b64      	cmp	r3, #100	@ 0x64
3400c64c:	da0b      	bge.n	3400c666 <tm_vsprintf+0x262>
3400c64e:	2b63      	cmp	r3, #99	@ 0x63
3400c650:	f000 8135 	beq.w	3400c8be <tm_vsprintf+0x4ba>
3400c654:	2b63      	cmp	r3, #99	@ 0x63
3400c656:	f300 8145 	bgt.w	3400c8e4 <tm_vsprintf+0x4e0>
3400c65a:	2b00      	cmp	r3, #0
3400c65c:	f000 813e 	beq.w	3400c8dc <tm_vsprintf+0x4d8>
3400c660:	2b58      	cmp	r3, #88	@ 0x58
3400c662:	d022      	beq.n	3400c6aa <tm_vsprintf+0x2a6>
3400c664:	e13e      	b.n	3400c8e4 <tm_vsprintf+0x4e0>
3400c666:	3b64      	subs	r3, #100	@ 0x64
3400c668:	2201      	movs	r2, #1
3400c66a:	fa02 f303 	lsl.w	r3, r2, r3
3400c66e:	4a9f      	ldr	r2, [pc, #636]	@ (3400c8ec <tm_vsprintf+0x4e8>)
3400c670:	401a      	ands	r2, r3
3400c672:	2a00      	cmp	r2, #0
3400c674:	bf14      	ite	ne
3400c676:	2201      	movne	r2, #1
3400c678:	2200      	moveq	r2, #0
3400c67a:	b2d2      	uxtb	r2, r2
3400c67c:	2a00      	cmp	r2, #0
3400c67e:	d114      	bne.n	3400c6aa <tm_vsprintf+0x2a6>
3400c680:	f403 4200 	and.w	r2, r3, #32768	@ 0x8000
3400c684:	2a00      	cmp	r2, #0
3400c686:	bf14      	ite	ne
3400c688:	2201      	movne	r2, #1
3400c68a:	2200      	moveq	r2, #0
3400c68c:	b2d2      	uxtb	r2, r2
3400c68e:	2a00      	cmp	r2, #0
3400c690:	f040 80f1 	bne.w	3400c876 <tm_vsprintf+0x472>
3400c694:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400c698:	2b00      	cmp	r3, #0
3400c69a:	bf14      	ite	ne
3400c69c:	2301      	movne	r3, #1
3400c69e:	2300      	moveq	r3, #0
3400c6a0:	b2db      	uxtb	r3, r3
3400c6a2:	2b00      	cmp	r3, #0
3400c6a4:	f040 80cf 	bne.w	3400c846 <tm_vsprintf+0x442>
3400c6a8:	e11c      	b.n	3400c8e4 <tm_vsprintf+0x4e0>
		case 'd':
		case 'u':
		case 'X':
		case 'x':
		case 'o':
			if (qual == 'l') {
3400c6aa:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3400c6ae:	2b6c      	cmp	r3, #108	@ 0x6c
3400c6b0:	d105      	bne.n	3400c6be <tm_vsprintf+0x2ba>
				v = va_arg(ap, UW);
3400c6b2:	683b      	ldr	r3, [r7, #0]
3400c6b4:	1d1a      	adds	r2, r3, #4
3400c6b6:	603a      	str	r2, [r7, #0]
3400c6b8:	681b      	ldr	r3, [r3, #0]
3400c6ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
3400c6bc:	e016      	b.n	3400c6ec <tm_vsprintf+0x2e8>
			} else {
				v = va_arg(ap, UINT);
3400c6be:	683b      	ldr	r3, [r7, #0]
3400c6c0:	1d1a      	adds	r2, r3, #4
3400c6c2:	603a      	str	r2, [r7, #0]
3400c6c4:	681b      	ldr	r3, [r3, #0]
3400c6c6:	63fb      	str	r3, [r7, #60]	@ 0x3c
				if (qual == 'h') {
3400c6c8:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3400c6cc:	2b68      	cmp	r3, #104	@ 0x68
3400c6ce:	d10d      	bne.n	3400c6ec <tm_vsprintf+0x2e8>
					v = (c == 'i' || c == 'd') ?
						(H)v :(UH)v;
3400c6d0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c6d4:	2b69      	cmp	r3, #105	@ 0x69
3400c6d6:	d003      	beq.n	3400c6e0 <tm_vsprintf+0x2dc>
					v = (c == 'i' || c == 'd') ?
3400c6d8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c6dc:	2b64      	cmp	r3, #100	@ 0x64
3400c6de:	d102      	bne.n	3400c6e6 <tm_vsprintf+0x2e2>
						(H)v :(UH)v;
3400c6e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c6e2:	b21b      	sxth	r3, r3
3400c6e4:	e001      	b.n	3400c6ea <tm_vsprintf+0x2e6>
3400c6e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c6e8:	b29b      	uxth	r3, r3
					v = (c == 'i' || c == 'd') ?
3400c6ea:	63fb      	str	r3, [r7, #60]	@ 0x3c
				}
			}
			switch (c) {
3400c6ec:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400c6f0:	3b58      	subs	r3, #88	@ 0x58
3400c6f2:	2b20      	cmp	r3, #32
3400c6f4:	f200 8094 	bhi.w	3400c820 <tm_vsprintf+0x41c>
3400c6f8:	a201      	add	r2, pc, #4	@ (adr r2, 3400c700 <tm_vsprintf+0x2fc>)
3400c6fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400c6fe:	bf00      	nop
3400c700:	3400c7c7 	.word	0x3400c7c7
3400c704:	3400c821 	.word	0x3400c821
3400c708:	3400c821 	.word	0x3400c821
3400c70c:	3400c821 	.word	0x3400c821
3400c710:	3400c821 	.word	0x3400c821
3400c714:	3400c821 	.word	0x3400c821
3400c718:	3400c821 	.word	0x3400c821
3400c71c:	3400c821 	.word	0x3400c821
3400c720:	3400c821 	.word	0x3400c821
3400c724:	3400c821 	.word	0x3400c821
3400c728:	3400c821 	.word	0x3400c821
3400c72c:	3400c821 	.word	0x3400c821
3400c730:	3400c785 	.word	0x3400c785
3400c734:	3400c821 	.word	0x3400c821
3400c738:	3400c821 	.word	0x3400c821
3400c73c:	3400c821 	.word	0x3400c821
3400c740:	3400c821 	.word	0x3400c821
3400c744:	3400c785 	.word	0x3400c785
3400c748:	3400c821 	.word	0x3400c821
3400c74c:	3400c821 	.word	0x3400c821
3400c750:	3400c821 	.word	0x3400c821
3400c754:	3400c821 	.word	0x3400c821
3400c758:	3400c821 	.word	0x3400c821
3400c75c:	3400c7db 	.word	0x3400c7db
3400c760:	3400c821 	.word	0x3400c821
3400c764:	3400c821 	.word	0x3400c821
3400c768:	3400c821 	.word	0x3400c821
3400c76c:	3400c821 	.word	0x3400c821
3400c770:	3400c821 	.word	0x3400c821
3400c774:	3400c821 	.word	0x3400c821
3400c778:	3400c821 	.word	0x3400c821
3400c77c:	3400c821 	.word	0x3400c821
3400c780:	3400c7d1 	.word	0x3400c7d1
			case 'i':
			case 'd':
				if ((W)v < 0) {
3400c784:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c786:	2b00      	cmp	r3, #0
3400c788:	da05      	bge.n	3400c796 <tm_vsprintf+0x392>
					v = - (W)v;
3400c78a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c78c:	425b      	negs	r3, r3
3400c78e:	63fb      	str	r3, [r7, #60]	@ 0x3c
					sign = '-';
3400c790:	232d      	movs	r3, #45	@ 0x2d
3400c792:	74fb      	strb	r3, [r7, #19]
3400c794:	e010      	b.n	3400c7b8 <tm_vsprintf+0x3b4>
				} else if ((flg & F_PLUS) != 0) {
3400c796:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c79a:	f003 0302 	and.w	r3, r3, #2
3400c79e:	2b00      	cmp	r3, #0
3400c7a0:	d002      	beq.n	3400c7a8 <tm_vsprintf+0x3a4>
					sign = '+';
3400c7a2:	232b      	movs	r3, #43	@ 0x2b
3400c7a4:	74fb      	strb	r3, [r7, #19]
3400c7a6:	e007      	b.n	3400c7b8 <tm_vsprintf+0x3b4>
				} else if ((flg & F_SPACE) != 0) {
3400c7a8:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c7ac:	f003 0304 	and.w	r3, r3, #4
3400c7b0:	2b00      	cmp	r3, #0
3400c7b2:	d032      	beq.n	3400c81a <tm_vsprintf+0x416>
					sign = ' ';
3400c7b4:	2320      	movs	r3, #32
3400c7b6:	74fb      	strb	r3, [r7, #19]
				} else {
					break;
				}
				wid--;		/* for sign */
3400c7b8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400c7bc:	b29b      	uxth	r3, r3
3400c7be:	3b01      	subs	r3, #1
3400c7c0:	b29b      	uxth	r3, r3
3400c7c2:	877b      	strh	r3, [r7, #58]	@ 0x3a
			case 'u':
				break;
3400c7c4:	e02c      	b.n	3400c820 <tm_vsprintf+0x41c>
			case 'X':
				base += 0x40;	/* base = 16 + 0x40 */
3400c7c6:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c7ca:	3340      	adds	r3, #64	@ 0x40
3400c7cc:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
			case 'x':
				base += 8;	/* base = 16 */
3400c7d0:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c7d4:	3308      	adds	r3, #8
3400c7d6:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
			case 'o':
				base -= 2;	/* base = 8 */
3400c7da:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c7de:	3b02      	subs	r3, #2
3400c7e0:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				if ((flg & F_PREFIX) != 0 && v != 0) {
3400c7e4:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c7e8:	f003 0308 	and.w	r3, r3, #8
3400c7ec:	2b00      	cmp	r3, #0
3400c7ee:	d016      	beq.n	3400c81e <tm_vsprintf+0x41a>
3400c7f0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c7f2:	2b00      	cmp	r3, #0
3400c7f4:	d013      	beq.n	3400c81e <tm_vsprintf+0x41a>
					wid -= (base == 8) ? 1 : 2;
3400c7f6:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
3400c7f8:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c7fc:	2b08      	cmp	r3, #8
3400c7fe:	d101      	bne.n	3400c804 <tm_vsprintf+0x400>
3400c800:	2301      	movs	r3, #1
3400c802:	e000      	b.n	3400c806 <tm_vsprintf+0x402>
3400c804:	2302      	movs	r3, #2
3400c806:	1ad3      	subs	r3, r2, r3
3400c808:	b29b      	uxth	r3, r3
3400c80a:	877b      	strh	r3, [r7, #58]	@ 0x3a
					base |= 0x80;
3400c80c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c810:	f063 037f 	orn	r3, r3, #127	@ 0x7f
3400c814:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				}
				break;
3400c818:	e001      	b.n	3400c81e <tm_vsprintf+0x41a>
					break;
3400c81a:	bf00      	nop
3400c81c:	e000      	b.n	3400c820 <tm_vsprintf+0x41c>
				break;
3400c81e:	bf00      	nop
			}
			/* Note: None outputs when v == 0 && prec == 0 */
			cbs = (v == 0 && prec == 0) ?
						cbe : outint(cbe, v, base);
3400c820:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c822:	2b00      	cmp	r3, #0
3400c824:	d103      	bne.n	3400c82e <tm_vsprintf+0x42a>
			cbs = (v == 0 && prec == 0) ?
3400c826:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400c82a:	2b00      	cmp	r3, #0
3400c82c:	d008      	beq.n	3400c840 <tm_vsprintf+0x43c>
						cbe : outint(cbe, v, base);
3400c82e:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c832:	461a      	mov	r2, r3
3400c834:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400c836:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
3400c838:	f7ff fda6 	bl	3400c388 <outint>
3400c83c:	4603      	mov	r3, r0
3400c83e:	e000      	b.n	3400c842 <tm_vsprintf+0x43e>
3400c840:	6abb      	ldr	r3, [r7, #40]	@ 0x28
			cbs = (v == 0 && prec == 0) ?
3400c842:	62fb      	str	r3, [r7, #44]	@ 0x2c
			break;
3400c844:	e055      	b.n	3400c8f2 <tm_vsprintf+0x4ee>
		case 'p':
			v = (UW)va_arg(ap, void *);
3400c846:	683b      	ldr	r3, [r7, #0]
3400c848:	1d1a      	adds	r2, r3, #4
3400c84a:	603a      	str	r2, [r7, #0]
3400c84c:	681b      	ldr	r3, [r3, #0]
3400c84e:	63fb      	str	r3, [r7, #60]	@ 0x3c
			if (v != 0) {
3400c850:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400c852:	2b00      	cmp	r3, #0
3400c854:	d006      	beq.n	3400c864 <tm_vsprintf+0x460>
				base = 16 | 0x80;
3400c856:	2390      	movs	r3, #144	@ 0x90
3400c858:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				wid -= 2;
3400c85c:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c85e:	3b02      	subs	r3, #2
3400c860:	b29b      	uxth	r3, r3
3400c862:	877b      	strh	r3, [r7, #58]	@ 0x3a
			}
			cbs = outint(cbe, v, base);
3400c864:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c868:	461a      	mov	r2, r3
3400c86a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400c86c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
3400c86e:	f7ff fd8b 	bl	3400c388 <outint>
3400c872:	62f8      	str	r0, [r7, #44]	@ 0x2c
			break;
3400c874:	e03d      	b.n	3400c8f2 <tm_vsprintf+0x4ee>
		case 's':
			cbe = cbs = va_arg(ap, UB *);
3400c876:	683b      	ldr	r3, [r7, #0]
3400c878:	1d1a      	adds	r2, r3, #4
3400c87a:	603a      	str	r2, [r7, #0]
3400c87c:	681b      	ldr	r3, [r3, #0]
3400c87e:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400c880:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400c882:	62bb      	str	r3, [r7, #40]	@ 0x28
			if (prec < 0) {
3400c884:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400c888:	2b00      	cmp	r3, #0
3400c88a:	da0b      	bge.n	3400c8a4 <tm_vsprintf+0x4a0>
				while (*cbe != '\0') cbe++;
3400c88c:	e002      	b.n	3400c894 <tm_vsprintf+0x490>
3400c88e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c890:	3301      	adds	r3, #1
3400c892:	62bb      	str	r3, [r7, #40]	@ 0x28
3400c894:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c896:	781b      	ldrb	r3, [r3, #0]
3400c898:	2b00      	cmp	r3, #0
3400c89a:	d1f8      	bne.n	3400c88e <tm_vsprintf+0x48a>
			} else {
				while (--prec >= 0 && *cbe != '\0') cbe++;
			}
			break;
3400c89c:	e028      	b.n	3400c8f0 <tm_vsprintf+0x4ec>
				while (--prec >= 0 && *cbe != '\0') cbe++;
3400c89e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8a0:	3301      	adds	r3, #1
3400c8a2:	62bb      	str	r3, [r7, #40]	@ 0x28
3400c8a4:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400c8a6:	3b01      	subs	r3, #1
3400c8a8:	b29b      	uxth	r3, r3
3400c8aa:	873b      	strh	r3, [r7, #56]	@ 0x38
3400c8ac:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400c8b0:	2b00      	cmp	r3, #0
3400c8b2:	db1d      	blt.n	3400c8f0 <tm_vsprintf+0x4ec>
3400c8b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8b6:	781b      	ldrb	r3, [r3, #0]
3400c8b8:	2b00      	cmp	r3, #0
3400c8ba:	d1f0      	bne.n	3400c89e <tm_vsprintf+0x49a>
			break;
3400c8bc:	e018      	b.n	3400c8f0 <tm_vsprintf+0x4ec>
		case 'c':
			cbs = cbe;
3400c8be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
			*--cbs = (UB)va_arg(ap, INT);
3400c8c2:	683b      	ldr	r3, [r7, #0]
3400c8c4:	1d1a      	adds	r2, r3, #4
3400c8c6:	603a      	str	r2, [r7, #0]
3400c8c8:	681a      	ldr	r2, [r3, #0]
3400c8ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400c8cc:	3b01      	subs	r3, #1
3400c8ce:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400c8d0:	b2d2      	uxtb	r2, r2
3400c8d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400c8d4:	701a      	strb	r2, [r3, #0]
			prec = 0;
3400c8d6:	2300      	movs	r3, #0
3400c8d8:	873b      	strh	r3, [r7, #56]	@ 0x38
			break;
3400c8da:	e00a      	b.n	3400c8f2 <tm_vsprintf+0x4ee>
		case '\0':
			fmt--;
3400c8dc:	687b      	ldr	r3, [r7, #4]
3400c8de:	3b01      	subs	r3, #1
3400c8e0:	607b      	str	r3, [r7, #4]
			continue;
3400c8e2:	e08b      	b.n	3400c9fc <tm_vsprintf+0x5f8>
		default:
			/* Output as fixed string */
			fms = (UB*)fmt - 1;
3400c8e4:	687b      	ldr	r3, [r7, #4]
3400c8e6:	3b01      	subs	r3, #1
3400c8e8:	633b      	str	r3, [r7, #48]	@ 0x30
			continue;
3400c8ea:	e087      	b.n	3400c9fc <tm_vsprintf+0x5f8>
3400c8ec:	00120821 	.word	0x00120821
			break;
3400c8f0:	bf00      	nop
		}

		n = cbe - cbs;				/* item length */
3400c8f2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400c8f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400c8f6:	1ad3      	subs	r3, r2, r3
3400c8f8:	86fb      	strh	r3, [r7, #54]	@ 0x36
		if ((prec -= n) > 0) n += prec;
3400c8fa:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
3400c8fc:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400c8fe:	1ad3      	subs	r3, r2, r3
3400c900:	b29b      	uxth	r3, r3
3400c902:	873b      	strh	r3, [r7, #56]	@ 0x38
3400c904:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400c908:	2b00      	cmp	r3, #0
3400c90a:	dd04      	ble.n	3400c916 <tm_vsprintf+0x512>
3400c90c:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
3400c90e:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400c910:	4413      	add	r3, r2
3400c912:	b29b      	uxth	r3, r3
3400c914:	86fb      	strh	r3, [r7, #54]	@ 0x36
		wid -= n;				/* pad length */
3400c916:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
3400c918:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400c91a:	1ad3      	subs	r3, r2, r3
3400c91c:	b29b      	uxth	r3, r3
3400c91e:	877b      	strh	r3, [r7, #58]	@ 0x3a

		/* Output preceding spaces */
		if ((flg & (F_LEFT | F_ZERO)) == 0 ) {
3400c920:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c924:	f003 0311 	and.w	r3, r3, #17
3400c928:	2b00      	cmp	r3, #0
3400c92a:	d10d      	bne.n	3400c948 <tm_vsprintf+0x544>
			while (--wid >= 0) (*ostr)((UB*)" ", 1, par);
3400c92c:	e004      	b.n	3400c938 <tm_vsprintf+0x534>
3400c92e:	68fb      	ldr	r3, [r7, #12]
3400c930:	68ba      	ldr	r2, [r7, #8]
3400c932:	2101      	movs	r1, #1
3400c934:	483e      	ldr	r0, [pc, #248]	@ (3400ca30 <tm_vsprintf+0x62c>)
3400c936:	4798      	blx	r3
3400c938:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c93a:	3b01      	subs	r3, #1
3400c93c:	b29b      	uxth	r3, r3
3400c93e:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400c940:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400c944:	2b00      	cmp	r3, #0
3400c946:	daf2      	bge.n	3400c92e <tm_vsprintf+0x52a>
		}

		/* Output sign */
		if (sign != 0) {
3400c948:	7cfb      	ldrb	r3, [r7, #19]
3400c94a:	2b00      	cmp	r3, #0
3400c94c:	d005      	beq.n	3400c95a <tm_vsprintf+0x556>
			(*ostr)(&sign, 1, par);
3400c94e:	f107 0013 	add.w	r0, r7, #19
3400c952:	68fb      	ldr	r3, [r7, #12]
3400c954:	68ba      	ldr	r2, [r7, #8]
3400c956:	2101      	movs	r1, #1
3400c958:	4798      	blx	r3
		}

		/* Output prefix "0x", "0X" or "0" */
		if ((base & 0x80) != 0) {
3400c95a:	f997 3026 	ldrsb.w	r3, [r7, #38]	@ 0x26
3400c95e:	2b00      	cmp	r3, #0
3400c960:	da17      	bge.n	3400c992 <tm_vsprintf+0x58e>
			(*ostr)((UB*)"0", 1, par);
3400c962:	68fb      	ldr	r3, [r7, #12]
3400c964:	68ba      	ldr	r2, [r7, #8]
3400c966:	2101      	movs	r1, #1
3400c968:	4832      	ldr	r0, [pc, #200]	@ (3400ca34 <tm_vsprintf+0x630>)
3400c96a:	4798      	blx	r3
			if ((base & 0x10) != 0) {
3400c96c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c970:	f003 0310 	and.w	r3, r3, #16
3400c974:	2b00      	cmp	r3, #0
3400c976:	d00c      	beq.n	3400c992 <tm_vsprintf+0x58e>
				(*ostr)((base & 0x40) ? (UB*)"X" : (UB*)"x", 1, par);
3400c978:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400c97c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400c980:	2b00      	cmp	r3, #0
3400c982:	d001      	beq.n	3400c988 <tm_vsprintf+0x584>
3400c984:	482c      	ldr	r0, [pc, #176]	@ (3400ca38 <tm_vsprintf+0x634>)
3400c986:	e000      	b.n	3400c98a <tm_vsprintf+0x586>
3400c988:	482c      	ldr	r0, [pc, #176]	@ (3400ca3c <tm_vsprintf+0x638>)
3400c98a:	68fb      	ldr	r3, [r7, #12]
3400c98c:	68ba      	ldr	r2, [r7, #8]
3400c98e:	2101      	movs	r1, #1
3400c990:	4798      	blx	r3
			}
		}

		/* Output preceding zeros for precision or padding */
		if ((n = prec) <= 0) {
3400c992:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400c994:	86fb      	strh	r3, [r7, #54]	@ 0x36
3400c996:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	@ 0x36
3400c99a:	2b00      	cmp	r3, #0
3400c99c:	dc0f      	bgt.n	3400c9be <tm_vsprintf+0x5ba>
			if ((flg & (F_LEFT | F_ZERO)) == F_ZERO ) {
3400c99e:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400c9a2:	f003 0311 	and.w	r3, r3, #17
3400c9a6:	2b10      	cmp	r3, #16
3400c9a8:	d109      	bne.n	3400c9be <tm_vsprintf+0x5ba>
				n = wid;
3400c9aa:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c9ac:	86fb      	strh	r3, [r7, #54]	@ 0x36
				wid = 0;
3400c9ae:	2300      	movs	r3, #0
3400c9b0:	877b      	strh	r3, [r7, #58]	@ 0x3a
			}
		}
		while (--n >= 0) (*ostr)((UB*)"0", 1, par);
3400c9b2:	e004      	b.n	3400c9be <tm_vsprintf+0x5ba>
3400c9b4:	68fb      	ldr	r3, [r7, #12]
3400c9b6:	68ba      	ldr	r2, [r7, #8]
3400c9b8:	2101      	movs	r1, #1
3400c9ba:	481e      	ldr	r0, [pc, #120]	@ (3400ca34 <tm_vsprintf+0x630>)
3400c9bc:	4798      	blx	r3
3400c9be:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400c9c0:	3b01      	subs	r3, #1
3400c9c2:	b29b      	uxth	r3, r3
3400c9c4:	86fb      	strh	r3, [r7, #54]	@ 0x36
3400c9c6:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	@ 0x36
3400c9ca:	2b00      	cmp	r3, #0
3400c9cc:	daf2      	bge.n	3400c9b4 <tm_vsprintf+0x5b0>

		/* Output item string */
		(*ostr)(cbs, cbe - cbs, par);
3400c9ce:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400c9d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400c9d2:	1ad1      	subs	r1, r2, r3
3400c9d4:	68fb      	ldr	r3, [r7, #12]
3400c9d6:	68ba      	ldr	r2, [r7, #8]
3400c9d8:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3400c9da:	4798      	blx	r3

		/* Output tailing spaces */
		while (--wid >= 0) (*ostr)((UB*)" ", 1, par);
3400c9dc:	e004      	b.n	3400c9e8 <tm_vsprintf+0x5e4>
3400c9de:	68fb      	ldr	r3, [r7, #12]
3400c9e0:	68ba      	ldr	r2, [r7, #8]
3400c9e2:	2101      	movs	r1, #1
3400c9e4:	4812      	ldr	r0, [pc, #72]	@ (3400ca30 <tm_vsprintf+0x62c>)
3400c9e6:	4798      	blx	r3
3400c9e8:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400c9ea:	3b01      	subs	r3, #1
3400c9ec:	b29b      	uxth	r3, r3
3400c9ee:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400c9f0:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400c9f4:	2b00      	cmp	r3, #0
3400c9f6:	daf2      	bge.n	3400c9de <tm_vsprintf+0x5da>
3400c9f8:	e000      	b.n	3400c9fc <tm_vsprintf+0x5f8>
			continue;
3400c9fa:	bf00      	nop
	for (fms = NULL; (c = *fmt++) != '\0'; ) {
3400c9fc:	687b      	ldr	r3, [r7, #4]
3400c9fe:	1c5a      	adds	r2, r3, #1
3400ca00:	607a      	str	r2, [r7, #4]
3400ca02:	781b      	ldrb	r3, [r3, #0]
3400ca04:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400ca08:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400ca0c:	2b00      	cmp	r3, #0
3400ca0e:	f47f ad03 	bne.w	3400c418 <tm_vsprintf+0x14>
	}

	/* Output last fix string */
	if (fms != NULL) {
3400ca12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400ca14:	2b00      	cmp	r3, #0
3400ca16:	d007      	beq.n	3400ca28 <tm_vsprintf+0x624>
		(*ostr)(fms, fmt - fms - 1, par);
3400ca18:	687a      	ldr	r2, [r7, #4]
3400ca1a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400ca1c:	1ad3      	subs	r3, r2, r3
3400ca1e:	1e59      	subs	r1, r3, #1
3400ca20:	68fb      	ldr	r3, [r7, #12]
3400ca22:	68ba      	ldr	r2, [r7, #8]
3400ca24:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3400ca26:	4798      	blx	r3
	}
#if	TM_OUTBUF_SZ > 0
	/* Flush output */
	(*ostr)(NULL, 0, par);
#endif
}
3400ca28:	bf00      	nop
3400ca2a:	3740      	adds	r7, #64	@ 0x40
3400ca2c:	46bd      	mov	sp, r7
3400ca2e:	bd80      	pop	{r7, pc}
3400ca30:	3400de54 	.word	0x3400de54
3400ca34:	3400de58 	.word	0x3400de58
3400ca38:	3400de5c 	.word	0x3400de5c
3400ca3c:	3400de60 	.word	0x3400de60

3400ca40 <out_cons>:

/*
 *	Output to console
 */
LOCAL	void	out_cons( UB *str, INT len,  OutPar *par )
{
3400ca40:	b580      	push	{r7, lr}
3400ca42:	b084      	sub	sp, #16
3400ca44:	af00      	add	r7, sp, #0
3400ca46:	60f8      	str	r0, [r7, #12]
3400ca48:	60b9      	str	r1, [r7, #8]
3400ca4a:	607a      	str	r2, [r7, #4]
#if	TM_OUTBUF_SZ == 0
	/* Direct output to console */
	par->len += len;
3400ca4c:	687b      	ldr	r3, [r7, #4]
3400ca4e:	f9b3 3000 	ldrsh.w	r3, [r3]
3400ca52:	b29a      	uxth	r2, r3
3400ca54:	68bb      	ldr	r3, [r7, #8]
3400ca56:	b29b      	uxth	r3, r3
3400ca58:	4413      	add	r3, r2
3400ca5a:	b29b      	uxth	r3, r3
3400ca5c:	b21a      	sxth	r2, r3
3400ca5e:	687b      	ldr	r3, [r7, #4]
3400ca60:	801a      	strh	r2, [r3, #0]
	while (--len >= 0) tm_putchar(*str++);
3400ca62:	e006      	b.n	3400ca72 <out_cons+0x32>
3400ca64:	68fb      	ldr	r3, [r7, #12]
3400ca66:	1c5a      	adds	r2, r3, #1
3400ca68:	60fa      	str	r2, [r7, #12]
3400ca6a:	781b      	ldrb	r3, [r3, #0]
3400ca6c:	4618      	mov	r0, r3
3400ca6e:	f7ff fc47 	bl	3400c300 <tm_putchar>
3400ca72:	68bb      	ldr	r3, [r7, #8]
3400ca74:	3b01      	subs	r3, #1
3400ca76:	60bb      	str	r3, [r7, #8]
3400ca78:	68bb      	ldr	r3, [r7, #8]
3400ca7a:	2b00      	cmp	r3, #0
3400ca7c:	daf2      	bge.n	3400ca64 <out_cons+0x24>
			}
			par->bufp[par->cnt++] = *str++;
		}
	}
#endif
}
3400ca7e:	bf00      	nop
3400ca80:	bf00      	nop
3400ca82:	3710      	adds	r7, #16
3400ca84:	46bd      	mov	sp, r7
3400ca86:	bd80      	pop	{r7, pc}

3400ca88 <tm_printf>:

EXPORT INT	tm_printf( const UB *format, ... )
{
3400ca88:	b40f      	push	{r0, r1, r2, r3}
3400ca8a:	b580      	push	{r7, lr}
3400ca8c:	b082      	sub	sp, #8
3400ca8e:	af00      	add	r7, sp, #0
	va_list	ap;

#if	TM_OUTBUF_SZ == 0
	H	len = 0;
3400ca90:	2300      	movs	r3, #0
3400ca92:	807b      	strh	r3, [r7, #2]

	va_start(ap, format);
3400ca94:	f107 0314 	add.w	r3, r7, #20
3400ca98:	607b      	str	r3, [r7, #4]
	tm_vsprintf(out_cons, (OutPar*)&len, format, ap);
3400ca9a:	1cb9      	adds	r1, r7, #2
3400ca9c:	687b      	ldr	r3, [r7, #4]
3400ca9e:	693a      	ldr	r2, [r7, #16]
3400caa0:	4805      	ldr	r0, [pc, #20]	@ (3400cab8 <tm_printf+0x30>)
3400caa2:	f7ff fcaf 	bl	3400c404 <tm_vsprintf>
	va_end(ap);
	return len;
3400caa6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
	va_start(ap, format);
	tm_vsprintf(out_cons, (OutPar*)&par, format, ap);
	va_end(ap);
	return par.len;
#endif
}
3400caaa:	4618      	mov	r0, r3
3400caac:	3708      	adds	r7, #8
3400caae:	46bd      	mov	sp, r7
3400cab0:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
3400cab4:	b004      	add	sp, #16
3400cab6:	4770      	bx	lr
3400cab8:	3400ca41 	.word	0x3400ca41

3400cabc <out_w>:
{
3400cabc:	b480      	push	{r7}
3400cabe:	b083      	sub	sp, #12
3400cac0:	af00      	add	r7, sp, #0
3400cac2:	6078      	str	r0, [r7, #4]
3400cac4:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400cac6:	687b      	ldr	r3, [r7, #4]
3400cac8:	683a      	ldr	r2, [r7, #0]
3400caca:	601a      	str	r2, [r3, #0]
}
3400cacc:	bf00      	nop
3400cace:	370c      	adds	r7, #12
3400cad0:	46bd      	mov	sp, r7
3400cad2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cad6:	4770      	bx	lr

3400cad8 <knl_force_dispatch>:
/* ----------------------------------------------------------------------- */
/*
 *	Task dispatcher startup
 */
EXPORT void knl_force_dispatch( void )
{
3400cad8:	b580      	push	{r7, lr}
3400cada:	af00      	add	r7, sp, #0
	knl_dispatch_disabled = DDS_DISABLE_IMPLICIT;
3400cadc:	4b07      	ldr	r3, [pc, #28]	@ (3400cafc <knl_force_dispatch+0x24>)
3400cade:	2201      	movs	r2, #1
3400cae0:	601a      	str	r2, [r3, #0]
	knl_ctxtsk = NULL;
3400cae2:	4b07      	ldr	r3, [pc, #28]	@ (3400cb00 <knl_force_dispatch+0x28>)
3400cae4:	2200      	movs	r2, #0
3400cae6:	601a      	str	r2, [r3, #0]
	out_w(SCB_ICSR, ICSR_PENDSVSET);	/* pendsv exception */
3400cae8:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
3400caec:	4805      	ldr	r0, [pc, #20]	@ (3400cb04 <knl_force_dispatch+0x2c>)
3400caee:	f7ff ffe5 	bl	3400cabc <out_w>
	set_basepri(0);
3400caf2:	2000      	movs	r0, #0
3400caf4:	f000 ff2b 	bl	3400d94e <set_basepri>
}
3400caf8:	bf00      	nop
3400cafa:	bd80      	pop	{r7, pc}
3400cafc:	340109c4 	.word	0x340109c4
3400cb00:	340109c8 	.word	0x340109c8
3400cb04:	e000ed04 	.word	0xe000ed04

3400cb08 <knl_dispatch>:

EXPORT void knl_dispatch( void )
{
3400cb08:	b580      	push	{r7, lr}
3400cb0a:	af00      	add	r7, sp, #0
	out_w(SCB_ICSR, ICSR_PENDSVSET);	/* pendsv exception */
3400cb0c:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
3400cb10:	4802      	ldr	r0, [pc, #8]	@ (3400cb1c <knl_dispatch+0x14>)
3400cb12:	f7ff ffd3 	bl	3400cabc <out_w>
}
3400cb16:	bf00      	nop
3400cb18:	bd80      	pop	{r7, pc}
3400cb1a:	bf00      	nop
3400cb1c:	e000ed04 	.word	0xe000ed04

3400cb20 <knl_nmi_handler>:

/*
 * NMI handler
 */
WEAK_FUNC EXPORT void knl_nmi_handler(void)
{
3400cb20:	b580      	push	{r7, lr}
3400cb22:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("NMI\n");
3400cb24:	4802      	ldr	r0, [pc, #8]	@ (3400cb30 <knl_nmi_handler+0x10>)
3400cb26:	f7ff fc0f 	bl	3400c348 <tm_putstring>
	while(1);
3400cb2a:	bf00      	nop
3400cb2c:	e7fd      	b.n	3400cb2a <knl_nmi_handler+0xa>
3400cb2e:	bf00      	nop
3400cb30:	3400de64 	.word	0x3400de64

3400cb34 <knl_hardfault_handler>:
/*
 * Hard fault handler
 */
//WEAK_FUNC EXPORT void knl_hardfault_handler(void)
void knl_hardfault_handler(void)
{
3400cb34:	b580      	push	{r7, lr}
3400cb36:	b084      	sub	sp, #16
3400cb38:	af00      	add	r7, sp, #0
#if (USE_EXCEPTION_DBG_MSG  && USE_TMONITOR)

	UW	hfsr, cfsr;
	ID	ctskid;

	hfsr	= *(_UW *)SCB_HFSR;
3400cb3a:	4b12      	ldr	r3, [pc, #72]	@ (3400cb84 <knl_hardfault_handler+0x50>)
3400cb3c:	681b      	ldr	r3, [r3, #0]
3400cb3e:	60bb      	str	r3, [r7, #8]
	if(knl_ctxtsk != NULL) {
3400cb40:	4b11      	ldr	r3, [pc, #68]	@ (3400cb88 <knl_hardfault_handler+0x54>)
3400cb42:	681b      	ldr	r3, [r3, #0]
3400cb44:	2b00      	cmp	r3, #0
3400cb46:	d004      	beq.n	3400cb52 <knl_hardfault_handler+0x1e>
		ctskid = knl_ctxtsk->tskid;
3400cb48:	4b0f      	ldr	r3, [pc, #60]	@ (3400cb88 <knl_hardfault_handler+0x54>)
3400cb4a:	681b      	ldr	r3, [r3, #0]
3400cb4c:	689b      	ldr	r3, [r3, #8]
3400cb4e:	60fb      	str	r3, [r7, #12]
3400cb50:	e001      	b.n	3400cb56 <knl_hardfault_handler+0x22>
	} else {
		ctskid = 0;
3400cb52:	2300      	movs	r3, #0
3400cb54:	60fb      	str	r3, [r7, #12]
	}

	if(hfsr & 0x40000000) {
3400cb56:	68bb      	ldr	r3, [r7, #8]
3400cb58:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400cb5c:	2b00      	cmp	r3, #0
3400cb5e:	d009      	beq.n	3400cb74 <knl_hardfault_handler+0x40>
		cfsr = *(_UW*)SCB_CFSR;
3400cb60:	4b0a      	ldr	r3, [pc, #40]	@ (3400cb8c <knl_hardfault_handler+0x58>)
3400cb62:	681b      	ldr	r3, [r3, #0]
3400cb64:	607b      	str	r3, [r7, #4]
		tm_printf((UB*)"*** Hard fault ***  ctxtsk:%d  HFSR:%x  CFSR:%x\n", ctskid, hfsr, cfsr);
3400cb66:	687b      	ldr	r3, [r7, #4]
3400cb68:	68ba      	ldr	r2, [r7, #8]
3400cb6a:	68f9      	ldr	r1, [r7, #12]
3400cb6c:	4808      	ldr	r0, [pc, #32]	@ (3400cb90 <knl_hardfault_handler+0x5c>)
3400cb6e:	f7ff ff8b 	bl	3400ca88 <tm_printf>
3400cb72:	e005      	b.n	3400cb80 <knl_hardfault_handler+0x4c>
	} else {
		tm_printf((UB*)"*** Hard fault ***  ctxtsk:%d  HFSR:%x%x\n", ctskid, hfsr);
3400cb74:	68ba      	ldr	r2, [r7, #8]
3400cb76:	68f9      	ldr	r1, [r7, #12]
3400cb78:	4806      	ldr	r0, [pc, #24]	@ (3400cb94 <knl_hardfault_handler+0x60>)
3400cb7a:	f7ff ff85 	bl	3400ca88 <tm_printf>
	}
#endif
	while(1);
3400cb7e:	bf00      	nop
3400cb80:	bf00      	nop
3400cb82:	e7fd      	b.n	3400cb80 <knl_hardfault_handler+0x4c>
3400cb84:	e000ed2c 	.word	0xe000ed2c
3400cb88:	340109c8 	.word	0x340109c8
3400cb8c:	e000ed28 	.word	0xe000ed28
3400cb90:	3400de6c 	.word	0x3400de6c
3400cb94:	3400dea0 	.word	0x3400dea0

3400cb98 <knl_memmanage_handler>:

/*
 * MPU Fault Handler
 */
WEAK_FUNC EXPORT void knl_memmanage_handler(void)
{
3400cb98:	b580      	push	{r7, lr}
3400cb9a:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("MPU Fault\n");
3400cb9c:	4802      	ldr	r0, [pc, #8]	@ (3400cba8 <knl_memmanage_handler+0x10>)
3400cb9e:	f7ff fbd3 	bl	3400c348 <tm_putstring>
	while(1);
3400cba2:	bf00      	nop
3400cba4:	e7fd      	b.n	3400cba2 <knl_memmanage_handler+0xa>
3400cba6:	bf00      	nop
3400cba8:	3400decc 	.word	0x3400decc

3400cbac <knl_busfault_handler>:

/* 
 * Bus Fault Handler
 */
WEAK_FUNC EXPORT void knl_busfault_handler(void)
{
3400cbac:	b580      	push	{r7, lr}
3400cbae:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Bus Fault\n");
3400cbb0:	4802      	ldr	r0, [pc, #8]	@ (3400cbbc <knl_busfault_handler+0x10>)
3400cbb2:	f7ff fbc9 	bl	3400c348 <tm_putstring>
	while(1);
3400cbb6:	bf00      	nop
3400cbb8:	e7fd      	b.n	3400cbb6 <knl_busfault_handler+0xa>
3400cbba:	bf00      	nop
3400cbbc:	3400ded8 	.word	0x3400ded8

3400cbc0 <knl_usagefault_handler>:
/*
 * Usage Fault Handler
 */
//WEAK_FUNC EXPORT void knl_usagefault_handler(void)
EXPORT void knl_usagefault_handler(void)
{
3400cbc0:	b580      	push	{r7, lr}
3400cbc2:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Usage Fault\n");
3400cbc4:	4802      	ldr	r0, [pc, #8]	@ (3400cbd0 <knl_usagefault_handler+0x10>)
3400cbc6:	f7ff fbbf 	bl	3400c348 <tm_putstring>
	while(1);
3400cbca:	bf00      	nop
3400cbcc:	e7fd      	b.n	3400cbca <knl_usagefault_handler+0xa>
3400cbce:	bf00      	nop
3400cbd0:	3400dee4 	.word	0x3400dee4

3400cbd4 <knl_svcall_handler>:

/*
 * Svcall
 */
WEAK_FUNC EXPORT void knl_svcall_handler(void)
{
3400cbd4:	b580      	push	{r7, lr}
3400cbd6:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("SVCall\n");
3400cbd8:	4802      	ldr	r0, [pc, #8]	@ (3400cbe4 <knl_svcall_handler+0x10>)
3400cbda:	f7ff fbb5 	bl	3400c348 <tm_putstring>
	while(1);
3400cbde:	bf00      	nop
3400cbe0:	e7fd      	b.n	3400cbde <knl_svcall_handler+0xa>
3400cbe2:	bf00      	nop
3400cbe4:	3400def4 	.word	0x3400def4

3400cbe8 <knl_debugmon_handler>:

/* 
 * Debug Monitor
 */
WEAK_FUNC EXPORT void knl_debugmon_handler(void)
{
3400cbe8:	b580      	push	{r7, lr}
3400cbea:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Debug Monitor\n");
3400cbec:	4802      	ldr	r0, [pc, #8]	@ (3400cbf8 <knl_debugmon_handler+0x10>)
3400cbee:	f7ff fbab 	bl	3400c348 <tm_putstring>
	while(1);
3400cbf2:	bf00      	nop
3400cbf4:	e7fd      	b.n	3400cbf2 <knl_debugmon_handler+0xa>
3400cbf6:	bf00      	nop
3400cbf8:	3400defc 	.word	0x3400defc

3400cbfc <knl_EnterTaskIndependent>:
/*
 * Move to/Restore task independent part
 */
Inline void knl_EnterTaskIndependent( void )
{
3400cbfc:	b480      	push	{r7}
3400cbfe:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400cc00:	4b04      	ldr	r3, [pc, #16]	@ (3400cc14 <knl_EnterTaskIndependent+0x18>)
3400cc02:	681b      	ldr	r3, [r3, #0]
3400cc04:	3301      	adds	r3, #1
3400cc06:	4a03      	ldr	r2, [pc, #12]	@ (3400cc14 <knl_EnterTaskIndependent+0x18>)
3400cc08:	6013      	str	r3, [r2, #0]
}
3400cc0a:	bf00      	nop
3400cc0c:	46bd      	mov	sp, r7
3400cc0e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cc12:	4770      	bx	lr
3400cc14:	3400f6b0 	.word	0x3400f6b0

3400cc18 <knl_LeaveTaskIndependent>:
Inline void knl_LeaveTaskIndependent( void )
{
3400cc18:	b480      	push	{r7}
3400cc1a:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400cc1c:	4b04      	ldr	r3, [pc, #16]	@ (3400cc30 <knl_LeaveTaskIndependent+0x18>)
3400cc1e:	681b      	ldr	r3, [r3, #0]
3400cc20:	3b01      	subs	r3, #1
3400cc22:	4a03      	ldr	r2, [pc, #12]	@ (3400cc30 <knl_LeaveTaskIndependent+0x18>)
3400cc24:	6013      	str	r3, [r2, #0]
}
3400cc26:	bf00      	nop
3400cc28:	46bd      	mov	sp, r7
3400cc2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cc2e:	4770      	bx	lr
3400cc30:	3400f6b0 	.word	0x3400f6b0

3400cc34 <knl_systim_inthdr>:
/* ------------------------------------------------------------------------ */
/*
 * System-timer Interrupt handler
 */
EXPORT void knl_systim_inthdr(void)
{
3400cc34:	b580      	push	{r7, lr}
3400cc36:	af00      	add	r7, sp, #0
	ENTER_TASK_INDEPENDENT;
3400cc38:	f7ff ffe0 	bl	3400cbfc <knl_EnterTaskIndependent>

	knl_timer_handler();
3400cc3c:	f7fe fe44 	bl	3400b8c8 <knl_timer_handler>

	LEAVE_TASK_INDEPENDENT;
3400cc40:	f7ff ffea 	bl	3400cc18 <knl_LeaveTaskIndependent>
}
3400cc44:	bf00      	nop
3400cc46:	bd80      	pop	{r7, pc}

3400cc48 <knl_init_interrupt>:
/* ------------------------------------------------------------------------ */
/*
 * Interrupt initialize
 */
EXPORT ER knl_init_interrupt( void )
{
3400cc48:	b480      	push	{r7}
3400cc4a:	af00      	add	r7, sp, #0
	/* Set Exception handler */
	knl_exctbl[2]	= (UW)knl_nmi_handler;		/* 2: NMI Handler */
3400cc4c:	4a10      	ldr	r2, [pc, #64]	@ (3400cc90 <knl_init_interrupt+0x48>)
3400cc4e:	4b11      	ldr	r3, [pc, #68]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc50:	609a      	str	r2, [r3, #8]
	knl_exctbl[3]	= (UW)knl_hardfault_handler;	/* 3: Hard Fault Handler */
3400cc52:	4a11      	ldr	r2, [pc, #68]	@ (3400cc98 <knl_init_interrupt+0x50>)
3400cc54:	4b0f      	ldr	r3, [pc, #60]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc56:	60da      	str	r2, [r3, #12]
	knl_exctbl[4]	= (UW)knl_memmanage_handler;	/* 4: MPU Fault Handler */
3400cc58:	4a10      	ldr	r2, [pc, #64]	@ (3400cc9c <knl_init_interrupt+0x54>)
3400cc5a:	4b0e      	ldr	r3, [pc, #56]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc5c:	611a      	str	r2, [r3, #16]
	knl_exctbl[5]	= (UW)knl_busfault_handler;	/* 5: Bus Fault Handler */
3400cc5e:	4a10      	ldr	r2, [pc, #64]	@ (3400cca0 <knl_init_interrupt+0x58>)
3400cc60:	4b0c      	ldr	r3, [pc, #48]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc62:	615a      	str	r2, [r3, #20]
	knl_exctbl[6]	= (UW)knl_usagefault_handler;	/* 6: Usage Fault Handler */
3400cc64:	4a0f      	ldr	r2, [pc, #60]	@ (3400cca4 <knl_init_interrupt+0x5c>)
3400cc66:	4b0b      	ldr	r3, [pc, #44]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc68:	619a      	str	r2, [r3, #24]

	knl_exctbl[11]	= (UW)knl_svcall_handler;	/* 11: Svcall */
3400cc6a:	4a0f      	ldr	r2, [pc, #60]	@ (3400cca8 <knl_init_interrupt+0x60>)
3400cc6c:	4b09      	ldr	r3, [pc, #36]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc6e:	62da      	str	r2, [r3, #44]	@ 0x2c
	knl_exctbl[12]	= (UW)knl_debugmon_handler;	/* 12: Debug Monitor Handler */
3400cc70:	4a0e      	ldr	r2, [pc, #56]	@ (3400ccac <knl_init_interrupt+0x64>)
3400cc72:	4b08      	ldr	r3, [pc, #32]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc74:	631a      	str	r2, [r3, #48]	@ 0x30

	knl_exctbl[14]	= (UW)knl_dispatch_entry;	/* 14: Pend SV */
3400cc76:	4a0e      	ldr	r2, [pc, #56]	@ (3400ccb0 <knl_init_interrupt+0x68>)
3400cc78:	4b06      	ldr	r3, [pc, #24]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc7a:	639a      	str	r2, [r3, #56]	@ 0x38
	knl_exctbl[15]	= (UW)knl_systim_inthdr;	/* 15: Systick */
3400cc7c:	4a0d      	ldr	r2, [pc, #52]	@ (3400ccb4 <knl_init_interrupt+0x6c>)
3400cc7e:	4b05      	ldr	r3, [pc, #20]	@ (3400cc94 <knl_init_interrupt+0x4c>)
3400cc80:	63da      	str	r2, [r3, #60]	@ 0x3c

	return E_OK;
3400cc82:	2300      	movs	r3, #0
}
3400cc84:	4618      	mov	r0, r3
3400cc86:	46bd      	mov	sp, r7
3400cc88:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cc8c:	4770      	bx	lr
3400cc8e:	bf00      	nop
3400cc90:	3400cb21 	.word	0x3400cb21
3400cc94:	3400e400 	.word	0x3400e400
3400cc98:	3400cb35 	.word	0x3400cb35
3400cc9c:	3400cb99 	.word	0x3400cb99
3400cca0:	3400cbad 	.word	0x3400cbad
3400cca4:	3400cbc1 	.word	0x3400cbc1
3400cca8:	3400cbd5 	.word	0x3400cbd5
3400ccac:	3400cbe9 	.word	0x3400cbe9
3400ccb0:	3400078d 	.word	0x3400078d
3400ccb4:	3400cc35 	.word	0x3400cc35

3400ccb8 <out_w>:
{
3400ccb8:	b480      	push	{r7}
3400ccba:	b083      	sub	sp, #12
3400ccbc:	af00      	add	r7, sp, #0
3400ccbe:	6078      	str	r0, [r7, #4]
3400ccc0:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400ccc2:	687b      	ldr	r3, [r7, #4]
3400ccc4:	683a      	ldr	r2, [r7, #0]
3400ccc6:	601a      	str	r2, [r3, #0]
}
3400ccc8:	bf00      	nop
3400ccca:	370c      	adds	r7, #12
3400cccc:	46bd      	mov	sp, r7
3400ccce:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ccd2:	4770      	bx	lr

3400ccd4 <in_w>:
{
3400ccd4:	b480      	push	{r7}
3400ccd6:	b083      	sub	sp, #12
3400ccd8:	af00      	add	r7, sp, #0
3400ccda:	6078      	str	r0, [r7, #4]
	return *(_UW*)port;
3400ccdc:	687b      	ldr	r3, [r7, #4]
3400ccde:	681b      	ldr	r3, [r3, #0]
}
3400cce0:	4618      	mov	r0, r3
3400cce2:	370c      	adds	r7, #12
3400cce4:	46bd      	mov	sp, r7
3400cce6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ccea:	4770      	bx	lr

3400ccec <knl_start_mtkernel>:
EXPORT void		*knl_sysmem_top	= 0;
EXPORT void		*knl_sysmem_end	= 0;
#endif

EXPORT void knl_start_mtkernel(void)
{
3400ccec:	b580      	push	{r7, lr}
3400ccee:	b084      	sub	sp, #16
3400ccf0:	af00      	add	r7, sp, #0
	UW	*src, *top;
	UW	reg;
	INT	i;

	disint();		// Disable Interrupt
3400ccf2:	f000 fe48 	bl	3400d986 <disint>

	knl_startup_hw();
3400ccf6:	f000 fde3 	bl	3400d8c0 <knl_startup_hw>

	/* Copy exception handler (ROM -> RAM) */
	src = knl_exctbl_o = (UW*)in_w(SCB_VTOR);
3400ccfa:	4830      	ldr	r0, [pc, #192]	@ (3400cdbc <knl_start_mtkernel+0xd0>)
3400ccfc:	f7ff ffea 	bl	3400ccd4 <in_w>
3400cd00:	4603      	mov	r3, r0
3400cd02:	461a      	mov	r2, r3
3400cd04:	4b2e      	ldr	r3, [pc, #184]	@ (3400cdc0 <knl_start_mtkernel+0xd4>)
3400cd06:	601a      	str	r2, [r3, #0]
3400cd08:	4b2d      	ldr	r3, [pc, #180]	@ (3400cdc0 <knl_start_mtkernel+0xd4>)
3400cd0a:	681b      	ldr	r3, [r3, #0]
3400cd0c:	60fb      	str	r3, [r7, #12]
	top = (UW*)knl_exctbl;
3400cd0e:	4b2d      	ldr	r3, [pc, #180]	@ (3400cdc4 <knl_start_mtkernel+0xd8>)
3400cd10:	60bb      	str	r3, [r7, #8]
	for(i=0; i < (N_SYSVEC + N_INTVEC); i++) {
3400cd12:	2300      	movs	r3, #0
3400cd14:	607b      	str	r3, [r7, #4]
3400cd16:	e00a      	b.n	3400cd2e <knl_start_mtkernel+0x42>
		*top++ = *src++;
3400cd18:	68fa      	ldr	r2, [r7, #12]
3400cd1a:	1d13      	adds	r3, r2, #4
3400cd1c:	60fb      	str	r3, [r7, #12]
3400cd1e:	68bb      	ldr	r3, [r7, #8]
3400cd20:	1d19      	adds	r1, r3, #4
3400cd22:	60b9      	str	r1, [r7, #8]
3400cd24:	6812      	ldr	r2, [r2, #0]
3400cd26:	601a      	str	r2, [r3, #0]
	for(i=0; i < (N_SYSVEC + N_INTVEC); i++) {
3400cd28:	687b      	ldr	r3, [r7, #4]
3400cd2a:	3301      	adds	r3, #1
3400cd2c:	607b      	str	r3, [r7, #4]
3400cd2e:	687b      	ldr	r3, [r7, #4]
3400cd30:	2bd3      	cmp	r3, #211	@ 0xd3
3400cd32:	ddf1      	ble.n	3400cd18 <knl_start_mtkernel+0x2c>
	}
	out_w(SCB_VTOR, (UW)knl_exctbl);
3400cd34:	4b23      	ldr	r3, [pc, #140]	@ (3400cdc4 <knl_start_mtkernel+0xd8>)
3400cd36:	4619      	mov	r1, r3
3400cd38:	4820      	ldr	r0, [pc, #128]	@ (3400cdbc <knl_start_mtkernel+0xd0>)
3400cd3a:	f7ff ffbd 	bl	3400ccb8 <out_w>

	/* Configure exception priorities */
	reg = *(_UW*)SCB_AIRCR;
3400cd3e:	4b22      	ldr	r3, [pc, #136]	@ (3400cdc8 <knl_start_mtkernel+0xdc>)
3400cd40:	681b      	ldr	r3, [r3, #0]
3400cd42:	603b      	str	r3, [r7, #0]
	reg = (reg & (~AIRCR_PRIGROUP3)) | AIRCR_PRIGROUP0;	// PRIGRP:SUBPRI = 4 : 4
3400cd44:	683b      	ldr	r3, [r7, #0]
3400cd46:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400cd4a:	603b      	str	r3, [r7, #0]
	*(_UW*)SCB_AIRCR = (reg & 0x0000FFFF) | AIRCR_VECTKEY;
3400cd4c:	683b      	ldr	r3, [r7, #0]
3400cd4e:	b29b      	uxth	r3, r3
3400cd50:	4a1d      	ldr	r2, [pc, #116]	@ (3400cdc8 <knl_start_mtkernel+0xdc>)
3400cd52:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
3400cd56:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
3400cd5a:	6013      	str	r3, [r2, #0]

	/* Enable UsageFault & BusFault & MemFault */
	out_w(SCB_SHCSR, SHCSR_USGFAULTENA | SHCSR_BUSFAULTENA | SHCSR_MEMFAULTENA);
3400cd5c:	f44f 21e0 	mov.w	r1, #458752	@ 0x70000
3400cd60:	481a      	ldr	r0, [pc, #104]	@ (3400cdcc <knl_start_mtkernel+0xe0>)
3400cd62:	f7ff ffa9 	bl	3400ccb8 <out_w>

	out_w(SCB_SHPR2, SCB_SHPR2_VAL);		// SVC pri = 0
3400cd66:	2100      	movs	r1, #0
3400cd68:	4819      	ldr	r0, [pc, #100]	@ (3400cdd0 <knl_start_mtkernel+0xe4>)
3400cd6a:	f7ff ffa5 	bl	3400ccb8 <out_w>
	out_w(SCB_SHPR3, SCB_SHPR3_VAL);		// SysTick = 1 , PendSV = 15
3400cd6e:	4919      	ldr	r1, [pc, #100]	@ (3400cdd4 <knl_start_mtkernel+0xe8>)
3400cd70:	4819      	ldr	r0, [pc, #100]	@ (3400cdd8 <knl_start_mtkernel+0xec>)
3400cd72:	f7ff ffa1 	bl	3400ccb8 <out_w>

	knl_sysclk	= SystemCoreClock;		// Get System clock frequency
3400cd76:	4b19      	ldr	r3, [pc, #100]	@ (3400cddc <knl_start_mtkernel+0xf0>)
3400cd78:	681b      	ldr	r3, [r3, #0]
3400cd7a:	4a19      	ldr	r2, [pc, #100]	@ (3400cde0 <knl_start_mtkernel+0xf4>)
3400cd7c:	6013      	str	r3, [r2, #0]
	knl_lowmem_top = knl_system_mem;
	knl_lowmem_limit = &knl_system_mem[SYSTEM_MEM_SIZE/sizeof(UW)];
#else
	/* Set System memory area */
	if(INTERNAL_RAM_START > SYSTEMAREA_TOP) {
		knl_lowmem_top = (UW*)INTERNAL_RAM_START;
3400cd7e:	4b19      	ldr	r3, [pc, #100]	@ (3400cde4 <knl_start_mtkernel+0xf8>)
3400cd80:	4a19      	ldr	r2, [pc, #100]	@ (3400cde8 <knl_start_mtkernel+0xfc>)
3400cd82:	601a      	str	r2, [r3, #0]
	} else {
		knl_lowmem_top = (UW*)SYSTEMAREA_TOP;
	}
	if((UW)knl_lowmem_top < (UW)&_end) {
3400cd84:	4b17      	ldr	r3, [pc, #92]	@ (3400cde4 <knl_start_mtkernel+0xf8>)
3400cd86:	681b      	ldr	r3, [r3, #0]
3400cd88:	461a      	mov	r2, r3
3400cd8a:	4b18      	ldr	r3, [pc, #96]	@ (3400cdec <knl_start_mtkernel+0x100>)
3400cd8c:	429a      	cmp	r2, r3
3400cd8e:	d202      	bcs.n	3400cd96 <knl_start_mtkernel+0xaa>
		knl_lowmem_top = (UW*)&_end;
3400cd90:	4b14      	ldr	r3, [pc, #80]	@ (3400cde4 <knl_start_mtkernel+0xf8>)
3400cd92:	4a16      	ldr	r2, [pc, #88]	@ (3400cdec <knl_start_mtkernel+0x100>)
3400cd94:	601a      	str	r2, [r3, #0]
	}

	if((SYSTEMAREA_END != 0) && (INTERNAL_RAM_END > CNF_SYSTEMAREA_END)) {
		knl_lowmem_limit = (UW*)(SYSTEMAREA_END - EXC_STACK_SIZE);
	} else {
		knl_lowmem_limit = (UW*)(INTERNAL_RAM_END - EXC_STACK_SIZE);
3400cd96:	4b16      	ldr	r3, [pc, #88]	@ (3400cdf0 <knl_start_mtkernel+0x104>)
3400cd98:	4a16      	ldr	r2, [pc, #88]	@ (3400cdf4 <knl_start_mtkernel+0x108>)
3400cd9a:	601a      	str	r2, [r3, #0]
	}
#endif

#if USE_DEBUG_SYSMEMINFO
	knl_sysmem_top	= knl_lowmem_top;
3400cd9c:	4b11      	ldr	r3, [pc, #68]	@ (3400cde4 <knl_start_mtkernel+0xf8>)
3400cd9e:	681b      	ldr	r3, [r3, #0]
3400cda0:	4a15      	ldr	r2, [pc, #84]	@ (3400cdf8 <knl_start_mtkernel+0x10c>)
3400cda2:	6013      	str	r3, [r2, #0]
	knl_sysmem_end	= knl_lowmem_limit;
3400cda4:	4b12      	ldr	r3, [pc, #72]	@ (3400cdf0 <knl_start_mtkernel+0x104>)
3400cda6:	681b      	ldr	r3, [r3, #0]
3400cda8:	4a14      	ldr	r2, [pc, #80]	@ (3400cdfc <knl_start_mtkernel+0x110>)
3400cdaa:	6013      	str	r3, [r2, #0]
#endif	// USE_DEBUG_MEMINFO
#endif	// USE_IMALLOC

	/* Temporarily disable stack pointer protection */
	// set_msplim((uint32_t)INTERNAL_RAM_START);
	Asm ("msr msplim, %0" : : "r" ((uint32_t)INTERNAL_RAM_START));
3400cdac:	4b0e      	ldr	r3, [pc, #56]	@ (3400cde8 <knl_start_mtkernel+0xfc>)
3400cdae:	f383 880a 	msr	MSPLIM, r3

	/* Startup Kernel */
	knl_main();		// *** No return ****/
3400cdb2:	f7fb ffdb 	bl	34008d6c <knl_main>
	while(1);		// guard - infinite loops
3400cdb6:	bf00      	nop
3400cdb8:	e7fd      	b.n	3400cdb6 <knl_start_mtkernel+0xca>
3400cdba:	bf00      	nop
3400cdbc:	e000ed08 	.word	0xe000ed08
3400cdc0:	3400f6b8 	.word	0x3400f6b8
3400cdc4:	3400e400 	.word	0x3400e400
3400cdc8:	e000ed0c 	.word	0xe000ed0c
3400cdcc:	e000ed24 	.word	0xe000ed24
3400cdd0:	e000ed1c 	.word	0xe000ed1c
3400cdd4:	10f00000 	.word	0x10f00000
3400cdd8:	e000ed20 	.word	0xe000ed20
3400cddc:	3400e118 	.word	0x3400e118
3400cde0:	3400f6b4 	.word	0x3400f6b4
3400cde4:	3400f6bc 	.word	0x3400f6bc
3400cde8:	34000400 	.word	0x34000400
3400cdec:	340119d0 	.word	0x340119d0
3400cdf0:	3400f6c0 	.word	0x3400f6c0
3400cdf4:	34200000 	.word	0x34200000
3400cdf8:	3400f6c4 	.word	0x3400f6c4
3400cdfc:	3400f6c8 	.word	0x3400f6c8

3400ce00 <knl_EnterTaskIndependent>:
{
3400ce00:	b480      	push	{r7}
3400ce02:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400ce04:	4b04      	ldr	r3, [pc, #16]	@ (3400ce18 <knl_EnterTaskIndependent+0x18>)
3400ce06:	681b      	ldr	r3, [r3, #0]
3400ce08:	3301      	adds	r3, #1
3400ce0a:	4a03      	ldr	r2, [pc, #12]	@ (3400ce18 <knl_EnterTaskIndependent+0x18>)
3400ce0c:	6013      	str	r3, [r2, #0]
}
3400ce0e:	bf00      	nop
3400ce10:	46bd      	mov	sp, r7
3400ce12:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ce16:	4770      	bx	lr
3400ce18:	3400f6b0 	.word	0x3400f6b0

3400ce1c <knl_LeaveTaskIndependent>:
{
3400ce1c:	b480      	push	{r7}
3400ce1e:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400ce20:	4b04      	ldr	r3, [pc, #16]	@ (3400ce34 <knl_LeaveTaskIndependent+0x18>)
3400ce22:	681b      	ldr	r3, [r3, #0]
3400ce24:	3b01      	subs	r3, #1
3400ce26:	4a03      	ldr	r2, [pc, #12]	@ (3400ce34 <knl_LeaveTaskIndependent+0x18>)
3400ce28:	6013      	str	r3, [r2, #0]
}
3400ce2a:	bf00      	nop
3400ce2c:	46bd      	mov	sp, r7
3400ce2e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ce32:	4770      	bx	lr
3400ce34:	3400f6b0 	.word	0x3400f6b0

3400ce38 <read_atr>:

/*---------------------------------------------------------------------*/
/* Attribute data control
 */
LOCAL ER read_atr(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400ce38:	b480      	push	{r7}
3400ce3a:	b083      	sub	sp, #12
3400ce3c:	af00      	add	r7, sp, #0
3400ce3e:	6078      	str	r0, [r7, #4]
3400ce40:	6039      	str	r1, [r7, #0]
	return E_PAR;
3400ce42:	f06f 0310 	mvn.w	r3, #16
}
3400ce46:	4618      	mov	r0, r3
3400ce48:	370c      	adds	r7, #12
3400ce4a:	46bd      	mov	sp, r7
3400ce4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ce50:	4770      	bx	lr

3400ce52 <write_atr>:

LOCAL ER write_atr(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400ce52:	b480      	push	{r7}
3400ce54:	b083      	sub	sp, #12
3400ce56:	af00      	add	r7, sp, #0
3400ce58:	6078      	str	r0, [r7, #4]
3400ce5a:	6039      	str	r1, [r7, #0]
	return E_PAR;
3400ce5c:	f06f 0310 	mvn.w	r3, #16
}
3400ce60:	4618      	mov	r0, r3
3400ce62:	370c      	adds	r7, #12
3400ce64:	46bd      	mov	sp, r7
3400ce66:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ce6a:	4770      	bx	lr

3400ce6c <HAL_ADC_ConvCpltCallback>:
/* Device-specific data control
 */

/* HAL Callback functions */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
3400ce6c:	b580      	push	{r7, lr}
3400ce6e:	b084      	sub	sp, #16
3400ce70:	af00      	add	r7, sp, #0
3400ce72:	6078      	str	r0, [r7, #4]
	T_HAL_ADC_DCB	*p_dcb;
	UINT	i;

	ENTER_TASK_INDEPENDENT
3400ce74:	f7ff ffc4 	bl	3400ce00 <knl_EnterTaskIndependent>

	for(i = 0; i < DEV_HAL_ADC_UNITNM; i++) {
3400ce78:	2300      	movs	r3, #0
3400ce7a:	60fb      	str	r3, [r7, #12]
3400ce7c:	e01b      	b.n	3400ceb6 <HAL_ADC_ConvCpltCallback+0x4a>
		p_dcb = get_dcb_ptr(i);
3400ce7e:	4a12      	ldr	r2, [pc, #72]	@ (3400cec8 <HAL_ADC_ConvCpltCallback+0x5c>)
3400ce80:	68fb      	ldr	r3, [r7, #12]
3400ce82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400ce86:	60bb      	str	r3, [r7, #8]
		if(p_dcb->hadc == hadc) {
3400ce88:	68bb      	ldr	r3, [r7, #8]
3400ce8a:	681b      	ldr	r3, [r3, #0]
3400ce8c:	687a      	ldr	r2, [r7, #4]
3400ce8e:	429a      	cmp	r2, r3
3400ce90:	d10e      	bne.n	3400ceb0 <HAL_ADC_ConvCpltCallback+0x44>
			p_dcb->err = E_OK;
3400ce92:	68bb      	ldr	r3, [r7, #8]
3400ce94:	2200      	movs	r2, #0
3400ce96:	615a      	str	r2, [r3, #20]
			tk_set_flg(id_flgid, 1<< p_dcb->unit);
3400ce98:	4b0c      	ldr	r3, [pc, #48]	@ (3400cecc <HAL_ADC_ConvCpltCallback+0x60>)
3400ce9a:	681a      	ldr	r2, [r3, #0]
3400ce9c:	68bb      	ldr	r3, [r7, #8]
3400ce9e:	689b      	ldr	r3, [r3, #8]
3400cea0:	2101      	movs	r1, #1
3400cea2:	fa01 f303 	lsl.w	r3, r1, r3
3400cea6:	4619      	mov	r1, r3
3400cea8:	4610      	mov	r0, r2
3400ceaa:	f7fc fe1b 	bl	34009ae4 <tk_set_flg>
			break;
3400ceae:	e005      	b.n	3400cebc <HAL_ADC_ConvCpltCallback+0x50>
	for(i = 0; i < DEV_HAL_ADC_UNITNM; i++) {
3400ceb0:	68fb      	ldr	r3, [r7, #12]
3400ceb2:	3301      	adds	r3, #1
3400ceb4:	60fb      	str	r3, [r7, #12]
3400ceb6:	68fb      	ldr	r3, [r7, #12]
3400ceb8:	2b02      	cmp	r3, #2
3400ceba:	d9e0      	bls.n	3400ce7e <HAL_ADC_ConvCpltCallback+0x12>
		}
	}

	LEAVE_TASK_INDEPENDENT
3400cebc:	f7ff ffae 	bl	3400ce1c <knl_LeaveTaskIndependent>
}
3400cec0:	bf00      	nop
3400cec2:	3710      	adds	r7, #16
3400cec4:	46bd      	mov	sp, r7
3400cec6:	bd80      	pop	{r7, pc}
3400cec8:	3400f6d0 	.word	0x3400f6d0
3400cecc:	3400f6cc 	.word	0x3400f6cc

3400ced0 <read_data>:

LOCAL ER read_data(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400ced0:	b580      	push	{r7, lr}
3400ced2:	b08a      	sub	sp, #40	@ 0x28
3400ced4:	af02      	add	r7, sp, #8
3400ced6:	6078      	str	r0, [r7, #4]
3400ced8:	6039      	str	r1, [r7, #0]
	uint32_t		value;
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	if(req->size == 0) {
3400ceda:	683b      	ldr	r3, [r7, #0]
3400cedc:	695b      	ldr	r3, [r3, #20]
3400cede:	2b00      	cmp	r3, #0
3400cee0:	d104      	bne.n	3400ceec <read_data+0x1c>
		req->asize = 1;
3400cee2:	683b      	ldr	r3, [r7, #0]
3400cee4:	2201      	movs	r2, #1
3400cee6:	61da      	str	r2, [r3, #28]
		return E_OK;
3400cee8:	2300      	movs	r3, #0
3400ceea:	e051      	b.n	3400cf90 <read_data+0xc0>
	}
	/* Configure for A/DC */
	err = dev_adc_setch(p_dcb->hadc, p_dcb->unit, req->start);
3400ceec:	687b      	ldr	r3, [r7, #4]
3400ceee:	6818      	ldr	r0, [r3, #0]
3400cef0:	687b      	ldr	r3, [r7, #4]
3400cef2:	6899      	ldr	r1, [r3, #8]
3400cef4:	683b      	ldr	r3, [r7, #0]
3400cef6:	691b      	ldr	r3, [r3, #16]
3400cef8:	461a      	mov	r2, r3
3400cefa:	f000 f967 	bl	3400d1cc <dev_adc_setch>
3400cefe:	61f8      	str	r0, [r7, #28]
	if(err != E_OK) return err;
3400cf00:	69fb      	ldr	r3, [r7, #28]
3400cf02:	2b00      	cmp	r3, #0
3400cf04:	d001      	beq.n	3400cf0a <read_data+0x3a>
3400cf06:	69fb      	ldr	r3, [r7, #28]
3400cf08:	e042      	b.n	3400cf90 <read_data+0xc0>

	wflgptn = 1 << p_dcb->unit;
3400cf0a:	687b      	ldr	r3, [r7, #4]
3400cf0c:	689b      	ldr	r3, [r3, #8]
3400cf0e:	2201      	movs	r2, #1
3400cf10:	fa02 f303 	lsl.w	r3, r2, r3
3400cf14:	61bb      	str	r3, [r7, #24]
	tk_clr_flg(id_flgid, ~wflgptn);
3400cf16:	4b20      	ldr	r3, [pc, #128]	@ (3400cf98 <read_data+0xc8>)
3400cf18:	681a      	ldr	r2, [r3, #0]
3400cf1a:	69bb      	ldr	r3, [r7, #24]
3400cf1c:	43db      	mvns	r3, r3
3400cf1e:	4619      	mov	r1, r3
3400cf20:	4610      	mov	r0, r2
3400cf22:	f7fc fe67 	bl	34009bf4 <tk_clr_flg>
	hal_sts = HAL_ADC_Start_IT(p_dcb->hadc);
3400cf26:	687b      	ldr	r3, [r7, #4]
3400cf28:	681b      	ldr	r3, [r3, #0]
3400cf2a:	4618      	mov	r0, r3
3400cf2c:	f7f5 fb1c 	bl	34002568 <HAL_ADC_Start_IT>
3400cf30:	4603      	mov	r3, r0
3400cf32:	75fb      	strb	r3, [r7, #23]
	if(hal_sts != HAL_OK) return E_BUSY;
3400cf34:	7dfb      	ldrb	r3, [r7, #23]
3400cf36:	2b00      	cmp	r3, #0
3400cf38:	d002      	beq.n	3400cf40 <read_data+0x70>
3400cf3a:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400cf3e:	e027      	b.n	3400cf90 <read_data+0xc0>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_ADC_TMOUT);
3400cf40:	4b15      	ldr	r3, [pc, #84]	@ (3400cf98 <read_data+0xc8>)
3400cf42:	6818      	ldr	r0, [r3, #0]
3400cf44:	f107 030c 	add.w	r3, r7, #12
3400cf48:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400cf4c:	9200      	str	r2, [sp, #0]
3400cf4e:	2220      	movs	r2, #32
3400cf50:	69b9      	ldr	r1, [r7, #24]
3400cf52:	f7fc feb3 	bl	34009cbc <tk_wai_flg>
3400cf56:	61f8      	str	r0, [r7, #28]
	if(err >= E_OK) {
3400cf58:	69fb      	ldr	r3, [r7, #28]
3400cf5a:	2b00      	cmp	r3, #0
3400cf5c:	db12      	blt.n	3400cf84 <read_data+0xb4>
		err  = p_dcb->err;
3400cf5e:	687b      	ldr	r3, [r7, #4]
3400cf60:	695b      	ldr	r3, [r3, #20]
3400cf62:	61fb      	str	r3, [r7, #28]
		if(err >= E_OK) {
3400cf64:	69fb      	ldr	r3, [r7, #28]
3400cf66:	2b00      	cmp	r3, #0
3400cf68:	db0c      	blt.n	3400cf84 <read_data+0xb4>
			value = HAL_ADC_GetValue(p_dcb->hadc);
3400cf6a:	687b      	ldr	r3, [r7, #4]
3400cf6c:	681b      	ldr	r3, [r3, #0]
3400cf6e:	4618      	mov	r0, r3
3400cf70:	f7f5 fc63 	bl	3400283a <HAL_ADC_GetValue>
3400cf74:	6138      	str	r0, [r7, #16]
			*(UW*)(req->buf) = (UW)value;
3400cf76:	683b      	ldr	r3, [r7, #0]
3400cf78:	699b      	ldr	r3, [r3, #24]
3400cf7a:	693a      	ldr	r2, [r7, #16]
3400cf7c:	601a      	str	r2, [r3, #0]
			req->asize= 1;
3400cf7e:	683b      	ldr	r3, [r7, #0]
3400cf80:	2201      	movs	r2, #1
3400cf82:	61da      	str	r2, [r3, #28]
		}
	}
	HAL_ADC_Stop_IT(p_dcb->hadc);
3400cf84:	687b      	ldr	r3, [r7, #4]
3400cf86:	681b      	ldr	r3, [r3, #0]
3400cf88:	4618      	mov	r0, r3
3400cf8a:	f7f5 fc1b 	bl	340027c4 <HAL_ADC_Stop_IT>

	return err;
3400cf8e:	69fb      	ldr	r3, [r7, #28]
}
3400cf90:	4618      	mov	r0, r3
3400cf92:	3720      	adds	r7, #32
3400cf94:	46bd      	mov	sp, r7
3400cf96:	bd80      	pop	{r7, pc}
3400cf98:	3400f6cc 	.word	0x3400f6cc

3400cf9c <write_data>:

LOCAL ER write_data(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400cf9c:	b480      	push	{r7}
3400cf9e:	b083      	sub	sp, #12
3400cfa0:	af00      	add	r7, sp, #0
3400cfa2:	6078      	str	r0, [r7, #4]
3400cfa4:	6039      	str	r1, [r7, #0]
	return E_RONLY;
3400cfa6:	f06f 0342 	mvn.w	r3, #66	@ 0x42
}
3400cfaa:	4618      	mov	r0, r3
3400cfac:	370c      	adds	r7, #12
3400cfae:	46bd      	mov	sp, r7
3400cfb0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cfb4:	4770      	bx	lr

3400cfb6 <dev_adc_openfn>:
 */
/*
 * Open device
 */
LOCAL ER dev_adc_openfn( ID devid, UINT omode, T_MSDI *msdi)
{
3400cfb6:	b480      	push	{r7}
3400cfb8:	b087      	sub	sp, #28
3400cfba:	af00      	add	r7, sp, #0
3400cfbc:	60f8      	str	r0, [r7, #12]
3400cfbe:	60b9      	str	r1, [r7, #8]
3400cfc0:	607a      	str	r2, [r7, #4]
	T_HAL_ADC_DCB	*p_dcb;

	p_dcb = (T_HAL_ADC_DCB*)(msdi->dmsdi.exinf);
3400cfc2:	687b      	ldr	r3, [r7, #4]
3400cfc4:	691b      	ldr	r3, [r3, #16]
3400cfc6:	617b      	str	r3, [r7, #20]
	if(p_dcb->hadc == NULL) return E_IO;
3400cfc8:	697b      	ldr	r3, [r7, #20]
3400cfca:	681b      	ldr	r3, [r3, #0]
3400cfcc:	2b00      	cmp	r3, #0
3400cfce:	d102      	bne.n	3400cfd6 <dev_adc_openfn+0x20>
3400cfd0:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400cfd4:	e003      	b.n	3400cfde <dev_adc_openfn+0x28>

	p_dcb->omode = omode;
3400cfd6:	697b      	ldr	r3, [r7, #20]
3400cfd8:	68ba      	ldr	r2, [r7, #8]
3400cfda:	60da      	str	r2, [r3, #12]
	return E_OK;
3400cfdc:	2300      	movs	r3, #0
}
3400cfde:	4618      	mov	r0, r3
3400cfe0:	371c      	adds	r7, #28
3400cfe2:	46bd      	mov	sp, r7
3400cfe4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cfe8:	4770      	bx	lr

3400cfea <dev_adc_closefn>:

/*
 * Close Device
 */
LOCAL ER dev_adc_closefn( ID devid, UINT option, T_MSDI *msdi)
{
3400cfea:	b480      	push	{r7}
3400cfec:	b085      	sub	sp, #20
3400cfee:	af00      	add	r7, sp, #0
3400cff0:	60f8      	str	r0, [r7, #12]
3400cff2:	60b9      	str	r1, [r7, #8]
3400cff4:	607a      	str	r2, [r7, #4]
	return E_OK;
3400cff6:	2300      	movs	r3, #0
}
3400cff8:	4618      	mov	r0, r3
3400cffa:	3714      	adds	r7, #20
3400cffc:	46bd      	mov	sp, r7
3400cffe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d002:	4770      	bx	lr

3400d004 <dev_adc_readfn>:

/*
 * Read Device
 */
LOCAL ER dev_adc_readfn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400d004:	b580      	push	{r7, lr}
3400d006:	b084      	sub	sp, #16
3400d008:	af00      	add	r7, sp, #0
3400d00a:	6078      	str	r0, [r7, #4]
3400d00c:	6039      	str	r1, [r7, #0]
	T_HAL_ADC_DCB	*p_dcb;
	ER		err;

	p_dcb = (T_HAL_ADC_DCB*)(p_msdi->dmsdi.exinf);
3400d00e:	683b      	ldr	r3, [r7, #0]
3400d010:	691b      	ldr	r3, [r3, #16]
3400d012:	60bb      	str	r3, [r7, #8]
	if(p_dcb->hadc == NULL) return E_IO;
3400d014:	68bb      	ldr	r3, [r7, #8]
3400d016:	681b      	ldr	r3, [r3, #0]
3400d018:	2b00      	cmp	r3, #0
3400d01a:	d102      	bne.n	3400d022 <dev_adc_readfn+0x1e>
3400d01c:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400d020:	e00f      	b.n	3400d042 <dev_adc_readfn+0x3e>

	if(req->start >= 0) {
3400d022:	687b      	ldr	r3, [r7, #4]
3400d024:	691b      	ldr	r3, [r3, #16]
3400d026:	2b00      	cmp	r3, #0
3400d028:	db05      	blt.n	3400d036 <dev_adc_readfn+0x32>
		err = read_data( p_dcb, req);	// Device specific data
3400d02a:	6879      	ldr	r1, [r7, #4]
3400d02c:	68b8      	ldr	r0, [r7, #8]
3400d02e:	f7ff ff4f 	bl	3400ced0 <read_data>
3400d032:	60f8      	str	r0, [r7, #12]
3400d034:	e004      	b.n	3400d040 <dev_adc_readfn+0x3c>
	} else {
		err = read_atr( p_dcb, req);	// Device attribute data
3400d036:	6879      	ldr	r1, [r7, #4]
3400d038:	68b8      	ldr	r0, [r7, #8]
3400d03a:	f7ff fefd 	bl	3400ce38 <read_atr>
3400d03e:	60f8      	str	r0, [r7, #12]
	}
	return err;
3400d040:	68fb      	ldr	r3, [r7, #12]
}
3400d042:	4618      	mov	r0, r3
3400d044:	3710      	adds	r7, #16
3400d046:	46bd      	mov	sp, r7
3400d048:	bd80      	pop	{r7, pc}

3400d04a <dev_adc_writefn>:

/*
 * Write Device
 */
LOCAL ER dev_adc_writefn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400d04a:	b580      	push	{r7, lr}
3400d04c:	b084      	sub	sp, #16
3400d04e:	af00      	add	r7, sp, #0
3400d050:	6078      	str	r0, [r7, #4]
3400d052:	6039      	str	r1, [r7, #0]
	T_HAL_ADC_DCB	*p_dcb;
	ER		rtn;

	p_dcb = (T_HAL_ADC_DCB*)(p_msdi->dmsdi.exinf);
3400d054:	683b      	ldr	r3, [r7, #0]
3400d056:	691b      	ldr	r3, [r3, #16]
3400d058:	60bb      	str	r3, [r7, #8]
	if(p_dcb->hadc == NULL) return E_IO;
3400d05a:	68bb      	ldr	r3, [r7, #8]
3400d05c:	681b      	ldr	r3, [r3, #0]
3400d05e:	2b00      	cmp	r3, #0
3400d060:	d102      	bne.n	3400d068 <dev_adc_writefn+0x1e>
3400d062:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400d066:	e00f      	b.n	3400d088 <dev_adc_writefn+0x3e>

	if(req->start >= 0) {
3400d068:	687b      	ldr	r3, [r7, #4]
3400d06a:	691b      	ldr	r3, [r3, #16]
3400d06c:	2b00      	cmp	r3, #0
3400d06e:	db05      	blt.n	3400d07c <dev_adc_writefn+0x32>
		rtn = write_data( p_dcb, req);	// Device specific data
3400d070:	6879      	ldr	r1, [r7, #4]
3400d072:	68b8      	ldr	r0, [r7, #8]
3400d074:	f7ff ff92 	bl	3400cf9c <write_data>
3400d078:	60f8      	str	r0, [r7, #12]
3400d07a:	e004      	b.n	3400d086 <dev_adc_writefn+0x3c>
	} else {
		rtn = write_atr( p_dcb, req);	// Device attribute data
3400d07c:	6879      	ldr	r1, [r7, #4]
3400d07e:	68b8      	ldr	r0, [r7, #8]
3400d080:	f7ff fee7 	bl	3400ce52 <write_atr>
3400d084:	60f8      	str	r0, [r7, #12]
	}
	return rtn;
3400d086:	68fb      	ldr	r3, [r7, #12]
}
3400d088:	4618      	mov	r0, r3
3400d08a:	3710      	adds	r7, #16
3400d08c:	46bd      	mov	sp, r7
3400d08e:	bd80      	pop	{r7, pc}

3400d090 <dev_adc_eventfn>:

/*
 * Event Device
 */
LOCAL ER dev_adc_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi)
{
3400d090:	b480      	push	{r7}
3400d092:	b085      	sub	sp, #20
3400d094:	af00      	add	r7, sp, #0
3400d096:	60f8      	str	r0, [r7, #12]
3400d098:	60b9      	str	r1, [r7, #8]
3400d09a:	607a      	str	r2, [r7, #4]
	return E_NOSPT;
3400d09c:	f06f 0308 	mvn.w	r3, #8
}
3400d0a0:	4618      	mov	r0, r3
3400d0a2:	3714      	adds	r7, #20
3400d0a4:	46bd      	mov	sp, r7
3400d0a6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d0aa:	4770      	bx	lr

3400d0ac <dev_init_hal_adc>:

/*----------------------------------------------------------------------
 * Device driver initialization and registration
 */
EXPORT ER dev_init_hal_adc( UW unit, ADC_HandleTypeDef *hadc )
{
3400d0ac:	b580      	push	{r7, lr}
3400d0ae:	b094      	sub	sp, #80	@ 0x50
3400d0b0:	af00      	add	r7, sp, #0
3400d0b2:	6078      	str	r0, [r7, #4]
3400d0b4:	6039      	str	r1, [r7, #0]
	T_MSDI		*p_msdi;
	T_DMSDI		dmsdi;
	ER		err;
	INT		i;

	if( unit >= DEV_HAL_ADC_UNITNM) return E_PAR;
3400d0b6:	687b      	ldr	r3, [r7, #4]
3400d0b8:	2b02      	cmp	r3, #2
3400d0ba:	d902      	bls.n	3400d0c2 <dev_init_hal_adc+0x16>
3400d0bc:	f06f 0310 	mvn.w	r3, #16
3400d0c0:	e06d      	b.n	3400d19e <dev_init_hal_adc+0xf2>

#if TK_SUPPORT_MEMLIB
	p_dcb = (T_HAL_ADC_DCB*)Kmalloc(sizeof(T_HAL_ADC_DCB));
3400d0c2:	2020      	movs	r0, #32
3400d0c4:	f7ff f8fe 	bl	3400c2c4 <Kmalloc>
3400d0c8:	64b8      	str	r0, [r7, #72]	@ 0x48
	if( p_dcb == NULL) return E_NOMEM;
3400d0ca:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d0cc:	2b00      	cmp	r3, #0
3400d0ce:	d102      	bne.n	3400d0d6 <dev_init_hal_adc+0x2a>
3400d0d0:	f06f 0320 	mvn.w	r3, #32
3400d0d4:	e063      	b.n	3400d19e <dev_init_hal_adc+0xf2>
	dev_adc_cb[unit]	= p_dcb;
3400d0d6:	4934      	ldr	r1, [pc, #208]	@ (3400d1a8 <dev_init_hal_adc+0xfc>)
3400d0d8:	687b      	ldr	r3, [r7, #4]
3400d0da:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400d0dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#else
	p_dcb = &dev_adc_cb[unit];
#endif

	id_flgid = tk_cre_flg(&id_flg);
3400d0e0:	4832      	ldr	r0, [pc, #200]	@ (3400d1ac <dev_init_hal_adc+0x100>)
3400d0e2:	f7fc fc4f 	bl	34009984 <tk_cre_flg>
3400d0e6:	4603      	mov	r3, r0
3400d0e8:	4a31      	ldr	r2, [pc, #196]	@ (3400d1b0 <dev_init_hal_adc+0x104>)
3400d0ea:	6013      	str	r3, [r2, #0]
	if(id_flgid <= E_OK) {
3400d0ec:	4b30      	ldr	r3, [pc, #192]	@ (3400d1b0 <dev_init_hal_adc+0x104>)
3400d0ee:	681b      	ldr	r3, [r3, #0]
3400d0f0:	2b00      	cmp	r3, #0
3400d0f2:	dc03      	bgt.n	3400d0fc <dev_init_hal_adc+0x50>
		err = (ER)id_flgid;
3400d0f4:	4b2e      	ldr	r3, [pc, #184]	@ (3400d1b0 <dev_init_hal_adc+0x104>)
3400d0f6:	681b      	ldr	r3, [r3, #0]
3400d0f8:	64fb      	str	r3, [r7, #76]	@ 0x4c
		goto err_1;
3400d0fa:	e04c      	b.n	3400d196 <dev_init_hal_adc+0xea>
	}

	/* Device registration information */
	dmsdi.exinf	= p_dcb;
3400d0fc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d0fe:	60bb      	str	r3, [r7, #8]
	dmsdi.drvatr	= 0;			/* Driver attributes */
3400d100:	2300      	movs	r3, #0
3400d102:	61bb      	str	r3, [r7, #24]
	dmsdi.devatr	= TDK_UNDEF;		/* Device attributes */
3400d104:	2300      	movs	r3, #0
3400d106:	61fb      	str	r3, [r7, #28]
	dmsdi.nsub	= 0;			/* Number of sub units */
3400d108:	2300      	movs	r3, #0
3400d10a:	623b      	str	r3, [r7, #32]
	dmsdi.blksz	= 1;			/* Unique data block size (-1 = unknown) */
3400d10c:	2301      	movs	r3, #1
3400d10e:	627b      	str	r3, [r7, #36]	@ 0x24
	dmsdi.openfn	= dev_adc_openfn;
3400d110:	4b28      	ldr	r3, [pc, #160]	@ (3400d1b4 <dev_init_hal_adc+0x108>)
3400d112:	62bb      	str	r3, [r7, #40]	@ 0x28
	dmsdi.closefn	= dev_adc_closefn;
3400d114:	4b28      	ldr	r3, [pc, #160]	@ (3400d1b8 <dev_init_hal_adc+0x10c>)
3400d116:	62fb      	str	r3, [r7, #44]	@ 0x2c
	dmsdi.readfn	= dev_adc_readfn;
3400d118:	4b28      	ldr	r3, [pc, #160]	@ (3400d1bc <dev_init_hal_adc+0x110>)
3400d11a:	633b      	str	r3, [r7, #48]	@ 0x30
	dmsdi.writefn	= dev_adc_writefn;
3400d11c:	4b28      	ldr	r3, [pc, #160]	@ (3400d1c0 <dev_init_hal_adc+0x114>)
3400d11e:	637b      	str	r3, [r7, #52]	@ 0x34
	dmsdi.eventfn	= dev_adc_eventfn;
3400d120:	4b28      	ldr	r3, [pc, #160]	@ (3400d1c4 <dev_init_hal_adc+0x118>)
3400d122:	63bb      	str	r3, [r7, #56]	@ 0x38
	
	knl_strcpy( (char*)dmsdi.devnm, DEVNAME_HAL_ADC);
3400d124:	f107 0308 	add.w	r3, r7, #8
3400d128:	3304      	adds	r3, #4
3400d12a:	4927      	ldr	r1, [pc, #156]	@ (3400d1c8 <dev_init_hal_adc+0x11c>)
3400d12c:	4618      	mov	r0, r3
3400d12e:	f7fe fe9a 	bl	3400be66 <knl_strcpy>
	i = knl_strlen(DEVNAME_HAL_ADC);
3400d132:	4825      	ldr	r0, [pc, #148]	@ (3400d1c8 <dev_init_hal_adc+0x11c>)
3400d134:	f7fe fe86 	bl	3400be44 <knl_strlen>
3400d138:	6478      	str	r0, [r7, #68]	@ 0x44
	dmsdi.devnm[i] = (UB)('a' + unit);
3400d13a:	687b      	ldr	r3, [r7, #4]
3400d13c:	b2db      	uxtb	r3, r3
3400d13e:	3361      	adds	r3, #97	@ 0x61
3400d140:	b2d9      	uxtb	r1, r3
3400d142:	f107 020c 	add.w	r2, r7, #12
3400d146:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400d148:	4413      	add	r3, r2
3400d14a:	460a      	mov	r2, r1
3400d14c:	701a      	strb	r2, [r3, #0]
	dmsdi.devnm[i+1] = 0;
3400d14e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400d150:	3301      	adds	r3, #1
3400d152:	3350      	adds	r3, #80	@ 0x50
3400d154:	443b      	add	r3, r7
3400d156:	2200      	movs	r2, #0
3400d158:	f803 2c44 	strb.w	r2, [r3, #-68]

	err = msdi_def_dev( &dmsdi, &idev, &p_msdi);
3400d15c:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
3400d160:	f107 0140 	add.w	r1, r7, #64	@ 0x40
3400d164:	f107 0308 	add.w	r3, r7, #8
3400d168:	4618      	mov	r0, r3
3400d16a:	f7fb fd33 	bl	34008bd4 <msdi_def_dev>
3400d16e:	64f8      	str	r0, [r7, #76]	@ 0x4c
	if(err != E_OK) goto err_1;
3400d170:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400d172:	2b00      	cmp	r3, #0
3400d174:	d10e      	bne.n	3400d194 <dev_init_hal_adc+0xe8>

	p_dcb->hadc	= hadc;
3400d176:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d178:	683a      	ldr	r2, [r7, #0]
3400d17a:	601a      	str	r2, [r3, #0]
	p_dcb->devid	= p_msdi->devid;
3400d17c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400d17e:	681a      	ldr	r2, [r3, #0]
3400d180:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d182:	605a      	str	r2, [r3, #4]
	p_dcb->unit	= unit;
3400d184:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d186:	687a      	ldr	r2, [r7, #4]
3400d188:	609a      	str	r2, [r3, #8]
	p_dcb->evtmbfid	= idev.evtmbfid;
3400d18a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400d18c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d18e:	619a      	str	r2, [r3, #24]

	return E_OK;
3400d190:	2300      	movs	r3, #0
3400d192:	e004      	b.n	3400d19e <dev_init_hal_adc+0xf2>
	if(err != E_OK) goto err_1;
3400d194:	bf00      	nop

err_1:
#if TK_SUPPORT_MEMLIB
	Kfree(p_dcb);
3400d196:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3400d198:	f7ff f8a1 	bl	3400c2de <Kfree>
#endif
	return err;
3400d19c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
3400d19e:	4618      	mov	r0, r3
3400d1a0:	3750      	adds	r7, #80	@ 0x50
3400d1a2:	46bd      	mov	sp, r7
3400d1a4:	bd80      	pop	{r7, pc}
3400d1a6:	bf00      	nop
3400d1a8:	3400f6d0 	.word	0x3400f6d0
3400d1ac:	3400e124 	.word	0x3400e124
3400d1b0:	3400f6cc 	.word	0x3400f6cc
3400d1b4:	3400cfb7 	.word	0x3400cfb7
3400d1b8:	3400cfeb 	.word	0x3400cfeb
3400d1bc:	3400d005 	.word	0x3400d005
3400d1c0:	3400d04b 	.word	0x3400d04b
3400d1c4:	3400d091 	.word	0x3400d091
3400d1c8:	3400df30 	.word	0x3400df30

3400d1cc <dev_adc_setch>:
	ADC_CHANNEL_12, ADC_CHANNEL_13, ADC_CHANNEL_14, ADC_CHANNEL_15, ADC_CHANNEL_16, ADC_CHANNEL_17, 
	ADC_CHANNEL_18, ADC_CHANNEL_19, 
};

EXPORT ER dev_adc_setch(ADC_HandleTypeDef *hadc, UW unit, W start)
{
3400d1cc:	b580      	push	{r7, lr}
3400d1ce:	b08e      	sub	sp, #56	@ 0x38
3400d1d0:	af00      	add	r7, sp, #0
3400d1d2:	60f8      	str	r0, [r7, #12]
3400d1d4:	60b9      	str	r1, [r7, #8]
3400d1d6:	607a      	str	r2, [r7, #4]
	ADC_ChannelConfTypeDef	sConfig = {0};
3400d1d8:	f107 0314 	add.w	r3, r7, #20
3400d1dc:	2220      	movs	r2, #32
3400d1de:	2100      	movs	r1, #0
3400d1e0:	4618      	mov	r0, r3
3400d1e2:	f000 fc31 	bl	3400da48 <memset>
	HAL_StatusTypeDef	hal_sts;

	if(start >= sizeof(adc_cfg_ch)/sizeof(UW)) return E_PAR;
3400d1e6:	687b      	ldr	r3, [r7, #4]
3400d1e8:	2b13      	cmp	r3, #19
3400d1ea:	d902      	bls.n	3400d1f2 <dev_adc_setch+0x26>
3400d1ec:	f06f 0310 	mvn.w	r3, #16
3400d1f0:	e036      	b.n	3400d260 <dev_adc_setch+0x94>

	sConfig.Channel = adc_cfg_ch[start];
3400d1f2:	4a1d      	ldr	r2, [pc, #116]	@ (3400d268 <dev_adc_setch+0x9c>)
3400d1f4:	687b      	ldr	r3, [r7, #4]
3400d1f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400d1fa:	617b      	str	r3, [r7, #20]
	if(unit == 0) {		// ADC1
3400d1fc:	68bb      	ldr	r3, [r7, #8]
3400d1fe:	2b00      	cmp	r3, #0
3400d200:	d10b      	bne.n	3400d21a <dev_adc_setch+0x4e>
		sConfig.Rank = ADC_REGULAR_RANK_1;
3400d202:	2306      	movs	r3, #6
3400d204:	61bb      	str	r3, [r7, #24]
		sConfig.SamplingTime = ADC_SAMPLETIME_246CYCLES_5;
3400d206:	2306      	movs	r3, #6
3400d208:	61fb      	str	r3, [r7, #28]
		sConfig.SingleDiff = ADC_SINGLE_ENDED;
3400d20a:	f240 33ff 	movw	r3, #1023	@ 0x3ff
3400d20e:	623b      	str	r3, [r7, #32]
		sConfig.OffsetNumber = ADC_OFFSET_NONE;
3400d210:	2304      	movs	r3, #4
3400d212:	627b      	str	r3, [r7, #36]	@ 0x24
		sConfig.Offset = 0;
3400d214:	2300      	movs	r3, #0
3400d216:	62bb      	str	r3, [r7, #40]	@ 0x28
3400d218:	e011      	b.n	3400d23e <dev_adc_setch+0x72>
	}else if(unit == 1) {	// ADC2
3400d21a:	68bb      	ldr	r3, [r7, #8]
3400d21c:	2b01      	cmp	r3, #1
3400d21e:	d10b      	bne.n	3400d238 <dev_adc_setch+0x6c>
		sConfig.Rank = ADC_REGULAR_RANK_1;
3400d220:	2306      	movs	r3, #6
3400d222:	61bb      	str	r3, [r7, #24]
		sConfig.SamplingTime = ADC_SAMPLETIME_246CYCLES_5;
3400d224:	2306      	movs	r3, #6
3400d226:	61fb      	str	r3, [r7, #28]
		sConfig.SingleDiff = ADC_SINGLE_ENDED;
3400d228:	f240 33ff 	movw	r3, #1023	@ 0x3ff
3400d22c:	623b      	str	r3, [r7, #32]
		sConfig.OffsetNumber = ADC_OFFSET_NONE;
3400d22e:	2304      	movs	r3, #4
3400d230:	627b      	str	r3, [r7, #36]	@ 0x24
		sConfig.Offset = 0;
3400d232:	2300      	movs	r3, #0
3400d234:	62bb      	str	r3, [r7, #40]	@ 0x28
3400d236:	e002      	b.n	3400d23e <dev_adc_setch+0x72>
	} else {
		return E_IO;
3400d238:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400d23c:	e010      	b.n	3400d260 <dev_adc_setch+0x94>
	}

	hal_sts = HAL_ADC_ConfigChannel(hadc, &sConfig);
3400d23e:	f107 0314 	add.w	r3, r7, #20
3400d242:	4619      	mov	r1, r3
3400d244:	68f8      	ldr	r0, [r7, #12]
3400d246:	f7f5 fd05 	bl	34002c54 <HAL_ADC_ConfigChannel>
3400d24a:	4603      	mov	r3, r0
3400d24c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37

	return (hal_sts == HAL_OK)?E_OK:E_IO;
3400d250:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400d254:	2b00      	cmp	r3, #0
3400d256:	d101      	bne.n	3400d25c <dev_adc_setch+0x90>
3400d258:	2300      	movs	r3, #0
3400d25a:	e001      	b.n	3400d260 <dev_adc_setch+0x94>
3400d25c:	f06f 0338 	mvn.w	r3, #56	@ 0x38
}
3400d260:	4618      	mov	r0, r3
3400d262:	3738      	adds	r7, #56	@ 0x38
3400d264:	46bd      	mov	sp, r7
3400d266:	bd80      	pop	{r7, pc}
3400d268:	3400e090 	.word	0x3400e090

3400d26c <knl_EnterTaskIndependent>:
{
3400d26c:	b480      	push	{r7}
3400d26e:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400d270:	4b04      	ldr	r3, [pc, #16]	@ (3400d284 <knl_EnterTaskIndependent+0x18>)
3400d272:	681b      	ldr	r3, [r3, #0]
3400d274:	3301      	adds	r3, #1
3400d276:	4a03      	ldr	r2, [pc, #12]	@ (3400d284 <knl_EnterTaskIndependent+0x18>)
3400d278:	6013      	str	r3, [r2, #0]
}
3400d27a:	bf00      	nop
3400d27c:	46bd      	mov	sp, r7
3400d27e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d282:	4770      	bx	lr
3400d284:	3400f6b0 	.word	0x3400f6b0

3400d288 <knl_LeaveTaskIndependent>:
{
3400d288:	b480      	push	{r7}
3400d28a:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400d28c:	4b04      	ldr	r3, [pc, #16]	@ (3400d2a0 <knl_LeaveTaskIndependent+0x18>)
3400d28e:	681b      	ldr	r3, [r3, #0]
3400d290:	3b01      	subs	r3, #1
3400d292:	4a03      	ldr	r2, [pc, #12]	@ (3400d2a0 <knl_LeaveTaskIndependent+0x18>)
3400d294:	6013      	str	r3, [r2, #0]
}
3400d296:	bf00      	nop
3400d298:	46bd      	mov	sp, r7
3400d29a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d29e:	4770      	bx	lr
3400d2a0:	3400f6b0 	.word	0x3400f6b0

3400d2a4 <read_atr>:

/*---------------------------------------------------------------------*/
/* Attribute data control
 */
LOCAL ER read_atr(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400d2a4:	b480      	push	{r7}
3400d2a6:	b083      	sub	sp, #12
3400d2a8:	af00      	add	r7, sp, #0
3400d2aa:	6078      	str	r0, [r7, #4]
3400d2ac:	6039      	str	r1, [r7, #0]
	if((req->start >= TDN_HAL_I2C_MODE) && (req->start <= TDN_HAL_I2C_MAX)) return E_PAR;
3400d2ae:	683b      	ldr	r3, [r7, #0]
3400d2b0:	691b      	ldr	r3, [r3, #16]
3400d2b2:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400d2b6:	db07      	blt.n	3400d2c8 <read_atr+0x24>
3400d2b8:	683b      	ldr	r3, [r7, #0]
3400d2ba:	691b      	ldr	r3, [r3, #16]
3400d2bc:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400d2c0:	da02      	bge.n	3400d2c8 <read_atr+0x24>
3400d2c2:	f06f 0310 	mvn.w	r3, #16
3400d2c6:	e027      	b.n	3400d318 <read_atr+0x74>

	req->asize = sizeof(UW);
3400d2c8:	683b      	ldr	r3, [r7, #0]
3400d2ca:	2204      	movs	r2, #4
3400d2cc:	61da      	str	r2, [r3, #28]
	
	if(req->size == 0) return E_OK;
3400d2ce:	683b      	ldr	r3, [r7, #0]
3400d2d0:	695b      	ldr	r3, [r3, #20]
3400d2d2:	2b00      	cmp	r3, #0
3400d2d4:	d101      	bne.n	3400d2da <read_atr+0x36>
3400d2d6:	2300      	movs	r3, #0
3400d2d8:	e01e      	b.n	3400d318 <read_atr+0x74>
	else if(req->size != sizeof(UW)) return E_PAR;
3400d2da:	683b      	ldr	r3, [r7, #0]
3400d2dc:	695b      	ldr	r3, [r3, #20]
3400d2de:	2b04      	cmp	r3, #4
3400d2e0:	d002      	beq.n	3400d2e8 <read_atr+0x44>
3400d2e2:	f06f 0310 	mvn.w	r3, #16
3400d2e6:	e017      	b.n	3400d318 <read_atr+0x74>

	switch(req->start) {
3400d2e8:	683b      	ldr	r3, [r7, #0]
3400d2ea:	691b      	ldr	r3, [r3, #16]
3400d2ec:	f113 0f65 	cmn.w	r3, #101	@ 0x65
3400d2f0:	d008      	beq.n	3400d304 <read_atr+0x60>
3400d2f2:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400d2f6:	d10b      	bne.n	3400d310 <read_atr+0x6c>
	case TDN_HAL_I2C_MODE:
		*(UW*)req->buf = p_dcb->dmode;
3400d2f8:	683b      	ldr	r3, [r7, #0]
3400d2fa:	699b      	ldr	r3, [r3, #24]
3400d2fc:	687a      	ldr	r2, [r7, #4]
3400d2fe:	6992      	ldr	r2, [r2, #24]
3400d300:	601a      	str	r2, [r3, #0]
		break;
3400d302:	e008      	b.n	3400d316 <read_atr+0x72>
	case TDN_HAL_I2C_TADR:
		*(UW*)req->buf = p_dcb->tadr;
3400d304:	683b      	ldr	r3, [r7, #0]
3400d306:	699b      	ldr	r3, [r3, #24]
3400d308:	687a      	ldr	r2, [r7, #4]
3400d30a:	69d2      	ldr	r2, [r2, #28]
3400d30c:	601a      	str	r2, [r3, #0]
		break;
3400d30e:	e002      	b.n	3400d316 <read_atr+0x72>
	default:
		return E_PAR;
3400d310:	f06f 0310 	mvn.w	r3, #16
3400d314:	e000      	b.n	3400d318 <read_atr+0x74>
	}
	return E_OK;
3400d316:	2300      	movs	r3, #0
}
3400d318:	4618      	mov	r0, r3
3400d31a:	370c      	adds	r7, #12
3400d31c:	46bd      	mov	sp, r7
3400d31e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d322:	4770      	bx	lr

3400d324 <write_atr>:

LOCAL ER write_atr(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400d324:	b480      	push	{r7}
3400d326:	b085      	sub	sp, #20
3400d328:	af00      	add	r7, sp, #0
3400d32a:	6078      	str	r0, [r7, #4]
3400d32c:	6039      	str	r1, [r7, #0]
	UW	data;

	if(req->size != sizeof(UW)) return E_PAR;
3400d32e:	683b      	ldr	r3, [r7, #0]
3400d330:	695b      	ldr	r3, [r3, #20]
3400d332:	2b04      	cmp	r3, #4
3400d334:	d002      	beq.n	3400d33c <write_atr+0x18>
3400d336:	f06f 0310 	mvn.w	r3, #16
3400d33a:	e020      	b.n	3400d37e <write_atr+0x5a>
	data = *(UW*)req->buf;
3400d33c:	683b      	ldr	r3, [r7, #0]
3400d33e:	699b      	ldr	r3, [r3, #24]
3400d340:	681b      	ldr	r3, [r3, #0]
3400d342:	60fb      	str	r3, [r7, #12]

	switch(req->start) {
3400d344:	683b      	ldr	r3, [r7, #0]
3400d346:	691b      	ldr	r3, [r3, #16]
3400d348:	f113 0f65 	cmn.w	r3, #101	@ 0x65
3400d34c:	d00c      	beq.n	3400d368 <write_atr+0x44>
3400d34e:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400d352:	d10d      	bne.n	3400d370 <write_atr+0x4c>
	case TDN_HAL_I2C_MODE:
		if(data <HAL_I2C_MODE_CNT || data > HAL_I2C_MODE_TAR) return E_PAR;
3400d354:	68fb      	ldr	r3, [r7, #12]
3400d356:	2b01      	cmp	r3, #1
3400d358:	d902      	bls.n	3400d360 <write_atr+0x3c>
3400d35a:	f06f 0310 	mvn.w	r3, #16
3400d35e:	e00e      	b.n	3400d37e <write_atr+0x5a>
		p_dcb->dmode = data;
3400d360:	687b      	ldr	r3, [r7, #4]
3400d362:	68fa      	ldr	r2, [r7, #12]
3400d364:	619a      	str	r2, [r3, #24]
		break;
3400d366:	e006      	b.n	3400d376 <write_atr+0x52>
	case TDN_HAL_I2C_TADR:
		p_dcb->tadr = data;
3400d368:	687b      	ldr	r3, [r7, #4]
3400d36a:	68fa      	ldr	r2, [r7, #12]
3400d36c:	61da      	str	r2, [r3, #28]
		break;
3400d36e:	e002      	b.n	3400d376 <write_atr+0x52>
	default:
		return E_PAR;
3400d370:	f06f 0310 	mvn.w	r3, #16
3400d374:	e003      	b.n	3400d37e <write_atr+0x5a>
	}
	req->asize = sizeof(UW);
3400d376:	683b      	ldr	r3, [r7, #0]
3400d378:	2204      	movs	r2, #4
3400d37a:	61da      	str	r2, [r3, #28]
	return E_OK;
3400d37c:	2300      	movs	r3, #0
}
3400d37e:	4618      	mov	r0, r3
3400d380:	3714      	adds	r7, #20
3400d382:	46bd      	mov	sp, r7
3400d384:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d388:	4770      	bx	lr
	...

3400d38c <HAL_I2C_Callback>:
/*Device-specific data control
 */

/* HAL Callback functions */
LOCAL void HAL_I2C_Callback(I2C_HandleTypeDef *hi2c, ER err)
{
3400d38c:	b580      	push	{r7, lr}
3400d38e:	b084      	sub	sp, #16
3400d390:	af00      	add	r7, sp, #0
3400d392:	6078      	str	r0, [r7, #4]
3400d394:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	UINT	i;

	ENTER_TASK_INDEPENDENT
3400d396:	f7ff ff69 	bl	3400d26c <knl_EnterTaskIndependent>

	for(i = 0; i < DEV_HAL_I2C_UNITNM; i++) {
3400d39a:	2300      	movs	r3, #0
3400d39c:	60fb      	str	r3, [r7, #12]
3400d39e:	e01b      	b.n	3400d3d8 <HAL_I2C_Callback+0x4c>
		p_dcb = get_dcb_ptr(i);
3400d3a0:	4a12      	ldr	r2, [pc, #72]	@ (3400d3ec <HAL_I2C_Callback+0x60>)
3400d3a2:	68fb      	ldr	r3, [r7, #12]
3400d3a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400d3a8:	60bb      	str	r3, [r7, #8]
		if(p_dcb->hi2c == hi2c) {
3400d3aa:	68bb      	ldr	r3, [r7, #8]
3400d3ac:	681b      	ldr	r3, [r3, #0]
3400d3ae:	687a      	ldr	r2, [r7, #4]
3400d3b0:	429a      	cmp	r2, r3
3400d3b2:	d10e      	bne.n	3400d3d2 <HAL_I2C_Callback+0x46>
			p_dcb->err = err;
3400d3b4:	68bb      	ldr	r3, [r7, #8]
3400d3b6:	683a      	ldr	r2, [r7, #0]
3400d3b8:	611a      	str	r2, [r3, #16]
			tk_set_flg(id_flgid, 1<< p_dcb->unit);
3400d3ba:	4b0d      	ldr	r3, [pc, #52]	@ (3400d3f0 <HAL_I2C_Callback+0x64>)
3400d3bc:	681a      	ldr	r2, [r3, #0]
3400d3be:	68bb      	ldr	r3, [r7, #8]
3400d3c0:	68db      	ldr	r3, [r3, #12]
3400d3c2:	2101      	movs	r1, #1
3400d3c4:	fa01 f303 	lsl.w	r3, r1, r3
3400d3c8:	4619      	mov	r1, r3
3400d3ca:	4610      	mov	r0, r2
3400d3cc:	f7fc fb8a 	bl	34009ae4 <tk_set_flg>
			break;
3400d3d0:	e005      	b.n	3400d3de <HAL_I2C_Callback+0x52>
	for(i = 0; i < DEV_HAL_I2C_UNITNM; i++) {
3400d3d2:	68fb      	ldr	r3, [r7, #12]
3400d3d4:	3301      	adds	r3, #1
3400d3d6:	60fb      	str	r3, [r7, #12]
3400d3d8:	68fb      	ldr	r3, [r7, #12]
3400d3da:	2b04      	cmp	r3, #4
3400d3dc:	d9e0      	bls.n	3400d3a0 <HAL_I2C_Callback+0x14>
		}
	}

	LEAVE_TASK_INDEPENDENT
3400d3de:	f7ff ff53 	bl	3400d288 <knl_LeaveTaskIndependent>
}
3400d3e2:	bf00      	nop
3400d3e4:	3710      	adds	r7, #16
3400d3e6:	46bd      	mov	sp, r7
3400d3e8:	bd80      	pop	{r7, pc}
3400d3ea:	bf00      	nop
3400d3ec:	3400f6e0 	.word	0x3400f6e0
3400d3f0:	3400f6dc 	.word	0x3400f6dc

3400d3f4 <HAL_I2C_MasterRxCpltCallback>:

void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d3f4:	b580      	push	{r7, lr}
3400d3f6:	b082      	sub	sp, #8
3400d3f8:	af00      	add	r7, sp, #0
3400d3fa:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d3fc:	2100      	movs	r1, #0
3400d3fe:	6878      	ldr	r0, [r7, #4]
3400d400:	f7ff ffc4 	bl	3400d38c <HAL_I2C_Callback>
}
3400d404:	bf00      	nop
3400d406:	3708      	adds	r7, #8
3400d408:	46bd      	mov	sp, r7
3400d40a:	bd80      	pop	{r7, pc}

3400d40c <HAL_I2C_MasterTxCpltCallback>:

void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d40c:	b580      	push	{r7, lr}
3400d40e:	b082      	sub	sp, #8
3400d410:	af00      	add	r7, sp, #0
3400d412:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d414:	2100      	movs	r1, #0
3400d416:	6878      	ldr	r0, [r7, #4]
3400d418:	f7ff ffb8 	bl	3400d38c <HAL_I2C_Callback>
}
3400d41c:	bf00      	nop
3400d41e:	3708      	adds	r7, #8
3400d420:	46bd      	mov	sp, r7
3400d422:	bd80      	pop	{r7, pc}

3400d424 <HAL_I2C_SlaveRxCpltCallback>:

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d424:	b580      	push	{r7, lr}
3400d426:	b082      	sub	sp, #8
3400d428:	af00      	add	r7, sp, #0
3400d42a:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d42c:	2100      	movs	r1, #0
3400d42e:	6878      	ldr	r0, [r7, #4]
3400d430:	f7ff ffac 	bl	3400d38c <HAL_I2C_Callback>
}
3400d434:	bf00      	nop
3400d436:	3708      	adds	r7, #8
3400d438:	46bd      	mov	sp, r7
3400d43a:	bd80      	pop	{r7, pc}

3400d43c <HAL_I2C_SlaveTxCpltCallback>:

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d43c:	b580      	push	{r7, lr}
3400d43e:	b082      	sub	sp, #8
3400d440:	af00      	add	r7, sp, #0
3400d442:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d444:	2100      	movs	r1, #0
3400d446:	6878      	ldr	r0, [r7, #4]
3400d448:	f7ff ffa0 	bl	3400d38c <HAL_I2C_Callback>
}
3400d44c:	bf00      	nop
3400d44e:	3708      	adds	r7, #8
3400d450:	46bd      	mov	sp, r7
3400d452:	bd80      	pop	{r7, pc}

3400d454 <HAL_I2C_MemRxCpltCallback>:

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d454:	b580      	push	{r7, lr}
3400d456:	b082      	sub	sp, #8
3400d458:	af00      	add	r7, sp, #0
3400d45a:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d45c:	2100      	movs	r1, #0
3400d45e:	6878      	ldr	r0, [r7, #4]
3400d460:	f7ff ff94 	bl	3400d38c <HAL_I2C_Callback>
}
3400d464:	bf00      	nop
3400d466:	3708      	adds	r7, #8
3400d468:	46bd      	mov	sp, r7
3400d46a:	bd80      	pop	{r7, pc}

3400d46c <HAL_I2C_MemTxCpltCallback>:

void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d46c:	b580      	push	{r7, lr}
3400d46e:	b082      	sub	sp, #8
3400d470:	af00      	add	r7, sp, #0
3400d472:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400d474:	2100      	movs	r1, #0
3400d476:	6878      	ldr	r0, [r7, #4]
3400d478:	f7ff ff88 	bl	3400d38c <HAL_I2C_Callback>
}
3400d47c:	bf00      	nop
3400d47e:	3708      	adds	r7, #8
3400d480:	46bd      	mov	sp, r7
3400d482:	bd80      	pop	{r7, pc}

3400d484 <HAL_I2C_ErrorCallback>:

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
3400d484:	b580      	push	{r7, lr}
3400d486:	b082      	sub	sp, #8
3400d488:	af00      	add	r7, sp, #0
3400d48a:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_IO);
3400d48c:	f06f 0138 	mvn.w	r1, #56	@ 0x38
3400d490:	6878      	ldr	r0, [r7, #4]
3400d492:	f7ff ff7b 	bl	3400d38c <HAL_I2C_Callback>
}
3400d496:	bf00      	nop
3400d498:	3708      	adds	r7, #8
3400d49a:	46bd      	mov	sp, r7
3400d49c:	bd80      	pop	{r7, pc}

3400d49e <HAL_I2C_AbortCpltCallback>:

void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400d49e:	b580      	push	{r7, lr}
3400d4a0:	b082      	sub	sp, #8
3400d4a2:	af00      	add	r7, sp, #0
3400d4a4:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_ABORT);
3400d4a6:	f06f 0141 	mvn.w	r1, #65	@ 0x41
3400d4aa:	6878      	ldr	r0, [r7, #4]
3400d4ac:	f7ff ff6e 	bl	3400d38c <HAL_I2C_Callback>
}
3400d4b0:	bf00      	nop
3400d4b2:	3708      	adds	r7, #8
3400d4b4:	46bd      	mov	sp, r7
3400d4b6:	bd80      	pop	{r7, pc}

3400d4b8 <read_data>:

LOCAL ER read_data(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400d4b8:	b580      	push	{r7, lr}
3400d4ba:	b088      	sub	sp, #32
3400d4bc:	af02      	add	r7, sp, #8
3400d4be:	6078      	str	r0, [r7, #4]
3400d4c0:	6039      	str	r1, [r7, #0]
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	wflgptn = 1 << p_dcb->unit;
3400d4c2:	687b      	ldr	r3, [r7, #4]
3400d4c4:	68db      	ldr	r3, [r3, #12]
3400d4c6:	2201      	movs	r2, #1
3400d4c8:	fa02 f303 	lsl.w	r3, r2, r3
3400d4cc:	60fb      	str	r3, [r7, #12]
	tk_clr_flg(id_flgid, ~wflgptn);
3400d4ce:	4b2a      	ldr	r3, [pc, #168]	@ (3400d578 <read_data+0xc0>)
3400d4d0:	681a      	ldr	r2, [r3, #0]
3400d4d2:	68fb      	ldr	r3, [r7, #12]
3400d4d4:	43db      	mvns	r3, r3
3400d4d6:	4619      	mov	r1, r3
3400d4d8:	4610      	mov	r0, r2
3400d4da:	f7fc fb8b 	bl	34009bf4 <tk_clr_flg>

	switch(p_dcb->dmode) {
3400d4de:	687b      	ldr	r3, [r7, #4]
3400d4e0:	699b      	ldr	r3, [r3, #24]
3400d4e2:	2b00      	cmp	r3, #0
3400d4e4:	d002      	beq.n	3400d4ec <read_data+0x34>
3400d4e6:	2b01      	cmp	r3, #1
3400d4e8:	d011      	beq.n	3400d50e <read_data+0x56>
3400d4ea:	e01d      	b.n	3400d528 <read_data+0x70>
	case HAL_I2C_MODE_CNT:
		hal_sts = HAL_I2C_Master_Receive_IT(
3400d4ec:	687b      	ldr	r3, [r7, #4]
3400d4ee:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			(req->start)<<1,	// Target device address
3400d4f0:	683b      	ldr	r3, [r7, #0]
3400d4f2:	691b      	ldr	r3, [r3, #16]
		hal_sts = HAL_I2C_Master_Receive_IT(
3400d4f4:	b29b      	uxth	r3, r3
3400d4f6:	005b      	lsls	r3, r3, #1
3400d4f8:	b299      	uxth	r1, r3
			req->buf,		// Pointer to data buffer
3400d4fa:	683b      	ldr	r3, [r7, #0]
3400d4fc:	699a      	ldr	r2, [r3, #24]
			req->size		// Amount of data to be sent
3400d4fe:	683b      	ldr	r3, [r7, #0]
3400d500:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Master_Receive_IT(
3400d502:	b29b      	uxth	r3, r3
3400d504:	f7f6 fe82 	bl	3400420c <HAL_I2C_Master_Receive_IT>
3400d508:	4603      	mov	r3, r0
3400d50a:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400d50c:	e00f      	b.n	3400d52e <read_data+0x76>
	case HAL_I2C_MODE_TAR:
		hal_sts = HAL_I2C_Slave_Receive_IT(
3400d50e:	687b      	ldr	r3, [r7, #4]
3400d510:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			req->buf,		// Pointer to data buffer
3400d512:	683b      	ldr	r3, [r7, #0]
3400d514:	6999      	ldr	r1, [r3, #24]
			req->size		// Amount of data to be sent
3400d516:	683b      	ldr	r3, [r7, #0]
3400d518:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Slave_Receive_IT(
3400d51a:	b29b      	uxth	r3, r3
3400d51c:	461a      	mov	r2, r3
3400d51e:	f7f6 ff53 	bl	340043c8 <HAL_I2C_Slave_Receive_IT>
3400d522:	4603      	mov	r3, r0
3400d524:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400d526:	e002      	b.n	3400d52e <read_data+0x76>
	default:
		return E_SYS;
3400d528:	f06f 0304 	mvn.w	r3, #4
3400d52c:	e01f      	b.n	3400d56e <read_data+0xb6>
	}
	if(hal_sts != HAL_OK) return E_BUSY;
3400d52e:	7dfb      	ldrb	r3, [r7, #23]
3400d530:	2b00      	cmp	r3, #0
3400d532:	d002      	beq.n	3400d53a <read_data+0x82>
3400d534:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400d538:	e019      	b.n	3400d56e <read_data+0xb6>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_I2C_TMOUT);
3400d53a:	4b0f      	ldr	r3, [pc, #60]	@ (3400d578 <read_data+0xc0>)
3400d53c:	6818      	ldr	r0, [r3, #0]
3400d53e:	f107 0308 	add.w	r3, r7, #8
3400d542:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400d546:	9200      	str	r2, [sp, #0]
3400d548:	2220      	movs	r2, #32
3400d54a:	68f9      	ldr	r1, [r7, #12]
3400d54c:	f7fc fbb6 	bl	34009cbc <tk_wai_flg>
3400d550:	6138      	str	r0, [r7, #16]
	if(err >= E_OK) {
3400d552:	693b      	ldr	r3, [r7, #16]
3400d554:	2b00      	cmp	r3, #0
3400d556:	db09      	blt.n	3400d56c <read_data+0xb4>
		err  = p_dcb->err;
3400d558:	687b      	ldr	r3, [r7, #4]
3400d55a:	691b      	ldr	r3, [r3, #16]
3400d55c:	613b      	str	r3, [r7, #16]
		if(err >= E_OK) req->asize = req->size;
3400d55e:	693b      	ldr	r3, [r7, #16]
3400d560:	2b00      	cmp	r3, #0
3400d562:	db03      	blt.n	3400d56c <read_data+0xb4>
3400d564:	683b      	ldr	r3, [r7, #0]
3400d566:	695a      	ldr	r2, [r3, #20]
3400d568:	683b      	ldr	r3, [r7, #0]
3400d56a:	61da      	str	r2, [r3, #28]
	}

	return err;
3400d56c:	693b      	ldr	r3, [r7, #16]
}
3400d56e:	4618      	mov	r0, r3
3400d570:	3718      	adds	r7, #24
3400d572:	46bd      	mov	sp, r7
3400d574:	bd80      	pop	{r7, pc}
3400d576:	bf00      	nop
3400d578:	3400f6dc 	.word	0x3400f6dc

3400d57c <write_data>:

LOCAL ER write_data(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400d57c:	b580      	push	{r7, lr}
3400d57e:	b088      	sub	sp, #32
3400d580:	af02      	add	r7, sp, #8
3400d582:	6078      	str	r0, [r7, #4]
3400d584:	6039      	str	r1, [r7, #0]
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	wflgptn = 1 << p_dcb->unit;
3400d586:	687b      	ldr	r3, [r7, #4]
3400d588:	68db      	ldr	r3, [r3, #12]
3400d58a:	2201      	movs	r2, #1
3400d58c:	fa02 f303 	lsl.w	r3, r2, r3
3400d590:	60fb      	str	r3, [r7, #12]
	tk_clr_flg(id_flgid, ~wflgptn);
3400d592:	4b2a      	ldr	r3, [pc, #168]	@ (3400d63c <write_data+0xc0>)
3400d594:	681a      	ldr	r2, [r3, #0]
3400d596:	68fb      	ldr	r3, [r7, #12]
3400d598:	43db      	mvns	r3, r3
3400d59a:	4619      	mov	r1, r3
3400d59c:	4610      	mov	r0, r2
3400d59e:	f7fc fb29 	bl	34009bf4 <tk_clr_flg>

	switch(p_dcb->dmode) {
3400d5a2:	687b      	ldr	r3, [r7, #4]
3400d5a4:	699b      	ldr	r3, [r3, #24]
3400d5a6:	2b00      	cmp	r3, #0
3400d5a8:	d002      	beq.n	3400d5b0 <write_data+0x34>
3400d5aa:	2b01      	cmp	r3, #1
3400d5ac:	d011      	beq.n	3400d5d2 <write_data+0x56>
3400d5ae:	e01d      	b.n	3400d5ec <write_data+0x70>
	case HAL_I2C_MODE_CNT:
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400d5b0:	687b      	ldr	r3, [r7, #4]
3400d5b2:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			(req->start)<<1,	// Target device address
3400d5b4:	683b      	ldr	r3, [r7, #0]
3400d5b6:	691b      	ldr	r3, [r3, #16]
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400d5b8:	b29b      	uxth	r3, r3
3400d5ba:	005b      	lsls	r3, r3, #1
3400d5bc:	b299      	uxth	r1, r3
			req->buf,		// Pointer to data buffer
3400d5be:	683b      	ldr	r3, [r7, #0]
3400d5c0:	699a      	ldr	r2, [r3, #24]
			req->size		// Amount of data to be sent
3400d5c2:	683b      	ldr	r3, [r7, #0]
3400d5c4:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400d5c6:	b29b      	uxth	r3, r3
3400d5c8:	f7f6 fdb0 	bl	3400412c <HAL_I2C_Master_Transmit_IT>
3400d5cc:	4603      	mov	r3, r0
3400d5ce:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400d5d0:	e00f      	b.n	3400d5f2 <write_data+0x76>
	case HAL_I2C_MODE_TAR:
		hal_sts = HAL_I2C_Slave_Transmit_IT(
3400d5d2:	687b      	ldr	r3, [r7, #4]
3400d5d4:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			req->buf,		// Pointer to data buffer
3400d5d6:	683b      	ldr	r3, [r7, #0]
3400d5d8:	6999      	ldr	r1, [r3, #24]
			req->size		// Amount of data to be sent
3400d5da:	683b      	ldr	r3, [r7, #0]
3400d5dc:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Slave_Transmit_IT(
3400d5de:	b29b      	uxth	r3, r3
3400d5e0:	461a      	mov	r2, r3
3400d5e2:	f7f6 fe83 	bl	340042ec <HAL_I2C_Slave_Transmit_IT>
3400d5e6:	4603      	mov	r3, r0
3400d5e8:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400d5ea:	e002      	b.n	3400d5f2 <write_data+0x76>
	default:
		return E_SYS;
3400d5ec:	f06f 0304 	mvn.w	r3, #4
3400d5f0:	e01f      	b.n	3400d632 <write_data+0xb6>
	}
	if(hal_sts != HAL_OK) return E_BUSY;
3400d5f2:	7dfb      	ldrb	r3, [r7, #23]
3400d5f4:	2b00      	cmp	r3, #0
3400d5f6:	d002      	beq.n	3400d5fe <write_data+0x82>
3400d5f8:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400d5fc:	e019      	b.n	3400d632 <write_data+0xb6>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_I2C_TMOUT);
3400d5fe:	4b0f      	ldr	r3, [pc, #60]	@ (3400d63c <write_data+0xc0>)
3400d600:	6818      	ldr	r0, [r3, #0]
3400d602:	f107 0308 	add.w	r3, r7, #8
3400d606:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400d60a:	9200      	str	r2, [sp, #0]
3400d60c:	2220      	movs	r2, #32
3400d60e:	68f9      	ldr	r1, [r7, #12]
3400d610:	f7fc fb54 	bl	34009cbc <tk_wai_flg>
3400d614:	6138      	str	r0, [r7, #16]
	if(err >= E_OK) {
3400d616:	693b      	ldr	r3, [r7, #16]
3400d618:	2b00      	cmp	r3, #0
3400d61a:	db09      	blt.n	3400d630 <write_data+0xb4>
		err  = p_dcb->err;
3400d61c:	687b      	ldr	r3, [r7, #4]
3400d61e:	691b      	ldr	r3, [r3, #16]
3400d620:	613b      	str	r3, [r7, #16]
		if(err >= E_OK) req->asize = req->size;
3400d622:	693b      	ldr	r3, [r7, #16]
3400d624:	2b00      	cmp	r3, #0
3400d626:	db03      	blt.n	3400d630 <write_data+0xb4>
3400d628:	683b      	ldr	r3, [r7, #0]
3400d62a:	695a      	ldr	r2, [r3, #20]
3400d62c:	683b      	ldr	r3, [r7, #0]
3400d62e:	61da      	str	r2, [r3, #28]
	}

	return err;
3400d630:	693b      	ldr	r3, [r7, #16]
}
3400d632:	4618      	mov	r0, r3
3400d634:	3718      	adds	r7, #24
3400d636:	46bd      	mov	sp, r7
3400d638:	bd80      	pop	{r7, pc}
3400d63a:	bf00      	nop
3400d63c:	3400f6dc 	.word	0x3400f6dc

3400d640 <dev_i2c_openfn>:
 */
/*
 * Open device
 */
LOCAL ER dev_i2c_openfn( ID devid, UINT omode, T_MSDI *msdi)
{
3400d640:	b480      	push	{r7}
3400d642:	b087      	sub	sp, #28
3400d644:	af00      	add	r7, sp, #0
3400d646:	60f8      	str	r0, [r7, #12]
3400d648:	60b9      	str	r1, [r7, #8]
3400d64a:	607a      	str	r2, [r7, #4]
	T_HAL_I2C_DCB	*p_dcb;

	p_dcb = (T_HAL_I2C_DCB*)(msdi->dmsdi.exinf);
3400d64c:	687b      	ldr	r3, [r7, #4]
3400d64e:	691b      	ldr	r3, [r3, #16]
3400d650:	617b      	str	r3, [r7, #20]
	p_dcb->omode = omode;
3400d652:	697b      	ldr	r3, [r7, #20]
3400d654:	68ba      	ldr	r2, [r7, #8]
3400d656:	609a      	str	r2, [r3, #8]
	return E_OK;
3400d658:	2300      	movs	r3, #0
}
3400d65a:	4618      	mov	r0, r3
3400d65c:	371c      	adds	r7, #28
3400d65e:	46bd      	mov	sp, r7
3400d660:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d664:	4770      	bx	lr

3400d666 <dev_i2c_closefn>:

/*
 * Close Device
 */
LOCAL ER dev_i2c_closefn( ID devid, UINT option, T_MSDI *msdi)
{
3400d666:	b480      	push	{r7}
3400d668:	b085      	sub	sp, #20
3400d66a:	af00      	add	r7, sp, #0
3400d66c:	60f8      	str	r0, [r7, #12]
3400d66e:	60b9      	str	r1, [r7, #8]
3400d670:	607a      	str	r2, [r7, #4]
	return E_OK;
3400d672:	2300      	movs	r3, #0
}
3400d674:	4618      	mov	r0, r3
3400d676:	3714      	adds	r7, #20
3400d678:	46bd      	mov	sp, r7
3400d67a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d67e:	4770      	bx	lr

3400d680 <dev_i2c_readfn>:

/*
 * Read Device
 */
LOCAL ER dev_i2c_readfn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400d680:	b580      	push	{r7, lr}
3400d682:	b084      	sub	sp, #16
3400d684:	af00      	add	r7, sp, #0
3400d686:	6078      	str	r0, [r7, #4]
3400d688:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	ER		err;

	p_dcb = (T_HAL_I2C_DCB*)(p_msdi->dmsdi.exinf);
3400d68a:	683b      	ldr	r3, [r7, #0]
3400d68c:	691b      	ldr	r3, [r3, #16]
3400d68e:	60bb      	str	r3, [r7, #8]

	if(req->start >= 0) {
3400d690:	687b      	ldr	r3, [r7, #4]
3400d692:	691b      	ldr	r3, [r3, #16]
3400d694:	2b00      	cmp	r3, #0
3400d696:	db05      	blt.n	3400d6a4 <dev_i2c_readfn+0x24>
		err = read_data( p_dcb, req);	// Device specific data
3400d698:	6879      	ldr	r1, [r7, #4]
3400d69a:	68b8      	ldr	r0, [r7, #8]
3400d69c:	f7ff ff0c 	bl	3400d4b8 <read_data>
3400d6a0:	60f8      	str	r0, [r7, #12]
3400d6a2:	e004      	b.n	3400d6ae <dev_i2c_readfn+0x2e>
	} else {
		err = read_atr( p_dcb, req);	// Device attribute data
3400d6a4:	6879      	ldr	r1, [r7, #4]
3400d6a6:	68b8      	ldr	r0, [r7, #8]
3400d6a8:	f7ff fdfc 	bl	3400d2a4 <read_atr>
3400d6ac:	60f8      	str	r0, [r7, #12]
	}
	return err;
3400d6ae:	68fb      	ldr	r3, [r7, #12]
}
3400d6b0:	4618      	mov	r0, r3
3400d6b2:	3710      	adds	r7, #16
3400d6b4:	46bd      	mov	sp, r7
3400d6b6:	bd80      	pop	{r7, pc}

3400d6b8 <dev_i2c_writefn>:

/*
 * Write Device
 */
LOCAL ER dev_i2c_writefn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400d6b8:	b580      	push	{r7, lr}
3400d6ba:	b084      	sub	sp, #16
3400d6bc:	af00      	add	r7, sp, #0
3400d6be:	6078      	str	r0, [r7, #4]
3400d6c0:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	ER		rtn;

	p_dcb = (T_HAL_I2C_DCB*)(p_msdi->dmsdi.exinf);
3400d6c2:	683b      	ldr	r3, [r7, #0]
3400d6c4:	691b      	ldr	r3, [r3, #16]
3400d6c6:	60bb      	str	r3, [r7, #8]

	if(req->start >= 0) {
3400d6c8:	687b      	ldr	r3, [r7, #4]
3400d6ca:	691b      	ldr	r3, [r3, #16]
3400d6cc:	2b00      	cmp	r3, #0
3400d6ce:	db05      	blt.n	3400d6dc <dev_i2c_writefn+0x24>
		rtn = write_data( p_dcb, req);	// Device specific data
3400d6d0:	6879      	ldr	r1, [r7, #4]
3400d6d2:	68b8      	ldr	r0, [r7, #8]
3400d6d4:	f7ff ff52 	bl	3400d57c <write_data>
3400d6d8:	60f8      	str	r0, [r7, #12]
3400d6da:	e004      	b.n	3400d6e6 <dev_i2c_writefn+0x2e>
	} else {
		rtn = write_atr( p_dcb, req);	// Device attribute data
3400d6dc:	6879      	ldr	r1, [r7, #4]
3400d6de:	68b8      	ldr	r0, [r7, #8]
3400d6e0:	f7ff fe20 	bl	3400d324 <write_atr>
3400d6e4:	60f8      	str	r0, [r7, #12]
	}
	return rtn;
3400d6e6:	68fb      	ldr	r3, [r7, #12]
}
3400d6e8:	4618      	mov	r0, r3
3400d6ea:	3710      	adds	r7, #16
3400d6ec:	46bd      	mov	sp, r7
3400d6ee:	bd80      	pop	{r7, pc}

3400d6f0 <dev_i2c_eventfn>:

/*
 * Event Device
 */
LOCAL ER dev_i2c_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi)
{
3400d6f0:	b480      	push	{r7}
3400d6f2:	b085      	sub	sp, #20
3400d6f4:	af00      	add	r7, sp, #0
3400d6f6:	60f8      	str	r0, [r7, #12]
3400d6f8:	60b9      	str	r1, [r7, #8]
3400d6fa:	607a      	str	r2, [r7, #4]
	return E_NOSPT;
3400d6fc:	f06f 0308 	mvn.w	r3, #8
}
3400d700:	4618      	mov	r0, r3
3400d702:	3714      	adds	r7, #20
3400d704:	46bd      	mov	sp, r7
3400d706:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d70a:	4770      	bx	lr

3400d70c <dev_init_hal_i2c>:

/*----------------------------------------------------------------------
 * Device driver initialization and registration
 */
EXPORT ER dev_init_hal_i2c( UW unit, I2C_HandleTypeDef *hi2c )
{
3400d70c:	b580      	push	{r7, lr}
3400d70e:	b094      	sub	sp, #80	@ 0x50
3400d710:	af00      	add	r7, sp, #0
3400d712:	6078      	str	r0, [r7, #4]
3400d714:	6039      	str	r1, [r7, #0]
	T_MSDI		*p_msdi;
	T_DMSDI		dmsdi;
	ER		err;
	INT		i;

	if( unit >= DEV_HAL_I2C_UNITNM) return E_PAR;
3400d716:	687b      	ldr	r3, [r7, #4]
3400d718:	2b04      	cmp	r3, #4
3400d71a:	d902      	bls.n	3400d722 <dev_init_hal_i2c+0x16>
3400d71c:	f06f 0310 	mvn.w	r3, #16
3400d720:	e070      	b.n	3400d804 <dev_init_hal_i2c+0xf8>

#if TK_SUPPORT_MEMLIB
	p_dcb = (T_HAL_I2C_DCB*)Kmalloc(sizeof(T_HAL_I2C_DCB));
3400d722:	2020      	movs	r0, #32
3400d724:	f7fe fdce 	bl	3400c2c4 <Kmalloc>
3400d728:	64b8      	str	r0, [r7, #72]	@ 0x48
	if( p_dcb == NULL) return E_NOMEM;
3400d72a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d72c:	2b00      	cmp	r3, #0
3400d72e:	d102      	bne.n	3400d736 <dev_init_hal_i2c+0x2a>
3400d730:	f06f 0320 	mvn.w	r3, #32
3400d734:	e066      	b.n	3400d804 <dev_init_hal_i2c+0xf8>
	dev_i2c_cb[unit]	= p_dcb;
3400d736:	4935      	ldr	r1, [pc, #212]	@ (3400d80c <dev_init_hal_i2c+0x100>)
3400d738:	687b      	ldr	r3, [r7, #4]
3400d73a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400d73c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#else
	p_dcb = &dev_i2c_cb[unit];
#endif

	id_flgid = tk_cre_flg(&id_flg);
3400d740:	4833      	ldr	r0, [pc, #204]	@ (3400d810 <dev_init_hal_i2c+0x104>)
3400d742:	f7fc f91f 	bl	34009984 <tk_cre_flg>
3400d746:	4603      	mov	r3, r0
3400d748:	4a32      	ldr	r2, [pc, #200]	@ (3400d814 <dev_init_hal_i2c+0x108>)
3400d74a:	6013      	str	r3, [r2, #0]
	if(id_flgid <= E_OK) {
3400d74c:	4b31      	ldr	r3, [pc, #196]	@ (3400d814 <dev_init_hal_i2c+0x108>)
3400d74e:	681b      	ldr	r3, [r3, #0]
3400d750:	2b00      	cmp	r3, #0
3400d752:	dc03      	bgt.n	3400d75c <dev_init_hal_i2c+0x50>
		err = (ER)id_flgid;
3400d754:	4b2f      	ldr	r3, [pc, #188]	@ (3400d814 <dev_init_hal_i2c+0x108>)
3400d756:	681b      	ldr	r3, [r3, #0]
3400d758:	64fb      	str	r3, [r7, #76]	@ 0x4c
		goto err_1;
3400d75a:	e04f      	b.n	3400d7fc <dev_init_hal_i2c+0xf0>
	}

	/* Device registration information */
	dmsdi.exinf	= p_dcb;
3400d75c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d75e:	60bb      	str	r3, [r7, #8]
	dmsdi.drvatr	= 0;			/* Driver attributes */
3400d760:	2300      	movs	r3, #0
3400d762:	61bb      	str	r3, [r7, #24]
	dmsdi.devatr	= TDK_UNDEF;		/* Device attributes */
3400d764:	2300      	movs	r3, #0
3400d766:	61fb      	str	r3, [r7, #28]
	dmsdi.nsub	= 0;			/* Number of sub units */
3400d768:	2300      	movs	r3, #0
3400d76a:	623b      	str	r3, [r7, #32]
	dmsdi.blksz	= 1;			/* Unique data block size (-1 = unknown) */
3400d76c:	2301      	movs	r3, #1
3400d76e:	627b      	str	r3, [r7, #36]	@ 0x24
	dmsdi.openfn	= dev_i2c_openfn;
3400d770:	4b29      	ldr	r3, [pc, #164]	@ (3400d818 <dev_init_hal_i2c+0x10c>)
3400d772:	62bb      	str	r3, [r7, #40]	@ 0x28
	dmsdi.closefn	= dev_i2c_closefn;
3400d774:	4b29      	ldr	r3, [pc, #164]	@ (3400d81c <dev_init_hal_i2c+0x110>)
3400d776:	62fb      	str	r3, [r7, #44]	@ 0x2c
	dmsdi.readfn	= dev_i2c_readfn;
3400d778:	4b29      	ldr	r3, [pc, #164]	@ (3400d820 <dev_init_hal_i2c+0x114>)
3400d77a:	633b      	str	r3, [r7, #48]	@ 0x30
	dmsdi.writefn	= dev_i2c_writefn;
3400d77c:	4b29      	ldr	r3, [pc, #164]	@ (3400d824 <dev_init_hal_i2c+0x118>)
3400d77e:	637b      	str	r3, [r7, #52]	@ 0x34
	dmsdi.eventfn	= dev_i2c_eventfn;
3400d780:	4b29      	ldr	r3, [pc, #164]	@ (3400d828 <dev_init_hal_i2c+0x11c>)
3400d782:	63bb      	str	r3, [r7, #56]	@ 0x38
	
	knl_strcpy( (char*)dmsdi.devnm, DEVNAME_HAL_I2C);
3400d784:	f107 0308 	add.w	r3, r7, #8
3400d788:	3304      	adds	r3, #4
3400d78a:	4928      	ldr	r1, [pc, #160]	@ (3400d82c <dev_init_hal_i2c+0x120>)
3400d78c:	4618      	mov	r0, r3
3400d78e:	f7fe fb6a 	bl	3400be66 <knl_strcpy>
	i = knl_strlen(DEVNAME_HAL_I2C);
3400d792:	4826      	ldr	r0, [pc, #152]	@ (3400d82c <dev_init_hal_i2c+0x120>)
3400d794:	f7fe fb56 	bl	3400be44 <knl_strlen>
3400d798:	6478      	str	r0, [r7, #68]	@ 0x44
	dmsdi.devnm[i] = (UB)('a' + unit);
3400d79a:	687b      	ldr	r3, [r7, #4]
3400d79c:	b2db      	uxtb	r3, r3
3400d79e:	3361      	adds	r3, #97	@ 0x61
3400d7a0:	b2d9      	uxtb	r1, r3
3400d7a2:	f107 020c 	add.w	r2, r7, #12
3400d7a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400d7a8:	4413      	add	r3, r2
3400d7aa:	460a      	mov	r2, r1
3400d7ac:	701a      	strb	r2, [r3, #0]
	dmsdi.devnm[i+1] = 0;
3400d7ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400d7b0:	3301      	adds	r3, #1
3400d7b2:	3350      	adds	r3, #80	@ 0x50
3400d7b4:	443b      	add	r3, r7
3400d7b6:	2200      	movs	r2, #0
3400d7b8:	f803 2c44 	strb.w	r2, [r3, #-68]

	err = msdi_def_dev( &dmsdi, &idev, &p_msdi);
3400d7bc:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
3400d7c0:	f107 0140 	add.w	r1, r7, #64	@ 0x40
3400d7c4:	f107 0308 	add.w	r3, r7, #8
3400d7c8:	4618      	mov	r0, r3
3400d7ca:	f7fb fa03 	bl	34008bd4 <msdi_def_dev>
3400d7ce:	64f8      	str	r0, [r7, #76]	@ 0x4c
	if(err != E_OK) goto err_1;
3400d7d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400d7d2:	2b00      	cmp	r3, #0
3400d7d4:	d111      	bne.n	3400d7fa <dev_init_hal_i2c+0xee>

	p_dcb->hi2c	= hi2c;
3400d7d6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d7d8:	683a      	ldr	r2, [r7, #0]
3400d7da:	601a      	str	r2, [r3, #0]
	p_dcb->devid	= p_msdi->devid;
3400d7dc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400d7de:	681a      	ldr	r2, [r3, #0]
3400d7e0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d7e2:	605a      	str	r2, [r3, #4]
	p_dcb->unit	= unit;
3400d7e4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d7e6:	687a      	ldr	r2, [r7, #4]
3400d7e8:	60da      	str	r2, [r3, #12]
	p_dcb->evtmbfid	= idev.evtmbfid;
3400d7ea:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400d7ec:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d7ee:	615a      	str	r2, [r3, #20]
	p_dcb->dmode	= HAL_I2C_MODE_CNT;
3400d7f0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400d7f2:	2200      	movs	r2, #0
3400d7f4:	619a      	str	r2, [r3, #24]

	return E_OK;
3400d7f6:	2300      	movs	r3, #0
3400d7f8:	e004      	b.n	3400d804 <dev_init_hal_i2c+0xf8>
	if(err != E_OK) goto err_1;
3400d7fa:	bf00      	nop

err_1:
#if TK_SUPPORT_MEMLIB
	Kfree(p_dcb);
3400d7fc:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3400d7fe:	f7fe fd6e 	bl	3400c2de <Kfree>
#endif
	return err;
3400d802:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
3400d804:	4618      	mov	r0, r3
3400d806:	3750      	adds	r7, #80	@ 0x50
3400d808:	46bd      	mov	sp, r7
3400d80a:	bd80      	pop	{r7, pc}
3400d80c:	3400f6e0 	.word	0x3400f6e0
3400d810:	3400e130 	.word	0x3400e130
3400d814:	3400f6dc 	.word	0x3400f6dc
3400d818:	3400d641 	.word	0x3400d641
3400d81c:	3400d667 	.word	0x3400d667
3400d820:	3400d681 	.word	0x3400d681
3400d824:	3400d6b9 	.word	0x3400d6b9
3400d828:	3400d6f1 	.word	0x3400d6f1
3400d82c:	3400df38 	.word	0x3400df38

3400d830 <knl_init_device>:
/*
 * Initialization before micro T-Kernel starts
 */

EXPORT ER knl_init_device( void )
{
3400d830:	b480      	push	{r7}
3400d832:	af00      	add	r7, sp, #0
	return E_OK;
3400d834:	2300      	movs	r3, #0
}
3400d836:	4618      	mov	r0, r3
3400d838:	46bd      	mov	sp, r7
3400d83a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d83e:	4770      	bx	lr

3400d840 <knl_start_device>:
/*
 * Start processing after T-Kernel starts
 *	Called from the initial task contexts.
 */
EXPORT ER knl_start_device( void )
{
3400d840:	b580      	push	{r7, lr}
3400d842:	b082      	sub	sp, #8
3400d844:	af00      	add	r7, sp, #0
	ER	err	= E_OK;
3400d846:	2300      	movs	r3, #0
3400d848:	607b      	str	r3, [r7, #4]

#if DEVCNF_USE_HAL_IIC
	IMPORT I2C_HandleTypeDef	hi2c1;

	err = dev_init_hal_i2c(DEV_HAL_I2C1, &hi2c1);
3400d84a:	4916      	ldr	r1, [pc, #88]	@ (3400d8a4 <knl_start_device+0x64>)
3400d84c:	2000      	movs	r0, #0
3400d84e:	f7ff ff5d 	bl	3400d70c <dev_init_hal_i2c>
3400d852:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400d854:	687b      	ldr	r3, [r7, #4]
3400d856:	2b00      	cmp	r3, #0
3400d858:	da01      	bge.n	3400d85e <knl_start_device+0x1e>
3400d85a:	687b      	ldr	r3, [r7, #4]
3400d85c:	e01e      	b.n	3400d89c <knl_start_device+0x5c>
#endif

#if DEVCNF_USE_HAL_ADC
	IMPORT ADC_HandleTypeDef	hadc1;
	err = dev_init_hal_adc(DEV_HAL_ADC1, &hadc1);
3400d85e:	4912      	ldr	r1, [pc, #72]	@ (3400d8a8 <knl_start_device+0x68>)
3400d860:	2000      	movs	r0, #0
3400d862:	f7ff fc23 	bl	3400d0ac <dev_init_hal_adc>
3400d866:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400d868:	687b      	ldr	r3, [r7, #4]
3400d86a:	2b00      	cmp	r3, #0
3400d86c:	da01      	bge.n	3400d872 <knl_start_device+0x32>
3400d86e:	687b      	ldr	r3, [r7, #4]
3400d870:	e014      	b.n	3400d89c <knl_start_device+0x5c>
	if(err < E_OK) return err;

#elif defined(MTKBSP_NUCLEO_STM32G431) || defined(MTKBSP_NUCLEO_STM32G491)|| defined(MTKBSP_DISCOVERY_STM32N657)
	IMPORT ADC_HandleTypeDef	hadc2;
	
	err = dev_init_hal_adc(DEV_HAL_ADC2, &hadc2);
3400d872:	490e      	ldr	r1, [pc, #56]	@ (3400d8ac <knl_start_device+0x6c>)
3400d874:	2001      	movs	r0, #1
3400d876:	f7ff fc19 	bl	3400d0ac <dev_init_hal_adc>
3400d87a:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400d87c:	687b      	ldr	r3, [r7, #4]
3400d87e:	2b00      	cmp	r3, #0
3400d880:	da01      	bge.n	3400d886 <knl_start_device+0x46>
3400d882:	687b      	ldr	r3, [r7, #4]
3400d884:	e00a      	b.n	3400d89c <knl_start_device+0x5c>
	err = dev_init_hal_adc(DEV_HAL_ADC3, NULL);	// hadc3 is not used.
3400d886:	2100      	movs	r1, #0
3400d888:	2002      	movs	r0, #2
3400d88a:	f7ff fc0f 	bl	3400d0ac <dev_init_hal_adc>
3400d88e:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400d890:	687b      	ldr	r3, [r7, #4]
3400d892:	2b00      	cmp	r3, #0
3400d894:	da01      	bge.n	3400d89a <knl_start_device+0x5a>
3400d896:	687b      	ldr	r3, [r7, #4]
3400d898:	e000      	b.n	3400d89c <knl_start_device+0x5c>
	if(err < E_OK) return err;

#endif
#endif	/* DEVCNF_USE_HAL_ADC */

	return err;
3400d89a:	687b      	ldr	r3, [r7, #4]
}
3400d89c:	4618      	mov	r0, r3
3400d89e:	3708      	adds	r7, #8
3400d8a0:	46bd      	mov	sp, r7
3400d8a2:	bd80      	pop	{r7, pc}
3400d8a4:	3400f244 	.word	0x3400f244
3400d8a8:	3400f184 	.word	0x3400f184
3400d8ac:	3400f1e4 	.word	0x3400f1e4

3400d8b0 <knl_finish_device>:
 * System finalization
 *	Called just before system shutdown.
 *	Execute finalization that must be done before system shutdown.
 */
EXPORT ER knl_finish_device( void )
{
3400d8b0:	b480      	push	{r7}
3400d8b2:	af00      	add	r7, sp, #0
	return E_OK;
3400d8b4:	2300      	movs	r3, #0
}
3400d8b6:	4618      	mov	r0, r3
3400d8b8:	46bd      	mov	sp, r7
3400d8ba:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8be:	4770      	bx	lr

3400d8c0 <knl_startup_hw>:

/*
 * Startup Device
 */
EXPORT void knl_startup_hw(void)
{
3400d8c0:	b480      	push	{r7}
3400d8c2:	af00      	add	r7, sp, #0
#if USE_PTMR
	void knl_init_ptmr(void);
	knl_init_ptmr();
#endif
}
3400d8c4:	bf00      	nop
3400d8c6:	46bd      	mov	sp, r7
3400d8c8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8cc:	4770      	bx	lr

3400d8ce <knl_shutdown_hw>:
#if USE_SHUTDOWN
/*
 * Shutdown device
 */
EXPORT void knl_shutdown_hw( void )
{
3400d8ce:	b580      	push	{r7, lr}
3400d8d0:	af00      	add	r7, sp, #0
	disint();
3400d8d2:	f000 f858 	bl	3400d986 <disint>
	while(1);
3400d8d6:	bf00      	nop
3400d8d8:	e7fd      	b.n	3400d8d6 <knl_shutdown_hw+0x8>
	...

3400d8dc <knl_restart_hw>:
 *	mode = -1		reset and re-start	(Reset -> Boot -> Start)
 *	mode = -2		fast re-start		(Start)
 *	mode = -3		Normal re-start		(Boot -> Start)
 */
EXPORT ER knl_restart_hw( W mode )
{
3400d8dc:	b580      	push	{r7, lr}
3400d8de:	b082      	sub	sp, #8
3400d8e0:	af00      	add	r7, sp, #0
3400d8e2:	6078      	str	r0, [r7, #4]
	switch(mode) {
3400d8e4:	687b      	ldr	r3, [r7, #4]
3400d8e6:	f1b3 3fff 	cmp.w	r3, #4294967295
3400d8ea:	d00b      	beq.n	3400d904 <knl_restart_hw+0x28>
3400d8ec:	687b      	ldr	r3, [r7, #4]
3400d8ee:	2b00      	cmp	r3, #0
3400d8f0:	da1a      	bge.n	3400d928 <knl_restart_hw+0x4c>
3400d8f2:	687b      	ldr	r3, [r7, #4]
3400d8f4:	f113 0f03 	cmn.w	r3, #3
3400d8f8:	d010      	beq.n	3400d91c <knl_restart_hw+0x40>
3400d8fa:	687b      	ldr	r3, [r7, #4]
3400d8fc:	f113 0f02 	cmn.w	r3, #2
3400d900:	d006      	beq.n	3400d910 <knl_restart_hw+0x34>
3400d902:	e011      	b.n	3400d928 <knl_restart_hw+0x4c>
	case -1: /* Reset and re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM RESET & RESTART >>\n");
3400d904:	480b      	ldr	r0, [pc, #44]	@ (3400d934 <knl_restart_hw+0x58>)
3400d906:	f7fe fd1f 	bl	3400c348 <tm_putstring>
		return E_NOSPT;
3400d90a:	f06f 0308 	mvn.w	r3, #8
3400d90e:	e00d      	b.n	3400d92c <knl_restart_hw+0x50>
	case -2: /* fast re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM FAST RESTART >>\n");
3400d910:	4809      	ldr	r0, [pc, #36]	@ (3400d938 <knl_restart_hw+0x5c>)
3400d912:	f7fe fd19 	bl	3400c348 <tm_putstring>
		return E_NOSPT;
3400d916:	f06f 0308 	mvn.w	r3, #8
3400d91a:	e007      	b.n	3400d92c <knl_restart_hw+0x50>
	case -3: /* Normal re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM RESTART >>\n");
3400d91c:	4807      	ldr	r0, [pc, #28]	@ (3400d93c <knl_restart_hw+0x60>)
3400d91e:	f7fe fd13 	bl	3400c348 <tm_putstring>
		return E_NOSPT;
3400d922:	f06f 0308 	mvn.w	r3, #8
3400d926:	e001      	b.n	3400d92c <knl_restart_hw+0x50>
	default:
		return E_PAR;
3400d928:	f06f 0310 	mvn.w	r3, #16
	}
}
3400d92c:	4618      	mov	r0, r3
3400d92e:	3708      	adds	r7, #8
3400d930:	46bd      	mov	sp, r7
3400d932:	bd80      	pop	{r7, pc}
3400d934:	3400df40 	.word	0x3400df40
3400d938:	3400df60 	.word	0x3400df60
3400d93c:	3400df7c 	.word	0x3400df7c

3400d940 <low_pow>:

/*
 * Switch to power-saving mode
 */
EXPORT void low_pow( void )
{
3400d940:	b480      	push	{r7}
3400d942:	af00      	add	r7, sp, #0
}
3400d944:	bf00      	nop
3400d946:	46bd      	mov	sp, r7
3400d948:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d94c:	4770      	bx	lr

3400d94e <set_basepri>:

/*
 * Set Base Priority register
 */
EXPORT void set_basepri(UW intsts)
{	
3400d94e:	b480      	push	{r7}
3400d950:	b083      	sub	sp, #12
3400d952:	af00      	add	r7, sp, #0
3400d954:	6078      	str	r0, [r7, #4]
	Asm("msr basepri, %0":: "r"(intsts));
3400d956:	687b      	ldr	r3, [r7, #4]
3400d958:	f383 8811 	msr	BASEPRI, r3
	Asm("isb");
3400d95c:	f3bf 8f6f 	isb	sy
}
3400d960:	bf00      	nop
3400d962:	370c      	adds	r7, #12
3400d964:	46bd      	mov	sp, r7
3400d966:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d96a:	4770      	bx	lr

3400d96c <get_basepri>:

/*
 * Get Base Priority register
 */
EXPORT UW get_basepri(void)
{
3400d96c:	b480      	push	{r7}
3400d96e:	b083      	sub	sp, #12
3400d970:	af00      	add	r7, sp, #0
	UW	basepri;

	Asm("mrs %0, basepri": "=r"(basepri));
3400d972:	f3ef 8311 	mrs	r3, BASEPRI
3400d976:	607b      	str	r3, [r7, #4]
	return basepri;
3400d978:	687b      	ldr	r3, [r7, #4]
}
3400d97a:	4618      	mov	r0, r3
3400d97c:	370c      	adds	r7, #12
3400d97e:	46bd      	mov	sp, r7
3400d980:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d984:	4770      	bx	lr

3400d986 <disint>:

/* 
 * Disable interrupt 
 */
EXPORT UW disint(void)
{
3400d986:	b480      	push	{r7}
3400d988:	b083      	sub	sp, #12
3400d98a:	af00      	add	r7, sp, #0
	UW	intsts, maxint;

	maxint = INTPRI_VAL(INTPRI_MAX_EXTINT_PRI);
3400d98c:	2310      	movs	r3, #16
3400d98e:	607b      	str	r3, [r7, #4]
	Asm("mrs %0, basepri": "=r"(intsts));
3400d990:	f3ef 8311 	mrs	r3, BASEPRI
3400d994:	603b      	str	r3, [r7, #0]
	Asm("msr basepri, %0":: "r"(maxint));
3400d996:	687b      	ldr	r3, [r7, #4]
3400d998:	f383 8811 	msr	BASEPRI, r3

	return intsts;
3400d99c:	683b      	ldr	r3, [r7, #0]
}
3400d99e:	4618      	mov	r0, r3
3400d9a0:	370c      	adds	r7, #12
3400d9a2:	46bd      	mov	sp, r7
3400d9a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d9a8:	4770      	bx	lr
	...

3400d9ac <tm_snd_dat>:

/* Communication speed */
#define UART_BAUD	(115200)			/* 115200 bps */

EXPORT	void	tm_snd_dat( const UB* buf, INT size )
{
3400d9ac:	b480      	push	{r7}
3400d9ae:	b085      	sub	sp, #20
3400d9b0:	af00      	add	r7, sp, #0
3400d9b2:	6078      	str	r0, [r7, #4]
3400d9b4:	6039      	str	r1, [r7, #0]
	UB	*b;

	for( b = (UB *)buf; size > 0; size--, b++ ){
3400d9b6:	687b      	ldr	r3, [r7, #4]
3400d9b8:	60fb      	str	r3, [r7, #12]
3400d9ba:	e017      	b.n	3400d9ec <tm_snd_dat+0x40>
		while ((UART_ISR & ISR_TXE) == 0 );
3400d9bc:	bf00      	nop
3400d9be:	4b10      	ldr	r3, [pc, #64]	@ (3400da00 <tm_snd_dat+0x54>)
3400d9c0:	681b      	ldr	r3, [r3, #0]
3400d9c2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400d9c6:	2b00      	cmp	r3, #0
3400d9c8:	d0f9      	beq.n	3400d9be <tm_snd_dat+0x12>
		UART_TDR = *b;
3400d9ca:	68fb      	ldr	r3, [r7, #12]
3400d9cc:	781a      	ldrb	r2, [r3, #0]
3400d9ce:	4b0d      	ldr	r3, [pc, #52]	@ (3400da04 <tm_snd_dat+0x58>)
3400d9d0:	601a      	str	r2, [r3, #0]
		while ((UART_ISR & ISR_TC) == 0 );
3400d9d2:	bf00      	nop
3400d9d4:	4b0a      	ldr	r3, [pc, #40]	@ (3400da00 <tm_snd_dat+0x54>)
3400d9d6:	681b      	ldr	r3, [r3, #0]
3400d9d8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400d9dc:	2b00      	cmp	r3, #0
3400d9de:	d0f9      	beq.n	3400d9d4 <tm_snd_dat+0x28>
	for( b = (UB *)buf; size > 0; size--, b++ ){
3400d9e0:	683b      	ldr	r3, [r7, #0]
3400d9e2:	3b01      	subs	r3, #1
3400d9e4:	603b      	str	r3, [r7, #0]
3400d9e6:	68fb      	ldr	r3, [r7, #12]
3400d9e8:	3301      	adds	r3, #1
3400d9ea:	60fb      	str	r3, [r7, #12]
3400d9ec:	683b      	ldr	r3, [r7, #0]
3400d9ee:	2b00      	cmp	r3, #0
3400d9f0:	dce4      	bgt.n	3400d9bc <tm_snd_dat+0x10>
	}
}
3400d9f2:	bf00      	nop
3400d9f4:	bf00      	nop
3400d9f6:	3714      	adds	r7, #20
3400d9f8:	46bd      	mov	sp, r7
3400d9fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d9fe:	4770      	bx	lr
3400da00:	5200101c 	.word	0x5200101c
3400da04:	52001028 	.word	0x52001028

3400da08 <tm_com_init>:
}

UW get_pclk1(void);

EXPORT	void	tm_com_init(void)
{
3400da08:	b480      	push	{r7}
3400da0a:	af00      	add	r7, sp, #0
	/* Initialize serial communication. Disable all interrupt. */
	UART_CR1 = 0;		/* 8bit, Non parity (Reset value) */
3400da0c:	4b0a      	ldr	r3, [pc, #40]	@ (3400da38 <tm_com_init+0x30>)
3400da0e:	2200      	movs	r2, #0
3400da10:	601a      	str	r2, [r3, #0]
	UART_CR2 = 0;		/* Stop bit 1 (Reset value) */
3400da12:	4b0a      	ldr	r3, [pc, #40]	@ (3400da3c <tm_com_init+0x34>)
3400da14:	2200      	movs	r2, #0
3400da16:	601a      	str	r2, [r3, #0]
	UART_CR3 = 0;		/* No hard flow control (Reset value) */
3400da18:	4b09      	ldr	r3, [pc, #36]	@ (3400da40 <tm_com_init+0x38>)
3400da1a:	2200      	movs	r2, #0
3400da1c:	601a      	str	r2, [r3, #0]
	UART_BRR = 0x022C;	/* Set baud rate */
3400da1e:	4b09      	ldr	r3, [pc, #36]	@ (3400da44 <tm_com_init+0x3c>)
3400da20:	f44f 720b 	mov.w	r2, #556	@ 0x22c
3400da24:	601a      	str	r2, [r3, #0]

	UART_CR1 = CR1_UE | CR1_RE |CR1_TE;	/* Start UART */
3400da26:	4b04      	ldr	r3, [pc, #16]	@ (3400da38 <tm_com_init+0x30>)
3400da28:	220d      	movs	r2, #13
3400da2a:	601a      	str	r2, [r3, #0]
}
3400da2c:	bf00      	nop
3400da2e:	46bd      	mov	sp, r7
3400da30:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da34:	4770      	bx	lr
3400da36:	bf00      	nop
3400da38:	52001000 	.word	0x52001000
3400da3c:	52001004 	.word	0x52001004
3400da40:	52001008 	.word	0x52001008
3400da44:	5200100c 	.word	0x5200100c

3400da48 <memset>:
3400da48:	4402      	add	r2, r0
3400da4a:	4603      	mov	r3, r0
3400da4c:	4293      	cmp	r3, r2
3400da4e:	d100      	bne.n	3400da52 <memset+0xa>
3400da50:	4770      	bx	lr
3400da52:	f803 1b01 	strb.w	r1, [r3], #1
3400da56:	e7f9      	b.n	3400da4c <memset+0x4>

3400da58 <__libc_init_array>:
3400da58:	b570      	push	{r4, r5, r6, lr}
3400da5a:	4d0d      	ldr	r5, [pc, #52]	@ (3400da90 <__libc_init_array+0x38>)
3400da5c:	2600      	movs	r6, #0
3400da5e:	4c0d      	ldr	r4, [pc, #52]	@ (3400da94 <__libc_init_array+0x3c>)
3400da60:	1b64      	subs	r4, r4, r5
3400da62:	10a4      	asrs	r4, r4, #2
3400da64:	42a6      	cmp	r6, r4
3400da66:	d109      	bne.n	3400da7c <__libc_init_array+0x24>
3400da68:	4d0b      	ldr	r5, [pc, #44]	@ (3400da98 <__libc_init_array+0x40>)
3400da6a:	2600      	movs	r6, #0
3400da6c:	4c0b      	ldr	r4, [pc, #44]	@ (3400da9c <__libc_init_array+0x44>)
3400da6e:	f000 f817 	bl	3400daa0 <_init>
3400da72:	1b64      	subs	r4, r4, r5
3400da74:	10a4      	asrs	r4, r4, #2
3400da76:	42a6      	cmp	r6, r4
3400da78:	d105      	bne.n	3400da86 <__libc_init_array+0x2e>
3400da7a:	bd70      	pop	{r4, r5, r6, pc}
3400da7c:	f855 3b04 	ldr.w	r3, [r5], #4
3400da80:	3601      	adds	r6, #1
3400da82:	4798      	blx	r3
3400da84:	e7ee      	b.n	3400da64 <__libc_init_array+0xc>
3400da86:	f855 3b04 	ldr.w	r3, [r5], #4
3400da8a:	3601      	adds	r6, #1
3400da8c:	4798      	blx	r3
3400da8e:	e7f2      	b.n	3400da76 <__libc_init_array+0x1e>
3400da90:	3400e0e0 	.word	0x3400e0e0
3400da94:	3400e0e0 	.word	0x3400e0e0
3400da98:	3400e0e0 	.word	0x3400e0e0
3400da9c:	3400e0e4 	.word	0x3400e0e4

3400daa0 <_init>:
3400daa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400daa2:	bf00      	nop
3400daa4:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400daa6:	bc08      	pop	{r3}
3400daa8:	469e      	mov	lr, r3
3400daaa:	4770      	bx	lr

3400daac <_fini>:
3400daac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400daae:	bf00      	nop
3400dab0:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400dab2:	bc08      	pop	{r3}
3400dab4:	469e      	mov	lr, r3
3400dab6:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3400f140 <SECURE_SystemCoreClockUpdate>:
3400f140:	e97f e97f 	sg
3400f144:	f7f2 bb5c 	b.w	34001800 <__acle_se_SECURE_SystemCoreClockUpdate>

3400f148 <SECURE_RegisterCallback>:
3400f148:	e97f e97f 	sg
3400f14c:	f7f1 bee8 	b.w	34000f20 <__acle_se_SECURE_RegisterCallback>
	...
